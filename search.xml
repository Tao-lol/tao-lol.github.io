<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[编程小知识]]></title>
      <url>/2019/12/01/ProgrammingTips/</url>
      <content type="html"><![CDATA[<a id="more"></a>

<h1 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h1><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><h3 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h3><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><h3 id="SignalR"><a href="#SignalR" class="headerlink" title="SignalR"></a>SignalR</h3><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h3 id="Razor-Pages"><a href="#Razor-Pages" class="headerlink" title="Razor Pages"></a>Razor Pages</h3><h3 id="Blazor"><a href="#Blazor" class="headerlink" title="Blazor"></a>Blazor</h3><h3 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h3><h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><h2 id="Xamarin"><a href="#Xamarin" class="headerlink" title="Xamarin"></a>Xamarin</h2><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><blockquote>
<p>构建某个类型的某个实例时系统所执行的操作：</p>
<ol>
<li>把存放静态变量的空间清零。</li>
<li>执行静态变量的初始化语句。</li>
<li>执行基类的静态构造函数。</li>
<li>执行（本类的）静态构造函数。</li>
<li>把存放实例变量的空间清零。</li>
<li>执行实例变量的初始化语句。</li>
<li>适当地执行基类的实例构造函数。</li>
<li>执行（本类的）实例构造函数。</li>
</ol>
<p>&emsp;&emsp;以后如果还要构造该类型的实例，那么会直接从第5步开始执行，因为类级别的初始化工作只执行一次就够了。<br>此外，可以通过链式调用构造函数的办法来优化第6、7两步，使得编译器在制作程序码时不再生成重复的指令。</p>
</blockquote>
<blockquote>
<p>在类的继承体系中，位于根部的那个基类应该做到以下几点：</p>
<ul>
<li>实现 IDisposable 接口，以便释放资源。</li>
<li>如果本身含有非托管资源，那就添加 finalizer，以防客户端忘记调用 Dispose() 方法。若是没有非托管资源，则不用添加 finalizer。</li>
<li>Dispose 方法与 finalizer（如果有的话）都把释放资源的工作委派给虚方法，使得子类能够重写该方法，以释放它们自己的资源。</li>
</ul>
<p>继承体系中的子类应该做到以下几点：</p>
<ul>
<li>如果子类中有自己的资源需要释放，那就重写由基类所定义的那个虚方法，若是没有，则不用重写该方法。</li>
<li>如果子类自身的某个成员字段表示的是非托管资源，那么就实现 finalizer，若没有这样的字段，则不用实现 finalizer。</li>
<li>记得调用基类的同名函数。</li>
</ul>
</blockquote>
<blockquote>
<p>实现 IDisposable.Dispose() 方法时，要注意以下四点：</p>
<ol>
<li>把非托管资源全都释放掉。</li>
<li>把托管资源全都释放掉（这也包括不再订阅早前关注的那些事件）。</li>
<li>设定相关的状态标志，用以表示该对象已经清理过了。如果对象已经清理过了之后还有人要访问其中的公有成员，那么你可以通过此标志得知这一状况，从而令这些操作抛出 ObjectDisposedException。</li>
<li>阻止垃圾回收器重复清理该对象。这可以通过 GC.SuppressFinalize(this) 来完成。</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通俗易懂，什么是.NET? 什么是.NET Framework? 什么是.NET Core?]]></title>
      <url>/2019/11/28/WhatIsDotNet/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/1996V/p/9037603.html" target="_blank" rel="noopener">https://www.cnblogs.com/1996V/p/9037603.html</a></p>
</blockquote>
<p>&emsp;&emsp;什么是.NET？什么是.NET Framework?本文将从上往下，循序渐进的介绍一系列相关.NET的概念，先从类型系统开始讲起，我将通过跨语言操作这个例子来逐渐引入一系列.NET的相关概念，这主要包括：CLS、CTS(CLI)、FCL、Windows下CLR的相关核心组成、Windows下托管程序运行概念、什么是.NET Framework，.NET Core，.NET Standard及一些VS编译器相关杂项和相关阅读链接。完整的从上读到下则你可以理解个大概的.NET体系。</p>
<a id="more"></a>

<p><strong>目录</strong></p>
<ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET和C-是什么关系">.NET和C#是什么关系</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#跨语言和跨平台是什么">跨语言和跨平台是什么</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是跨语言互操作，什么是CLS">什么是跨语言互操作，什么是CLS</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#CLS异常">CLS异常</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CTS？">什么是CTS？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是类库？">什么是类库？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是基础类库BCL？">什么是基础类库BCL？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是框架类库FCL？">什么是框架类库FCL？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是基元类型？">什么是基元类型？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#System-Object的意义">System.Object的意义</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#计算机是如何运行程序的？">计算机是如何运行程序的？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CPU">什么是CPU？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是高级编程语言">什么是高级编程语言？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是托管代码，托管语言，托管模块？">什么是托管代码，托管语言，托管模块？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#非托管的异常">非托管的异常</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CLR，-NET虚拟机？">什么是CLR，.NET虚拟机？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CLR宿主进程，运行时主机？">什么是CLR宿主进程，运行时主机？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#Windows系统自带-NET-Framework">Windows系统自带.NET Framework</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework-4-0-30319">.NET Framework 4.0.30319</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework4-X覆盖更新">.NET Framework4.X覆盖更新</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何确认本机安装了哪些-NET-Framework和对应CLR的版本？">如何确认本机安装了哪些.NET Framework和对应CLR的版本？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是程序集">什么是程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#用csc-exe进行编译">用csc.exe进行编译</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET程序执行原理">.NET程序执行原理</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#JIT编译">JIT编译</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#AOT编译">AOT编译</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集的规则">程序集的规则</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集的加载方式">程序集的加载方式</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#强名称程序集">强名称程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集搜索规则">程序集搜索规则</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目的依赖顺序">项目的依赖顺序</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#为什么Newtonsoft-Json版本不一致？">为什么Newtonsoft.Json版本不一致？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何在编译时加载两个相同的程序集？">如何在编译时加载两个相同的程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何同时调用两个相同命名空间和类型的程序集？">如何同时调用两个相同命名空间和类型的程序集？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#共享程序集GAC">共享程序集GAC</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#延伸">延伸</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#应用程序域">应用程序域</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#跨边界访问">跨边界访问</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#AppDomain和AppPool">AppDomain和AppPool</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#内存">内存</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#堆栈和堆的区别">堆栈和堆的区别</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#线程堆栈">线程堆栈</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#为什么值类型存储在栈上">为什么值类型存储在栈上</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#托管堆模型">托管堆模型</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#选class还是struct">选class还是struct</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#GC管理器">GC管理器</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#弱引用、弱事件">弱引用、弱事件</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#GC堆回收">GC堆回收</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#垃圾回收对性能的影响">垃圾回收对性能的影响</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#性能建议">性能建议</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET程序执行图">.NET程序执行图</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET的安全性">.NET的安全性</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#基于角色的安全性">基于角色的安全性</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#代码访问安全性">代码访问安全性</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET是什么">什么是.NET</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework是什么">什么是.NET Framework</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何在VS中调试-NET-Framework源代码">如何在VS中调试.NET Framework源代码</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Core是什么">什么是.NET Core</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Standard是什么">什么是.NET Standard</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET官方开源项目链接">.NET官方开源项目链接</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#Visual-Studio">Visual Studio</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#sln解决方案">sln解决方案</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目模板">项目模板</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#csproj工程文件">csproj工程文件</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目属性杂项">项目属性杂项</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#IntelliTrace智能追溯">IntelliTrace智能追溯</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#链接">链接</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#建议">建议</a></li>
</ul>
<h1 id="NET和C-是什么关系"><a href="#NET和C-是什么关系" class="headerlink" title=".NET和C#是什么关系"></a>.NET和C#是什么关系</h1><p>&emsp;&emsp;语言，是人们进行沟通表达的主要方式。编程语言，是人与机器沟通的表达方式。不同的编程语言，其侧重点不同。有的编程语言是为了科学计算而开发的，所以其语法和功能更偏向于函数式思想。有些则是为了开发应用程序而创立的，所以其语法和功能更为均衡全面。<br>&emsp;&emsp;微软公司是全球最大的电脑软件提供商，为了占据开发者市场，进而在2002年推出了Visual Studio(简称VS，是微软提供给开发者的工具集) .NET 1.0版本的开发者平台。而为了吸引更多的开发者涌入平台，微软还在2002年宣布推出一个特性强大并且与.NET平台无缝集成的编程语言，即C# 1.0正式版。<br>&emsp;&emsp;只要是.NET支持的编程语言，开发者就可以通过.NET平台提供的工具服务和框架支持便捷的开发应用程序。<br>&emsp;&emsp;C#就是为宣传.NET而创立的，它直接集成于Visual Studio .NET中，VB也在.NET 1.0发布后对其进行支持， 所以这两门语言与.NET平台耦合度很高，并且.NET上的技术大多都是以C#编程语言为示例，所以经常就.NET和C#混为一谈(实质上它们是相辅相成的两个概念)。<br>&emsp;&emsp;而作为一个开发者平台，它不仅仅是包含开发环境、技术框架、社区论坛、服务支持等，它还强调了平台的跨语言、跨平台编程的两个特性。  </p>
<h1 id="跨语言和跨平台是什么"><a href="#跨语言和跨平台是什么" class="headerlink" title="跨语言和跨平台是什么"></a>跨语言和跨平台是什么</h1><p>&emsp;&emsp;跨语言：即只要是面向.NET平台的编程语言(C#、Visual Basic、C++/CLI、Eiffel、F#、IronPython、IronRuby、PowerBuilder、Visual COBOL 以及 Windows PowerShell)，用其中一种语言编写的类型可以无缝地用在另一种语言编写的应用程序中的互操作性。<br>&emsp;&emsp;跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的平台上，即代码不依赖于操作系统，也不依赖硬件环境。  </p>
<h1 id="什么是跨语言互操作，什么是CLS"><a href="#什么是跨语言互操作，什么是CLS" class="headerlink" title="什么是跨语言互操作，什么是CLS"></a>什么是跨语言互操作，什么是CLS</h1><p>&emsp;&emsp;每门语言在最初被设计时都有其在功能和语法上的定位，让不同的人使用擅长的语言去干合适的事，这在团队协作时尤为重要。<br>&emsp;&emsp;.NET平台上的跨语言是通过CLS这个概念来实现的，接下来我就以C#和VB来演示 什么是.NET中的跨语言互操作性。<br>&emsp;&emsp;通俗来说，虽然c#和vb是两个不同的语言，但此处c#写的类可以在vb中当做自家写的类一样正常使用。<br>&emsp;&emsp;比如我在vb中写了一个针对String的首字母大写的扩展方法，将其编译后的dll引用至C#项目中。<br><img src="1026815-20180626183857074-2096426398.png" alt=" "><br>&emsp;&emsp;在C#项目中，可以像自身代码一样正常使用来自vb这个dll的扩展方法。<br><img src="1026815-20180626183936496-928087425.png" alt=" "><br>&emsp;&emsp;现在有那么多面向对象语言，但不是所有编程语言都能这样直接互操作使用，而.NET平台支持的C#和VB之所以能这样无缝衔接，先读而后知，后文将会介绍缘由。不过虽然.NET平台提供了这样一个互操作的特性，但终究语言是不一样的，每个语言有其特色和差异处，在相互操作的时候就会难免遇到一些例外情况。<br>&emsp;&emsp;比如我在C#中定义了一个基类，类里面包含一个公开的指针类型的成员，我想在vb中继承这个类，并访问这个公开的成员。<br><img src="1026815-20180626184210340-127662462.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626184235037-299865363.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;但是vb语言因为其定位不需要指针，所以并没有C#中如int*这样的指针类型，所以在vb中访问一个该语言不支持的类型会报错的，会提示：字段的类型不受支持。<br>&emsp;&emsp;再比如，C#语言中，对类名是区分大小写的，我在C#中定义了两个类，一个叫BaseBusiness，另一个叫baseBusiness。我在vb中去继承这个BaseBusiness类。<br><img src="1026815-20180626184409472-1770998540.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626184415319-1635326718.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;如图，在vb中访问这个类会报错的，报:”BaseBusiness”不明确，这是因为在vb中对类名是不区分大小写的。在vb中，它认为它同时访问了两个一模一样的类，所以按照vb的规则这是不合理的。那么为了在vb调用c#的程序集中避免这些因语言的差异性而导致的错误，在编写c#代码的时候 就应该提前知道vb中的这些规则，来应付式的开发。<br>&emsp;&emsp;但是，如果我想不仅仅局限于C#和VB，我还想我编写的代码在.Net平台上通用的话，那么我还必须得知道.NET平台支持的每一种语言和我编写代码所使用的语言的差异，从而在编写代码中避免这些。<br>&emsp;&emsp;这几年编程语言层出不穷，在将来.NET可能还会支持更多的语言，如果说对一个开发者而言掌握所有语言的差异处这是不现实的，所以.NET专门为此参考每种语言并找出了语言间的共性，然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。<br>&emsp;&emsp;而与其说是规则，不如说它是一组语言互操作的标准规范，它就是公共语言规范 - Common Language Specification ,简称CLS<br><img src="1026815-20180626184537026-621328968.png" alt=" "><br>&emsp;&emsp;CLS从类型、命名、事件、属性、数组等方面对语言进行了共性的定义及规范。这些东西被提交给欧洲计算机制造联合会ECMA，称为：共同语言基础设施。<br>&emsp;&emsp;就以类型而言，CLS定义了在C#语言中符合规范的类型和不符合的有：<br><img src="1026815-20180626190145917-2079608898.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626190219058-1162748836.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;当然，就编码角度而言，我们不是必须要看那些详略的文档。为了方便开发者开发，.NET提供了一个特性，名叫：<code>CLSCompliantAttribute</code>，代码被<code>CLSCompliantAttribute</code>标记后，如果你写的代码不符合CLS规范的话，编译器就会给你一条警告。<br><img src="1026815-20180626184619698-1304394925.png" alt=" "><br>&emsp;&emsp;值得一提的是，CLS规则只是面向那些公开可被其它程序集访问的成员，如<code>public</code>、继承的<code>protected</code>，对于该程序集的内部成员如<code>private</code>、<code>internal</code>则不会执行该检测规则。也就是说，所适应的CLS遵从性规则，仅是那些公开的成员，而非私有实现。<br><img src="1026815-20180626184828785-553094494.png" alt=" "><br>&emsp;&emsp;那么有没有那种特殊情况，比如我通过反射技术来访问该程序集中，当前语言并不拥有的类型时会发生什么情况呢？<br>&emsp;&emsp;答案是可以尝试的，如用vb反射访问c#中的<code>char*</code>指针类型，即使vb中没有<code>char*</code>这种等价的指针类型，但mscorlib提供了针对指针类型的 <code>Pointer</code> 包装类供其访问，可以从运行时类携带的类型名称看到其原本的类型名。<br><img src="1026815-20180626184959109-1666010143.png" alt=" "><br>&emsp;&emsp;可以看到，该类中的元素是不符合CLS规范的。  </p>
<h2 id="CLS异常"><a href="#CLS异常" class="headerlink" title="CLS异常"></a>CLS异常</h2><p>&emsp;&emsp;提到特殊情况，还要说的一点就是异常处理。.NET框架组成中定义了异常类型系统，在编译器角度，所有catch捕获的异常都必须继承自<code>System.Exception</code>，如果你要调用一个 由不遵循此规范的语言 抛出其它类型的异常对象(C++允许抛出任何类型的异常，如C#调用C++代码，C++抛出一个string类型的异常)，在C#2.0之前Catch(Exception)是捕捉不了的，但之后的版本可以。<br>&emsp;&emsp;在后续版本中，微软提供了<code>System.Runtime.CompilerServices.RuntimeWrappedException</code>异常类，将那些不符合CLS的包含Exception的对象封装起来。并且可以通过<code>RuntimeCompatibilityAttribute</code>特性来过滤这些异常。<br>&emsp;&emsp;RuntimeWrappedException ：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimewrappedexception?view=netframework-4.7.2" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimewrappedexception?view=netframework-4.7.2</a>  </p>
<h2 id="那么，这个段落总结一下，什么是CLS呢？"><a href="#那么，这个段落总结一下，什么是CLS呢？" class="headerlink" title="那么，这个段落总结一下，什么是CLS呢？"></a>那么，这个段落总结一下，什么是CLS呢？</h2><p>&emsp;&emsp;在面向.NET开发中，编写跨语言组件时所遵循的那些共性，那些规范就叫做 Common Langrage Specification简称 CLS，公共语言规范<br>&emsp;&emsp;官方CLS介绍：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/language-independence-and-language-independent-components" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/language-independence-and-language-independent-components</a>  </p>
<h1 id="什么是CTS？"><a href="#什么是CTS？" class="headerlink" title="什么是CTS？"></a>什么是CTS？</h1><p>&emsp;&emsp;如果理解了什么是CLS的话，那么你将很轻松理解什么是CTS。<br>&emsp;&emsp;假设你已经围绕着封装 继承 多态 这3个特性设计出了多款面向对象的语言，你发现大家都是面向对象，都能很好的将现实中的对象模型表达出来。除了语法和功能擅长不同，语言的定义和设计结构其实都差不多一回事。<br>&emsp;&emsp;比如，现实中你看到了一辆小汽车，这辆车里坐着两个人，那么如何用这门语言来表达这样的一个概念和场面？<br>&emsp;&emsp;首先要为这门语言横向定义一个“类型”的概念。接下来在程序中就可以这样表示：有一个汽车类型，有一个人类型，在一个汽车类型的对象内包含着两个人类型的对象，因为要表达出这个模型，你又引入了“对象”的概念 。而现在，你又看到，汽车里面的人做出了开车的这样一个动作，由此你又引入了“动作指令”这样一个概念。<br>&emsp;&emsp;接着，你又恍然大悟总结出一个定理，无论是什么样的“类型”，都只会存在这样一个特征，即活着的 带生命特征的(如人) 和 死的 没有生命特征的(如汽车) 这两者中的一个。最后，随着思想模型的成熟，你发现，这个“类型”就相当于一个富有主体特征的一组指令的集合。<br>&emsp;&emsp;好，然后你开始照葫芦画瓢。你参考其它程序语言，你发现大家都是用<code>class</code>来表示类的含义，用<code>struct</code>表示结构的含义，用<code>new</code>来表示 新建一个对象的含义，于是，你对这部分功能的语法也使用class和new关键字来表示。然后你又发现，他们还用很多关键字来更丰富的表示这些现实模型，比如<code>override</code>、<code>virtual</code>等。于是，在不断的思想升级和借鉴后，你对这个设计语言过程中思想的变化仔细分析，对这套语言体系给抽象归纳，最终总结出一套体系。<br>&emsp;&emsp;于是你对其它人这样说，我总结出了一门语言很多必要的东西如两种主要类别：值类别和引用类别，五个主要类型：类、接口、委托、结构、枚举，我还规定了，一个类型可以包含字段、属性、方法、事件等成员，我还指定了每种类型的可见性规则和类型成员的访问规则，等等等等，只要按照我这个体系来设计语言，设计出来的语言它能够拥有很多不错的特性，比如跨语言，跨平台等，C#和VB.net之所以能够这样就是因为这两门语言的设计符合我这个体系。  </p>
<h2 id="那么，什么是CTS呢？"><a href="#那么，什么是CTS呢？" class="headerlink" title="那么，什么是CTS呢？"></a>那么，什么是CTS呢？</h2><p>&emsp;&emsp;当你需要设计面向.Net的语言时所需要遵循一个体系(.Net平台下的语言都支持的一个体系)这个体系就是CTS（Common Type System 公共类型系统），它包括但不限于：  </p>
<ul>
<li>建立用于跨语言执行的框架。</li>
<li>提供面向对象的模型，支持在 .NET 实现上实现各种语言。 </li>
<li>定义处理类型时所有语言都必须遵守的一组规则(CLS)。 </li>
<li>提供包含应用程序开发中使用的基本基元数据类型（如 <code>Boolean</code>、<code>Byte</code>、<code>Char</code> 等）的库。  </li>
</ul>
<p>&emsp;&emsp;上文的CLS是CTS（Common Type System 公共类型系统）这个体系中的子集。<br>&emsp;&emsp;一个编程语言，如果它能够支持CTS，那么我们就称它为面向.NET平台的语言。<br>&emsp;&emsp;官方CTS介绍： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/common-type-system" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/common-type-system</a>  </p>
<blockquote>
<p>微软已经将CTS和.NET的一些其它组件，提交给ECMA以成为公开的标准，最后形成的标准称为CLI（Common Language Infrastructure）公共语言基础结构。<br>所以有的时候你见到的书籍或文章有的只提起CTS，有的只提起CLI，请不要奇怪，你可以宽泛的把他们理解成一个意思，CLI是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准。  </p>
</blockquote>
<h1 id="什么是类库？"><a href="#什么是类库？" class="headerlink" title="什么是类库？"></a>什么是类库？</h1><p>&emsp;&emsp;在CTS中有一条就是要求基元数据类型的类库。我们先搞清什么是类库？类库就是类的逻辑集合，你开发工作中你用过或自己编写过很多工具类，比如搞Web的经常要用到的 JsonHelper、XmlHelper、HttpHelper 等等，这些类通常都会在命名为Tool、Utility等这样的项目中。 像这些类的集合我们可以在逻辑上称之为 “类库”，比如这些Helper我们统称为工具类库。  </p>
<h2 id="什么是基础类库BCL？"><a href="#什么是基础类库BCL？" class="headerlink" title="什么是基础类库BCL？"></a>什么是基础类库BCL？</h2><p>&emsp;&emsp;当你通过VS创建一个项目后，你这个项目就已经引用好了通过.NET下的语言编写好的一些类库。比如控制台中你直接就可以用<code>Console</code>类来输出信息，或者<code>using System.IO</code> 即可通过<code>File</code>类对文件进行读取或写入操作，这些类都是微软帮你写好的，不用你自己去编写，它帮你编写了一个面向.NET的开发语言中使用的基本的功能，这部分类，我们称之为BCL（Base Class Library）， 基础类库，它们大多都包含在<code>System</code>命名空间下。<br>&emsp;&emsp;基础类库BCL包含：基本数据类型，文件操作，集合，自定义属性，格式设置，安全属性，I/O流，字符串操作，事件日志等的类型  </p>
<h2 id="什么是框架类库FCL？"><a href="#什么是框架类库FCL？" class="headerlink" title="什么是框架类库FCL？"></a>什么是框架类库FCL？</h2><p>&emsp;&emsp;有关BCL的就不在此一一类举。.NET之大，发展至今，由微软帮助开发人员编写的类库越来越多，这让我们开发人员开发更加容易。由微软开发的类库统称为：FCL，Framework Class Library ，.NET框架类库，我上述所表达的BCL就是FCL中的一个基础部分，FCL中大部分类都是通过C#来编写的。<br>&emsp;&emsp;在FCL中，除了最基础的那部分BCL之外，还包含我们常见的 如 ： 用于网站开发技术的 ASP.NET类库，该子类包含webform/webpage/mvc，用于桌面开发的 WPF类库、WinForm类库，用于通信交互的WCF、asp.net web api、Web Service类库等等  </p>
<h1 id="什么是基元类型？"><a href="#什么是基元类型？" class="headerlink" title="什么是基元类型？"></a>什么是基元类型？</h1><p>&emsp;&emsp;像上文在CTS中提到了 基本基元数据类型，大家知道，每门语言都会定义一些基础的类型，比如C#通过 <code>int</code> 来定义整型，用 <code>string</code> 来定义 字符串 ，用 <code>object</code> 来定义 根类。当我们来描述这样一个类型的对象时可以有这两种写法，如图：<br><img src="1026815-20180626185607189-1458214346.png" alt=" "><br>&emsp;&emsp;我们可以看到，上边用首字母小写的蓝色体string、object能描述，用首字母大写的浅蓝色String、Object也能描述,这两种表述方式有何不同？<br>&emsp;&emsp;要知道，在vs默认的颜色方案中，蓝色体 代表关键字，浅蓝色体 代表类型。<br>&emsp;&emsp;那么这样也就意味着，由微软提供的FCL类库里面 包含了 一些用于描述数据类型的 基础类型，无论我们使用的是什么语言，只要引用了FCL，我们都可以通过new一个类的方式来表达数据类型。<br>&emsp;&emsp;如图：<br><img src="1026815-20180626185646714-1678378546.png" alt=" "><br>&emsp;&emsp;用new来创建这些类型的对象，但这样就太繁琐，所以C#就用 <code>int</code> 关键字来表示<code>System.Int32</code>，用 <code>string</code> 关键字来表示 <code>System.String</code> 等，所以我们才能这样去写。<br><img src="1026815-20180626185736390-1921725105.png" alt=" "><br>&emsp;&emsp;像这样被表述于编译器直接支持的类型叫做基元类型，它被直接映射于BCL中具体的类。<br>&emsp;&emsp;下面是部分面向.NET的语言的基元类型与对应的BCL的类别图：<br><img src="1026815-20180626190310924-274605711.png" alt=" ">  </p>
<h1 id="System-Object的意义"><a href="#System-Object的意义" class="headerlink" title="System.Object的意义"></a>System.Object的意义</h1><p>&emsp;&emsp;说起类型，这里要说CTS定义的一个非常重要的规则，就是类与类之间只能单继承，<code>System.Object</code>类是所有类型的根，任何类都是显式或隐式的继承于<code>System.Object</code>。<br>&emsp;&emsp;<code>System.Object</code>定义了类型的最基本的行为：用于实例比较的<code>Equals</code>系列方法、用于Hash表中Hash码的<code>GetHashCode</code>、用于Clr运行时获取的类型信息<code>GetType</code>、用于表示当前对象字符串的<code>ToString</code>、用于执行实例的浅复制<code>MemberwiseClone</code>、用于GC回收前操作的析构方法<code>Finalize</code> 这6类方法。<br>&emsp;&emsp;所以 Object不仅是C#语言的类型根、还是VB等所有面向.NET的语言的类型根，它是整个FCL的类型根。<br>&emsp;&emsp;当然，CTS定义了单继承，很多编程语言都满足这个规则，但也有语言是例外，如C++就不做继承限制，可以继承多个，C++/CLI作为C++在对.NET的CLI实现，如果在非托管编码中多继承那也可以，如果试图在托管代码中多继承，那就会报错。我前面已经举过这样特殊情况的例子，这也在另一方面反映出，各语言对CTS的支持并不是都如C#那样全面的，我们只需明记一点：对于符合CTS的那部分自然就按照CTS定义的规则来。 任何可遵循CTS的类型规范，同时又有.NET运行时的实现的编程语言就可以成为.NET中的一员。  </p>
<h1 id="计算机是如何运行程序的？"><a href="#计算机是如何运行程序的？" class="headerlink" title="计算机是如何运行程序的？"></a>计算机是如何运行程序的？</h1><p>&emsp;&emsp;接下来我要说什么是.NET的跨平台，并解释为什么能够跨语言。不过要想知道什么是跨平台，首先你得知道一个程序是如何在本机上运行的。  </p>
<h2 id="什么是CPU"><a href="#什么是CPU" class="headerlink" title="什么是CPU"></a>什么是CPU</h2><p>&emsp;&emsp;CPU,全称Central Processing Unit,叫做中央处理器,它是一块超大规模的集成电路，是计算机组成上必不可少的组成硬件，没了它，计算机就是个壳。<br>&emsp;&emsp;无论你编程水平怎样，你都应该先知道，CPU是一台计算机的运算核心和控制核心，CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，执行指令。<br>&emsp;&emsp;我们运行一个程序，CPU就会不断的读取程序中的指令并执行，直到关闭程序。事实上，从电脑开机开始，CPU就一直在不断的执行指令直到电脑关机。  </p>
<h2 id="什么是高级编程语言"><a href="#什么是高级编程语言" class="headerlink" title="什么是高级编程语言"></a>什么是高级编程语言</h2><p>&emsp;&emsp;在计算机角度，每一种CPU类型都有自己可以识别的一套指令集，计算机不管你这个程序是用什么语言来编写的，其最终只认其CPU能够识别的二进制指令集。<br>&emsp;&emsp;在早期计算机刚发展的时代，人们都是直接输入01010101这样的没有语义的二进制指令来让计算机工作的，可读性几乎没有，没人愿意直接编写那些没有可读性、繁琐、费时，易出差错的二进制01代码，所以后来才出现了编程语言。<br>&emsp;&emsp;编程语言的诞生，使得人们编写的代码有了可读性，有了语义，与直接用01相比，更有利于记忆。<br>&emsp;&emsp;而前面说了，计算机最终只识别二进制的指令，那么，我们用编程语言编写出来的代码就必须要转换成供机器识别的指令。<br>&emsp;&emsp;就像这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">code: 1+2 </span><br><span class="line">function 翻译方法(参数:code) </span><br><span class="line">&#123; </span><br><span class="line">    ... </span><br><span class="line">    &quot;1&quot;=&gt;&quot;001&quot;; </span><br><span class="line">    &quot;2&quot;=&gt;&quot;002&quot;;</span><br><span class="line">    &quot;+&quot;=&gt;&quot;000&quot;; </span><br><span class="line">    return 能让机器识别的二进制代码; </span><br><span class="line">&#125; </span><br><span class="line">call 翻译方法(&quot;1+2&quot;) =&gt; &quot;001 000 002&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以从一门编程语言所编写的代码文件转换成能让本机识别的指令，这中间是需要一个翻译的过程。<br>&emsp;&emsp;而我们现在计算机上是运载着操作系统的，光翻译成机器指令也不行，还得让代码文件转化成可供操作系统执行的程序才行。<br>&emsp;&emsp;那么这些步骤，就是编程语言所对应的编译环节的工程了。这个翻译过程是需要工具来完成，我们把它叫做 编译器。<br>&emsp;&emsp;不同厂商的CPU有着不同的指令集，为了克服面向CPU的指令集的难读、难编、难记和易出错的缺点，后来就出现了面向特定CPU的特定汇编语言， 比如我打上这样的x86汇编指令 mov ax,bx ，然后用上用机器码做的汇编器，它将会被翻译成 1000100111011000 这样的二进制01格式的机器指令。<br>&emsp;&emsp;不同CPU架构上的汇编语言指令不同，而为了统一一套写法，同时又不失汇编的表达能力，C语言就诞生了。<br>&emsp;&emsp;用C语言写的代码文件，会被C编译器先转换成对应平台的汇编指令，再转成机器码，最后将这些过程中产生的中间模块链接成一个可以被操作系统执行的程序。<br>&emsp;&emsp;那么汇编语言和C语言比较，我们就不需要去阅读特定CPU的汇编码，我只需要写通用的C源码就可以实现程序的编写，我们用将更偏机器实现的汇编语言称为低级语言，与汇编相比，C语言就称之为高级语言。<br>&emsp;&emsp;在看看我们C#，我们在编码的时候都不需要过于偏向特定平台的实现，翻译过程也基本遵循这个过程。它的编译模型和C语言类似，都是属于这种间接转换的中间步骤，故而能够跨平台。<br>&emsp;&emsp;所以就类似于C/C#等这样的高级语言来说是不区分平台的，而在于其背后支持的这个 翻译原理 是否能支持其它平台。  </p>
<h1 id="什么是托管代码，托管语言，托管模块？"><a href="#什么是托管代码，托管语言，托管模块？" class="headerlink" title="什么是托管代码，托管语言，托管模块？"></a>什么是托管代码，托管语言，托管模块？</h1><p>&emsp;&emsp;作为一门年轻的语言，C#借鉴了许多语言的长处，与C比较，C#则更为高级。<br>&emsp;&emsp;往往一段简小的C#代码，其功能却相当于C的一大段代码，并且用C#语言你几乎不需要指针的使用，这也就意味着你几乎不需要进行人为的内存管控与安全考虑因素，也不需要多懂一些操作系统的知识，这让编写程序变得更加轻松和快捷。<br>&emsp;&emsp;如果说C#一段代码可以完成其它低级语言一大段任务，那么我们可以说它特性丰富或者类库丰富。而用C#编程不需要人为内存管控是怎么做到的呢？<br>&emsp;&emsp;.NET提供了一个垃圾回收器(GC)来完成这部分工作，当你创建类型的时候，它会自动给你分配所需要的这部分内存空间。就相当于，有一个专门的软件或进程，它会读取你的代码，然后当你执行这行代码的时候，它帮你做了内存分配工作。 这部分本该你做的工作，它帮你做了，这就是“托管”的概念。比如现实中 托管店铺、托管教育等这样的别人替你完成的概念。<br>&emsp;&emsp;因此，C#被称之为托管语言。C#编写的代码也就称之为托管代码,C#生成的模块称之为托管模块等。(对于托管的资源，是不需要也无法我们人工去干预的，但我们可以了解它的一些机制原理，在后文我会简单介绍。)<br>&emsp;&emsp;只要有比较，就会产生概念。那么在C#角度，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。  </p>
<h2 id="非托管的异常"><a href="#非托管的异常" class="headerlink" title="非托管的异常"></a>非托管的异常</h2><p>&emsp;&emsp;我们编写的程序有的模块是由托管代码编写，有的模块则调用了非托管代码。在.NET Framework中也有一套基于此操作系统SEH的异常机制，理想的机制设定下我们可以直接通过<code>catch(e)</code>或<code>catch</code>来捕获指定的异常和框架设计人员允许我们捕获的异常。<br>&emsp;&emsp;而异常类型的级别也有大有小，有小到可以直接框架本身或用代码处理的，有大到需要操作系统的异常机制来处理。.NET会对那些能让程序崩溃的异常类型给进行标记，对于这部分异常，在.NET Framework 4.0之前允许开发人员在代码中自己去处理，但4.0版本之后有所变更，这些被标记的异常默认不会在托管环境中抛出(即无法catch到)，而是由操作系统的SEH机制去处理。<br>&emsp;&emsp;不过如果你仍然想在代码中捕获处理这样的异常也是可以的，你可以对需要捕获的方法上标记<code>[System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute]</code>特性，就可以在该方法内通过<code>catch</code>捕获到该类型的异常。你也可以通过在配置文件中添加运行时节点来对全局进行这样的一个配置：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">    &lt;legacyCorruptedStateExceptionsPolicy enabled=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HandleProcessCorruptedStateExceptions特性：<a href="https://msdn.microsoft.com/zh-cn/library/azure/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/azure/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute.aspx</a><br>&emsp;&emsp;SEHException类：<a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception(v=vs.100).aspx</a><br>&emsp;&emsp;处理损坏状态异常博客专栏： <a href="https://msdn.microsoft.com/zh-cn/magazine/dd419661.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/magazine/dd419661.aspx</a>  </p>
<h1 id="什么是CLR，-NET虚拟机？"><a href="#什么是CLR，-NET虚拟机？" class="headerlink" title="什么是CLR，.NET虚拟机？"></a>什么是CLR，.NET虚拟机？</h1><p>&emsp;&emsp;实际上，.NET不仅提供了自动内存管理的支持，他还提供了一些列的如类型安全、应用程序域、异常机制等支持，这些 都被统称为CLR公共语言运行库。<br>&emsp;&emsp;CLR是.NET类型系统的基础，所有的.NET技术都是建立在此之上，熟悉它可以帮助我们更好的理解框架组件的核心、原理。<br>&emsp;&emsp;在我们执行托管代码之前，总会先运行这些运行库代码，通过运行库的代码调用，从而构成了一个用来支持托管程序的运行环境，进而完成诸如不需要开发人员手动管理内存，一套代码即可在各大平台跑的这样的操作。<br>&emsp;&emsp;这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。那么，如果以进程为最低端，进程的上面就是.NET虚拟机(CLR)，而虚拟机的上面才是我们的托管代码。换句话说，托管程序实际上是寄宿于.NET虚拟机中。  </p>
<h1 id="什么是CLR宿主进程，运行时主机？"><a href="#什么是CLR宿主进程，运行时主机？" class="headerlink" title="什么是CLR宿主进程，运行时主机？"></a>什么是CLR宿主进程，运行时主机？</h1><p>&emsp;&emsp;那么相对应的，容纳.NET虚拟机的进程就是CLR宿主进程了，该程序称之为运行时主机。<br>&emsp;&emsp;这些运行库的代码，全是由C/C++编写，具体表现为以 <code>mscoree.dll</code> 为代表的核心dll文件，该dll提供了N多函数用来构建一个CLR环境 ，最后当运行时环境构建完毕(一些函数执行完毕)后，调用<code>_CorDllMain</code>或<code>_CorExeMain</code>来查找并执行托管程序的入口方法(如控制台就是Main方法)。<br>&emsp;&emsp;如果你足够熟悉CLR，那么你完全可以在一个非托管程序中通过调用运行库函数来定制CLR并执行托管代码。<br>&emsp;&emsp;像SqlServer就集成了CLR，可以使用任何 .NET Framework 语言编写存储过程、触发器、用户定义类型、用户定义函数（标量函数和表值函数）以及用户定义的聚合函数。<br>&emsp;&emsp;有关CLR大纲介绍： <a href="https://msdn.microsoft.com/zh-cn/library/9x0wh2z3(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/9x0wh2z3(v=vs.85).aspx</a><br>&emsp;&emsp;CLR集成： <a href="https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/ms131052(v%3dsql.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/ms131052(v%3dsql.100)</a><br>&emsp;&emsp;构造CLR的接口：<a href="https://msdn.microsoft.com/zh-cn/library/ms231039(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms231039(v=vs.85).aspx</a><br>&emsp;&emsp;适用于 .NET Framework 2.0 的宿主接口：<a href="https://msdn.microsoft.com/zh-cn/library/ms164336(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms164336(v=vs.85).aspx</a><br>&emsp;&emsp;选择CLR版本： <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/startup/supportedruntime-element" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/startup/supportedruntime-element</a><br>&emsp;&emsp;所以C#编写的程序如果想运行就必须要依靠.NET提供的CLR环境来支持。 而CLR是.NET技术框架中的一部分，故只要在Windows系统中安装.NET Framework即可。  </p>
<h1 id="Windows系统自带-NET-Framework"><a href="#Windows系统自带-NET-Framework" class="headerlink" title="Windows系统自带.NET Framework"></a>Windows系统自带.NET Framework</h1><p>&emsp;&emsp;Windows系统默认安装的有.NET Framework，并且可以安装多个.NET Framework版本，你也不需要因此卸载，因为你使用的应用程序可能依赖于特定版本，如果你移除该版本，则应用程序可能会中断。<br>&emsp;&emsp;Microsoft .NET Framework百度百科下有windows系统默认安装的.NET版本<br><img src="1026815-20180626193928463-1860763399.png" alt=" "><br>&emsp;&emsp;图出自 <a href="https://baike.baidu.com/item/Microsoft%20.NET%20Framework/9926417?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Microsoft%20.NET%20Framework/9926417?fr=aladdin</a>  </p>
<h1 id="NET-Framework-4-0-30319"><a href="#NET-Framework-4-0-30319" class="headerlink" title=".NET Framework 4.0.30319"></a>.NET Framework 4.0.30319</h1><p>&emsp;&emsp;在%SystemRoot%\Microsoft.NET下的Framework和Framework64文件夹中分别可以看到32位和64位的.NET Framework安装的版本。<br>&emsp;&emsp;我们点进去可以看到以.NET版本号为命名的文件夹，有2.0,3.0,3.5,4.0这几个文件夹。<br><img src="1026815-20180626190844595-825495686.png" alt=" ">  </p>
<h2 id="NET-Framework4-X覆盖更新"><a href="#NET-Framework4-X覆盖更新" class="headerlink" title=".NET Framework4.X覆盖更新"></a>.NET Framework4.X覆盖更新</h2><p>&emsp;&emsp;要知道.NET Framework版本目前已经迭代到4.7系列，电脑上明明安装了比4.0更高版本的.NET Framework，然而从文件夹上来看，最高不过4.0，这是为何？<br>&emsp;&emsp;原来自.NET Framework 4以来的所有.NET Framework版本都是直接在v4.0.30319文件夹上覆盖更新，并且无法安装以前的4.x系列的老版本，所以v4.0.30319这个目录中其实放的是你最后一次更新的NET Framework版本。<br>&emsp;&emsp;.NET Framework覆盖更新：<a href="https://docs.microsoft.com/en-us/dotnet/framework/install/guide-for-developers" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/install/guide-for-developers</a>  </p>
<h2 id="如何确认本机安装了哪些-NET-Framework和对应CLR的版本？"><a href="#如何确认本机安装了哪些-NET-Framework和对应CLR的版本？" class="headerlink" title="如何确认本机安装了哪些.NET Framework和对应CLR的版本？"></a>如何确认本机安装了哪些.NET Framework和对应CLR的版本？</h2><p>&emsp;&emsp;我们可以通过注册表等其它方式来查看安装的最新版本：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed</a> 。<br>&emsp;&emsp;不过如果不想那么复杂的话，还有种最直接简单的：<br>&emsp;&emsp;那就是进入该目录文件夹，随便找到几个文件对其右键，然后点击详细信息即可查看到对应的文件版本，可以依据文件版本估摸出.NET Framework版本，比如csc.exe文件。<br><img src="1026815-20180626191049347-855171658.png" alt=" ">  </p>
<h1 id="什么是程序集"><a href="#什么是程序集" class="headerlink" title="什么是程序集"></a>什么是程序集</h1><p>&emsp;&emsp;上文我介绍了编译器，即将源代码文件给翻译成一个计算机可识别的二进制程序。而在.NET Framework目录文件夹中就附带的有 用于C#语言的命令行形式的编译器<code>csc.exe</code> 和 用于VB语言的命令行形式的编译器<code>vbc.exe</code>。<br>&emsp;&emsp;我们通过编译器可以将后缀为<code>.cs(C#)</code>和<code>.vb(VB)</code>类型的文件编译成程序集。<br>&emsp;&emsp;程序集是一个抽象的概念，不同的编译选项会产生不同形式的程序集。以文件个数来区分的话，那么就分 单文件程序集(即一个文件)和多文件程序集(多个文件)。<br>&emsp;&emsp;而不论是单文件程序集还是多文件程序集，其总有一个核心文件，就是表现为后缀为<code>.dll</code>或<code>.exe</code>格式的文件。它们都是标准的PE格式的文件，主要由4部分构成：  </p>
<ol>
<li>PE头，即Windows系统上的可移植可执行文件的标准格式 </li>
<li>CLR头，它是托管模块特有的，它主要包括 <ol>
<li>程序入口方法</li>
<li>CLR版本号等一些标志</li>
<li>一个可选的强名称数字签名</li>
<li>元数据表，主要用来记录了在源代码中定义和引用的所有的类型成员(如方法、字段、属性、参数、事件…)的位置和其标志Flag(各种修饰符)<br>正是因为元数据表的存在，VS才能智能提示，反射才能获取MemberInfo，CLR扫描元数据表即可获得该程序集的相关重要信息，所以元数据表使得程序集拥有了自我描述的这一特性。clr2中，元数据表大概40多个，其核心按照用途分为3类： <ol>
<li>即用于记录在源代码中所定义的类型的定义表：ModuleDef、TypeDef、MethodDef、ParamDef、FieldDef、PropertyDef、EventDef，</li>
<li>引用了其它程序集中的类型成员的引用表：MemberRef、AssemblyRef、ModuleRef、TypeRef</li>
<li>用于描述一些杂项(如版本、发布者、语言文化、多文件程序集中的一些资源文件等)的清单表：AssemblyDef、FileDef、ManifestResourceDef、ExportedTypeDef</li>
</ol>
</li>
</ol>
</li>
<li>IL代码(也称MSIL，后来被改名为CIL：Common Intermediate Language通用中间语言)，是介于源代码和本机机器指令中间的代码，将通过CLR在不同的平台产生不同的二进制机器码。 </li>
<li>一些资源文件  </li>
</ol>
<p>&emsp;&emsp;多文件程序集的诞生场景有：比如我想为.exe绑定资源文件(如Icon图标)，或者我想按照功能以增量的方式来按需编译成.dll文件。 通常很少情况下才会将源代码编译成多文件程序集，并且在VS IDE中总是将源代码给编译成单文件的程序集(要么是.dll或.exe)，所以接下来我就以单文件程序集为例来讲解。  </p>
<h1 id="用csc-exe进行编译"><a href="#用csc-exe进行编译" class="headerlink" title="用csc.exe进行编译"></a>用csc.exe进行编译</h1><p>&emsp;&emsp;现在，我将演示一段文本是如何被csc.exe编译成一个可执行的控制台程序的。<br>&emsp;&emsp;我们新建个记事本，然后将下面代码复制上去。  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> rootDirectory = Environment.CurrentDirectory;</span><br><span class="line">        Console.WriteLine(<span class="string">"开始连接，端口号：8090"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        socket.Bind(<span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Loopback, <span class="number">8090</span>));</span><br><span class="line">        socket.Listen(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Socket socketClient = socket.Accept();</span><br><span class="line">            Console.WriteLine(<span class="string">"新请求"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> length = socketClient.Receive(buffer, <span class="number">4096</span>, SocketFlags.None);</span><br><span class="line">            <span class="keyword">string</span> requestStr = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, length);</span><br><span class="line">            Console.WriteLine(requestStr);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">string</span>[] strs = requestStr.Split(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"\r\n"</span> &#125;, StringSplitOptions.None);</span><br><span class="line">            <span class="keyword">string</span> url = strs[<span class="number">0</span>].Split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] statusBytes, headerBytes, bodyBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Path.GetExtension(url) == <span class="string">".jpg"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> status = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">                statusBytes = Encoding.UTF8.GetBytes(status);</span><br><span class="line">                bodyBytes = File.ReadAllBytes(rootDirectory + url);</span><br><span class="line">                <span class="keyword">string</span> header = <span class="keyword">string</span>.Format(<span class="string">"Content-Type:image/jpg;\r\ncharset=UTF-8\r\nContent-Length:&#123;0&#125;\r\n"</span>, bodyBytes.Length);</span><br><span class="line">                headerBytes = Encoding.UTF8.GetBytes(header);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (url == <span class="string">"/"</span>)</span><br><span class="line">                    url = <span class="string">"默认页"</span>;</span><br><span class="line">                <span class="keyword">string</span> status = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">                statusBytes = Encoding.UTF8.GetBytes(status);</span><br><span class="line">                <span class="keyword">string</span> body = <span class="string">"&lt;html&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;head&gt;"</span> +</span><br><span class="line">                        <span class="string">"&lt;title&gt;socket webServer  -- Login&lt;/title&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;/head&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;body&gt;"</span> +</span><br><span class="line">                       <span class="string">"&lt;div style=\"text-align:center\"&gt;"</span> +</span><br><span class="line">                           <span class="string">"当前访问"</span> + url +</span><br><span class="line">                       <span class="string">"&lt;/div&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;/body&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">                bodyBytes = Encoding.UTF8.GetBytes(body);</span><br><span class="line">                <span class="keyword">string</span> header = <span class="keyword">string</span>.Format(<span class="string">"Content-Type:text/html;charset=UTF-8\r\nContent-Length:&#123;0&#125;\r\n"</span>, bodyBytes.Length);</span><br><span class="line">                headerBytes = Encoding.UTF8.GetBytes(header);</span><br><span class="line">            &#125;</span><br><span class="line">            socketClient.Send(statusBytes);</span><br><span class="line">            socketClient.Send(headerBytes);</span><br><span class="line">            socketClient.Send(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>)<span class="string">'\r'</span>, (<span class="keyword">byte</span>)<span class="string">'\n'</span> &#125;);</span><br><span class="line">            socketClient.Send(bodyBytes);</span><br><span class="line"></span><br><span class="line">            socketClient.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后关闭记事本，将之.txt的后缀改为.cs的后缀(后缀是用来标示这个文件是什么类型的文件，并不影响文件的内容)。<br>&emsp;&emsp;上述代码相当于Web中的http.sys伪实现，是建立了通信的socket服务端，并通过while循环来不断的监视获取包的数据实现最基本的监听功能，最终我们将通过csc.exe将该文本文件编译成一个控制台程序。<br>&emsp;&emsp;我已经在前面讲过BCL，基础类库。在这部分代码中，为了完成我想要的功能，我用到了微软已经帮我们实现好了的<code>String</code>数据类型系列类(.NET下的一些数据类型)、<code>Environment</code>类(提供有关当前环境和平台的信息以及操作它们的方法)、<code>Console</code>类(用于控制台输入输出等)、<code>Socket</code>系列类(对tcp协议抽象的接口)、<code>File</code>文件系列类(对文件目录等操作系统资源的一些操作)、<code>Encoding</code>类(字符流的编码)等<br>&emsp;&emsp;这些类，都属于BCL中的一部分，它们存在但不限于<code>mscorlib.dll</code>、<code>System.dll</code>、<code>System.core.dll</code>、<code>System.Data.dll</code>等这些程序集中。<br>&emsp;&emsp;附：不要纠结BCL到底存在于哪些dll中，总之，它是个物理分散，逻辑上的类库总称。<br>&emsp;&emsp;mscorlib.dll和System.dll的区别：<a href="https://stackoverflow.com/questions/402582/mscorlib-dll-system-dll" target="_blank" rel="noopener">https://stackoverflow.com/questions/402582/mscorlib-dll-system-dll</a><br>&emsp;&emsp;因为我用了这些类，那么按照编程规则我必须在代码中using这些类的命名空间，并通过<code>csc.exe</code>中的 <code>/r:dll</code>路径 命令来为生成的程序集注册元数据表(即以AssemblyRef为代表的程序集引用表)。<br>&emsp;&emsp;而这些代码引用了4个命名空间，但实际上它们只被包含在<code>mscorlib.dll</code>和<code>System.dll</code>中，那么我只需要在编译的时候注册这两个dll的信息就行了。<br>&emsp;&emsp;好，接下来我将通过<code>cmd</code>运行<code>csc.exe</code>编译器，再输入编译命令： <code>csc /out:D:\demo.exe D:\dic\demo.cs /r:D:\dic\System.dll</code>  </p>
<ul>
<li><code>/r</code>：是将引用dll中的类型数据注册到程序集中的元数据表中。  </li>
<li><code>/out</code>:是输出文件的意思，如果没有该命令则默认输出<code>{name}.exe</code>。  </li>
</ul>
<p>&emsp;&emsp;使用csc.exe编译生成： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe</a><br>&emsp;&emsp;csc编译命令行介绍：<a href="https://www.cnblogs.com/shuang121/archive/2012/12/24/2830874.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuang121/archive/2012/12/24/2830874.html</a><br>&emsp;&emsp;总之，你除了要掌握基本的编译指令外，当你打上这行命令并按回车后，必须满足几个条件，1.是.cs后缀的c#格式文件，2.是 代码语法等检测分析必须正确，3.是 使用的类库必须有出处(引用的dll)，当然 因为我是编译为控制台程序，所以还必须得有个静态Main方法入口，以上缺一不可。<br>&emsp;&emsp;可以看出，这段命令我是将 位于D:\dic\的demo.cs文件给编译成 位于D:\名为demo.exe的控制台文件，并且因为在代码中使用到了System.dll，所以还需要通过/r注册该元数据表。<br>&emsp;&emsp;这里得注意为什么没有<code>/r:mscorlib.dll</code>,因为mscorlib.dll地位的特殊，所以csc总是对每个程序集进行mscorlib.dll的注册(自包含引用该dll),因此我们可以不用<code>/r:mscorlib.dll</code>这个引用命令，但为了演示效果我还是决定通过<code>/nostdlib</code>命令来禁止csc默认导入mscorlib.dll文件。<br>&emsp;&emsp;所以，最终命令是这样的： <code>csc D:\dic\demo.cs /r:D:\dic\mscorlib.dll /r:D:\dic\System.dll /nostdlib</code><br><img src="1026815-20180626192059660-977860665.png" alt=" "><br>&emsp;&emsp;因为没有指定输出文件<code>/out</code>选项， 所以会默认输出在与csc同一目录下名为demo.exe的文件。事实上，在csc的命令中，如果你没有指定路径，那么就默认采用在csc.exe的所在目录的相对路径。<br><img src="1026815-20180626192159540-608756226.png" alt=" "><br>&emsp;&emsp;而我们可以看到，在该目录下有许多程序集，其中就包含我们需要的System.dll和mscorlib.dll，所以我们完全可以直接<code>/r:mscorlib.dll /r:System.dll</code><br>&emsp;&emsp;而类似于System.dll、System.Data.dll这样使用非常频繁的程序集，我们其实不用每次编译的时候都去手动/r一下，对于需要重复劳动的编译指令，我们可以将其放在后缀为.rsp的指令文件中，然后在编译时直接调用文件即可执行里面的命令 <code>@ {name}.rsp</code>。<br><img src="1026815-20180626192239508-1912250944.png" alt=" "><br>&emsp;&emsp;csc.exe默认包含csc.rsp文件,我们可以用<code>/noconfig</code>来禁止默认包含，而csc.rsp里面已经写好了我们会经常用到的指令。<br>&emsp;&emsp;所以，最终我可以这样写 <code>csc D:\dic\demo.cs</code> 直接生成控制台应用程序。<br><img src="1026815-20180626193627595-1254138010.gif" alt=" ">  </p>
<h1 id="NET程序执行原理"><a href="#NET程序执行原理" class="headerlink" title=".NET程序执行原理"></a>.NET程序执行原理</h1><p>&emsp;&emsp;好的，现在我们已经有了一个demo.exe的可执行程序，它是如何被我们运行的？<br>&emsp;&emsp;C#源码被编译成程序集，程序集内主要是由一些元数据表和IL代码构成，我们双击执行该exe，Windows加载器将该exe(PE格式文件)给映射到虚拟内存中，程序集的相关信息都会被加载至内存中，并查看PE文件的入口点  (EntryPoint)并跳转至指定的mscoree.dll中的<code>_CorExeMain</code>函数，该函数会执行一系列相关dll来构造CLR环境，当CLR预热后调用该程序集的入口方法<code>Main()</code>，接下来由CLR来执行托管代码(IL代码)。  </p>
<h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>&emsp;&emsp;前面说了，计算机最终只识别二进制的机器码，在CLR下有一个用来将IL代码转换成机器码的引擎，称为Just In Time Compiler，简称JIT，CLR总是先将IL代码按需通过该引擎编译成机器指令再让CPU执行，在这期间CLR会验证代码和元数据是否类型安全(在对象上只调用正确定义的操作、标识与声称的要求一致、对类型的引用严格符合所引用的类型)，被编译过的代码无需JIT再次编译，而被编译好的机器指令是被存在内存当中，当程序关闭后再打开仍要重新JIT编译。  </p>
<h2 id="AOT编译"><a href="#AOT编译" class="headerlink" title="AOT编译"></a>AOT编译</h2><p>&emsp;&emsp;CLR的内嵌编译器是即时性的，这样的一个很明显的好处就是可以根据当时本机情况生成更有利于本机的优化代码，但同样的，每次在对代码编译时都需要一个预热的操作，它需要一个运行时环境来支持，这之间还是有消耗的。<br>&emsp;&emsp;而与即时编译所对应的，就是提前编译了，英文为Ahead of Time Compilation，简称AOT，也称之为静态编译。<br>&emsp;&emsp;在.NET中，使用<code>Ngen.exe</code>或者开源的<code>.NET Native</code>可以提前将代码编译成本机指令。<br>&emsp;&emsp;Ngen是将IL代码提前给全部编译成本机代码并安装在本机的本机映像缓存中，故而可以减少程序因JIT预热的时间，但同样的也会有很多注意事项，比如因JIT的丧失而带来的一些特性就没有了，如类型验证。Ngen仅是尽可能代码提前编译，程序的运行仍需要完整的CLR来支持。<br>&emsp;&emsp;.NET Native在将IL转换为本机代码的时候，会尝试消除所有元数据将依靠反射和元数据的代码替换为静态本机代码，并且将完整的CLR替换为主要包含垃圾回收器的重构运行时<code>mrt100_app.dll</code>。<br>&emsp;&emsp;.NET Native: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/net-native/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/net-native/</a><br>&emsp;&emsp;Ngen.exe：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator</a><br>&emsp;&emsp;Ngen与.NET Native比较：<a href="https://www.zhihu.com/question/27997478/answer/38978762" target="_blank" rel="noopener">https://www.zhihu.com/question/27997478/answer/38978762</a>  </p>
<hr>
<p>&emsp;&emsp;现在，我们可以通过<code>ILDASM</code>工具(一款查看程序集IL代码的软件，在Microsoft SDKs目录中的子目录中)来查看该程序集的元数据表和Main方法中间码。<br><img src="1026815-20180626194204408-1416829392.png" alt=" "><br>&emsp;&emsp;c#源码第一行代码：<code>string rootDirectory = Environment.CurrentDirectory</code>;被翻译成IL代码： <code>call string [mscorlib/*23000001*/]System.Environment/*01000004*/::get_CurrentDirectory() /* 0A000003 */</code><br>&emsp;&emsp;这句话意思是调用 <code>System.Environment</code>类的<code>get_CurrentDirectory()</code>方法(属性会被编译为一个私有字段+对应get/set方法)。<br>&emsp;&emsp;点击视图=&gt;元信息=&gt;显示，即可查看该程序集的元数据。<br>&emsp;&emsp;我们可以看到<code>System.Environment</code>标记值为01000004，在<code>TypeRef</code>类型引用表中找到该项:<br><img src="1026815-20180626194233787-1487817175.png" alt=" "><br>&emsp;&emsp;注意图，<code>TypeRefName</code>下面有该类型中被引用的成员，其标记值为0A000003，也就是<code>get_CurrentDirectory</code>了。<br>&emsp;&emsp;而从其<code>ResolutionScope</code>指向位于0x23000001而得之，该类型存在于mscorlib程序集。<br><img src="1026815-20180626194312588-1104904496.png" alt=" "><br>&emsp;&emsp;于是我们打开mscorlib.dll的元数据清单，可以在类型定义表(TypeDef)找到<code>System.Environment</code>,可以从元数据得知该类型的一些标志(Flags,常见的public、sealed、class、abstract)，也得知继承(Extends)于<code>System.Object</code>。在该类型定义下还有类型的相关信息，我们可以在其中找到<code>get_CurrentDirectory</code>方法。 我们可以得到该方法的相关信息，这其中表明了该方法位于0x0002b784这个相对虚地址(RVA)，接着JIT在新地址处理CIL，周而复始。<br>&emsp;&emsp;元数据在运行时的作用： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/metadata-and-self-describing-components#run-time-use-of-metadata" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/metadata-and-self-describing-components#run-time-use-of-metadata</a>  </p>
<h1 id="程序集的规则"><a href="#程序集的规则" class="headerlink" title="程序集的规则"></a>程序集的规则</h1><p>&emsp;&emsp;上文我通过ILDASM来描述CLR执行代码的方式，但还不够具体，还需要补充的是对于程序集的搜索方式。<br>&emsp;&emsp;对于System.Environment类型，它存在于mscorlib.dll程序集中，demo.exe是个独立的个体，它通过csc编译的时候只是注册了引用mscorlib.dll中的类型的引用信息，并没有记录mscorlib.dll在磁盘上的位置，那么，CLR怎么知道get_CurrentDirectory的代码？它是从何处读取mscorlib.dll的？<br>&emsp;&emsp;对于这个问题，.NET有个专门的概念定义，我们称为 程序集的加载方式。  </p>
<h2 id="程序集的加载方式"><a href="#程序集的加载方式" class="headerlink" title="程序集的加载方式"></a>程序集的加载方式</h2><p>&emsp;&emsp;对于自身程序集内定义的类型，我们可以直接从自身程序集中的元数据中获取，对于在其它程序集中定义的类型，CLR会通过一组规则来在磁盘中找到该程序集并加载在内存。<br>&emsp;&emsp;CLR在查找引用的程序集的位置时候，第一个判断条件是 判断该程序集是否被签名。<br>&emsp;&emsp;什么是签名？  </p>
<h2 id="强名称程序集"><a href="#强名称程序集" class="headerlink" title="强名称程序集"></a>强名称程序集</h2><p>&emsp;&emsp;就比如大家都叫张三，姓名都一样，喊一声张三不知道到底在叫谁。这时候我们就必须扩展一下这个名字以让它具有唯一性。<br>&emsp;&emsp;我们可以通过<code>sn.exe</code>或<code>VS</code>对项目右键属性在签名选项卡中采取RSA算法对程序集进行数字签名（加密：公钥加密，私钥解密。签名：私钥签名，公钥验证签名），会将构成程序集的所有文件通过哈希算法生成哈希值，然后通过非对称加密算法用私钥签名，最后公布公钥生成一串token，最终将生成一个由程序集名称、版本号、语言文化、公钥组成的唯一标识，它相当于一个强化的名称，即强名称程序集。<br>&emsp;&emsp;<code>mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code><br>&emsp;&emsp;我们日常在VS中的项目默认都没有被签名，所以就是弱名称程序集。强名称程序集是具有唯一标识性的程序集，并且可以通过对比哈希值来比较程序集是否被篡改，不过仍然有很多手段和软件可以去掉程序集的签名。<br>&emsp;&emsp;需要值得注意的一点是：当你试图在已生成好的强名称程序集中引用弱名称程序集，那么你必须对弱名称程序集进行签名并在强名称程序集中重新注册。<br>&emsp;&emsp;之所以这样是因为一个程序集是否被篡改还要考虑到该程序集所引用的那些程序集，根据CLR搜索程序集的规则(下文会介绍)，没有被签名的程序集可以被随意替换，所以考虑到安全性，强名称程序集必须引用强名称程序集，否则就会报错：需要强名称程序集。<br>&emsp;&emsp;.NET Framework 4.5中对强签名的更改：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/enhanced-strong-naming" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/enhanced-strong-naming</a>  </p>
<h2 id="程序集搜索规则"><a href="#程序集搜索规则" class="headerlink" title="程序集搜索规则"></a>程序集搜索规则</h2><p>&emsp;&emsp;事实上，按照存储位置来说，程序集分为共享(全局)程序集和私有程序集。<br>&emsp;&emsp;CLR查找程序集的时候，会先判断该程序集是否被强签名，如果强签名了那么就会去共享程序集的存储位置(后文的GAC)去找，如果没找到或者该程序集没有被强签名，那么就从该程序集的同一目录下去寻找。<br>&emsp;&emsp;强名称程序集是先找到与程序集名称(VS中对项目右键属性应用程序-&gt;程序集名称)相等的文件名称，然后 按照唯一标识再来确认，确认后CLR加载程序集，同时会通过公钥效验该签名来验证程序集是否被篡改(如果想跳过验证可查阅<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/how-to-disable-the-strong-name-bypass-feature)，如果强名称程序集被篡改则报错。" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/how-to-disable-the-strong-name-bypass-feature)，如果强名称程序集被篡改则报错。</a><br>&emsp;&emsp;而弱名称程序集则直接按照与程序集名称相等的文件名称来找，如果还是没有找到就以该程序集名称为目录的文件夹下去找。总之，如果最终结果就是没找到那就会报<code>System.IO.FileNotFoundException</code>异常，即尝试访问磁盘上不存在的文件失败时引发的异常。<br>&emsp;&emsp;注意：此处文件名称和程序集名称是两个概念，不要模棱两可，文件CLR头内嵌程序集名称。<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;我有一个控制台程序，其路径为D:\Demo\Debug\demo.exe，通过该程序的元数据得知，其引用了一个程序集名称为aa的普通程序集，引用了一个名为bb的强名称程序集，该bb.dll的强名称标识为：xx001。<br>&emsp;&emsp;现在CLR开始搜索程序集aa，首先它会从demo.exe控制台的同一目录（也就是D:\Demo\Debug\）中查找程序集aa，搜索文件名为aa.dll的文件，如果没找到就在该目录下以程序集名称为目录的目录中查找，也就是会查 D:\Demo\Debug\aa\aa.dll，这也找不到那就报错。<br>&emsp;&emsp;然后CLR开始搜索程序集bb，CLR从demo.exe的元数据中发现bb是强名称程序集，其标识为:xx001。于是CLR会先从一个被定义为GAC的目录中去通过标识找，没找到的话剩下的寻找步骤就和寻找aa一样完全一致了。<br>&emsp;&emsp;当然，你也可以通过配置文件config中(配置文件存在于应用程序的同一目录中)人为增加程序集搜索规则：<br>&emsp;&emsp;1.在运行时<code>runtime</code>节点中，添加<code>privatePath</code>属性来添加搜索目录，不过只能填写相对路径：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;probing privatePath=&quot;relative1;relative2;&quot; /&gt; //程序集当前目录下的相对路径目录，用;号分割</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;2.如果程序集是强签名后的，那么可以通过<code>codeBase</code>来指定网络路径或本地绝对路径。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;dependentAssembly&gt;</span><br><span class="line">                    &lt;assemblyIdentity name=&quot;myAssembly&quot;</span><br><span class="line">                                      publicKeyToken=&quot;32ab4ba45e0a69a1&quot;</span><br><span class="line">                                      culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                    &lt;codeBase version=&quot;2.0.0.0&quot;</span><br><span class="line">                              href=&quot;http://www.litwareinc.com/myAssembly.dll&quot; /&gt;</span><br><span class="line">                &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，我们还可以在代码中通过<code>AppDomain</code>类中的几个成员来改变搜索规则，如<code>AssemblyResolve</code>事件、<code>AppDomainSetup</code>类等。<br>&emsp;&emsp;有关运行时节点的描述:<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/runtime-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/runtime-element</a>  </p>
<h2 id="项目的依赖顺序"><a href="#项目的依赖顺序" class="headerlink" title="项目的依赖顺序"></a>项目的依赖顺序</h2><p>&emsp;&emsp;如果没有通过config或者在代码中来设定CLR搜索程序集的规则，那么CLR就按照默认的也就是我上述所说的模式来寻找。<br>&emsp;&emsp;所以如果我们通过csc.exe来编译项目，引用了其它程序集的话，通常需要将那些程序集复制到同一目录下。故而每当我们通过VS编译器对项目右键重新生成项目(重新编译)时，VS都会将引用的程序集给复制一份到项目bin\输出目录Debug文件夹下，我们可以通过VS中对引用的程序集右键属性-复制本地 True/Flase 来决定这一默认行为。<br>&emsp;&emsp;值得一提的是，项目间的生成是有序生成的，它取决于项目间的依赖顺序。<br>&emsp;&emsp;比如Web项目引用BLL项目，BLL项目引用了DAL项目。那么当我生成Web项目的时候，因为我要注册Bll程序集，所以我要先生成Bll程序集，而BLL程序集又引用了Dal，所以又要先生成Dal程序集，所以程序集生成顺序就是Dal=&gt;BLL=&gt;Web，项目越多编译的时间就越久。<br>&emsp;&emsp;程序集之间的依赖顺序决定了编译顺序，所以在设计项目间的分层划分时不仅要体现出层级职责，还要考虑到依赖顺序。代码存放在哪个项目要有讲究，不允许出现互相引用的情况，比如A项目中的代码引用B，B项目中的代码又引用A。  </p>
<h2 id="为什么Newtonsoft-Json版本不一致？"><a href="#为什么Newtonsoft-Json版本不一致？" class="headerlink" title="为什么Newtonsoft.Json版本不一致？"></a>为什么Newtonsoft.Json版本不一致？</h2><p>&emsp;&emsp;而除了注意编译顺序外，我们还要注意程序集间的版本问题，版本间的错乱会导致程序的异常。<br>&emsp;&emsp;举个经典的例子：Newtonsoft.Json的版本警告，大多数人都知道通过版本重定向来解决这个问题，但很少有人会琢磨为什么会出现这个问题，找了一圈文章，没找到一个解释的。<br>&emsp;&emsp;比如：<br>&emsp;&emsp;A程序集引用了 C盘:\Newtonsoft.Json 6.0程序集<br>&emsp;&emsp;B程序集引用了 从Nuget下载下来的Newtonsoft.Json 10.0程序集<br>&emsp;&emsp;此时A引用B，就会报：发现同一依赖程序集的不同版本间存在无法解决的冲突 这一警告。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A：引用Newtonsoft.Json 6.0</span><br><span class="line">       Func()</span><br><span class="line">       &#123;</span><br><span class="line">           var obj= Newtonsoft.Json.Obj;</span><br><span class="line">           B.JsonObj();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">B: 引用Newtonsoft.Json 10.0</span><br><span class="line">       JsonObj()</span><br><span class="line">       &#123;</span><br><span class="line">           return  Newtonsoft.Json.Obj;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;A程序集中的Func方法调用了B程序集中的JsonObj方法，JsonObj方法又调用了Newtonsoft.Json 10.0程序集中的对象，那么当执行Func方法时程序就会异常，报<code>System.IO.FileNotFoundException</code>: 未能加载文件或程序集Newtonsoft.Json 10.0的错误。<br>&emsp;&emsp;这是为什么？  </p>
<ol>
<li>这是因为依赖顺序引起的。A引用了B，首先会先生成B，而B引用了 Newtonsoft.Json 10.0，那么VS就会将源引用文件(Newtonsoft.Json 10.0)复制到B程序集同一目录(bin/Debug)下，名为Newtonsoft.Json.dll文件，其内嵌程序集版本为10.0。  </li>
<li>然后A引用了B，所以会将B程序集和B程序集的依赖项(Newtonsoft.Json.dll)给复制到A的程序集目录下，而A又引用了C盘的Newtonsoft.Json 6.0程序集文件，所以又将C:\Newtonsoft.Json.dll文件给复制到自己程序集目录下。因为两个Newtonsoft.Json.dll重名，所以直接覆盖了前者，那么只保留了Newtonsoft.Json 6.0。  </li>
<li>当我们调用Func方法中的B.Convert()时候，CLR会搜索B程序集，找到后再调用 return Newtonsoft.Json.Obj 这行代码，而这行代码又用到了Newtonsoft.Json程序集，接下来CLR搜索Newtonsoft.Json.dll，文件名称满足，接下来CLR判断其标识，发现版本号是6.0，与B程序集清单里注册的10.0版本不符，故而才会报出异常：未能加载文件或程序集Newtonsoft.Json 10.0。  </li>
</ol>
<p>&emsp;&emsp;以上就是为何Newtonsoft.Json版本不一致会导致错误的原因，其也诠释了CLR搜索程序集的一个过程。<br>&emsp;&emsp;那么，如果我执意如此，有什么好的解决方法能让程序顺利执行呢？有，有2个方法。<br>&emsp;&emsp;第一种：通过<code>bindingRedirect</code>节点重定向，即当找到10.0的版本时，给定向到6.0版本  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;dependentAssembly&gt;</span><br><span class="line">                    &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                      publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                      culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                    &lt;bindingRedirect oldVersion=&quot;10.0.0.0&quot;</span><br><span class="line">                                     newVersion=&quot;6.0.0.0&quot; /&gt;</span><br><span class="line">                &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何在编译时加载两个相同的程序集？"><a href="#如何在编译时加载两个相同的程序集？" class="headerlink" title="如何在编译时加载两个相同的程序集？"></a>如何在编译时加载两个相同的程序集？</h2><p>&emsp;&emsp;注意：我看过有的文章里写的一个AppDomain只能加载一个相同的程序集，很多人都以为不能同时加载2个不同版本的程序集，实际上CLR是可以同时加载Newtonsoft.Json 6.0和Newtonsoft.Json 10.0的。<br>&emsp;&emsp;第二种：对每个版本指定<code>codeBase</code>路径，然后分别放上不同版本的程序集，这样就可以加载两个相同的程序集。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">        &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">            &lt;dependentAssembly&gt;</span><br><span class="line">                &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                  publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                  culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                &lt;codeBase version=&quot;6.0.0.0&quot;</span><br><span class="line">                          href=&quot;D:\6.0\Newtonsoft.Json.dll&quot; /&gt;</span><br><span class="line">            &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;dependentAssembly&gt;</span><br><span class="line">                &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                  publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                  culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                &lt;codeBase version=&quot;10.0.0.0&quot;</span><br><span class="line">                          href=&quot;D:\10.0\Newtonsoft.Json.dll&quot; /&gt;</span><br><span class="line">            &lt;/dependentAssembly&gt;</span><br><span class="line">        &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何同时调用两个相同命名空间和类型的程序集？"><a href="#如何同时调用两个相同命名空间和类型的程序集？" class="headerlink" title="如何同时调用两个相同命名空间和类型的程序集？"></a>如何同时调用两个相同命名空间和类型的程序集？</h2><p>&emsp;&emsp;除了程序集版本不同外，还有一种情况就是，我一个项目同时引用了程序集A和程序集B，但程序集A和程序集B中的命名空间和类型名称完全一模一样，这个时候我调用任意一个类型都无法区分它是来自于哪个程序集的，那么这种情况我们可以使用<code>extern alias</code>外部别名。<br>&emsp;&emsp;我们需要在所有代码前定义别名，extern alias a;extern alias b;，然后在VS中对引用的程序集右键属性-别名，分别将其更改为a和b(或在csc中通过<code>/r:{别名}={程序集}.dll</code>)。<br>&emsp;&emsp;在代码中通过 <code>{别名}::{命名空间}.{类型}</code>的方式来使用。<br>&emsp;&emsp;extern-alias介绍： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern-alias" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern-alias</a>  </p>
<h2 id="共享程序集GAC"><a href="#共享程序集GAC" class="headerlink" title="共享程序集GAC"></a>共享程序集GAC</h2><p>&emsp;&emsp;我上面说了这么多有关CLR加载程序集的细节和规则，事实上，类似于mscorlib.dll、System.dll这样的FCL类库被引用的如此频繁，它已经是我们.NET编程中必不可少的一部分，几尽每个项目都会引用，为了不再每次使用的时候都复制一份，所以计算机上有一个位置专门存储这些我们都会用到的程序集，叫做全局程序集缓存(Global Assembly Cache,GAC)，这个位置一般位于C:\Windows\Microsoft.NET\assembly和3.5之前版本的C:\Windows\assembly。<br>&emsp;&emsp;既然是共享存放的位置，那不可避免的会遇到文件名重复的情况，那么为了杜绝该类情况，规定在GAC中只能存在强名称程序集，每当CLR要加载强名称程序集时，会先通过标识去GAC中查找，而考虑到程序集文件名称一致但版本文化等复杂的情况，所以GAC有自己的一套目录结构。我们如果想将自己的程序集放入GAC中，那么就必须先签名，然后通过如gacutil.exe工具(其存在于命令行工具中 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/developer-command-prompt-for-vs中)来注册至GAC中，值得一提的是在将强名称程序集安装在GAC中，会效验签名。" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/tools/developer-command-prompt-for-vs中)来注册至GAC中，值得一提的是在将强名称程序集安装在GAC中，会效验签名。</a><br>&emsp;&emsp;GAC工具： <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/gacutil-exe-gac-tool" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/tools/gacutil-exe-gac-tool</a>  </p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>&emsp;&emsp;CLR是按需加载程序集的，没有执行代码也就没有调用相应的指令，没有相应的指令，CLR也不会对其进行相应的操作。 当我们执行<code>Environment.CurrentDirectory</code>这段代码的时候，CLR首先要获取Environment类型信息，通过自身元数据得知其存在mscorlib.dll程序集中，所以CLR要加载该程序集，而mscorlib.dll又由于其地位特殊，早在CLR初始化的时候就已经被类型加载器自动加载至内存中，所以这行代码可以直接在内存中读取到类型的方法信息。<br>&emsp;&emsp;在这个章节，我虽然描述了CLR搜索程序集的规则，但事实上，加载程序集读取类型信息远远没有这么简单，这涉及到了属于.NET Framework独有的”应用程序域”概念和内存信息的查找。<br>&emsp;&emsp;简单延伸两个问题，mscorlib.dll被加载在哪里？内存堆中又是什么样的一个情况？  </p>
<h1 id="应用程序域"><a href="#应用程序域" class="headerlink" title="应用程序域"></a>应用程序域</h1><p>&emsp;&emsp;传统非托管程序是直接承载在Windows进程中，托管程序是承载在.NET虚拟机CLR上的，而在CLR中管控的这部分资源中，被分成了一个个逻辑上的分区，这个逻辑分区被称为应用程序域，是.NET Framework中定义的一个概念。<br>&emsp;&emsp;因为堆内存的构建和删除都通过GC去托管，降低了人为出错的几率，在此特性基础上.NET强调在一个进程中通过CLR强大的管理建立起对资源逻辑上的隔离区域，每个区域的应用程序互不影响，从而让托管代码程序的安全性和健壮性得到了提升。<br>&emsp;&emsp;熟悉程序集加载规则和<code>AppDomain</code>是在.NET技术下进行插件编程的前提。<code>AppDomain</code>这部分概念并不复杂。<br>&emsp;&emsp;当启动一个托管程序时，最先启动的是<code>CLR</code>，在这过程中会通过代码初始化三个逻辑区域，最先是<code>SystemDomain</code>系统程序域，然后是<code>SharedDoamin</code>共享域，最后是<code>{程序集名称}Domain</code>默认域。<br>&emsp;&emsp;系统程序域里维持着一些系统构建项，我们可以通过这些项来监控并管理其它应用程序域等。共享域存放着其它域都会访问到的一些信息，当共享域初始化完毕后，会自动加载mscorlib.dll程序集至该共享域。而默认域则用储存自身程序集的信息，我们的主程序集就会被加载至这个默认域中，执行程序入口方法，在没有特殊动作外所产生的一切耗费都发生在该域。<br>&emsp;&emsp;我们可以在代码中创建和卸载应用程序域，域与域之间有隔离性，挂掉A域不会影响到B域，并且对于每一个加载的程序集都要指定域的，没有在代码中指定域的话，默认都是加载至默认域中。<br>&emsp;&emsp;<code>AppDomain</code>可以想象成组的概念，<code>AppDomain</code>包含了我们加载的一组程序集。我们通过代码卸载<code>AppDomain</code>，即同时卸载了该<code>AppDomain</code>中所加载的所有程序集在内存中的相关区域。<br>&emsp;&emsp;<code>AppDomain</code>的初衷是边缘隔离，它可以让程序不重新启动而长时间运行，围绕着该概念建立的体系从而让我们能够使用.NET技术进行插件编程。<br>&emsp;&emsp;当我们想让程序在不关闭不重新部署的情况下添加一个新的功能或者改变某一块功能，我们可以这样做：将程序的主模块仍默认加载至默认域，再创建一个新的应用程序域，然后将需要更改或替换的模块的程序集加载至该域，每当更改和替换的时候直接卸载该域即可。 而因为域的隔离性，我在A域和B域加载同一个程序集，那么A域和B域就会各存在内存地址不同但数据相同的程序集数据。  </p>
<h2 id="跨边界访问"><a href="#跨边界访问" class="headerlink" title="跨边界访问"></a>跨边界访问</h2><p>&emsp;&emsp;事实上，在开发中我们还应该注意跨域访问对象的操作(即在A域中的程序集代码直接调用B域中的对象)是与平常编程中有所不同的，一个域中的应用程序不能直接访问另一个域中的代码和数据，对于这样的在进程内跨域访问操作分两类。<br>&emsp;&emsp;一是按引用封送，需要继承<code>System.MarshalByRefObject</code>，传递的是该对象的代理引用，与源域有相同的生命周期。<br>&emsp;&emsp;二是按值封送，需要被<code>[Serializable]</code>标记，是通过序列化传递的副本，副本与源域的对象无关。<br>&emsp;&emsp;无论哪种方式都涉及到两个域直接的封送、解封，所以跨域访问调用不适用于过高频率。<br>&emsp;&emsp;(比如，原来你是这样调用对象： <code>var user=new User();</code> 现在你要这样：<code>var user=(User){应用程序域对象实例}.CreateInstanceFromAndUnwrap(&quot;Model.dll&quot;,&quot;Model.User&quot;);</code> )<br>&emsp;&emsp;值得注意的是，应用程序域是对程序集的组的划分，它与进程中的线程是两个一横一竖，方向不一样的概念，不应该将这2个概念放在一起比较。我们可以通过<code>Thread.GetDomain</code>来查看执行线程所在的域。<br>&emsp;&emsp;应用程序域在类库中是<code>System.AppDomain</code>类,部分重要的成员有：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">获取当前 System.Threading.Thread 的当前应用程序域</span><br><span class="line">public static AppDomain CurrentDomain &#123; get; &#125;</span><br><span class="line">使用指定的名称新建应用程序域</span><br><span class="line">public static AppDomain CreateDomain(string friendlyName);</span><br><span class="line">卸载指定的应用程序域。</span><br><span class="line">public static void Unload(AppDomain domain);</span><br><span class="line">指示是否对当前进程启用应用程序域的 CPU 和内存监视，开启后可以根据相关属性进行监控</span><br><span class="line">public static bool MonitoringIsEnabled &#123; get; set; &#125;</span><br><span class="line">当前域托管代码抛出异常时最先发生的一个事件，框架设计中可以用到</span><br><span class="line">public event EventHandler&lt;FirstChanceExceptionEventArgs&gt; FirstChanceException;</span><br><span class="line">当某个异常未被捕获时调用该事件，如代码里只catch了a异常，实际产生的是 b异常，那么b异常就没有捕捉到。</span><br><span class="line">public event UnhandledExceptionEventHandler UnhandledException;</span><br><span class="line">为指定的应用程序域属性分配指定值。该应用程序域的局部存储值，该存储不划分上下文和线程，均可通过GetData获取。</span><br><span class="line">public void SetData(string name, object data);</span><br><span class="line">如果想使用托管代码来覆盖CLR的默认行为https://msdn.microsoft.com/zh-cn/library/system.appdomainmanager(v=vs.85).aspx</span><br><span class="line">public AppDomainManager DomainManager &#123; get; &#125;</span><br><span class="line">返回域的配置信息，如在config中配置的节点信息</span><br><span class="line">public AppDomainSetup SetupInformation &#123; get; &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;应用程序域： <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/application-domains" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/application-domains</a>  </p>
<h2 id="AppDomain和AppPool"><a href="#AppDomain和AppPool" class="headerlink" title="AppDomain和AppPool"></a>AppDomain和AppPool</h2><p>&emsp;&emsp;注意：此处的<code>AppDomain</code>应用程序域 和 IIS中的<code>AppPool</code>应用程序池 是2个概念，AppPool是IIS独有的概念，它也相当于一个组的概念，对网站进行划组，然后对组进行一些如进程模型、CPU、内存、请求队列的高级配置。  </p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>&emsp;&emsp;应用程序域把资源给隔离开，这个资源，主要指内存。那么什么是内存呢？<br>&emsp;&emsp;要知道，程序运行的过程就是电脑不断通过CPU进行计算的过程，这个过程需要读取并产生运算的数据，为此我们需要一个拥有足够容量能够快速与CPU交互的存储容器，这就是内存了。对于内存大小，32位处理器，寻址空间最大为2的32次方byte，也就是4G内存，除去操作系统所占用的公有部分，进程大概能占用2G内存，而如果是64位处理器，则是8T。<br>&emsp;&emsp;而在.NET中，内存区域分为堆栈和托管堆。  </p>
<h2 id="堆栈和堆的区别"><a href="#堆栈和堆的区别" class="headerlink" title="堆栈和堆的区别"></a>堆栈和堆的区别</h2><p>&emsp;&emsp;堆和堆栈就内存而言只不过是地址范围的区别。不过堆栈的数据结构和其存储定义让其在时间和空间上都紧密的存储，这样能带来更高的内存密度，能在CPU缓存和分页系统表现的更好。故而访问堆栈的速度总体来说比访问堆要快点。  </p>
<h2 id="线程堆栈"><a href="#线程堆栈" class="headerlink" title="线程堆栈"></a>线程堆栈</h2><p>&emsp;&emsp;操作系统会为每条线程分配一定的空间，Windwos为1M，这称之为线程堆栈。在CLR中的栈主要用来执行线程方法时，保存临时的局部变量和函数所需的参数及返回的值等，在栈上的成员不受GC管理器的控制，它们由操作系统负责分配，当线程走出方法后，该栈上成员采用后进先出的顺序由操作系统负责释放，执行效率高。<br>&emsp;&emsp;而托管堆则没有固定容量限制，它取决于操作系统允许进程分配的内存大小和程序本身对内存的使用情况，托管堆主要用来存放对象实例，不需要我们人工去分配和释放，其由GC管理器托管。  </p>
<h2 id="为什么值类型存储在栈上"><a href="#为什么值类型存储在栈上" class="headerlink" title="为什么值类型存储在栈上"></a>为什么值类型存储在栈上</h2><p>&emsp;&emsp;不同的类型拥有不同的编译时规则和运行时内存分配行为，我们应知道，C# 是一种强类型语言，每个变量和常量都有一个类型，在.NET中，每种类型又被定义为值类型或引用类型。<br>&emsp;&emsp;使用 <code>struct</code>、<code>enum</code> 关键字直接派生于<code>System.ValueType</code>定义的类型是值类型，使用 <code>class</code>、<code>interface</code>、<code>delagate</code> 关键字派生于<code>System.Object</code>定义的类型是引用类型。<br>&emsp;&emsp;对于在一个方法中产生的值类型成员，将其值分配在栈中。这样做的原因是因为值类型的值其占用固定内存的大小。<br>&emsp;&emsp;C#中<code>int</code>关键字对应BCL中的<code>Int32</code>，<code>short</code>对应<code>Int16</code>。<code>Int32</code>为2的32位，如果把32个二进制数排列开来，我们要求既能表达正数也能表达负数，所以得需要其中1位来表达正负，首位是0则为+，首位是1则为-，那么我们能表示数据的数就只有31位了，而0是介于-1和1之间的整数，所以对应的Int32能表现的就是2的31次方到2的31次方-1，即2147483647和-2147483648这个整数段。<br>&emsp;&emsp;1个字节=8位，32位就是4个字节，像这种以Int32为代表的值类型，本身就是固定的内存占用大小，所以将值类型放在内存连续分配的栈中。  </p>
<h2 id="托管堆模型"><a href="#托管堆模型" class="headerlink" title="托管堆模型"></a>托管堆模型</h2><p>&emsp;&emsp;而引用类型相比值类型就有点特殊，<code>newobj</code>创建一个引用类型，因其类型内的引用对象可以指向任何类型，故而无法准确得知其固定大小，所以像对于引用类型这种无法预知的容易产生内存碎片的动态内存，我们把它放到托管堆中存储。<br>&emsp;&emsp;托管堆由GC托管，其分配的核心在于堆中维护着一个<code>nextObjPtr</code>指针，我们每次实例(new)一个对象的时候，CLR将对象存入堆中，并在栈中存放该对象的起始地址，然后该指针都会根据该对象的大小来计算下一个对象的起始地址。不同于值类型直接在栈中存放值，引用类型则还需要在栈中存放一个代表(指向)堆中对象的值(地址)。<br>&emsp;&emsp;而托管堆又可以因存储规则的不同将其分类，托管堆可以被分为3类：  </p>
<ol>
<li>用于托管对象实例化的垃圾回收堆，又以存储对象大小分为小对象(&lt;85000byte)的GC堆(SOH，Small Object Heap)和用于存储大对象实例的(&gt;=85000byte)大对象堆(LOG，Larage Object Heap)。 </li>
<li>用于存储CLR组件和类型系统的加载(Loader)堆，其中又以使用频率分为经常访问的高频堆(里面包含有MethodTables方法表, MeghodDescs方法描述, FieldDescs方法描述和InterfaceMaps接口图)，和较低的低频堆，和Stub堆(辅助代码，如JIT编译后修改机器代码指令地址环节)。 </li>
<li>用于存储JIT代码的堆及其它杂项的堆。</li>
</ol>
<p>&emsp;&emsp;加载程序集就是将程序集中的信息给映射在加载堆，对产生的实例对象存放至垃圾回收堆。前文说过应用程序域是指通过CLR管理而建立起的逻辑上的内存边界，那么每个域都有其自己的加载堆，只有卸载应用程序域的时候，才会回收该域对应的加载堆。<br>&emsp;&emsp;而加载堆中的高频堆包含的有一个非常重要的数据结构表—方法表，每个类型都仅有一份方法表(MethodTables)，它是对象的第一个实例创建前的类加载活动的结果，它主要包含了我们所关注的3部分信息：  </p>
<ol>
<li>包含指向EEClass的一个指针。EEClass是一个非常重要的数据结构，当类加载器加载到该类型时会从元数据中创建出EEClass，EEClass里主要存放着与类型相关的表达信息。</li>
<li>包含指向各自方法的方法描述器(MethodDesc)的指针逻辑组成的线性表信息:继承的虚函数, 新虚函数, 实例方法, 静态方法。</li>
<li>包含指向静态字段的指针。</li>
</ol>
<p>&emsp;&emsp;那么，实例一个对象，CLR是如何将该对象所对应的类型行为及信息的内存位置(加载堆)关联起来的呢？<br>&emsp;&emsp;原来，在托管堆上的每个对象都有2个额外的供于CLR使用的成员，我们是访问不到的，其中一个就是类型对象指针，它指向位于加载堆中的方法表从而让类型的状态和行为关联了起来， 类型指针的这部分概念我们可以想象成obj.GetType()方法获得的运行时对象类型的实例。而另一个成员就是同步块索引，其主要用于2点：1.关联内置SyncBlock数组的项从而完成互斥锁等目的。 2.是对象Hash值计算的输入参数之一。<br><img src="1026815-20180626200740668-572794231.gif" alt=" "><br>&emsp;&emsp;上述gif是我简单画的一个图，可以看到对于方法中申明的值类型变量，其在栈中作为一块值表示，我们可以直接通过c#运算符sizeof来获得值类型所占byte大小。而方法中申明的引用类型变量，其在托管堆中存放着对象实例(对象实例至少会包含上述两个固定成员以及实例数据，可能)，在栈中存放着指向该实例的地址。<br>&emsp;&emsp;当我new一个引用对象的时候，会先分配同步块索引(也叫对象头字节)，然后是类型指针，最后是类型实例数据(静态字段的指针存在于方法表中)。会先分配对象的字段成员，然后分配对象父类的字段成员，接着再执行父类的构造函数，最后才是本对象的构造函数。这个多态的过程，对于CLR来说就是一系列指令的集合，所以不能纠结new一个子类对象是否会也会new一个父类对象这样的问题。而也正是因为引用类型的这样一个特征，我们虽然可以估计一个实例大概占用多少内存，但对于具体占用的大小，我们需要专门的工具来测量。<br>&emsp;&emsp;对于引用类型，u2=u1，我们在赋值的时候，实际上赋的是地址，那么我改动数据实际上是改动该地址指向的数据，这样一来，因为u2和u1都指向同一块区域，所以我对u1的改动会影响到u2，对u2的改动会影响到u1。如果我想互不影响，那么我可以继承<code>IClone</code>接口来实现内存克隆，已有的CLR实现是浅克隆方法，但也只能克隆值类型和String(string是个特殊的引用类型，对于string的更改，其会产生一个新实例对象)，如果对包含其它引用类型的这部分，我们可以自己通过其它手段实现深克隆，如序列化、反射等方式来完成。而如果引用类型中包含有值类型字段，那么该字段仍然分配在堆上。<br>&emsp;&emsp;对于值类型，a=b，我们在赋值的时候，实际上是新建了个值，那么我改动a的值那就只会改动a的值，改动b的值就只会改动b的值。而如果值类型(如struct)中包含的有引用类型，那么仍是同样的规则，引用类型的那部分实例在托管堆中，地址在栈上。<br>&emsp;&emsp;我如果将值类型放到引用类型中(如：object a=3)，会在栈中生成一个地址，在堆中生成该值类型的值对象，还会再生成这类型指针和同步块索引两个字段，这也就是常说装箱，反过来就是拆箱。每一次的这样的操作，都会涉及到内存的分布、拷贝，可见，装箱和拆箱是有性能损耗，因此应该减少值类型和引用类型之间转换的次数。<br>&emsp;&emsp;但对于引用类型间的子类父类的转换，仅是指令的执行消耗，几尽没有开销。  </p>
<h2 id="选class还是struct"><a href="#选class还是struct" class="headerlink" title="选class还是struct"></a>选class还是struct</h2><p>&emsp;&emsp;那么我到底是该new一个class呢还是选择struct呢？<br>&emsp;&emsp;通过上文知道对于class，用完之后对象仍然存在托管堆，占用内存。对于struct，用完之后直接由操作系统销毁。那么在实际开发中定义类型时，选择class还是struct就需要注意了，要综合应用场景来辨别。struct存在于栈上，栈和托管堆比较，最大的优势就是即用即毁。所以如果我们单纯的传递一个类型，那么选择struct比较合适。但须注意线程堆栈有容量限制，不可多存放超大量的值类型对象，并且因为是值类型直接传递副本，所以struct作为方法参数是线程安全的，但同样要避免装箱的操作。而相比较class，如果类型中还需要多一些封装继承多态的行为，那么class当然是更好的选择。  </p>
<h2 id="GC管理器"><a href="#GC管理器" class="headerlink" title="GC管理器"></a>GC管理器</h2><p>&emsp;&emsp;值得注意的是，当我new完一个对象不再使用的时候，这个对象在堆中所占用的内存如何处理？<br>&emsp;&emsp;在非托管世界中，可以通过代码手动进行释放，但在.NET中，堆完全由CLR托管，也就是说GC堆是如何具体来释放的呢？<br>&emsp;&emsp;当GC堆需要进行清理的时候，GC收集器就会通过一定的算法来清理堆中的对象，并且版本不同算法也不同。最主要的则为Mark-Compact标记-压缩算法。<br>&emsp;&emsp;这个算法的大概含义就是，通过一个图的数据结构来收集对象的根，这个根就是引用地址，可以理解为指向托管堆的这根关系线。当触发这个算法时，会检查图中的每个根是否可达，如果可达就对其标记，然后在堆上找到剩余没有标记(也就是不可达)的对象进行删除，这样，那些不在使用的堆中对象就删除了。<br>&emsp;&emsp;前面说了，因为<code>nextObjPtr</code>的缘故，在堆中分配的对象都是连续分配的，因为未被标记而被删除，那么经过删除后的堆就会显得支零破碎，那么为了避免空间碎片化，所以需要一个操作来让堆中的对象再变得紧凑、连续，而这样一个操作就叫做：Compact压缩。<br>&emsp;&emsp;而对堆中的分散的对象进行挪动后，还会修改这些被挪动对象的指向地址，从而得以正确的访问，最后重新更新一下<code>nextObjPtr</code>指针，周而复始。<br>&emsp;&emsp;而为了优化内存结构，减少在图中搜索的成本，GC机制又为每个托管堆对象定义了一个属性，将每个对象分成了3个等级，这个属性就叫做：代，0代、1代、2代。<br>&emsp;&emsp;每当new一个对象的时候，该对象都会被定义为第0代，当GC开始回收的时候，先从0代回收，在这一次回收动作之后，0代中没有被回收的对象则会被定义成第1代。当回收第1代的时候，第1代中没有被清理掉的对象就会被定义到第2代。<br>&emsp;&emsp;CLR初始化时会为0/1/2这三代选择一个预算的容量。0代通常以256 KB-4 MB之间的预算开始，1代的典型起始预算为512 KB-4 MB，2代不受限制，最大可扩展至操作系统进程的整个内存空间。<br>&emsp;&emsp;比如第0代为256K，第1代为2MB。我们不停的new对象，直到这些对象达到256k的时候，GC会进行一次垃圾回收，假设这次回收中回收了156k的不可达对象，剩余100k的对象没有被回收，那么这100k的对象就被定义为第1代。现在就变成了第0代里面什么都没有，第1代里放的有100k的对象。这样周而复始，GC清除的永远都只有第0代对象，除非当第一代中的对象累积达到了定义的2MB的时候，才会连同清理第1代，然后第1代中活着的部分再升级成第二代…<br>&emsp;&emsp;第二代的容量是没有限制，但是它有动态的阈值(因为等到整个内存空间已满以执行垃圾回收是没有意义的)，当达到第二代的阈值后会触发一次0/1/2代完整的垃圾收集。<br>&emsp;&emsp;也就是说，代数越长说明这个对象经历了回收的次数也就越多，那么也就意味着该对象是不容易被清除的。<br>&emsp;&emsp;这种分代的思想来将对象分割成新老对象，进而配对不同的清除条件，这种巧妙的思想避免了直接清理整个堆的尴尬。<br><img src="1026815-20180626200925015-777215609.gif" alt=" ">   </p>
<h2 id="弱引用、弱事件"><a href="#弱引用、弱事件" class="headerlink" title="弱引用、弱事件"></a>弱引用、弱事件</h2><p>&emsp;&emsp;GC收集器会在第0代饱和时开始回收托管堆对象，对于那些已经申明或绑定的不经访问的对象或事件，因为不经常访问而且还占内存(有点懒加载的意思)，所以即时对象可达，但我想在GC回收的时候仍然对其回收，当需要用到的时候再创建，这种情况该怎么办？<br>&emsp;&emsp;那么这其中就引入了两个概念：<br>&emsp;&emsp;<code>WeakReference</code>弱引用、<code>WeakEventManager</code>弱事件<br>&emsp;&emsp;对于这两个不区分语言的共同概念，大家可自行扩展百度，此处就不再举例。  </p>
<h2 id="GC堆回收"><a href="#GC堆回收" class="headerlink" title="GC堆回收"></a>GC堆回收</h2><p>&emsp;&emsp;那么除了通过new对象而达到代的阈(临界)值时，还有什么能够导致垃圾堆进行垃圾回收呢？ 还可能windows报告内存不足、CLR卸载AppDomain、CLR关闭等其它特殊情况。<br>&emsp;&emsp;或者，我们还可以自己通过代码调用。<br>&emsp;&emsp;.NET有GC来帮助开发人员管理内存，并且版本也在不断迭代。GC帮我们托管内存，但仍然提供了<code>System.GC</code>类让开发人员能够轻微的协助管理。 这其中有一个可以清理内存的方法(并没有提供清理某个对象的方法)：GC.Collect方法，可以对所有或指定代进行即时垃圾回收(如果想调试，需在release模式下才有效果)。这个方法尽量别用，因为它会扰乱代与代间的秩序，从而让低代的垃圾对象跑到生命周期长的高代中。<br>&emsp;&emsp;GC还提供了，判断当前对象所处代数、判断指定代数经历了多少次垃圾回收、获取已在托管堆中分配的字节数这样的三个方法，我们可以从这3个方法简单的了解托管堆的情况。<br>&emsp;&emsp;托管世界的内存不需要我们打理，我们无法从代码中得知具体的托管对象的大小，你如果想追求对内存最细微的控制，显然C#并不适合你，不过类似于有关内存把控的这部分功能模块，我们可以通过非托管语言来编写，然后通过.NET平台的P/Invoke或COM技术(微软为CLR定义了COM接口并在注册表中注册)来调用。<br>&emsp;&emsp;像FCL中的源码，很多涉及到操作系统的诸如 文件句柄、网络连接等外部extren的底层方法都是非托管语言编写的，对于这些非托管模块所占用的资源，我们可以通过隐式调用析构函数(<code>Finalize</code>)或者显式调用的<code>Dispose</code>方法通过在方法内部写上非托管提供的释放方法来进行释放。<br>&emsp;&emsp;像文中示例的socket就将释放资源的方法写入Dispose中，析构函数和Close方法均调用Dispose方法以此完成释放。事实上，在FCL中的使用了非托管资源的类大多都遵循IDispose模式。而如果你没有释放非托管资源直接退出程序，那么操作系统会帮你释放该程序所占的内存的。  </p>
<h2 id="垃圾回收对性能的影响"><a href="#垃圾回收对性能的影响" class="headerlink" title="垃圾回收对性能的影响"></a>垃圾回收对性能的影响</h2><p>&emsp;&emsp;还有一点，垃圾回收是对性能有影响的。<br>&emsp;&emsp;GC虽然有很多优化策略，但总之，只要当它开始回收垃圾的时候，为了防止线程在CLR检查期间对对象更改状态，所以CLR会暂停进程中的几乎所有线程(所以线程太多也会影响GC时间)，而暂停的时间就是应用程序卡死的时间，为此，对于具体的处理细节，GC提供了2种配置模式让我们选择。<br>&emsp;&emsp;第一种为：单CPU的工作站模式，专为单CPU处理器定做。这种模式会采用一系列策略来尽可能减少GC回收中的暂停时间。<br>&emsp;&emsp;而工作站模式又分为并发(或后台)与不并发两种，并发模式表现为响应时间快速，不并发模式表现为高吞吐量。<br>&emsp;&emsp;第二种为：多CPU的服务器模式，它会为每个CPU都运行一个GC回收线程，通过并行算法来使线程能真正同时工作，从而获得性能的提升。<br>&emsp;&emsp;我们可以通过在Config文件中更改配置来修改GC模式，如果没有进行配置，那么应用程序总是默认为单CPU的工作站的并发模式，并且如果机器为单CPU的话，那么配置服务器模式则无效。<br>&emsp;&emsp;如果在工作站模式中想禁用并发模式，则应该在config中运行时节点添加 <code>&lt;gcConcurrent enabled=&quot;false&quot; /&gt;</code><br>&emsp;&emsp;如果想更改至服务器模式，则可以添加 <code>&lt;gcServer enabled=&quot;true&quot; /&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;configuration&gt;</span><br><span class="line">        &lt;runtime&gt;</span><br><span class="line">            &lt;!--&lt;gcConcurrent enabled=&quot;true|false&quot;/&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;gcServer enabled=&quot;true|false&quot;/&gt;--&gt;</span><br><span class="line">        &lt;/runtime&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;gcConcurrent: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element</a><br>&emsp;&emsp;gcServer: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element</a>  </p>
<h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>&emsp;&emsp;虽然我们可以选择适合的GC工作模式来改善垃圾回收时的表现，但在实际开发中我们更应该注意减少不必要的内存开销。<br>&emsp;&emsp;几个建议是，减换需要创建大量的临时变量的模式、考虑对象池、大对象使用懒加载、对固定容量的集合指定长度、注意字符串操作、注意高频率的隐式装箱操作、延迟查询、对于不需要面向对象特性的类用<code>static</code>、需要高性能操作的算法改用外部组件实现(p/invoke、com)、减少<code>throw</code>次数、注意匿名函数捕获的外部对象将延长生命周期、可以阅读GC相关运行时配置在高并发场景注意变换GC模式…<br>&emsp;&emsp;对于.NET中改善性能可延伸阅读 <a href="https://msdn.microsoft.com/zh-cn/library/ms973838.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms973838.aspx</a> 、 <a href="https://msdn.microsoft.com/library/ms973839.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/library/ms973839.aspx</a>  </p>
<h1 id="NET程序执行图"><a href="#NET程序执行图" class="headerlink" title=".NET程序执行图"></a>.NET程序执行图</h1><p>&emsp;&emsp;至此，.NET Framework上的三个重要概念，程序集、应用程序域、内存在本文讲的差不多了，我画了一张图简单的概述.NET程序的一个执行流程：<br><img src="1026815-20180627094402682-185765111.jpg" alt=" "><br>&emsp;&emsp;对于后文，我将单独的介绍一些其它杂项，首先是.NET平台的安全性。  </p>
<h1 id="NET的安全性"><a href="#NET的安全性" class="headerlink" title=".NET的安全性"></a>.NET的安全性</h1><p>&emsp;&emsp;.NET Framework中的安全机制分为 基于角色的安全机制 和 代码访问安全机制。  </p>
<h2 id="基于角色的安全性"><a href="#基于角色的安全性" class="headerlink" title="基于角色的安全性"></a>基于角色的安全性</h2><p>&emsp;&emsp;基于角色的安全机制作为传统的访问控制，其运用的非常广泛，如操作系统的安全策略、数据库的安全策略等等…它的概念就相当于我们经常做的那些RBAC权限管理系统一样，用户关联角色，角色关联权限，权限对应着操作。<br>&emsp;&emsp;整个机制的安全逻辑就和我们平时编写代码判断是一样的，大致可以分为两个步骤。<br>&emsp;&emsp;第一步就是创建一个主体，然后标识这个主体是什么身份(角色) ，第二步就是 身份验证，也就是if判断该身份是否可以这样操作。<br>&emsp;&emsp;而在.NET Framework中，这主体可以是Windows账户，也可以是自定义的标识，通过生成如当前线程或应用程序域使用的主体相关的信息来支持授权。<br>&emsp;&emsp;比如，构造一个代表当前登录账户的主体对象WindowsPrincipal，然后通过<code>AppDomain.CurrentDomain.SetThreadPrincipal(主体对象);</code>或<code>Thread.CurrentPrincipal</code>的set方法来设置应用程序域或线程的主体对象， 最后使用<code>System.Security.Permissions.PrincipalPermission</code>特性来标记在方法上来进行授权验证。<br><img src="1026815-20180627091948062-1470556345.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180627091950748-1063703508.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;如图，我当前登录账号名称为DemoXiaoZeng，然后通过<code>Thread.CurrentPrincipal</code>设置当前主体，执行aa方法，顺利打印111。如果检测到PrincipalPermission类中的Name属性值不是当前登录账号，那么就报错：对主体权限请求失败。<br><img src="1026815-20180627092034043-1822965136.png" alt=" "><br>&emsp;&emsp;在官方文档中有对.NET Framework基于角色的安全性的详细的介绍，感兴趣可以去了解 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/security/principal-and-identity-objects#principal-objects" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/security/principal-and-identity-objects#principal-objects</a>  </p>
<h2 id="代码访问安全性"><a href="#代码访问安全性" class="headerlink" title="代码访问安全性"></a>代码访问安全性</h2><p>&emsp;&emsp;在.NET Framework中还有一个安全策略，叫做 代码访问安全Code Access Security，也就是CAS了。<br>&emsp;&emsp;代码访问安全性在.NET Framework中是用来帮助限制代码对受保护资源和操作的访问权限。<br>&emsp;&emsp;举个例子，我通过创建一个<code>FileIOPermission</code>对象来限制对后续代码对D盘的文件和目录的访问，如果后续代码对D盘进行资源操作则报错。<br><img src="1026815-20180627092115880-961385890.png" alt=" "><br>&emsp;&emsp;<code>FileIOPermission</code>是代码控制访问文件和文件夹的能力。除了<code>FileIOPermission</code>外，还有如<code>PrintingPermission</code>代码控制访问打印机的权限、<code>RegistryPermission</code>代码控制操作注册表的权限、<code>SocketPermission</code>控制接受连接或启动Socket连接的权限。<br>&emsp;&emsp;对于这些通过代码来对受保护资源和操作的权限限制，也就是这些类名后缀为Permission的类，它们叫做 Permissions(权限)，都继承自<code>CodeAccessPermission</code>，都有如<code>Demand</code>，<code>Assert</code>，<code>Deny</code>，<code>PermitOnly</code>，<code>IsSubsetOf</code>，<code>Intersect</code>和<code>Union</code>这些方法，在MSDN上有完整的权限列表：<a href="https://msdn.microsoft.com/en-us/library/h846e9b3(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/h846e9b3(v=vs.100).aspx</a><br>&emsp;&emsp;为了确定代码是否有权访问某一资源或执行某一操作，CLR的安全系统将审核调用堆栈，以将每个调用方获得的权限与要求的权限进行比较。 如果调用堆栈中的任何调用方不具备要求的权限，则会引发安全性异常并拒绝访问。<br><img src="1026815-20180627092153838-808529507.png" alt=" "><br>&emsp;&emsp;图出自 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/misc/code-access-security" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/misc/code-access-security</a><br>&emsp;&emsp;而除了Permissions权限，代码访问安全性机制还有 权限集、证据、代码组、策略等概念。这些概念让CAS如此强大，但相应的，它们也让CAS变得复杂，必须为每个特定机器定义正确的<code>PermissionSet</code>和<code>Code Groups</code>才能设置成一个成功的CAS策略。<br>&emsp;&emsp;考虑到这层原因，Microsoft .NET安全小组决定从头开始重建代码访问安全性。在.NET Framework4.0之后，就不再使用之前的那套CAS模型了，而是使用.NET Framework 2.0中引入的安全透明模型，然后稍加修改，修改后的安全透明模型成为保护资源的标准方法，被称之为：安全透明度级别2<br>&emsp;&emsp;安全透明度2介绍：<a href="https://msdn.microsoft.com/en-us/library/dd233102(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd233102(v=vs.100).aspx</a><br>&emsp;&emsp;.NET Framework4.0的安全更改：<a href="https://msdn.microsoft.com/en-us/library/dd233103(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd233103(v=vs.100).aspx</a><br>&emsp;&emsp;一个完整的CAS演示：<a href="https://www.codeproject.com/Articles/5724/Understanding-NET-Code-Access-Security" target="_blank" rel="noopener">https://www.codeproject.com/Articles/5724/Understanding-NET-Code-Access-Security</a><br>&emsp;&emsp;对于安全透明度级别2我将不再介绍，感兴趣的可以看我推荐的这2篇文章，对Level2的安全透明度介绍的比较详细，包括实践、迁移。<br>&emsp;&emsp;<a href="https://www.red-gate.com/simple-talk/dotnet/.net-framework/whats-new-in-code-access-security-in-.net-framework-4.0---part-i/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/dotnet/.net-framework/whats-new-in-code-access-security-in-.net-framework-4.0---part-i/</a><br>&emsp;&emsp;<a href="https://www.red-gate.com/simple-talk/dotnet/net-framework/whats-new-in-code-access-security-in-net-framework-4-0-part-2/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/dotnet/net-framework/whats-new-in-code-access-security-in-net-framework-4-0-part-2/</a>  </p>
<hr>
<p>&emsp;&emsp;须注意：<br>&emsp;&emsp;.NET平台上的安全机制，仅仅是.NET平台上的，因此它只限制于托管代码，我们可以直接调用非托管代码或进程通信间接调用非托管代码等多个手段来突破对托管代码 操作资源的限制。<br>&emsp;&emsp;事实上，我们在平常项目中代码编写的安全机制(业务逻辑身份验证、项目框架验证)与这些平台级的安全机制没什么不同。我们可以理解为代码写的位置不一样，.NET安全机制是写在CLR组件中，而我们的安全机制是写在上层的代码中。这些平台级的标识更多的是和操作系统用户有关，而我们项目代码中的标识则是和在数据库中注册的用户有关， 大家都是通过if else来去判断，判断的主体和格局不一样，逻辑本质都是相同的。<br>&emsp;&emsp;NET Core不支持代码访问安全性和安全性透明性。  </p>
<h1 id="NET是什么"><a href="#NET是什么" class="headerlink" title=".NET是什么"></a>.NET是什么</h1><p>&emsp;&emsp;我在前文对.NET系统概述时，有的直接称.NET，有的称.NET Framework。那么准确来说什么是.NET?什么又是.NET Framework呢？<br>&emsp;&emsp;.NET是一个微软搭造的开发者平台，它主要包括：  </p>
<ul>
<li>1.支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…)，</li>
<li>2.用于该平台下开发人员的技术框架体系(.NET Framework、.NET Core、Mono、UWP等)，<ul>
<li>1.定义了通用类型系统，庞大的CTS体系 </li>
<li>2.用于支撑.NET下的语言运行时的环境：CLR </li>
<li>3..NET体系技术的框架库FCL </li>
</ul>
</li>
<li>3.用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等)</li>
</ul>
<h2 id="NET-Framework是什么"><a href="#NET-Framework是什么" class="headerlink" title=".NET Framework是什么"></a>.NET Framework是什么</h2><p>&emsp;&emsp;事实上，像我上面讲的那些诸如程序集、GC、AppDomain这样的为CLR的一些概念组成，实质上指的是.NET Framework CLR。<br>&emsp;&emsp;.NET平台是微软为了占据开发市场而成立的，不是无利益驱动的纯技术平台的那种东西。基于该平台下的技术框架也因为 商业间的利益 从而和微软自身的Windows操作系统所绑定。所以虽然平台雄心和口号很大，但很多框架类库技术都是以Windows系统为蓝本，这样就导致，虽然.NET各方面都挺好，但是用.NET就必须用微软的东西，直接形成了技术-商业的绑定。<br>&emsp;&emsp;.NET Framework就是.NET 技术框架组成在Windows系统下的具体的实现，和Windows系统高度耦合，上文介绍的.NET系统，就是指.NET Framework。<br>&emsp;&emsp;部署.net Framework ：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers</a><br>&emsp;&emsp;.NET Framework高级开发：<a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/29eafad8(v%3dvs.90)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/29eafad8(v%3dvs.90)</a><br>&emsp;&emsp;.NET Framework源码在线浏览：<a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">https://referencesource.microsoft.com/</a>  </p>
<h3 id="如何在VS中调试-NET-Framework源代码"><a href="#如何在VS中调试-NET-Framework源代码" class="headerlink" title="如何在VS中调试.NET Framework源代码"></a>如何在VS中调试.NET Framework源代码</h3><p>&emsp;&emsp;最为关键的是pdb符号文件，没得符号就调不了，对于符号我们从微软的符号服务器上下载(默认就已配置)，还得有源代码来调试。<br>&emsp;&emsp;点击工具-选项-调试-常规，如果你之前没有在该配置栏配置过，那么你就勾选 启用源服务器支持 、启用.net Framework源代码单步执行，然后将 要求源文件与原始版本完全匹配 给取消掉。<br>&emsp;&emsp;然后就是下载pdb符号文件了，如果想直接下载那么可以在调试-符号这栏 将Microsoft符号服务器给勾上 。如果想按需下载，那么在调试的时候，可以点击调试-窗口 选择 模块/调用堆栈 来选择自己想加载的去加载。<br>&emsp;&emsp;然后至 <a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">https://referencesource.microsoft.com/</a> 网站 点击右上角下载源代码。当你调试代码的时候，会提示你无可用源，这个时候你再将你下载下来的源码文件给浏览查找一下就可以了。<br><img src="1026815-20180627092252642-95078986.png" alt=" "><br>&emsp;&emsp;如何配置VS来调试.NET Framework源码： <a href="https://referencesource.microsoft.com/#q=web" target="_blank" rel="noopener">https://referencesource.microsoft.com/#q=web</a> 、 <a href="https://technet.microsoft.com/zh-cn/cc667410.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/cc667410.aspx</a><br>&emsp;&emsp;还一种方法是，下载.NET Reflector插件，该插件可以帮助我们在VS中直接调试dll，这种方式操作非常简单，不过该插件收费，具体的可以查看我之前写过的文章(群里有该插件的注册版)  </p>
<h2 id="NET-Core是什么"><a href="#NET-Core是什么" class="headerlink" title=".NET Core是什么"></a>.NET Core是什么</h2><p>&emsp;&emsp;有丑才有美，有低才有高，概念是比较中诞生的。.NET Core就是如此，它是其它操作系统的.NET Framework翻版实现。<br>&emsp;&emsp;操作系统不止Windows，还有Mac和类Linux等系统， .NET的实现 如果按操作系统来横向分割的话，可以分为 Windows系统下的 .NET Framework 和 兼容多个操作系统的 .NET Core。<br>&emsp;&emsp;我们知道，一个.NET程序运行核心在于.NET CLR，为了能让.NET程序在其它平台上运行，一些非官方社区和组织为此开发了在其它平台下的.NET实现（最为代表的是mono，其团队后来又被微软给合并了 ），但因为不是官方，所以在一些方面多少有些缺陷(如FCL)，后来微软官方推出了.NET Core，其开源在Github中，并被收录在NET基金会(.NET Foundation，由微软公司成立与赞助的独立自由软件组织，其目前收录包括.NET编译器平台(“Roslyn”)以及ASP.NET项目系列，.NET Core，Xamarin Forms以及其它流行的.NET开源框架)，旨在真正的 .NET跨平台。<br>&emsp;&emsp;.NET Core是.NET 技术框架组成在Windows.macOS.Linux系统下的具体的实现。<br>&emsp;&emsp;.NET Core是一个开源的项目，其由 Microsoft 和 GitHub 上的 .NET 社区共同维护，但 这份工作仍然是巨大的，因为在早期对.NET上的定义及最初的实现一直是以Windows系统为参照及载体，一些.NET机制实际上与Windows系统耦合度非常高，有些属于.NET自己体系内的概念，有些则属于Windows系统api的封装。 那么从Windows转到其它平台上，不仅要实现相应的CLR，还要舍弃或重写一部分BCL，因而，.NET Core在概念和在项目中的行为与我们平常有些不同。<br>&emsp;&emsp;比如，NET Core不支持AppDomains、远程处理、代码访问安全性 (CAS) 和安全透明度，任何有关该概念的库代码都应该被替换。<br>&emsp;&emsp;这部分代码它不仅指你项目中的代码，还指你项目中using的那些程序集代码，所以你会在github上看到很多开源项目都在跟进对.NET Core的支持,并且很多开发者也尝试学习.NET Core，这也是一种趋势。<br>&emsp;&emsp;.NET Core指南<a href="https://docs.microsoft.com/en-us/dotnet/core/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/core/</a><br>&emsp;&emsp;.NET基金会：<a href="https://dotnetfoundation.org" target="_blank" rel="noopener">https://dotnetfoundation.org</a><br>&emsp;&emsp;.NET Core跨平台的行为变更：<a href="https://github.com/dotnet/corefx/wiki/ApiCompat" target="_blank" rel="noopener">https://github.com/dotnet/corefx/wiki/ApiCompat</a><br>&emsp;&emsp;微软宣布.NET开发环境将开源 ：<a href="https://news.cnblogs.com/n/508410/" target="_blank" rel="noopener">https://news.cnblogs.com/n/508410/</a>  </p>
<h2 id="NET-Standard是什么"><a href="#NET-Standard是什么" class="headerlink" title=".NET Standard是什么"></a>.NET Standard是什么</h2><p>&emsp;&emsp;值得一提的是微软还为BCL提出了一个标准，毕竟各式各样的平台，技术层出不穷，为了防止.NET在类库方面的碎片化，即提出了一套正式的 .NET API (.NET 的应用程序编程接口)规范，.NET Standard。<br>&emsp;&emsp;正如上面CLS一样，.NET Standard就类似于这样的一个概念，无论是哪个托管框架，我们遵循这个标准，就能始终保持在BCL的统一性，即我不需要关心我是用的.NET Framework还是.NET Core，只要该类被定义于.NET Standard中，我就一定能在对应支持的.NET Standard的版本的托管框架中找到它。<br><img src="1026815-20180627092519198-1182560984.png" alt=" "><br>&emsp;&emsp;.NET Standard： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard#net-implementation-support" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard#net-implementation-support</a><br>&emsp;&emsp;.NET Standard开源代码：<a href="https://github.com/dotnet/standard" target="_blank" rel="noopener">https://github.com/dotnet/standard</a>  </p>
<h2 id="NET官方开源项目链接"><a href="#NET官方开源项目链接" class="headerlink" title=".NET官方开源项目链接"></a>.NET官方开源项目链接</h2><p>&emsp;&emsp;现在我将给出.NET相关的开源项目地址：<br>&emsp;&emsp;参与.NET和.NET开源项目的起点：<a href="https://github.com/Microsoft/dotnet" target="_blank" rel="noopener">https://github.com/Microsoft/dotnet</a>  </p>
<ul>
<li>.NET Core：<a href="https://github.com/dotnet/core" target="_blank" rel="noopener">https://github.com/dotnet/core</a></li>
<li>.NET Core文档：<a href="https://github.com/dotnet/docs" target="_blank" rel="noopener">https://github.com/dotnet/docs</a></li>
<li>ASP.NET Core：<a href="https://github.com/aspnet/home" target="_blank" rel="noopener">https://github.com/aspnet/home</a></li>
<li>ASP.NET Core文档：<a href="https://github.com/aspnet/Docs" target="_blank" rel="noopener">https://github.com/aspnet/Docs</a></li>
<li>EntityFramework Core框架:<a href="https://github.com/aspnet/EntityFrameworkCore" target="_blank" rel="noopener">https://github.com/aspnet/EntityFrameworkCore</a></li>
<li>ASP.NET Core MVC框架：<a href="https://github.com/aspnet/Mvc" target="_blank" rel="noopener">https://github.com/aspnet/Mvc</a></li>
<li>EntityFramework6:<a href="https://github.com/aspnet/EntityFramework6" target="_blank" rel="noopener">https://github.com/aspnet/EntityFramework6</a></li>
<li>.NET Framework源码：<a href="https://github.com/microsoft/referencesource" target="_blank" rel="noopener">https://github.com/microsoft/referencesource</a></li>
<li>.NET Core基类库：<a href="https://github.com/dotnet/corefx" target="_blank" rel="noopener">https://github.com/dotnet/corefx</a></li>
<li>.NET Core CLR：<a href="https://github.com/dotnet/coreclr" target="_blank" rel="noopener">https://github.com/dotnet/coreclr</a></li>
<li>Roslyn编译器：<a href="https://github.com/dotnet/roslyn" target="_blank" rel="noopener">https://github.com/dotnet/roslyn</a></li>
<li>MVC5、Web API2、Web Pages3框架源码：<a href="https://github.com/aspnet/AspNetWebStack" target="_blank" rel="noopener">https://github.com/aspnet/AspNetWebStack</a></li>
<li>.NET Standard：<a href="https://github.com/dotnet/standard" target="_blank" rel="noopener">https://github.com/dotnet/standard</a></li>
<li>KestrelHttpServer用于ASP.NET Core的跨平台Web服务器：<a href="https://github.com/aspnet/KestrelHttpServer" target="_blank" rel="noopener">https://github.com/aspnet/KestrelHttpServer</a></li>
<li>Visual Studio Code源码：<a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">https://github.com/Microsoft/vscode</a></li>
<li>一些优秀的.NET库、工具、框架、软件开源集合：<a href="https://github.com/quozd/awesome-dotnet" target="_blank" rel="noopener">https://github.com/quozd/awesome-dotnet</a></li>
<li>一些常用框架对ASP.NET Core和.NET Core的支持报告：<a href="https://github.com/jpsingleton/ANCLAFS" target="_blank" rel="noopener">https://github.com/jpsingleton/ANCLAFS</a> </li>
<li>一些.NET下用于支持开发的开源项目集合：<a href="https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md" target="_blank" rel="noopener">https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md</a> </li>
<li>微软出品的分布式框架orleans：<a href="https://github.com/dotnet/orleans" target="_blank" rel="noopener">https://github.com/dotnet/orleans</a></li>
<li>ML.NET 用于.NET的开源和跨平台机器学习框架：<a href="https://github.com/dotnet/machinelearning" target="_blank" rel="noopener">https://github.com/dotnet/machinelearning</a></li>
</ul>
<h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><p>&emsp;&emsp;在文章最后，我还要简单的说下Visual Studio。<br>&emsp;&emsp;通过上文得知，只需要一个txt记事本+csc.exe我们就可以开发出一个.NET程序，那么与之相比，.NET提供的开发工具VS有什么不同呢？<br>&emsp;&emsp;我们用记事本+csc.exe来编写一个.NET程序只适合小打小闹，对于真正要开发一个项目而言，我们需要文件管理、版本管理、一个好的开发环境等。而vs ide则就是这样一个集成代码编辑、编译、调试、追踪、测试、部署、协作、插件扩展这样多个组件的集成开发环境，csc.exe的编译功能只是vs ide中的其中之一。使用vside开发可以节省大量的开发时间和成本。  </p>
<h2 id="sln解决方案"><a href="#sln解决方案" class="headerlink" title="sln解决方案"></a>sln解决方案</h2><p>&emsp;&emsp;当你用VS来新建一个项目时，VS会先为你新建一个整体的解决方案。这个解决方案表现为.sln和.suo后缀格式的文件，它们均是文本文件，对解决方案右键属性可以进行相应的修改，也可以直接用记事本打开。<br>&emsp;&emsp;在sln中，定义了解决方案的版本及环境，如包含的项目，方案启动项，生成或部署的一些项目配置等，你可以通过修改或重新定义sln来更改你的整个解决方案。<br>&emsp;&emsp;而suo则包含于解决方案建立关联的选项，相当于快照，储存了用户界面的自定义配置、调试器断点、观察窗口设置等这样的东西，它是隐藏文件，可删除但建议不要删除。<br>&emsp;&emsp;我们可以通过对比各版本之间的sln来修改sln,也可以使用网上的一些转换工具，也可以直接点击VS的文件-新建-从现有代码创建项目来让项目在不同VS版本间切换。<br>&emsp;&emsp;Visual Studio 2010 - # Visual Studio 4.0<br>&emsp;&emsp;Visual Studio 2012 - # Visual Studio 4.0<br>&emsp;&emsp;Visual Studio 2013 - # Visual Studio 12.00<br>&emsp;&emsp;Visual Studio 2015 - # Visual Studio 14<br>&emsp;&emsp;Visual Studio 2017 - # Visual Studio 15  </p>
<h2 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h2><p>&emsp;&emsp;VS使用项目模板来基于用户的选择而创建新的项目，也就是新建项目中的那些展示项(如mvc5项目/winform项目等等)，具体表现为包含<code>.vstemplate</code>及一些定义的关联文件这样的母版文件。将这些文件压缩为一个 <code>.zip</code> 文件并放在正确的文件夹中时，就会在展示项中予以显示。<br>&emsp;&emsp;用户可以创建或自定义项目模板，也可以选择现有的模板，比如我创建一个控制台项目就会生成一个在<code>.vstemplate</code>中定义好的<code>Program.cs</code>、<code>AssemblyInfo.cs</code>(程序集级别的特性)、<code>App.config</code>、<code>ico</code>、<code>csproj</code>文件<br><img src="1026815-20180627092814795-1540367679.png" alt=" ">  </p>
<h2 id="csproj工程文件"><a href="#csproj工程文件" class="headerlink" title="csproj工程文件"></a>csproj工程文件</h2><p>&emsp;&emsp;这里面，csproj是我们最常见的核心文件，CSharp Project，它是用于构建这个项目的工程文件。<br>&emsp;&emsp;csproj是基于xml格式的MSBuild项目文件，其仍然是文本文件，可以打开并修改定义了的工程构造的属性，比如选择性的添加或删除或修改包含在项目中的文件或引用、修改项目版本、将其转换为其它类型项目等。<br>&emsp;&emsp;MSBuild是微软定义的一个用于生成应用程序的平台(Microsoft Build Engine)，在这里为VS提供了项目的构造系统，在微软官方文档上有着详细的说明：<a href="https://msdn.microsoft.com/zh-cn/library/dd393573.aspx、https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd393573.aspx、https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild</a>  </p>
<h2 id="项目属性杂项"><a href="#项目属性杂项" class="headerlink" title="项目属性杂项"></a>项目属性杂项</h2><p>&emsp;&emsp;现在，简单说明一下csproj文件的一些核心元素。我们用vs新建一个控制台项目，然后对项目右键属性打开项目属性，在应用程序页我们可以定义：程序集名称(生成出来的程序集以程序集名称作为文件名，相当于csc中的/out)、默认命名空间(每次新建类里面显示的命名空间)、目标框架、应用程序类型、程序集信息(AssemblyInfo中的信息)、启动对象(可同时存在多个Main方法，需指定其中一个为入口对象)、程序集资源(一些可选的图标及文件)  </p>
<ol>
<li><p>在生成页有：  </p>
<ul>
<li>条件编译符号(全局的预编译#define指令，不用在每个文件头部定义，相当于csc中的/define)</li>
<li>定义DEBUG/TRACE常量(用于调试输出的定义变量，如智能追踪的时候可以输出该变量)</li>
<li>目标平台(指定当前面向什么处理器生成的程序集，相当于csc中的/platform。选择x86则生成的程序集生成32位程序，能在32/64位Intel处理器中使用。选择x64则生成64位，只能在64位系统中运行。选择Any CPU则32位系统生成32位，64位系统则生成64位。注意：编译平台和目标调用平台必须保持一致，否则报错。生成的32位程序集不能调用64位程序集，64位也不能调用32位)、首选32位(如果目标平台是Any CPU并且项目是应用程序类型，则生成的是32位程序集)</li>
<li>允许不安全代码(unsafe开关，在c#中进行指针编程，如调换a方法和b方法的地址)</li>
<li>优化代码(相当于csc中的/optimize，优化IL代码让调试难以进行，优化JIT代码)</li>
<li>输出路径(程序集输出目录，可选择填写相对路径目录或绝对路径目录)</li>
<li>XML文档文件(相当于csc中的/doc，为程序集生成文档注释文件，浏览对方程序集对象就可以看到相关注释，VS的智能提示技术就运用于此)</li>
<li>为COM互操作注册(指示托管应用程序将公开一个 COM 对象,使COM对象可以与托管应用程序进行交互)</li>
</ul>
</li>
<li><p>在高级生成设置中有:语言版本(可以选择C#版本)、调试信息(相当于csc中的/debug。选择none则不生成任何调试信息，无法调试。选择full则允许将调试器附加到运行程序，生成pdb调试文件。选择pdb-only，自.NET2.0开始与full选项完全相同，生成相同的pdb调试文件。)、文件对齐(指定输出文件中节的大小)、DLL基址(起点地址)  </p>
</li>
<li><p>在生成事件选项中可以设置生成前和生产后执行的命令行，我们可以执行一些命令。  </p>
</li>
<li><p>在调试选项中有一栏叫：启用Visual Studio承载进程，通过在vshost.exe中加载运行项目程序集，这个选项可以增加程序的调试性能，启用后会自动在输出目录生成{程序集名称}.vshost.exe这样一个文件，只有当当前项目不是启动项目的时候才能删除该文件。  </p>
</li>
</ol>
<h2 id="IntelliTrace智能追溯"><a href="#IntelliTrace智能追溯" class="headerlink" title="IntelliTrace智能追溯"></a>IntelliTrace智能追溯</h2><p>&emsp;&emsp;还要介绍一点VS的是，其IntelliTrace智能追溯功能，该功能最早存在于VS2010旗舰版，是我用的最舒服的一个功能。<br>&emsp;&emsp;简单介绍，该功能是用来辅助调试的，在调试时可以让开发人员了解并追溯代码所产生的一些事件，并且能够进行回溯以查看应用程序中发生的情形，它是一个非常强大的调试追踪器，它可以捕捉由你代码产生的事件，如异常事件、函数调用(从入口)、ADO.NET的命令(Sql查询语句…)、ASP.NET相关事件、代码发送的HTTP请求、程序集加载卸载事件、文件访问打开关闭事件、Winform/Webform/WPF动作事件、线程事件、环境变量、Console/Trace等输出…<br>&emsp;&emsp;我们可以通过在调试状态下点击调试菜单-窗口-显示诊断工具，或者直接按<code>Ctrl+Alt+F2</code>来唤起该功能窗口。<br><img src="1026815-20180627093009099-519860392.png" alt=" "><br>&emsp;&emsp;当然，VS还有其它强大的功能，我建议大家依次点完 菜单项中的 调试、体系结构、分析这三个大菜单里面的所有项，你会发现VS真是一个强大的IDE。比较实用且方便的功能举几个例子：<br>&emsp;&emsp;比如 从代码生成的序列图，该功能在vs2015之前的版本可以找到(<a href="https://msdn.microsoft.com/en-us/library/dd409377.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd409377.aspx</a> 、<a href="https://www.zhihu.com/question/36413876" target="_blank" rel="noopener">https://www.zhihu.com/question/36413876</a>)<br><img src="1026815-20180627093037839-1150553069.png" alt=" "><br>&emsp;&emsp;比如 模块关系的代码图，可以看到各模块间的关系<br><img src="1026815-20180627093124326-512090758.png" alt=" "><br>&emsp;&emsp;比如 对解决方案的代码度量分析结果<br><img src="1026815-20180627093148912-1896119331.png" alt=" "><br>&emsp;&emsp;比如 调试状态下 函数调用的 代码图，我们可以看到MVC框架的函数管道模型<br><img src="1026815-20180627093233279-525978653.png" alt=" "><br>&emsp;&emsp;以及并行堆栈情况、加载的模块、线程的实际情况<br><img src="1026815-20180627093315515-525631630.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180627093342703-1181912035.png" alt title class>
                <p></p>
            </figure>  
<figure class="image-box">
                <img src="1026815-20180627093350454-462024400.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;还有如进程、内存、反汇编、寄存器等的功能，这里不再一一展示  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>&emsp;&emsp;有关解决方案：<a href="https://msdn.microsoft.com/zh-cn/library/b142f8e7(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/b142f8e7(v=vs.110).aspx</a><br>&emsp;&emsp;有关项目模板： <a href="https://msdn.microsoft.com/zh-cn/library/ms247121(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms247121(v=vs.110).aspx</a><br>&emsp;&emsp;有关项目元素的说明介绍：<a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/16satcwx(v%3dvs.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/16satcwx(v%3dvs.100)</a><br>&emsp;&emsp;有关调试更多内容：<a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/debugger/</a><br>&emsp;&emsp;有关代码设计建议：<a href="https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-analysis-for-managed-code-warnings" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-analysis-for-managed-code-warnings</a><br>&emsp;&emsp;有关IntelliTrace介绍：<a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/dd264915(v%3dvs.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/dd264915(v%3dvs.100)</a>  </p>
<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>&emsp;&emsp;我热爱编程。<br>&emsp;&emsp;我知道大多数人对技术的积累都是来自于平常工作中，工作中用到的就去学，用不到就不学，学一年的知识，然后用个五六年。<br>&emsp;&emsp;我也能理解人的理想和追求不同，有的人可能就想平淡点生活。有的人可能是过了拼劲，习惯了安逸。有的人已经认命了。<br>&emsp;&emsp;而我现在也每天饱满工作没多少时间，但在下班之余我仍然坚持每天都看一看书。<br>&emsp;&emsp;想学没时间学，想拼不知道往哪拼。有埋汰自己脑袋笨的，有说自己不感兴趣的。有明明踌躇满志，但总三天捕鱼两天晒网的。我身边的朋友大多都这样。<br>&emsp;&emsp;我想说，尽管我们每个人的境遇、思想、规划不同，但我肯定大家大部分是出于生计而工作。<br>&emsp;&emsp;而出于生计，那就是为了自己。而既然是为了自己，那就别每天浑浑噩噩过，即使你因各种原因而没有斗志。<br>&emsp;&emsp;编程来不得虚的，如果你没走上管理，那么你的技术好就是好，不好就是不好，混不得，一分技术一分钱。自己不扎实，你运气就不可能太好。<br>&emsp;&emsp;技术是相通的，操作系统、通信、数据结构、协议标准、技术规范、设计模式，语言只是门工具。要知其然也要知其所以然，只知道1个梨+1个梨=2个梨，不知道1个苹果+1个苹果等于啥就悲剧了。<br>&emsp;&emsp;那怎样提升自己？肯定不能像之前那样被动的去学习了。<br>&emsp;&emsp;光靠工作中的积累带来的提升是没有多少。你不能靠1年的技术重复3年的劳动，自己不想提升就不能怨天尤人。<br>&emsp;&emsp;上班大家都一样，我认为成功与否取决于你的业余时间。你每天下班无论再苦都要花一个小时来学习，学什么都行，肯定能改变你的人生轨迹。<br>&emsp;&emsp;比如你每天下班后都用一小时来学一个概念或技术点，那么300天就是300个概念或者技术点，这是何等的恐怖。<br>&emsp;&emsp;当然，这里的学要有点小方法小技巧的。不能太一条道摸到黑的那种，虽然这样最终也能成功，并且印象还深刻，但是总归效率是有点低的。<br>&emsp;&emsp;比如你从网上下载个项目源码，你项目结构不知道，该项目运用技术栈也不太了解，就一点一点的开始解读。这是个提升的好方法，但这样很累，可以成功，但是很慢。见的多懂的少，往往会因为一个概念上的缺失而在一个细小的问题上浪费很长时间。或者说一直漫无目的的看博客来了解技术，那样获取的知识也不系统。<br>&emsp;&emsp;我的建议是读书，书分两类，一类是 讲底层概念的 一类是 讲上层技术实现的。<br>&emsp;&emsp;可以先从上层技术实现的书读起(如何连接数据库、如何写网页、如何写窗体这些)。在有一定编程经验后就从底层概念的书开始读，操作系统的、通信的、数据库的、.NET相关组成的这些…<br>&emsp;&emsp;读完之后再回过头读这些上层技术的书就会看的更明白更透彻，最后再琢磨git下来的项目就显得轻松了。<br>&emsp;&emsp;就.NET CLR组成这一块中文书籍比较少，由浅到深推荐的书有 你必须知道的.NET(挺通俗)，CLR C#(挺通俗，进阶必看)，如果你想进一步了解CLR，可以看看园子里 包建强 <a href="http://www.cnblogs.com/Jax/archive/2009/05/25/1488835.html" target="_blank" rel="noopener">http://www.cnblogs.com/Jax/archive/2009/05/25/1488835.html</a> 和中道学友 <a href="http://www.cnblogs.com/awpatp/archive/2009/11/11/1601397.html" target="_blank" rel="noopener">http://www.cnblogs.com/awpatp/archive/2009/11/11/1601397.html</a> 翻译的书籍及文章，当然如果你英语合格的话也可以直接阅读他们翻译的来源书籍，我这里有Expert .NET 2.0 IL Assembler的机器翻译版，同时我也建议从调试的方面入手，如 NET高级调试(好多.NET文件调试、反编译的文章都是参考这本书和Apress.Expert.dot.NET.2.0.IL.Assembler(这本书我有机器翻译版)的内容)或者看看Java的JVM的文章。<br>&emsp;&emsp;欢迎加群和我交流(书籍我都放在群文件里了)  </p>
<p>&emsp;&emsp;现在技术发展很快，我建议大家有基础的可以直接看官方文档，(详细链接我已经在各小节给出)以下是部分常用总链接：<br>&emsp;&emsp;asp.net指南：<a href="https://docs.microsoft.com/zh-cn/aspnet/#pivot=core" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/#pivot=core</a><br>&emsp;&emsp;Visual Studio IDE 指南：<a href="https://docs.microsoft.com/zh-cn/visualstudio/ide/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/ide/</a><br>&emsp;&emsp;C# 指南： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/</a><br>&emsp;&emsp;.NET指南：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/</a><br>&emsp;&emsp;微软开发文档：<a href="https://docs.microsoft.com/zh-cn/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/</a><br>&emsp;&emsp;最后送给大家我经常做的两句话：  </p>
<ol>
<li>先问是不是，再问怎样做，最后我一定会问 为什么  </li>
<li>没人比谁差多少，相信自己，坚持不断努力，你也能成功  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图册]]></title>
      <url>/2019/11/10/Pictures/</url>
      <content type="html"><![CDATA[<p>&emsp;</p>
<a id="more"></a>


<h1 id="Nintendo-Switch"><a href="#Nintendo-Switch" class="headerlink" title="Nintendo Switch"></a>Nintendo Switch</h1><figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/NS20171101-20180501.jpg" alt="2017.11.01 - 2018.05.01" title class>
                <p>2017.11.01 - 2018.05.01</p>
            </figure>  
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/NS20171101-20190112.jpg" alt="2017.11.01 - 2019.01.12" title class>
                <p>2017.11.01 - 2019.01.12</p>
            </figure>  
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/NS20171101-20191101.jpg" alt="2017.11.01 - 2019.11.01" title class>
                <p>2017.11.01 - 2019.11.01</p>
            </figure>  

<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><figure class="image-box">
                <img src="设计模式.png" alt="设计模式" title class>
                <p>设计模式</p>
            </figure>  
<figure class="image-box">
                <img src="CQRS架构.png" alt="CQRS架构" title class>
                <p>CQRS架构</p>
            </figure>  ]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在浏览器输入 URL 回车之后发生了什么]]></title>
      <url>/2019/09/06/WhatHappensWhenYouTypeURLIntoYourBrowserAndPressEnter/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">https://4ark.me/post/b6c7c0a2.html</a></p>
</blockquote>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。<br>&emsp;&emsp;这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅  </p>
<p>&emsp;&emsp;<strong>注意</strong>：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。  </p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol>
<li>URL 解析</li>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面</li>
</ol>
<h1 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h1><h2 id="地址解析："><a href="#地址解析：" class="headerlink" title="地址解析："></a>地址解析：</h2><p>&emsp;&emsp;首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p>
<h2 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h2><p>&emsp;&emsp;由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a>。</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>&emsp;&emsp;浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p>
<h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><figure class="image-box">
                <img src="检查缓存.png" alt title class>
                <p></p>
            </figure>

<h1 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><figure class="image-box">
                <img src="DNS查询.png" alt title class>
                <p></p>
            </figure>
<h2 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h2><p>&emsp;&emsp;浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p>
<h2 id="2-操作系统缓存"><a href="#2-操作系统缓存" class="headerlink" title="2. 操作系统缓存"></a>2. 操作系统缓存</h2><p>&emsp;&emsp;操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p>
<h2 id="3-路由器缓存"><a href="#3-路由器缓存" class="headerlink" title="3. 路由器缓存"></a>3. 路由器缓存</h2><p>&emsp;&emsp;路由器也有自己的缓存。</p>
<h2 id="4-ISP-DNS-缓存"><a href="#4-ISP-DNS-缓存" class="headerlink" title="4. ISP DNS 缓存"></a>4. ISP DNS 缓存</h2><p>&emsp;&emsp;ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p>
<h2 id="根域名服务器查询"><a href="#根域名服务器查询" class="headerlink" title="根域名服务器查询"></a>根域名服务器查询</h2><p>&emsp;&emsp;在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p>
<figure class="image-box">
                <img src="DNS根域名服务器查询.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ol>
<li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li>
<li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li>
<li>什么是 DNS 劫持</li>
<li>前端 dns-prefetch 优化</li>
</ol>
<h1 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h1><p>&emsp;&emsp;TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="TCP%E8%BF%9E%E6%8E%A5.png" alt=" "></p>
<h2 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a>1. 应用层：发送 HTTP 请求</h2><p>&emsp;&emsp;在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p>
<ul>
<li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li>
<li>请求主体（其他参数）</li>
</ul>
<p>&emsp;&emsp;其中需要注意的点：</p>
<ul>
<li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li>
</ul>
<h2 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a>2. 传输层：TCP 传输报文</h2><p>&emsp;&emsp;传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。<br>&emsp;&emsp;在建立连接前，会先进行 TCP 三次握手。</p>
<blockquote>
<p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：<br>&emsp;&emsp;SYN 泛洪攻击</p>
</blockquote>
<h2 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a>3. 网络层：IP协议查询Mac地址</h2><p>&emsp;&emsp;将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。<br>&emsp;&emsp;判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>
<blockquote>
<p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p>
</blockquote>
<h2 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a>4. 链路层：以太网协议</h2><h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><p>&emsp;&emsp;根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p>
<ul>
<li>标头：数据包的发送者、接受者、数据类型</li>
<li>数据：数据包具体内容</li>
</ul>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>&emsp;&emsp;以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>&emsp;&emsp;发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。<br>&emsp;&emsp;<strong>注意</strong>：接收方回应是单播。</p>
<blockquote>
<p>相关知识点：<br>&emsp;&emsp;ARP 攻击</p>
</blockquote>
<h2 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a>服务器接受请求</h2><p>&emsp;&emsp;接受过程就是把以上步骤逆转过来，参见上图。</p>
<h1 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h1><h2 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h2><figure class="image-box">
                <img src="服务器处理请求.png" alt title class>
                <p></p>
            </figure>
<h2 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h2><p>&emsp;&emsp;最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。<br>&emsp;&emsp;它会监听得到的请求，然后开启一个子进程去处理这个请求。</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>&emsp;&emsp;接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p>
<ul>
<li>验证是否配置虚拟主机</li>
<li>验证虚拟主机是否接受此方法</li>
<li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>&emsp;&emsp;假如服务器配置了 HTTP 重定向，就会返回一个<code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p>
<blockquote>
<p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html" target="_blank" rel="noopener">详见这篇文章</a></p>
</blockquote>
<h2 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h2><p>&emsp;&emsp;然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。<br>&emsp;&emsp;否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。<br>&emsp;&emsp;然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。<br>&emsp;&emsp;以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p>
<h1 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h1><p>&emsp;&emsp;浏览器接收到来自服务器的响应资源后，会对资源进行分析。<br>&emsp;&emsp;首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。<br>&emsp;&emsp;如果响应资源进行了压缩（比如 gzip），还需要进行解压。<br>&emsp;&emsp;然后，对响应资源做缓存。<br>&emsp;&emsp;接下来，根据响应资源里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME</a> 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p>
<h1 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h1><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><figure class="image-box">
                <img src="浏览器内核.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><figure class="image-box">
                <img src="渲染页面.png" alt title class>
                <p></p>
            </figure>
<h2 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1. HTML 解析"></a>1. HTML 解析</h2><p>&emsp;&emsp;首先要知道浏览器解析是从上往下一行一行地解析的。  </p>
<p>解析的过程可以分为四个步骤：</p>
<h3 id="1-解码（encoding）"><a href="#1-解码（encoding）" class="headerlink" title="1. 解码（encoding）"></a>1. 解码（encoding）</h3><p>&emsp;&emsp;传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p>
<h3 id="2-预解析（pre-parsing）"><a href="#2-预解析（pre-parsing）" class="headerlink" title="2. 预解析（pre-parsing）"></a>2. 预解析（pre-parsing）</h3><p>&emsp;&emsp;预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p>
<h3 id="3-符号化（Tokenization）"><a href="#3-符号化（Tokenization）" class="headerlink" title="3. 符号化（Tokenization）"></a>3. 符号化（Tokenization）</h3><p>&emsp;&emsp;符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。<br>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p>
<h3 id="4-构建树（tree-construction）"><a href="#4-构建树（tree-construction）" class="headerlink" title="4. 构建树（tree construction）"></a>4. 构建树（tree construction）</h3><blockquote>
<p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p>
</blockquote>
<p>&emsp;&emsp;在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="构建树.png" alt title class>
                <p></p>
            </figure>
<h3 id="浏览器容错进制"><a href="#浏览器容错进制" class="headerlink" title="浏览器容错进制"></a>浏览器容错进制</h3><p>&emsp;&emsp;你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>&emsp;&emsp;当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p>
<h2 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h2><p>&emsp;&emsp;一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://drafts.csswg.org/css-syntax-3/" target="_blank" rel="noopener">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p>
<h3 id="CSS-匹配规则"><a href="#CSS-匹配规则" class="headerlink" title="CSS 匹配规则"></a>CSS 匹配规则</h3><p>&emsp;&emsp;在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。<br>&emsp;&emsp;所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p>
<h2 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h2><p>&emsp;&emsp;其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p>
<blockquote>
<p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p>
</blockquote>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>&emsp;&emsp;通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>&emsp;&emsp;浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p>
<ol>
<li>标签名、class、id</li>
<li>是否内联样式</li>
<li><code>!important</code> </li>
</ol>
<p>&emsp;&emsp;然后得出一个权重值，取最高的那个。</p>
<h3 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h3><p>&emsp;&emsp;当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。<br>&emsp;&emsp;但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。  </p>
<p>&emsp;&emsp;所以我们知道：</p>
<ul>
<li>CSS 会阻塞 JS 执行</li>
<li>JS 会阻塞后面的 DOM 解析</li>
</ul>
<p>&emsp;&emsp;为了避免这种情况，应该以下原则：</p>
<ul>
<li>CSS 资源排在 JavaScript 资源前面</li>
<li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li>
</ul>
<p>&emsp;&emsp;另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h2><p>&emsp;&emsp;确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。<br>&emsp;&emsp;然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p>
<h2 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a>5. 合并渲染层</h2><p>&emsp;&emsp;把以上绘制的所有图片合并，最终输出一张图片。</p>
<h2 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a>6. 回流与重绘</h2><h3 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流(reflow)"></a>回流(reflow)</h3><p>&emsp;&emsp;当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。<br>&emsp;&emsp;reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p>
<h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h3><p>&emsp;&emsp;改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。<br>&emsp;&emsp;每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。<br>&emsp;&emsp;回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。  </p>
<p>&emsp;&emsp;比如：</p>
<ul>
<li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li>
</ul>
<h2 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h2><h3 id="大致流程-2"><a href="#大致流程-2" class="headerlink" title="大致流程"></a>大致流程</h3><figure class="image-box">
                <img src="JavaScript编译运行.png" alt title class>
                <p></p>
            </figure>  

<p>可以分为三个阶段：</p>
<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h3><p>&emsp;&emsp;JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。  </p>
<p>&emsp;&emsp;几个步骤：</p>
<ul>
<li>分词，例如将<code>var a = 2</code>，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li>
<li>解析，将词法单元转换成抽象语法树（AST）。</li>
<li>代码生成，将抽象语法树转换成机器指令。</li>
</ul>
<h3 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h3><p>&emsp;&emsp;JS 有三种运行环境：</p>
<ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval</li>
</ul>
<p>&emsp;&emsp;每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p>
<h4 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h4><p>&emsp;&emsp;创建执行上下文的过程中，主要做了以下三件事：</p>
<ul>
<li>创建变量对象<ul>
<li>参数、函数、变量</li>
</ul>
</li>
<li>建立作用域链<ul>
<li>确认当前执行环境是否能访问变量</li>
</ul>
</li>
<li>确定 This 指向</li>
</ul>
<h3 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h3><h4 id="JS-线程"><a href="#JS-线程" class="headerlink" title="JS 线程"></a>JS 线程</h4><figure class="image-box">
                <img src="JS线程.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p>
<blockquote>
<p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p>
</blockquote>
<ul>
<li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li>
<li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li>
<li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li>
<li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li>
</ul>
<p>&emsp;&emsp;<strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>&emsp;&emsp;分为：</p>
<ul>
<li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li>
<li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>&emsp;&emsp;微任务是ES6和Node环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。<br>&emsp;&emsp;微任务的执行在宏任务的同步任务之后，在异步任务之前。<br><img src="%E5%BE%AE%E4%BB%BB%E5%8A%A1.png" alt=" ">  </p>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码输出顺序为：1,3,5,4,2</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li>
<li><a href="https://alistapart.com/article/tags-to-dom/" target="_blank" rel="noopener">Tags to DOM</a></li>
<li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
<li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li>
<li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js引擎的执行过程（一）</a></li>
<li>还有一些找不到了。。。。。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[行为型(Behavioral) 设计模式]]></title>
      <url>/2019/09/05/BehavioralDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>模板方法模式(Template Method) <a href="http://www.cnblogs.com/zhili/p/TemplateMethodPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/TemplateMethodPattern.html</a><br>命令模式(Command) <a href="http://www.cnblogs.com/zhili/p/CommandPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/CommandPattern.html</a><br>迭代器模式(Iterator) <a href="http://www.cnblogs.com/zhili/p/IteratorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/IteratorPattern.html</a><br>观察者模式(Observer) <a href="http://www.cnblogs.com/zhili/p/ObserverPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ObserverPattern.html</a><br>中介者模式(Mediator) <a href="http://www.cnblogs.com/zhili/p/MediatorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/MediatorPattern.html</a><br>状态者模式(State) <a href="http://www.cnblogs.com/zhili/p/StatePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/StatePattern.html</a><br>策略者模式(Strategy) <a href="http://www.cnblogs.com/zhili/p/StragetyPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/StragetyPattern.html</a><br>责任链模式(Chain of Responsibiliy) <a href="http://www.cnblogs.com/zhili/p/ChainOfResponsibity.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ChainOfResponsibity.html</a><br>访问者模式(Visitor) <a href="http://www.cnblogs.com/zhili/p/VistorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/VistorPattern.html</a><br>备忘录模式(Memento) <a href="http://www.cnblogs.com/zhili/p/MementoPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/MementoPattern.html</a><br>解释器模式(Interpreter)<br>空对象模式(Null Object)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结构型(Structural) 设计模式]]></title>
      <url>/2019/09/05/StructuralDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>适配器模式(Adapter) <a href="http://www.cnblogs.com/zhili/p/AdapterPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/AdapterPattern.html</a><br>桥接模式(Bridge) <a href="http://www.cnblogs.com/zhili/p/BridgePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/BridgePattern.html</a><br>装饰者模式(Decorator) <a href="http://www.cnblogs.com/zhili/p/DecoratorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/DecoratorPattern.html</a><br>组合模式(Composite) <a href="http://www.cnblogs.com/zhili/p/CompositePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/CompositePattern.html</a><br>外观模式(Facade) <a href="http://www.cnblogs.com/zhili/p/FacadePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FacadePattern.html</a><br>亨元模式(Flyweight) <a href="http://www.cnblogs.com/zhili/p/FlyweightPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FlyweightPattern.html</a><br>代理模式(Proxy) <a href="http://www.cnblogs.com/zhili/p/ProxyPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ProxyPattern.html</a><br>私有类数据模式(Private Class Data)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型(Creational) 设计模式]]></title>
      <url>/2019/09/05/CreationalDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>单例模式(Singleton) <a href="http://www.cnblogs.com/zhili/p/SingletonPatterm.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/SingletonPatterm.html</a><br>简单工厂模式(Factory) <a href="http://www.cnblogs.com/zhili/p/SimpleFactory.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/SimpleFactory.html</a><br>工厂方法模式(Factory Method) <a href="http://www.cnblogs.com/zhili/p/FactoryMethod.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FactoryMethod.html</a><br>抽象工厂模式(Abstract Factory) <a href="http://www.cnblogs.com/zhili/p/AbstractFactory.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/AbstractFactory.html</a><br>建造者模式(Builder) <a href="http://www.cnblogs.com/zhili/p/BuilderPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/BuilderPattern.html</a><br>原型模式(Prototype) <a href="http://www.cnblogs.com/zhili/p/PrototypePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/PrototypePattern.html</a><br>对象池模式(Object Pool)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计原则]]></title>
      <url>/2019/09/03/DesignPrinciples/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简介：<a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/DesignPatternSummery.html</a><br>第一篇：<a href="https://www.cnblogs.com/shoshana-kong/p/8847893.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoshana-kong/p/8847893.html</a><br>第二篇：<a href="https://www.cnblogs.com/www-zsl187-com/p/8821885.html" target="_blank" rel="noopener">https://www.cnblogs.com/www-zsl187-com/p/8821885.html</a>  </p>
</blockquote>
<p>1、开放 - 封闭原则 ( Open-Closed Principle, OCP )<br>&emsp;&emsp;通俗：对扩展开发，对修改关闭<br>&emsp;&emsp;开闭原则（Open-Closed Principle, OCP）强调的是：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。<br>&emsp;&emsp;符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。  </p>
<p>2、单一职责原则 ( Single Responsibility Principle )<br>&emsp;&emsp;通俗：一个类只做一件事<br>&emsp;&emsp;就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。  </p>
<p>3、里氏替换原则 ( Liskov Substitution Principle )<br>&emsp;&emsp;通俗：子类不能去修改父类的功能<br>&emsp;&emsp;里氏代替原则（Liskov Substitution Principle, LSP）指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。  </p>
<p>4、迪米特法则 / 最少知识原则 ( Law Of Demeter )<br>&emsp;&emsp;通俗：高内聚，低耦合<br>&emsp;&emsp;迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。<br>&emsp;&emsp;关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。  </p>
<p>5、依赖倒置原则 ( Dependence Inversion Principle )<br>&emsp;&emsp;通俗：类似 IOC，采用接口编程<br>&emsp;&emsp;依赖倒置（Dependence Inversion Principle, DIP）原则指的是抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。  </p>
<p>6、接口隔离原则 ( Interface Segregation Principle )<br>&emsp;&emsp;通俗：细节接口<br>&emsp;&emsp;接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。  </p>
<p>7、合成 / 聚合原则 ( Composite / Aggregate Reuse Principle, CARP )<br>&emsp;&emsp;通俗：避免使用继承<br>&emsp;&emsp;合成复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。  </p>
<a id="more"></a>

<h1 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h1><p>&emsp;&emsp;开放-封闭原则具有理想主义的色彩，他是面向对象设计的终极目标。其他几条则可以看做是开放-封闭原则的实现方法。设计模式就是实现了这些原则，从而达到了代码复用，增加可维护性的目的。  </p>
<h2 id="一-开放-封闭原则"><a href="#一-开放-封闭原则" class="headerlink" title="一.开放 - 封闭原则"></a>一.开放 - 封闭原则</h2><p>&emsp;&emsp;概念：一个软件实体如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。模块应该尽量在不修改原代码的情况下进行扩展。<br>　　在软件周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给代码引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码来实现变化。<br>　　开放封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是<strong>可维护、可扩展、可复用、灵活性好</strong>。开发人员应该仅对程序中呈现的频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。<br>　　注意事项：<br>　　1. 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的 public 方法。<br>　　2. 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类<br>　　3. 抽象层尽量保持稳定，一旦确定不允许修改。  </p>
<h2 id="二-单一职责原则"><a href="#二-单一职责原则" class="headerlink" title="二.单一职责原则"></a>二.单一职责原则</h2><p>&emsp;&emsp;概念：<strong>就一个类而言，应该仅有一个引起它变化的原因</strong>。<br>　　当我们在做编程的时候，很自然地会一个一个类加上各种各样的功能。这样意味着，<strong>无论任何需求要来，你都需要更改这个类</strong>，这样其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。如果一个类承担的职责过多，就等于把这些职责耦合起来，一个职责变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到很多意想不到的破坏。  </p>
<h2 id="三-依赖倒转原则"><a href="#三-依赖倒转原则" class="headerlink" title="三.依赖倒转原则"></a>三.依赖倒转原则</h2><p>&emsp;&emsp;概念：依赖倒转原则是程序要<strong>依赖于抽象接口，不要依赖于具体实现。简单的来说就是要求对抽象进行编程，不要对实现进行编程</strong>，这样就降低了客户与实现模块的耦合。<br>　　有时候为了代码复用，一般会把常用的代码写成函数或类库。这样开发新项目的时候直接用就行了。比如做项目的时候大多要访问数据库，所以我们把访问数据库的代码写成了函数。每次做项目去调用这些函数。那么问题来了，我们要做新项目的时候，发现业务逻辑高层模块都是一样的，但客户却希望使用不同的数据库或存储方式，这时就出现了麻烦。我们希望能再次利用这些高层模块，但是高层模块都是与低层的访问数据库绑定在一起，没办法复用这些高层的模块。所以不管是高层模块和底层模块都应该依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个更改都不用担心。<br>　　注意事项：<br>　　1. 高层模块不应该依赖于低层模块。两个都应该依赖抽象。<br>　　2. 抽象不应该依赖细节。细节应依赖于抽象。  </p>
<h2 id="四-迪米特法则（也称为最少知识原则）"><a href="#四-迪米特法则（也称为最少知识原则）" class="headerlink" title="四.迪米特法则（也称为最少知识原则）"></a>四.迪米特法则（也称为最少知识原则）</h2><p>&emsp;&emsp;概念：一个软件实体应当尽可能地少与其他实体发生相互作用。每一个软件单位对其他软件单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果有真的需要建立联系的，也希望能通过他的友元类来转达。因此，应用迪米特法则有可能造成一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互关系，这在一定程度上增加了系统的复杂度。  </p>
<h2 id="五-接口隔离原则"><a href="#五-接口隔离原则" class="headerlink" title="五.接口隔离原则"></a>五.接口隔离原则</h2><p>&emsp;&emsp;概念：客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。<br>　　接口隔离原则的核心定义，<strong>不出现臃肿的接口</strong>，但是“小”是有限度的，首先就是不能违反单一职责原则。  </p>
<h2 id="六-合成-聚合复用原则"><a href="#六-合成-聚合复用原则" class="headerlink" title="六.合成 / 聚合复用原则"></a>六.合成 / 聚合复用原则</h2><p>&emsp;&emsp;概念：合成 / 聚合复用原则经常又叫做合成复用原则，就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过这些对象的委派达到复用已有功能的目的。他的设计原则是：<strong>要尽量使用合成 / 聚合，尽量不要使用继承</strong>。  </p>
<h2 id="七-里氏代换原则"><a href="#七-里氏代换原则" class="headerlink" title="七.里氏代换原则"></a>七.里氏代换原则</h2><p>&emsp;&emsp;概念：里氏代换原则是面向对象设计的基本原则之一。即任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能被真正复用，而衍生类也能够在积累的基础上增加新的行为，里氏代换原则是对 “ 开 - 闭 ” 原则的补充。实现 “ 开 - 闭 ” 原则的关键步骤就是抽象化。在基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<br>　　当满足继承的时候，父类肯定存在非私有的成员，子类肯定是得到了父类的这些非私有成员（假设，父类的成员全部是私有的，那么子类没办法从父类继承任何成员，也就不存在继承的额概念了）。既然子类继承了父类的这些非私有成员，那么父类对象也就可以在子类对象中调用这些非私有成员。所以，子类对象可以替换父类对象的位置。<br>　　在里氏代换原则下，<strong>当需求有变化时，只需继承，而别的东西不会改变</strong>。由于里氏代换原则才使得开放封闭称为可能。这样使得子类在父类无需修改就可以扩展。  </p>
<h1 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h1><h2 id="1-开闭原则-Open-Closed-Principle-OCP"><a href="#1-开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="1. 开闭原则(Open-Closed Principle, OCP)"></a>1. 开闭原则(Open-Closed Principle, OCP)</h2><p>&emsp;&emsp;<strong>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：软件实体如同你租住的房子一般，你可以向里面添加东西，但是却很难修改这个房间。<strong>扩展开放</strong>就相当于你向租住的房子里放置家具，充实这个房子的功能。<strong>修改关闭</strong>就好比是房子的已经存在的物件，道理上你是没有这个改变他们的能力，实际是你在付出代价之后可以更改。<strong>但</strong>绝对的修改关闭是不可能的。就好比如水龙头、下水管道、灯泡等这些房子存在的基本物件损坏一样，不可避免的，所以需要提前做好准备避免。而在软件中避免就是<strong>创建抽象来隔离以后发生同类的变化</strong>。<br>&emsp;&emsp;<strong>开放-封闭原则，可以保证以前代码的正确性，因为没有修改以前代码，所以可以保证开发人员专注于将设计放在新扩展的代码上。</strong><br>&emsp;&emsp;简单的用一句经典的话来说：过去的事已成历史，是不可修改的，因为时光不可倒流，但现在或明天计划做什么，是可以自己决定（即扩展）的。  </p>
<h2 id="2-单一职责原则（Single-Responsibility-Principle）"><a href="#2-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="2. 单一职责原则（Single Responsibility Principle）"></a>2. 单一职责原则（Single Responsibility Principle）</h2><p>&emsp;&emsp;<strong>定义：即一个类只负责一项职责，应该仅有一个引起它变化的原因。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：你有一个带茶漏的茶杯（即类）用来喝茶和喝水（即两种职责）。有一天你想将奶茶倒入这个茶杯，但由于奶茶有珍珠，茶杯有茶漏，为了将珍珠也放入茶杯中，你将茶漏取出（改变了茶杯的功能），此时的茶杯就不能用来喝茶，所以该茶杯的职责也就被改变。为了避免这种改变你准备了茶杯和水杯，喝茶就用茶杯，喝水就用水杯。这就符合单一职责原则，一个类（杯子）只负责一种职责（喝茶或者喝水）。  </p>
<p>&emsp;&emsp;<strong>单一职责的优点</strong>：  </p>
<ol>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；  </li>
<li>提高类的可读性，提高系统的可维护性；  </li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。  </li>
</ol>
<p>&emsp;&emsp;<strong>需要说明的一点</strong>是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。  </p>
<h2 id="3-里氏替换原则（Liskov-Substitution-Principle）"><a href="#3-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle）"></a>3. 里氏替换原则（Liskov Substitution Principle）</h2><p>&emsp;&emsp;<strong>定义：子类型必须能够替换掉它们的父类型。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：如果父类型是鸟，子类型是企鹅，在生物学中企鹅归属于鸟，但是企鹅不会飞，在编程的世界中，企鹅就无法归属于鸟，即企鹅不能继承鸟类。<br>&emsp;&emsp;只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>&emsp;&emsp;正是有里氏代换原则，使得继承复用成为了可能。<strong>正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展，不然还谈什么扩展开放，修改关闭呢？</strong><br>&emsp;&emsp;<strong>里氏替换原则通俗的来讲就是</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。  </p>
<p>&emsp;&emsp;<strong>它包含以下4层含义：</strong>  </p>
<ol>
<li><strong>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</strong>  </li>
<li><strong>子类中可以增加自己特有的方法。</strong>  </li>
<li><strong>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</strong>  </li>
<li><strong>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</strong>  </li>
</ol>
<h2 id="4-迪米特法则（Law-Of-Demeter）"><a href="#4-迪米特法则（Law-Of-Demeter）" class="headerlink" title="4. 迪米特法则（Law Of Demeter）"></a>4. 迪米特法则（Law Of Demeter）</h2><p>&emsp;&emsp;<strong>定义：迪米特法则又叫最少知道原则，即一个对象应该对其他对象保持最少的了解。</strong><br>&emsp;&emsp;<strong>解释</strong>：迪米特法则其根本思想是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说信息的隐藏促进了软件的复用。<br>&emsp;&emsp;软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。而迪米特法则就是解决低耦合的方法。<br>&emsp;&emsp;<strong>个人解释</strong>：迪米特法则有个简单的方法叫做：只与直接的朋友通信。朋友关系在编程中就是耦合关系，耦合的方式就像现实世界中交朋友一样有多种，例如：依赖，关联，组合，聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。  </p>
<h2 id="5-依赖倒置原则（Dependence-Inversion-Principle）"><a href="#5-依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="5. 依赖倒置原则（Dependence Inversion Principle）"></a>5. 依赖倒置原则（Dependence Inversion Principle）</h2><p>&emsp;&emsp;<strong>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。中心思想是面向接口编程。</strong>  </p>
<p>&emsp;&emsp;在实际编程中，我们一般需要做到如下3点：  </p>
<ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。  </li>
<li>变量的声明类型尽量是抽象类或接口。  </li>
<li>使用继承时遵循里氏替换原则。  </li>
</ol>
<p>&emsp;&emsp;<strong>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</strong>  </p>
<h2 id="6-接口隔离原则（Interface-Segregation-Principle）"><a href="#6-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="6. 接口隔离原则（Interface Segregation Principle）"></a>6. 接口隔离原则（Interface Segregation Principle）</h2><p>&emsp;&emsp;<strong>定义：我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</strong><br>&emsp;&emsp;<strong>解释</strong>：在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。就好比术业有专攻一样。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。  </p>
<p>&emsp;&emsp;采用接口隔离原则对接口进行约束时，要注意以下几点：  </p>
<ol>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。  </li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。  </li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。  </li>
</ol>
<p>&emsp;&emsp;<strong>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</strong>  </p>
<h2 id="7-合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#7-合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="7. 合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)"></a>7. 合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)</h2><p>&emsp;&emsp;<strong>定义：尽量的使用合成和聚合，而不是继承关系达到复用的目的。换句话说，就是能用合成/聚合的地方，绝不用继承。</strong>  </p>
<p>&emsp;&emsp;<strong>为什么要尽量使用合成/聚合而不使用类继承？</strong>  </p>
<ol>
<li>对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现  </li>
<li>子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化  </li>
<li>当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换，这种依赖关系限制了灵活性，并最终限制了复用性。  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>/2019/08/30/DesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简介：<a href="https://www.cnblogs.com/www-zsl187-com/p/8834734.html" target="_blank" rel="noopener">https://www.cnblogs.com/www-zsl187-com/p/8834734.html</a><br>正文：<a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/DesignPatternSummery.html</a>  </p>
</blockquote>
<p>一、创建型模式<br>1、抽象工厂模式(Abstract factory pattern): 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类.<br>2、生成器模式(Builder pattern): 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.<br>3、工厂模式(factory method pattern): 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.<br>4、原型模式(prototype pattern): 当创建给定类的实例过程很昂贵或很复杂时, 就使用原型模式.<br>5、单例模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点.<br>6、多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题.<br>二、结构型模式<br>1、适配器模式(Adapter pattern): 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承.<br>2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变.<br>3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合.<br>4、装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案.<br>5、外观模式(facade pattern): 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用.<br>6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多”虚拟实例”, 就使用蝇量模式.<br>7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问.<br>三、行为型模式<br>1、责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象.<br>2、命令模式(Command pattern): 将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作.<br>3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器.<br>4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示.<br>5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式.<br>6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式.<br>7、观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新.<br>8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类.<br>9、策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户.<br>10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤.<br>11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.  </p>
<a id="more"></a>

<h1 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h1><p>&emsp;&emsp;创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。第一，它们都将系统使用哪些具体类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和组织的。创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。  </p>
<ul>
<li>单例模式：解决的是实例化对象的个数的问题，比如抽象工厂中的工厂、对象池等，除了Singleton之外，其他创建型模式解决的都是 new 所带来的耦合关系。  </li>
<li>抽象工厂：创建一系列相互依赖对象，并能在运行时改变系列。  </li>
<li>工厂方法：创建单个对象，在Abstract Factory有使用到。  </li>
<li>原型模式：通过拷贝原型来创建新的对象。  </li>
</ul>
<p>&emsp;&emsp;工厂方法、抽象工厂、建造者都需要一个额外的工厂类来负责实例化“一个对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。<br>&emsp;&emsp;下面详细介绍下它们。  </p>
<h2 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1  单例模式"></a>1.1  单例模式</h2><p>&emsp;&emsp;单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：  </p>
<ul>
<li>类只有一个实例。问：如何保证呢？答：通过私有构造函数来保证类外部不能对类进行实例化  </li>
<li>提供一个全局的访问点。问：如何实现呢？答：创建一个返回该类对象的静态方法  </li>
</ul>
<p>&emsp;&emsp;单例模式的结构图如下所示：  </p>
<p><img src="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h2><p>&emsp;&emsp;工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：  </p>
<ul>
<li>定义一个工厂接口。问：如何实现呢？答：声明一个工厂抽象类  </li>
<li>由其具体子类创建对象。问：如何去实现呢？答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。  </li>
</ul>
<p>&emsp;&emsp;其具体的UML结构图如下所示：  </p>
<p><img src="%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<p>&emsp;&emsp;在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。  </p>
<h2 id="1-3-抽象工厂模式"><a href="#1-3-抽象工厂模式" class="headerlink" title="1.3 抽象工厂模式"></a>1.3 抽象工厂模式</h2><p>&emsp;&emsp;抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，使得客户端可以在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象，强调的是”系列对象“的变化。其实现要点有：  </p>
<ul>
<li>提供一系列对象的接口。问：如何去实现呢？答：提供多个产品的抽象接口  </li>
<li>创建多个产品族中的多个产品对象。问：如何做到呢？答：每个具体工厂创建一个产品族中的多个产品对象，多个具体工厂就可以创建多个产品族中的多个对象了。  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="1-4-建造者模式"><a href="#1-4-建造者模式" class="headerlink" title="1.4 建造者模式"></a>1.4 建造者模式</h2><p>&emsp;&emsp;建造者模式指的是将一个产品的内部表示与产品的构造过程分割开来，从而可以使一个建造过程生成具体不同的内部表示的产品对象。强调的是产品的构造过程。其实现要点有：  </p>
<ul>
<li>将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="1-5-原型工厂模式"><a href="#1-5-原型工厂模式" class="headerlink" title="1.5 原型工厂模式"></a>1.5 原型工厂模式</h2><p>&emsp;&emsp;原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。其实现要点有：  </p>
<ul>
<li>给出一个原型对象。问：如何办到呢？答：很简单嘛，直接给出一个原型类就好了。  </li>
<li>通过复制的方法来创建同类型对象。问：又是如何实现呢？答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E5%8E%9F%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h1 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h1><p>&emsp;&emsp;结构型模式，顾名思义讨论的是类和对象的结构 ，主要用来处理类或对象的组合。它包括两种类型，一是类结构型模式，指的是采用继承机制来组合接口或实现；二是对象结构型模式，指的是通过组合对象的方式来实现新的功能。它包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。  </p>
<ul>
<li>适配器模式注重转换接口，将不吻合的接口适配对接   </li>
<li>桥接模式注重分离接口与其实现，支持多维度变化   </li>
<li>组合模式注重统一接口，将“一对多”的关系转化为“一对一”的关系   </li>
<li>装饰者模式注重稳定接口，在此前提下为对象扩展功能   </li>
<li>外观模式注重简化接口，简化组件系统与外部客户程序的依赖关系   </li>
<li>享元模式注重保留接口，在内部使用共享技术对对象存储进行优化   </li>
<li>代理模式注重假借接口，增加间接层来实现灵活控制  </li>
</ul>
<h2 id="2-1-适配器模式"><a href="#2-1-适配器模式" class="headerlink" title="2.1 适配器模式"></a>2.1 适配器模式</h2><p>&emsp;&emsp;适配器模式意在转换接口，它能够使原本不能在一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如DataAdapter类就应用了适配器模式。适配器模式包括类适配器模式和对象适配器模式，具体结构如下图所示，左边是类适配器模式，右边是对象适配器模式。  </p>
<p><img src="%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt=" "></p>
<h2 id="2-2-桥接模式"><a href="#2-2-桥接模式" class="headerlink" title="2.2 桥接模式"></a>2.2 桥接模式</h2><p>&emsp;&emsp;桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化，桥接模式的结构图如下所示。  </p>
<p><img src="%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-3-装饰者模式"><a href="#2-3-装饰者模式" class="headerlink" title="2.3 装饰者模式"></a>2.3 装饰者模式</h2><p>&emsp;&emsp;装饰者模式又称包装（Wrapper）模式，它可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。具体的结构图如下所示。  </p>
<p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="2-4-组合模式"><a href="#2-4-组合模式" class="headerlink" title="2.4 组合模式"></a>2.4 组合模式</h2><p>&emsp;&emsp;组合模式又称为部分—整体模式。组合模式将对象组合成树形结构，用来表示整体与部分的关系。组合模式使得客户端将单个对象和组合对象同等对待。如在.NET中WinForm中的控件，TextBox、Label等简单控件继承与Control类，同时GroupBox这样的组合控件也是继承于Control类。组合模式的具体结构图如下所示。  </p>
<p><img src="%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-5-外观模式"><a href="#2-5-外观模式" class="headerlink" title="2.5 外观模式"></a>2.5 外观模式</h2><p>&emsp;&emsp;在系统中，客户端经常需要与多个子系统进行交互，这样导致客户端会随着子系统的变化而变化，此时可以使用外观模式把客户端与各个子系统解耦。外观模式指的是为子系统中的一组接口提供一个一致的门面，它提供了一个高层接口，这个接口使子系统更加容易使用。如电信的客户专员，你可以让客户专员来完成冲话费，修改套餐等业务，而不需要自己去与各个子系统进行交互。具体类结构图如下所示：  </p>
<p><img src="%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-6-享元模式"><a href="#2-6-享元模式" class="headerlink" title="2.6 享元模式"></a>2.6 享元模式</h2><p>&emsp;&emsp;在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。<br>&emsp;&emsp;享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，String类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。更多内容参考博文：<a href="http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html" target="_blank" rel="noopener">http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html</a> 。享元模式的具体结构图如下所示。  </p>
<p><img src="%E4%BA%A8%E5%85%83%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-7-代理模式"><a href="#2-7-代理模式" class="headerlink" title="2.7 代理模式"></a>2.7 代理模式</h2><p>&emsp;&emsp;在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。<br>&emsp;&emsp;代理模式指的是给某一个对象提供一个代理，并由代理对象控制对原对象的访问。具体的结构图如下所示。  </p>
<p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<p>&emsp;&emsp;注：外观模式、适配器模式和代理模式区别？<br>&emsp;&emsp;解答：这三个模式的相同之处是，它们都是作为客户端与真实被使用的类或系统之间的一个中间层，起到让客户端间接调用真实类的作用，不同之处在于，所应用的场合和意图不同。<br>&emsp;&emsp;代理模式与外观模式主要区别在于，代理对象无法直接访问对象，只能由代理对象提供访问，而外观对象提供对各个子系统简化访问调用接口，而适配器模式则不需要虚构一个代理者，目的是复用原有的接口。外观模式是定义新的接口，而适配器则是复用一个原有的接口。<br>&emsp;&emsp;另外，它们应用设计的不同阶段，外观模式用于设计的前期，因为系统需要前期就需要依赖于外观，而适配器应用于设计完成之后，当发现设计完成的类无法协同工作时，可以采用适配器模式。然而很多情况下在设计初期就要考虑适配器模式的使用，如涉及到大量第三方应用接口的情况；代理模式是模式完成后，想以服务的方式提供给其他客户端进行调用，此时其他客户端可以使用代理模式来对模块进行访问。<br>&emsp;&emsp;总之，代理模式提供与真实类一致的接口，旨在用来代理类来访问真实的类，外观模式旨在简化接口，适配器模式旨在转换接口。  </p>
<h1 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h1><p>&emsp;&emsp;行为型模式是对在不同对象之间划分责任和算法的抽象化。行为模式不仅仅关于类和对象，还关于它们之间的相互作用。行为型模式又分为类的行为模式和对象的行为模式两种。  </p>
<ul>
<li>类的行为模式——使用继承关系在几个类之间分配行为。  </li>
<li>对象的行为模式——使用对象聚合的方式来分配行为。  </li>
</ul>
<p>&emsp;&emsp;行为型模式包括11种模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、状态模式、策略模式、责任链模式、访问者模式、解释器模式和备忘录模式。  </p>
<ul>
<li>模板方法模式：封装算法结构，定义算法骨架，支持算法子步骤变化。  </li>
<li>命令模式：注重将请求封装为对象，支持请求的变化，通过将一组行为抽象为对象，实现行为请求者和行为实现者之间的解耦。  </li>
<li>迭代器模式：注重封装特定领域变化，支持集合的变化，屏蔽集合对象内部复杂结构，提供客户程序对它的透明遍历。  </li>
<li>观察者模式：注重封装对象通知，支持通信对象的变化，实现对象状态改变，通知依赖它的对象并更新。  </li>
<li>中介者模式：注重封装对象间的交互，通过封装一系列对象之间的复杂交互，使他们不需要显式相互引用，实现解耦。  </li>
<li>状态模式：注重封装与状态相关的行为，支持状态的变化，通过封装对象状态，从而在其内部状态改变时改变它的行为。  </li>
<li>策略模式：注重封装算法，支持算法的变化，通过封装一系列算法，从而可以随时独立于客户替换算法。  </li>
<li>责任链模式：注重封装对象责任，支持责任的变化，通过动态构建职责链，实现事务处理。  </li>
<li>访问者模式：注重封装对象操作变化，支持在运行时为类结构添加新的操作，在类层次结构中，在不改变各类的前提下定义作用于这些类实例的新的操作。  </li>
<li>备忘录模式：注重封装对象状态变化，支持状态保存、恢复。  </li>
<li>解释器模式：注重封装特定领域变化，支持领域问题的频繁变化，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。  </li>
</ul>
<h2 id="3-1-模板方法模式"><a href="#3-1-模板方法模式" class="headerlink" title="3.1 模板方法模式"></a>3.1 模板方法模式</h2><p>&emsp;&emsp;在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。<br>&emsp;&emsp;模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。具体的结构图如下所示（以生活中做菜为例子实现的模板方法结构图）。  </p>
<p><img src="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="以生活中做菜为例子实现的模板方法结构图"></p>
<h2 id="3-2-命令模式"><a href="#3-2-命令模式" class="headerlink" title="3.2 命令模式"></a>3.2 命令模式</h2><p>&emsp;&emsp;命令模式属于对象的行为模式，命令模式把一个请求或操作封装到一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。具体的结构图如下所示。  </p>
<p><img src="%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="3-3-迭代器模式"><a href="#3-3-迭代器模式" class="headerlink" title="3.3 迭代器模式"></a>3.3 迭代器模式</h2><p>&emsp;&emsp;迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。<br>&emsp;&emsp;迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。具体的结构图如下所示。  </p>
<p><img src="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-4-观察者模式"><a href="#3-4-观察者模式" class="headerlink" title="3.4 观察者模式"></a>3.4 观察者模式</h2><p>&emsp;&emsp;在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。<br>&emsp;&emsp;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。具体结构图如下所示：  </p>
<p><img src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-5-中介者模式"><a href="#3-5-中介者模式" class="headerlink" title="3.5 中介者模式"></a>3.5 中介者模式</h2><p>&emsp;&emsp;在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。<br>&emsp;&emsp;中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。具体的结构图如下所示：  </p>
<p><img src="%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-6-状态模式"><a href="#3-6-状态模式" class="headerlink" title="3.6 状态模式"></a>3.6 状态模式</h2><p>&emsp;&emsp;每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。<br>&emsp;&emsp;状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。具体的结构图如下所示：  </p>
<p><img src="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-7-策略模式"><a href="#3-7-策略模式" class="headerlink" title="3.7 策略模式"></a>3.7 策略模式</h2><p>&emsp;&emsp;在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。<br>&emsp;&emsp;策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。下面是策略模式的结构图：  </p>
<p><img src="%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt=" ">
　　</p>
<h2 id="3-8-责任链模式"><a href="#3-8-责任链模式" class="headerlink" title="3.8 责任链模式"></a>3.8 责任链模式</h2><p>&emsp;&emsp;在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能需要请求技术总监的批准。<br>&emsp;&emsp;责任链模式——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。具体结构图如下所示：  </p>
<p><img src="%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-9-访问者模式"><a href="#3-9-访问者模式" class="headerlink" title="3.9 访问者模式"></a>3.9 访问者模式</h2><p>&emsp;&emsp;访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。具体结构图如下所示：  </p>
<p><img src="%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-10-备忘录模式"><a href="#3-10-备忘录模式" class="headerlink" title="3.10 备忘录模式"></a>3.10 备忘录模式</h2><p>&emsp;&emsp;生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。具体的结构图如下所示：  </p>
<p><img src="%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-11-解释器模式"><a href="#3-11-解释器模式" class="headerlink" title="3.11 解释器模式"></a>3.11 解释器模式</h2><p>&emsp;&emsp;解释器模式是一个比较少用的模式，所以我自己也没有对该模式进行深入研究，在生活中，英汉词典的作用就是实现英文和中文互译，这就是解释器模式的应用。<br>&emsp;&emsp;解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。具体的结构图如下所示：  </p>
<p><img src="%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[More Effective C# 书目录]]></title>
      <url>/2019/08/30/MoreEffectiveCSharpContents/</url>
      <content type="html"><![CDATA[<blockquote>
<p>书名：More Effective C# : 改善 C# 代码的 50 个有效方法（原书第 2 版）<br>作者：[ 美 ] 比尔·瓦格纳 ( Bill Wagner )<br>译者：爱飞翔<br>出版：机械工业出版社  </p>
</blockquote>
<p>适用于 <strong>C# 7.0</strong></p>
<a id="more"></a>

<hr>
<h2 id="第1章-处理各种类型的数据"><a href="#第1章-处理各种类型的数据" class="headerlink" title="第1章 处理各种类型的数据"></a>第1章 处理各种类型的数据</h2><h3 id="第1条：使用属性而不是可直接访问的数据成员"><a href="#第1条：使用属性而不是可直接访问的数据成员" class="headerlink" title="第1条：使用属性而不是可直接访问的数据成员"></a>第1条：使用属性而不是可直接访问的数据成员</h3><h3 id="第2条：尽量采用隐式属性来表示可变的数据"><a href="#第2条：尽量采用隐式属性来表示可变的数据" class="headerlink" title="第2条：尽量采用隐式属性来表示可变的数据"></a>第2条：尽量采用隐式属性来表示可变的数据</h3><h3 id="第3条：尽量把值类型设计成不可变的类型"><a href="#第3条：尽量把值类型设计成不可变的类型" class="headerlink" title="第3条：尽量把值类型设计成不可变的类型"></a>第3条：尽量把值类型设计成不可变的类型</h3><h3 id="第4条：注意值类型与引用类型之间的区别"><a href="#第4条：注意值类型与引用类型之间的区别" class="headerlink" title="第4条：注意值类型与引用类型之间的区别"></a>第4条：注意值类型与引用类型之间的区别</h3><h3 id="第5条：确保-0-可以当成值类型的有效状态使用"><a href="#第5条：确保-0-可以当成值类型的有效状态使用" class="headerlink" title="第5条：确保 0 可以当成值类型的有效状态使用"></a>第5条：确保 0 可以当成值类型的有效状态使用</h3><h3 id="第6条：确保属性能够像数据那样运用"><a href="#第6条：确保属性能够像数据那样运用" class="headerlink" title="第6条：确保属性能够像数据那样运用"></a>第6条：确保属性能够像数据那样运用</h3><h3 id="第7条：用元组来限制类型的作用范围"><a href="#第7条：用元组来限制类型的作用范围" class="headerlink" title="第7条：用元组来限制类型的作用范围"></a>第7条：用元组来限制类型的作用范围</h3><h3 id="第8条：在匿名类型中定义局部函数"><a href="#第8条：在匿名类型中定义局部函数" class="headerlink" title="第8条：在匿名类型中定义局部函数"></a>第8条：在匿名类型中定义局部函数</h3><h3 id="第9条：理解相等的不同概念及它们之间的关系"><a href="#第9条：理解相等的不同概念及它们之间的关系" class="headerlink" title="第9条：理解相等的不同概念及它们之间的关系"></a>第9条：理解相等的不同概念及它们之间的关系</h3><h3 id="第10条：留意-GetHashCode-方法的使用陷阱"><a href="#第10条：留意-GetHashCode-方法的使用陷阱" class="headerlink" title="第10条：留意 GetHashCode() 方法的使用陷阱"></a>第10条：留意 GetHashCode() 方法的使用陷阱</h3><hr>
<h2 id="第2章-API-设计"><a href="#第2章-API-设计" class="headerlink" title="第2章 API 设计"></a>第2章 API 设计</h2><h3 id="第11条：不要在-API-中提供转换运算符"><a href="#第11条：不要在-API-中提供转换运算符" class="headerlink" title="第11条：不要在 API 中提供转换运算符"></a>第11条：不要在 API 中提供转换运算符</h3><h3 id="第12条：尽量用可选参数来取代方法重载"><a href="#第12条：尽量用可选参数来取代方法重载" class="headerlink" title="第12条：尽量用可选参数来取代方法重载"></a>第12条：尽量用可选参数来取代方法重载</h3><h3 id="第13条：尽量缩减类型的可见范围"><a href="#第13条：尽量缩减类型的可见范围" class="headerlink" title="第13条：尽量缩减类型的可见范围"></a>第13条：尽量缩减类型的可见范围</h3><h3 id="第14条：优先考虑定义并实现接口，而不是继承"><a href="#第14条：优先考虑定义并实现接口，而不是继承" class="headerlink" title="第14条：优先考虑定义并实现接口，而不是继承"></a>第14条：优先考虑定义并实现接口，而不是继承</h3><h3 id="第15条：理解接口方法与虚方法之间的区别"><a href="#第15条：理解接口方法与虚方法之间的区别" class="headerlink" title="第15条：理解接口方法与虚方法之间的区别"></a>第15条：理解接口方法与虚方法之间的区别</h3><h3 id="第16条：用-Event-模式来实现通知功能"><a href="#第16条：用-Event-模式来实现通知功能" class="headerlink" title="第16条：用 Event 模式来实现通知功能"></a>第16条：用 Event 模式来实现通知功能</h3><h3 id="第17条：不要把类的内部对象通过引用返回给外界"><a href="#第17条：不要把类的内部对象通过引用返回给外界" class="headerlink" title="第17条：不要把类的内部对象通过引用返回给外界"></a>第17条：不要把类的内部对象通过引用返回给外界</h3><h3 id="第18条：优先考虑重写相关的方法，而不是创建事件处理程序"><a href="#第18条：优先考虑重写相关的方法，而不是创建事件处理程序" class="headerlink" title="第18条：优先考虑重写相关的方法，而不是创建事件处理程序"></a>第18条：优先考虑重写相关的方法，而不是创建事件处理程序</h3><h3 id="第19条：不要重载基类中定义的方法"><a href="#第19条：不要重载基类中定义的方法" class="headerlink" title="第19条：不要重载基类中定义的方法"></a>第19条：不要重载基类中定义的方法</h3><h3 id="第20条：了解事件机制为何会提升对象在运行期的耦合程度"><a href="#第20条：了解事件机制为何会提升对象在运行期的耦合程度" class="headerlink" title="第20条：了解事件机制为何会提升对象在运行期的耦合程度"></a>第20条：了解事件机制为何会提升对象在运行期的耦合程度</h3><h3 id="第21条：不要把事件声明成-virtual"><a href="#第21条：不要把事件声明成-virtual" class="headerlink" title="第21条：不要把事件声明成 virtual"></a>第21条：不要把事件声明成 virtual</h3><h3 id="第22条：尽量把重载方法创建得清晰、简洁而完备"><a href="#第22条：尽量把重载方法创建得清晰、简洁而完备" class="headerlink" title="第22条：尽量把重载方法创建得清晰、简洁而完备"></a>第22条：尽量把重载方法创建得清晰、简洁而完备</h3><h3 id="第23条：让-partial-类的构造函数、mutator-方法和事件处理程序调用适当的-partial-方法"><a href="#第23条：让-partial-类的构造函数、mutator-方法和事件处理程序调用适当的-partial-方法" class="headerlink" title="第23条：让 partial 类的构造函数、mutator 方法和事件处理程序调用适当的 partial 方法"></a>第23条：让 partial 类的构造函数、mutator 方法和事件处理程序调用适当的 partial 方法</h3><h3 id="第24条：尽量不要实现-ICloneable-接口，以便留出更多的设计空间"><a href="#第24条：尽量不要实现-ICloneable-接口，以便留出更多的设计空间" class="headerlink" title="第24条：尽量不要实现 ICloneable 接口，以便留出更多的设计空间"></a>第24条：尽量不要实现 ICloneable 接口，以便留出更多的设计空间</h3><h3 id="第25条：数组类型的参数应该用-params-加以修饰"><a href="#第25条：数组类型的参数应该用-params-加以修饰" class="headerlink" title="第25条：数组类型的参数应该用 params 加以修饰"></a>第25条：数组类型的参数应该用 params 加以修饰</h3><h3 id="第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错"><a href="#第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错" class="headerlink" title="第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错"></a>第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错</h3><hr>
<h2 id="第3章-基于任务的异步编程"><a href="#第3章-基于任务的异步编程" class="headerlink" title="第3章 基于任务的异步编程"></a>第3章 基于任务的异步编程</h2><h3 id="第27条：使用异步方法执行异步工作"><a href="#第27条：使用异步方法执行异步工作" class="headerlink" title="第27条：使用异步方法执行异步工作"></a>第27条：使用异步方法执行异步工作</h3><h3 id="第28条：不要编写返回值类型为-void-的异步方法"><a href="#第28条：不要编写返回值类型为-void-的异步方法" class="headerlink" title="第28条：不要编写返回值类型为 void 的异步方法"></a>第28条：不要编写返回值类型为 void 的异步方法</h3><h3 id="第29条：不要把同步方法与异步方法组合起来使用"><a href="#第29条：不要把同步方法与异步方法组合起来使用" class="headerlink" title="第29条：不要把同步方法与异步方法组合起来使用"></a>第29条：不要把同步方法与异步方法组合起来使用</h3><h3 id="第30条：使用异步方法以避免线程分配和上下文切换"><a href="#第30条：使用异步方法以避免线程分配和上下文切换" class="headerlink" title="第30条：使用异步方法以避免线程分配和上下文切换"></a>第30条：使用异步方法以避免线程分配和上下文切换</h3><h3 id="第31条：避免不必要的上下文编组"><a href="#第31条：避免不必要的上下文编组" class="headerlink" title="第31条：避免不必要的上下文编组"></a>第31条：避免不必要的上下文编组</h3><h3 id="第32条：通过-Task-对象来安排异步工作"><a href="#第32条：通过-Task-对象来安排异步工作" class="headerlink" title="第32条：通过 Task 对象来安排异步工作"></a>第32条：通过 Task 对象来安排异步工作</h3><h3 id="第33条：考虑实现任务取消协议"><a href="#第33条：考虑实现任务取消协议" class="headerlink" title="第33条：考虑实现任务取消协议"></a>第33条：考虑实现任务取消协议</h3><h3 id="第34条：缓存泛型异步方法的返回值"><a href="#第34条：缓存泛型异步方法的返回值" class="headerlink" title="第34条：缓存泛型异步方法的返回值"></a>第34条：缓存泛型异步方法的返回值</h3><hr>
<h2 id="第4章-并行处理"><a href="#第4章-并行处理" class="headerlink" title="第4章 并行处理"></a>第4章 并行处理</h2><h3 id="第35条：了解-PLINQ-是怎样实现并行算法的"><a href="#第35条：了解-PLINQ-是怎样实现并行算法的" class="headerlink" title="第35条：了解 PLINQ 是怎样实现并行算法的"></a>第35条：了解 PLINQ 是怎样实现并行算法的</h3><h3 id="第36条：编写并行算法时要考虑异常状况"><a href="#第36条：编写并行算法时要考虑异常状况" class="headerlink" title="第36条：编写并行算法时要考虑异常状况"></a>第36条：编写并行算法时要考虑异常状况</h3><h3 id="第37条：优先使用线程池而不是创建新的线程"><a href="#第37条：优先使用线程池而不是创建新的线程" class="headerlink" title="第37条：优先使用线程池而不是创建新的线程"></a>第37条：优先使用线程池而不是创建新的线程</h3><h3 id="第38条：考虑使用-BackgroundWorker-在线程之间通信"><a href="#第38条：考虑使用-BackgroundWorker-在线程之间通信" class="headerlink" title="第38条：考虑使用 BackgroundWorker 在线程之间通信"></a>第38条：考虑使用 BackgroundWorker 在线程之间通信</h3><h3 id="第39条：学会在-XAML-环境下执行跨线程调用"><a href="#第39条：学会在-XAML-环境下执行跨线程调用" class="headerlink" title="第39条：学会在 XAML 环境下执行跨线程调用"></a>第39条：学会在 XAML 环境下执行跨线程调用</h3><h3 id="第40条：首先考虑用-lock-实现同步"><a href="#第40条：首先考虑用-lock-实现同步" class="headerlink" title="第40条：首先考虑用 lock() 实现同步"></a>第40条：首先考虑用 lock() 实现同步</h3><h3 id="第41条：尽量缩减锁定范围"><a href="#第41条：尽量缩减锁定范围" class="headerlink" title="第41条：尽量缩减锁定范围"></a>第41条：尽量缩减锁定范围</h3><h3 id="第42条：不要在加了锁的区域内调用未知的方法"><a href="#第42条：不要在加了锁的区域内调用未知的方法" class="headerlink" title="第42条：不要在加了锁的区域内调用未知的方法"></a>第42条：不要在加了锁的区域内调用未知的方法</h3><hr>
<h2 id="第5章-动态编程"><a href="#第5章-动态编程" class="headerlink" title="第5章 动态编程"></a>第5章 动态编程</h2><h3 id="第43条：了解动态编程的优点及缺点"><a href="#第43条：了解动态编程的优点及缺点" class="headerlink" title="第43条：了解动态编程的优点及缺点"></a>第43条：了解动态编程的优点及缺点</h3><h3 id="第44条：通过动态编程技术更好地运用泛型参数的运行期类型"><a href="#第44条：通过动态编程技术更好地运用泛型参数的运行期类型" class="headerlink" title="第44条：通过动态编程技术更好地运用泛型参数的运行期类型"></a>第44条：通过动态编程技术更好地运用泛型参数的运行期类型</h3><h3 id="第45条：使用-DynamicObject-和-IDynamicMetaObjectProvider-实现数据驱动的动态类型"><a href="#第45条：使用-DynamicObject-和-IDynamicMetaObjectProvider-实现数据驱动的动态类型" class="headerlink" title="第45条：使用 DynamicObject 和 IDynamicMetaObjectProvider 实现数据驱动的动态类型"></a>第45条：使用 DynamicObject 和 IDynamicMetaObjectProvider 实现数据驱动的动态类型</h3><h3 id="第46条：学会正确使用-Expression-API"><a href="#第46条：学会正确使用-Expression-API" class="headerlink" title="第46条：学会正确使用 Expression API"></a>第46条：学会正确使用 Expression API</h3><h3 id="第47条：尽量减少公有-API-中的动态对象"><a href="#第47条：尽量减少公有-API-中的动态对象" class="headerlink" title="第47条：尽量减少公有 API 中的动态对象"></a>第47条：尽量减少公有 API 中的动态对象</h3><hr>
<h2 id="第6章-加入全球-C-社区"><a href="#第6章-加入全球-C-社区" class="headerlink" title="第6章 加入全球 C# 社区"></a>第6章 加入全球 C# 社区</h2><h3 id="第48条：最流行的写法不一定最合适"><a href="#第48条：最流行的写法不一定最合适" class="headerlink" title="第48条：最流行的写法不一定最合适"></a>第48条：最流行的写法不一定最合适</h3><h3 id="第49条：与大家一起制定规范并编写代码"><a href="#第49条：与大家一起制定规范并编写代码" class="headerlink" title="第49条：与大家一起制定规范并编写代码"></a>第49条：与大家一起制定规范并编写代码</h3><h3 id="第50条：考虑用分析器自动检查代码质量"><a href="#第50条：考虑用分析器自动检查代码质量" class="headerlink" title="第50条：考虑用分析器自动检查代码质量"></a>第50条：考虑用分析器自动检查代码质量</h3><hr>
<h2 id="中英文词汇对照表"><a href="#中英文词汇对照表" class="headerlink" title="中英文词汇对照表"></a>中英文词汇对照表</h2>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective C# 书目录]]></title>
      <url>/2019/08/30/EffectiveCSharpContents/</url>
      <content type="html"><![CDATA[<blockquote>
<p>书名：Effective C# : 改善 C# 代码的 50 个有效方法（原书第 3 版）<br>作者：[ 美 ] 比尔·瓦格纳 ( Bill Wagner )<br>译者：爱飞翔<br>出版：机械工业出版社  </p>
</blockquote>
<p>适用于 <strong>C# 6.0</strong></p>
<a id="more"></a>

<hr>
<h2 id="第1章-C-语言的编程习惯"><a href="#第1章-C-语言的编程习惯" class="headerlink" title="第1章 C# 语言的编程习惯"></a>第1章 C# 语言的编程习惯</h2><h3 id="第1条：优先使用隐式类型的局部变量"><a href="#第1条：优先使用隐式类型的局部变量" class="headerlink" title="第1条：优先使用隐式类型的局部变量"></a>第1条：优先使用隐式类型的局部变量</h3><h3 id="第2条：考虑用-readonly-代替-const"><a href="#第2条：考虑用-readonly-代替-const" class="headerlink" title="第2条：考虑用 readonly 代替 const"></a>第2条：考虑用 readonly 代替 const</h3><h3 id="第3条：优先考虑-is-或-as-运算符，尽量少用强制类型转换"><a href="#第3条：优先考虑-is-或-as-运算符，尽量少用强制类型转换" class="headerlink" title="第3条：优先考虑 is 或 as 运算符，尽量少用强制类型转换"></a>第3条：优先考虑 is 或 as 运算符，尽量少用强制类型转换</h3><h3 id="第4条：用内插字符串取代-string-Format"><a href="#第4条：用内插字符串取代-string-Format" class="headerlink" title="第4条：用内插字符串取代 string.Format()"></a>第4条：用内插字符串取代 string.Format()</h3><h3 id="第5条：用-FormattableString-取代专门为特定区域而写的字符串"><a href="#第5条：用-FormattableString-取代专门为特定区域而写的字符串" class="headerlink" title="第5条：用 FormattableString 取代专门为特定区域而写的字符串"></a>第5条：用 FormattableString 取代专门为特定区域而写的字符串</h3><h3 id="第6条：不要用表示符号名称的硬字符串来调用-API"><a href="#第6条：不要用表示符号名称的硬字符串来调用-API" class="headerlink" title="第6条：不要用表示符号名称的硬字符串来调用 API"></a>第6条：不要用表示符号名称的硬字符串来调用 API</h3><h3 id="第7条：用委托表示回调"><a href="#第7条：用委托表示回调" class="headerlink" title="第7条：用委托表示回调"></a>第7条：用委托表示回调</h3><h3 id="第8条：用-null-条件运算符调用事件处理程序"><a href="#第8条：用-null-条件运算符调用事件处理程序" class="headerlink" title="第8条：用 null 条件运算符调用事件处理程序"></a>第8条：用 null 条件运算符调用事件处理程序</h3><h3 id="第9条：尽量避免装箱与取消装箱这两种操作"><a href="#第9条：尽量避免装箱与取消装箱这两种操作" class="headerlink" title="第9条：尽量避免装箱与取消装箱这两种操作"></a>第9条：尽量避免装箱与取消装箱这两种操作</h3><h3 id="第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用-new-修饰符"><a href="#第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用-new-修饰符" class="headerlink" title="第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用 new 修饰符"></a>第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用 new 修饰符</h3><hr>
<h2 id="第2章-NET-的资源管理"><a href="#第2章-NET-的资源管理" class="headerlink" title="第2章 .NET 的资源管理"></a>第2章 .NET 的资源管理</h2><h3 id="第11条：理解并善用-NET-的资源管理机制"><a href="#第11条：理解并善用-NET-的资源管理机制" class="headerlink" title="第11条：理解并善用 .NET 的资源管理机制"></a>第11条：理解并善用 .NET 的资源管理机制</h3><h3 id="第12条：声明字段时，尽量直接为其设定初始值"><a href="#第12条：声明字段时，尽量直接为其设定初始值" class="headerlink" title="第12条：声明字段时，尽量直接为其设定初始值"></a>第12条：声明字段时，尽量直接为其设定初始值</h3><h3 id="第13条：用适当的方式初始化类中的静态成员"><a href="#第13条：用适当的方式初始化类中的静态成员" class="headerlink" title="第13条：用适当的方式初始化类中的静态成员"></a>第13条：用适当的方式初始化类中的静态成员</h3><h3 id="第14条：尽量删减重复的初始化逻辑"><a href="#第14条：尽量删减重复的初始化逻辑" class="headerlink" title="第14条：尽量删减重复的初始化逻辑"></a>第14条：尽量删减重复的初始化逻辑</h3><h3 id="第15条：不要创建无谓的对象"><a href="#第15条：不要创建无谓的对象" class="headerlink" title="第15条：不要创建无谓的对象"></a>第15条：不要创建无谓的对象</h3><h3 id="第16条：绝对不要在构造函数里面调用虚函数"><a href="#第16条：绝对不要在构造函数里面调用虚函数" class="headerlink" title="第16条：绝对不要在构造函数里面调用虚函数"></a>第16条：绝对不要在构造函数里面调用虚函数</h3><h3 id="第17条：实现标准的-dispose-模式"><a href="#第17条：实现标准的-dispose-模式" class="headerlink" title="第17条：实现标准的 dispose 模式"></a>第17条：实现标准的 dispose 模式</h3><hr>
<h2 id="第3章-合理地运用泛型"><a href="#第3章-合理地运用泛型" class="headerlink" title="第3章 合理地运用泛型"></a>第3章 合理地运用泛型</h2><h3 id="第18条：只定义刚好够用的约束条件"><a href="#第18条：只定义刚好够用的约束条件" class="headerlink" title="第18条：只定义刚好够用的约束条件"></a>第18条：只定义刚好够用的约束条件</h3><h3 id="第19条：通过运行期类型检查实现特定的泛型算法"><a href="#第19条：通过运行期类型检查实现特定的泛型算法" class="headerlink" title="第19条：通过运行期类型检查实现特定的泛型算法"></a>第19条：通过运行期类型检查实现特定的泛型算法</h3><h3 id="第20条：通过-IComparable-lt-T-gt-及-IComparer-lt-T-gt-定义顺序关系"><a href="#第20条：通过-IComparable-lt-T-gt-及-IComparer-lt-T-gt-定义顺序关系" class="headerlink" title="第20条：通过 IComparable&lt;T&gt; 及 IComparer&lt;T&gt; 定义顺序关系"></a>第20条：通过 IComparable&lt;T&gt; 及 IComparer&lt;T&gt; 定义顺序关系</h3><h3 id="第21条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持"><a href="#第21条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持" class="headerlink" title="第21条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持"></a>第21条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持</h3><h3 id="第22条：考虑支持泛型协变与逆变"><a href="#第22条：考虑支持泛型协变与逆变" class="headerlink" title="第22条：考虑支持泛型协变与逆变"></a>第22条：考虑支持泛型协变与逆变</h3><h3 id="第23条：用委托要求类型参数必须提供某种方法"><a href="#第23条：用委托要求类型参数必须提供某种方法" class="headerlink" title="第23条：用委托要求类型参数必须提供某种方法"></a>第23条：用委托要求类型参数必须提供某种方法</h3><h3 id="第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"><a href="#第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本" class="headerlink" title="第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"></a>第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本</h3><h3 id="第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"><a href="#第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类" class="headerlink" title="第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"></a>第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类</h3><h3 id="第26条：实现泛型接口的同时，还应该实现非泛型接口"><a href="#第26条：实现泛型接口的同时，还应该实现非泛型接口" class="headerlink" title="第26条：实现泛型接口的同时，还应该实现非泛型接口"></a>第26条：实现泛型接口的同时，还应该实现非泛型接口</h3><h3 id="第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"><a href="#第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现" class="headerlink" title="第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"></a>第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现</h3><h3 id="第28条：考虑通过扩展方法增强已构造类型的功能"><a href="#第28条：考虑通过扩展方法增强已构造类型的功能" class="headerlink" title="第28条：考虑通过扩展方法增强已构造类型的功能"></a>第28条：考虑通过扩展方法增强已构造类型的功能</h3><hr>
<h2 id="第4章-合理地运用-LINQ"><a href="#第4章-合理地运用-LINQ" class="headerlink" title="第4章 合理地运用 LINQ"></a>第4章 合理地运用 LINQ</h2><h3 id="第29条：优先考虑提供迭代器方法，而不要返回集合"><a href="#第29条：优先考虑提供迭代器方法，而不要返回集合" class="headerlink" title="第29条：优先考虑提供迭代器方法，而不要返回集合"></a>第29条：优先考虑提供迭代器方法，而不要返回集合</h3><h3 id="第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句"><a href="#第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句" class="headerlink" title="第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句"></a>第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句</h3><h3 id="第31条：把针对序列的-API-设计得更加易于拼接"><a href="#第31条：把针对序列的-API-设计得更加易于拼接" class="headerlink" title="第31条：把针对序列的 API 设计得更加易于拼接"></a>第31条：把针对序列的 API 设计得更加易于拼接</h3><h3 id="第32条：将迭代逻辑与操作、谓词及函数解耦"><a href="#第32条：将迭代逻辑与操作、谓词及函数解耦" class="headerlink" title="第32条：将迭代逻辑与操作、谓词及函数解耦"></a>第32条：将迭代逻辑与操作、谓词及函数解耦</h3><h3 id="第33条：等真正用到序列中的元素时再去生成"><a href="#第33条：等真正用到序列中的元素时再去生成" class="headerlink" title="第33条：等真正用到序列中的元素时再去生成"></a>第33条：等真正用到序列中的元素时再去生成</h3><h3 id="第34条：考虑通过函数参数来放松耦合关系"><a href="#第34条：考虑通过函数参数来放松耦合关系" class="headerlink" title="第34条：考虑通过函数参数来放松耦合关系"></a>第34条：考虑通过函数参数来放松耦合关系</h3><h3 id="第35条：绝对不要重载扩展方法"><a href="#第35条：绝对不要重载扩展方法" class="headerlink" title="第35条：绝对不要重载扩展方法"></a>第35条：绝对不要重载扩展方法</h3><h3 id="第36条：理解查询表达式与方法调用之间的映射关系"><a href="#第36条：理解查询表达式与方法调用之间的映射关系" class="headerlink" title="第36条：理解查询表达式与方法调用之间的映射关系"></a>第36条：理解查询表达式与方法调用之间的映射关系</h3><h3 id="第37条：尽量采用惰性求值的方式来查询，而不要及早求值"><a href="#第37条：尽量采用惰性求值的方式来查询，而不要及早求值" class="headerlink" title="第37条：尽量采用惰性求值的方式来查询，而不要及早求值"></a>第37条：尽量采用惰性求值的方式来查询，而不要及早求值</h3><h3 id="第38条：考虑用-lambda-表达式来代替方法"><a href="#第38条：考虑用-lambda-表达式来代替方法" class="headerlink" title="第38条：考虑用 lambda 表达式来代替方法"></a>第38条：考虑用 lambda 表达式来代替方法</h3><h3 id="第39条：不要在-Func-与-Action-中抛出异常"><a href="#第39条：不要在-Func-与-Action-中抛出异常" class="headerlink" title="第39条：不要在 Func 与 Action 中抛出异常"></a>第39条：不要在 Func 与 Action 中抛出异常</h3><h3 id="第40条：掌握尽早执行与延迟执行之间的区别"><a href="#第40条：掌握尽早执行与延迟执行之间的区别" class="headerlink" title="第40条：掌握尽早执行与延迟执行之间的区别"></a>第40条：掌握尽早执行与延迟执行之间的区别</h3><h3 id="第41条：不要把开销较大的资源捕获到闭包中"><a href="#第41条：不要把开销较大的资源捕获到闭包中" class="headerlink" title="第41条：不要把开销较大的资源捕获到闭包中"></a>第41条：不要把开销较大的资源捕获到闭包中</h3><h3 id="第42条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别"><a href="#第42条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别" class="headerlink" title="第42条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别"></a>第42条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别</h3><h3 id="第43条：用-Single-及-First-来明确地验证你对查询结果所做的假设"><a href="#第43条：用-Single-及-First-来明确地验证你对查询结果所做的假设" class="headerlink" title="第43条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设"></a>第43条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设</h3><h3 id="第44条：不要修改绑定变量"><a href="#第44条：不要修改绑定变量" class="headerlink" title="第44条：不要修改绑定变量"></a>第44条：不要修改绑定变量</h3><hr>
<h2 id="第5章-合理地运用异常"><a href="#第5章-合理地运用异常" class="headerlink" title="第5章 合理地运用异常"></a>第5章 合理地运用异常</h2><h3 id="第45条：考虑在方法约定遭到违背时抛出异常"><a href="#第45条：考虑在方法约定遭到违背时抛出异常" class="headerlink" title="第45条：考虑在方法约定遭到违背时抛出异常"></a>第45条：考虑在方法约定遭到违背时抛出异常</h3><h3 id="第46条：利用-using-及-try-finally-来清理资源"><a href="#第46条：利用-using-及-try-finally-来清理资源" class="headerlink" title="第46条：利用 using 及 try / finally 来清理资源"></a>第46条：利用 using 及 try / finally 来清理资源</h3><h3 id="第47条：专门针对应用程序创建异常"><a href="#第47条：专门针对应用程序创建异常" class="headerlink" title="第47条：专门针对应用程序创建异常"></a>第47条：专门针对应用程序创建异常</h3><h3 id="第48条：优先考虑做出强异常保证"><a href="#第48条：优先考虑做出强异常保证" class="headerlink" title="第48条：优先考虑做出强异常保证"></a>第48条：优先考虑做出强异常保证</h3><h3 id="第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"><a href="#第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑" class="headerlink" title="第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"></a>第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑</h3><h3 id="第50条：合理利用异常筛选器的副作用来实现某些效果"><a href="#第50条：合理利用异常筛选器的副作用来实现某些效果" class="headerlink" title="第50条：合理利用异常筛选器的副作用来实现某些效果"></a>第50条：合理利用异常筛选器的副作用来实现某些效果</h3><hr>
<h2 id="中英文词汇对照表"><a href="#中英文词汇对照表" class="headerlink" title="中英文词汇对照表"></a>中英文词汇对照表</h2>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C# </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页书签]]></title>
      <url>/2019/08/30/Bookmarks/</url>
      <content type="html"><![CDATA[<p>个人网页收藏夹  </p>
<a id="more"></a>

<p><a href="https://tao-lol.top/">tao-lol</a></p>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/index" target="_blank" rel="noopener">.NET API 浏览器</a><br><a href="https://try.dot.net/" target="_blank" rel="noopener">try.dot.net</a>  </p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="微软官方文档"><a href="#微软官方文档" class="headerlink" title="微软官方文档"></a>微软官方文档</h3><p><a href="https://docs.microsoft.com/zh-cn/dotnet/" target="_blank" rel="noopener">.NET</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/" target="_blank" rel="noopener">.NET Standard</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/" target="_blank" rel="noopener">.NET Framework</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/core/" target="_blank" rel="noopener">.NET Core</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">C#</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/" target="_blank" rel="noopener">WPF</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/" target="_blank" rel="noopener">ASP.NET Core</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/razor-pages/" target="_blank" rel="noopener">Razor Pages</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/" target="_blank" rel="noopener">MVC</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/" target="_blank" rel="noopener">Blazor</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/web-api/" target="_blank" rel="noopener">Web API</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/" target="_blank" rel="noopener">SignalR</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/" target="_blank" rel="noopener">gRPC</a><br><a href="https://docs.microsoft.com/zh-cn/xamarin/" target="_blank" rel="noopener">Xamarin</a><br><a href="https://docs.microsoft.com/zh-cn/ef/core/" target="_blank" rel="noopener">Entity Framework Core</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/machine-learning/" target="_blank" rel="noopener">ML.NET</a><br><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md" target="_blank" rel="noopener">Microsoft REST API Guidelines</a><br><a href="https://docs.microsoft.com/zh-cn/azure/devops/" target="_blank" rel="noopener">Azure Devops</a><br><a href="https://docs.microsoft.com/en-us/azure/architecture/" target="_blank" rel="noopener">Azure Architecture</a>  </p>
<h3 id="程序架构"><a href="#程序架构" class="headerlink" title="程序架构"></a>程序架构</h3><p><a href="http://prismlibrary.github.io/docs/" target="_blank" rel="noopener">Prism</a><br><a href="https://docs.abp.io/zh-Hans/abp/master/" target="_blank" rel="noopener">ABP</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/" target="_blank" rel="noopener">微服务</a><br><a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a>  </p>
<h3 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h3><p><a href="https://github.com/domaindrivendev/Swashbuckle" target="_blank" rel="noopener">SwashBuckle</a><br><a href="https://github.com/RicoSuter/NSwag/wiki" target="_blank" rel="noopener">NSwag</a><br><a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">RabbitMQ</a><br><a href="https://github.com/EasyNetQ/EasyNetQ/wiki/Introduction" target="_blank" rel="noopener">EasyNetQ</a><br><a href="https://masstransit-project.com/MassTransit/" target="_blank" rel="noopener">MassTransit</a><br><a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener">Consul</a><br><a href="https://ocelot.readthedocs.io/" target="_blank" rel="noopener">Ocelot</a><br><a href="http://cap.dotnetcore.xyz/user-guide/zh/getting-started/quick-start/" target="_blank" rel="noopener">CAP</a><br><a href="https://autofac.readthedocs.io/" target="_blank" rel="noopener">Autofac</a><br><a href="docs.automapper.org/">AutoMapper</a><br><a href="https://github.com/jbogard/MediatR/wiki" target="_blank" rel="noopener">MediatR</a><br><a href="https://github.com/serilog/serilog/wiki" target="_blank" rel="noopener">Serilog</a><br><a href="https://github.com/NLog/NLog/wiki" target="_blank" rel="noopener">NLog</a><br><a href="https://fluentvalidation.net/start" target="_blank" rel="noopener">FluentValidation</a><br><a href="https://github.com/scottksmith95/LINQKit" target="_blank" rel="noopener">LINQKit</a><br><a href="docs.identityserver.io/">IdentityServer4</a><br><a href="https://identitymodel.readthedocs.io/" target="_blank" rel="noopener">IdentityModel</a><br><a href="https://github.com/App-vNext/Polly/wiki" target="_blank" rel="noopener">Polly</a><br><a href="https://github.com/JanKallman/EPPlus/wiki" target="_blank" rel="noopener">EPPlus</a><br><a href="https://joshclose.github.io/CsvHelper/getting-started" target="_blank" rel="noopener">CSVHelper</a><br><a href="https://www.newtonsoft.com/json/help/" target="_blank" rel="noopener">Json.NET</a><br><a href="https://www.quartz-scheduler.net/documentation/index.html" target="_blank" rel="noopener">Quartz.NET</a><br><a href="https://github.com/nunit/docs/wiki" target="_blank" rel="noopener">NUnit</a><br><a href="https://xunit.net/#documentation" target="_blank" rel="noopener">xUnit</a><br><a href="https://github.com/moq/moq4/wiki" target="_blank" rel="noopener">Moq</a><br><a href="https://nsubstitute.github.io/help.html" target="_blank" rel="noopener">NSubstitute</a><br><a href="https://shouldly.readthedocs.io/" target="_blank" rel="noopener">Shouldly</a><br><a href="https://fluentassertions.com/introduction" target="_blank" rel="noopener">FluentAssertions</a><br><a href="https://anglesharp.github.io/docs.html" target="_blank" rel="noopener">AngleSharp</a><br><a href="https://github.com/2881099/FreeSql/wiki" target="_blank" rel="noopener">FreeSql</a><br><a href="https://github.com/StackExchange/Dapper" target="_blank" rel="noopener">Dapper</a><br><a href="https://github.com/2881099/csredis" target="_blank" rel="noopener">CSRedis</a><br><a href="https://stackexchange.github.io/StackExchange.Redis/" target="_blank" rel="noopener">StackExchange.Redis</a><br><a href="http://docs.supersocket.net/" target="_blank" rel="noopener">SuperSocket</a><br><a href="docs.topshelf-project.com/">Topshelf</a><br><a href="https://github.com/dotnet-state-machine/stateless" target="_blank" rel="noopener">Stateless</a><br><a href="https://docs.hangfire.io/" target="_blank" rel="noopener">Hangfire</a>  </p>
<h3 id="WPF-UI"><a href="#WPF-UI" class="headerlink" title="WPF UI"></a>WPF UI</h3><p><a href="https://github.com/MahApps/MahApps.Metro/wiki" target="_blank" rel="noopener">MahApps.Metro</a><br><a href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit/wiki" target="_blank" rel="noopener">MaterialDesignInXamlToolkit</a><br><a href="https://github.com/spiegelp/MaterialDesignExtensions/wiki" target="_blank" rel="noopener">MaterialDesignExtensions</a><br><a href="https://github.com/Panuon/PanuonUI.Silver" target="_blank" rel="noopener">PanuonUI.Silver</a><br><a href="https://github.com/ButchersBoy/Dragablz/wiki" target="_blank" rel="noopener">Dragablz</a><br><a href="https://lvcharts.net/App/examples/wpf/start" target="_blank" rel="noopener">LiveCharts</a><br><a href="https://reactiveui.net/docs/" target="_blank" rel="noopener">ReactiveUI</a>  </p>
<h3 id="Web相关"><a href="#Web相关" class="headerlink" title="Web相关"></a>Web相关</h3><p><a href="https://angular.io/docs" target="_blank" rel="noopener">Angular</a><br><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a><br><a href="https://zh-hans.reactjs.org/docs/" target="_blank" rel="noopener">React</a><br><a href="https://datatables.net/manual/" target="_blank" rel="noopener">DataTables</a><br><a href="https://getbootstrap.com/docs/" target="_blank" rel="noopener">Bootstrap</a><br><a href="https://ng-bootstrap.github.io/#/getting-started" target="_blank" rel="noopener">NG-Bootstrap</a><br><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design of React</a><br><a href="https://ng.ant.design/docs/introduce/zh" target="_blank" rel="noopener">Ant Design of Angular</a><br><a href="https://vue.ant.design/docs/vue/introduce/" target="_blank" rel="noopener">Ant Design of Vue</a><br><a href="https://material.angular.io/components/categories" target="_blank" rel="noopener">Angular Material</a>  </p>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p><a href="https://docs.microsoft.com/zh-cn/sql/t-sql/" target="_blank" rel="noopener">T-SQL</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a><br><a href="https://api.jquery.com/" target="_blank" rel="noopener">jQuery</a><br><a href="https://www.typescriptlang.org/docs/" target="_blank" rel="noopener">TypeScript</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">HTML</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式</a></p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><a href="https://redis.io/documentation" target="_blank" rel="noopener">Redis</a><br><a href="https://docs.mongodb.com/" target="_blank" rel="noopener">mongoDB</a><br><a href="https://docs.microsoft.com/zh-cn/sql/sql-server/" target="_blank" rel="noopener">SQL Server</a><br><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">MySQL</a><br><a href="https://www.sqlite.org/docs.html" target="_blank" rel="noopener">SQLite</a>  </p>
<h3 id="未归类"><a href="#未归类" class="headerlink" title="未归类"></a>未归类</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch</a><br><a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">Kibana</a><br><a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">Logstash</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker</a><br><a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">LazyDocker</a><br><a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a><br><a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener">Kubernetes</a><br><a href="https://github.com/rancher/k3s" target="_blank" rel="noopener">K3s</a><br><a href="https://github.com/apache/skywalking/tree/master/docs" target="_blank" rel="noopener">SkyWalking</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP</a><br><a href="https://github.com/dotnetcore/surging" target="_blank" rel="noopener">Surging</a><br><a href="http://dotnet.github.io/orleans/Documentation/" target="_blank" rel="noopener">Orleans</a><br><a href="https://github.com/dapr/dapr/wiki" target="_blank" rel="noopener">Dapr</a>  </p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p><a href="https://git-scm.com/doc" target="_blank" rel="noopener">Git</a><br><a href="https://swagger.io/docs/" target="_blank" rel="noopener">Swagger</a><br><a href="https://docs.unity3d.com/Manual/" target="_blank" rel="noopener">Unity</a><br><a href="https://docs.microsoft.com/en-us/powershell/" target="_blank" rel="noopener">PowerShell</a><br><a href="https://visualgo.net/" target="_blank" rel="noopener">VisuAlgo</a><br><a href="https://www.connectionstrings.com/" target="_blank" rel="noopener">ConnectionStrings</a><br><a href="https://trac.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a><br><a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">TypeScript Types Search</a><br><a href="https://docs.python.org/" target="_blank" rel="noopener">Python</a>  </p>
<h3 id="中文教程"><a href="#中文教程" class="headerlink" title="中文教程"></a>中文教程</h3><p><a href="http://manual.phpv.net/regular_expression.html" target="_blank" rel="noopener">正则表达式30分钟入门教程</a><br><a href="https://linux.vbird.org/" target="_blank" rel="noopener">鳥哥的 Linux 私房菜</a><br><a href="https://www.cnblogs.com/abcdwxc/archive/2007/10/30/942834.html" target="_blank" rel="noopener">C#设计模式（23种设计模式）</a><br><a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">C#设计模式总结</a><br><a href="https://www.cnblogs.com/fatbird/p/SortAlgorithm.html" target="_blank" rel="noopener">8种主要排序算法的C#实现</a><br><a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">JavaScript教程 - 网道</a><br><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a><br><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程</a><br><a href="https://www.cnblogs.com/ZaraNet/p/10323105.html" target="_blank" rel="noopener">.NET Core IdentityServer4实战 - zaraNet</a><br><a href="https://www.cnblogs.com/viter/p/10474091.html" target="_blank" rel="noopener">Asp.NETCore轻松学系列阅读指引目录 - Ron Liang</a><br><a href="https://www.cnblogs.com/stulzq/p/8119928.html" target="_blank" rel="noopener">IdentityServer4 中文文档与实战 - 晓晨Master</a><br><a href="https://www.cnblogs.com/MrHSR/category/1368488.html" target="_blank" rel="noopener">asp.net Core系列篇 - 花阴偷移</a><br><a href="https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html" target="_blank" rel="noopener">.NET Core微服务架构系列文章索引目录 - Edison Zhou</a><br><a href="https://www.cnblogs.com/edisonchou/p/4820676.html" target="_blank" rel="noopener">.NET全栈开发工程师学习路径 - Edison Zhou</a><br><a href="https://www.cnblogs.com/edisonchou/p/3843287.html" target="_blank" rel="noopener">博文资源汇总 - Edison Zhou</a><br><a href="https://rachel53461.wordpress.com/2011/05/08/simplemvvmexample/" target="_blank" rel="noopener">A Simple MVVM Example</a><br><a href="https://www.cnblogs.com/youring2/p/quartz_net.html" target="_blank" rel="noopener">Quartz.Net使用教程</a><br><a href="https://learnku.com/docs/tutorial/3.7.0" target="_blank" rel="noopener">Python官方文档：入门教程 3.7.0</a>  </p>
<h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p><a href="https://icons8.com/icons" target="_blank" rel="noopener">Icons8</a><br><a href="https://materialdesignicons.com/" target="_blank" rel="noopener">Material Design Icons</a><br><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">IconFont 阿里巴巴矢量图标库</a><br><a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a><br><a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">Favicon</a><br><a href="https://unicode-table.com/" target="_blank" rel="noopener">Unicode</a>  </p>
<h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p><a href="https://keylol.com/forum.php" target="_blank" rel="noopener">其乐（SteamCN 蒸汽动力）</a><br><a href="https://www.gamersky.com/" target="_blank" rel="noopener">游民星空</a><br><a href="https://www.cnbeta.com/" target="_blank" rel="noopener">cnBeta</a><br><a href="https://www.ithome.com/" target="_blank" rel="noopener">IT之家</a><br><a href="https://t.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩动态</a><br><a href="https://m.weibo.cn/" target="_blank" rel="noopener">新浪微博</a><br><a href="https://steamcommunity.com/id/tao-lol/home/" target="_blank" rel="noopener">Steam好友动态</a><br><a href="https://www.amazon.cn/Kindle电子书/b?ie=UTF8&node=116169071&ref_=nav_topnav_giftcert" target="_blank" rel="noopener">Kindle电子书</a><br><a href="https://www.oschina.net/news/industry" target="_blank" rel="noopener">开源中国资讯</a><br><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a><br><a href="https://github.com/" target="_blank" rel="noopener">Github</a><br><a href="https://dev.azure.com/tao-lol/" target="_blank" rel="noopener">Azure DevOps</a><br><a href="https://wx.qq.com/" target="_blank" rel="noopener">微信网页版</a><br><a href="https://weread.qq.com/" target="_blank" rel="noopener">微信读书</a>  </p>
<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><h2 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h2><p><a href="https://store.steampowered.com/" target="_blank" rel="noopener">Steam</a><br><a href="https://store.steampowered.com/account/registerkey" target="_blank" rel="noopener">在Steam上激活产品</a><br><a href="https://steamdb.info/" target="_blank" rel="noopener">SteamDB</a><br><a href="https://isthereanydeal.com/" target="_blank" rel="noopener">IsThereAnyDeal</a><br><a href="https://www.steamcardexchange.net/index.php?showcase" target="_blank" rel="noopener">Steam Card Exchange Showcase</a><br><a href="https://steam.design/" target="_blank" rel="noopener">Steam.Design</a><br><a href="https://steamsignature.com/" target="_blank" rel="noopener">Steam Signature</a><br><a href="https://github.com/JustArchiNET/ArchiSteamFarm" target="_blank" rel="noopener">ArchiSteamFarm</a>  </p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p><a href="https://osu.ppy.sh/" target="_blank" rel="noopener">OSU</a><br><a href="https://www.oldmanemu.net/" target="_blank" rel="noopener">OldmanEmu</a><br><a href="https://minecraft-zh.gamepedia.com/Minecraft_Wiki" target="_blank" rel="noopener">Minecraft Wiki</a><br><a href="https://terraria.gamepedia.com/Terraria_Wiki" target="_blank" rel="noopener">Terraria Wiki</a><br><a href="https://starbounder.org/Starbound_Wiki" target="_blank" rel="noopener">StarBound Wiki</a><br><a href="http://transformice.wikia.com/wiki/Transformice_Wiki" target="_blank" rel="noopener">Transformice Wiki</a><br><a href="https://wiki.52poke.com/" target="_blank" rel="noopener">神奇宝贝百科</a><br><a href="https://game8.jp/splatoon-2" target="_blank" rel="noopener">スプラトゥーン2攻略Wiki</a><br><a href="https://splatoonwiki.org/" target="_blank" rel="noopener">Splatoon Wiki</a><br><a href="https://www.ssbwiki.com/" target="_blank" rel="noopener">SmashWiki</a><br><a href="https://vstab.com/s/eso/" target="_blank" rel="noopener">上古卷轴Online中文网</a><br><a href="http://octopath.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">八方旅人中文维基</a><br><a href="https://zh.stardewvalleywiki.com/Stardew_Valley_Wiki" target="_blank" rel="noopener">Stardew Valley 中文维基</a><br><a href="http://xinglugu.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">星露谷物语中文维基 - 灰机Wiki</a><br><a href="https://majsoul.com/" target="_blank" rel="noopener">雀魂麻将</a><br><a href="https://zh.moegirl.org/雀魂麻将" target="_blank" rel="noopener">雀魂麻将 - 萌娘百科</a><br><a href="http://139.199.75.237/TTT/" target="_blank" rel="noopener">Tetris T-SPIN 教程</a><br><a href="http://farter.cn/tetr.js/" target="_blank" rel="noopener">Tetr.js</a><br><a href="https://zh.jstris.jezevec10.com/" target="_blank" rel="noopener">Jstris</a><br><a href="https://taiko.bui.pm/" target="_blank" rel="noopener">太鼓ウェブ</a><br><a href="https://www.ffxiv.cn/" target="_blank" rel="noopener">最终幻想14中文攻略站 素素</a><br><a href="https://ff14.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">最终幻想14中文维基 灰机Wiki</a><br><a href="https://www.ffxivsc.cn/" target="_blank" rel="noopener">光之收藏家 - 最终幻想14幻化站</a><br><a href="https://www.mmgal.com/" target="_blank" rel="noopener">MyGalgame</a><br><a href="https://www.nintendo.co.jp/software/switch/" target="_blank" rel="noopener">Nintendo Switchソフトウェア｜任天堂</a><br><a href="https://www.nintendo.com/games/switch/" target="_blank" rel="noopener">Switch Games - Nintendo Game Store</a>  </p>
<h1 id="动漫影视"><a href="#动漫影视" class="headerlink" title="动漫影视"></a>动漫影视</h1><p><a href="https://www.equestriacn.com/" target="_blank" rel="noopener">小马中国 | EquestriaCN</a><br><a href="https://japari-cn.com/" target="_blank" rel="noopener">加帕里图书馆 - 兽娘动物园中文维基</a><br><a href="http://yuc.wiki/" target="_blank" rel="noopener">YuC’s AnimeList</a><br><a href="http://bangumi.tv/" target="_blank" rel="noopener">Bangumi 番组计划</a><br><a href="https://www.dmzj.com/" target="_blank" rel="noopener">动漫之家</a><br><a href="https://mangakakalot.com/page" target="_blank" rel="noopener">Mangakakalot</a><br><a href="http://www.zerobyw4.com/" target="_blank" rel="noopener">zero搬运网</a><br><a href="https://www.manhuadb.com/" target="_blank" rel="noopener">漫画DB</a><br><a href="https://www.acfun.cn/" target="_blank" rel="noopener">AcFun</a><br><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a><br><a href="http://www.fjisu.tv/" target="_blank" rel="noopener">飞极速在线</a><br><a href="http://www.imomoe.io/" target="_blank" rel="noopener">樱花动漫</a><br><a href="www.dilidili.name/">嘀哩嘀哩</a><br><a href="https://mikanani.me/" target="_blank" rel="noopener">蜜柑计划</a><br><a href="https://gaoqing.fm/" target="_blank" rel="noopener">高清电台</a><br><a href="http://www.ttmeiju.me/" target="_blank" rel="noopener">天天美剧</a><br><a href="https://www.dytt89.com" target="_blank" rel="noopener">电影天堂</a><br><a href="https://www.pixiv.net/" target="_blank" rel="noopener">Pixiv</a>  </p>
<h1 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h1><p><a href="https://antecer.gitee.io/amusingkeypad/" target="_blank" rel="noopener">AmusingKeypad</a><br><a href="http://www.52kindle.net/" target="_blank" rel="noopener">钱柜图书 Kindld特价书</a><br><a href="https://bookfere.com/" target="_blank" rel="noopener">书伴 Kindle伴侣</a><br><a href="http://www.pixvol.com/" target="_blank" rel="noopener">Kindle漫画</a><br><a href="https://www.sololearn.com/" target="_blank" rel="noopener">SoloLearn</a><br><a href="https://www.w3cschool.cn/" target="_blank" rel="noopener">W3Cschool</a><br><a href="http://www.mxroom.com/" target="_blank" rel="noopener">百度云资源</a><br><a href="http://www.kekenet.com/" target="_blank" rel="noopener">可可英语</a><br><a href="https://www.coolapk.com/" target="_blank" rel="noopener">酷安网</a><br><a href="https://www.wuxiaworld.com/" target="_blank" rel="noopener">WuXiaWorld</a><br><a href="https://studyspanish.com/" target="_blank" rel="noopener">StudySpanish</a><br><a href="https://bwh1.net/" target="_blank" rel="noopener">BandwagonHost</a><br><a href="https://shadowsky.world/" target="_blank" rel="noopener">ShadowSky</a><br><a href="http://www.xitie.com/" target="_blank" rel="noopener">西贴 网上商品历史价格</a><br><a href="https://www.smzdm.com/" target="_blank" rel="noopener">什么值得买</a><br><a href="https://homenew.console.aliyun.com/" target="_blank" rel="noopener">阿里云控制台</a><br><a href="https://console.cloud.tencent.com/" target="_blank" rel="noopener">腾讯云控制台</a><br><a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a><br><a href="https://www.urlgot.com/" target="_blank" rel="noopener">urlgot</a><br><a href="https://dillinger.io/" target="_blank" rel="noopener">Online Markdown Editor - Dillinger</a><br><a href="https://markdownapp.now.sh/" target="_blank" rel="noopener">Markdown Editor</a><br><a href="https://www.toolfk.com/" target="_blank" rel="noopener">TOOLFK - 程序员开发工具</a><br><a href="http://www.alltoall.net/" target="_blank" rel="noopener">在线格式转换 All2All</a><br><a href="http://www.chongdiantou.com/" target="_blank" rel="noopener">充电头网</a><br><a href="https://www.v2ray.com/" target="_blank" rel="noopener">V2Ray</a><br><a href="https://qxk.bnu.edu.cn/" target="_blank" rel="noopener">汉字全息资源应用系统</a><br><a href="https://www.appinn.com/" target="_blank" rel="noopener">小众软件</a><br><a href="https://www.10086.cn/" target="_blank" rel="noopener">中国移动</a><br><a href="https://www.189.cn/" target="_blank" rel="noopener">中国电信</a><br><a href="https://www.10010.com/" target="_blank" rel="noopener">中国联通</a><br><a href="https://www.amap.com/" target="_blank" rel="noopener">高德地图</a><br><a href="https://www.jd.com/" target="_blank" rel="noopener">京东</a><br><a href="https://www.taobao.com/" target="_blank" rel="noopener">淘宝</a><br><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a><br><a href="https://www.google.com/" target="_blank" rel="noopener">Google</a><br><a href="https://todo.microsoft.com/" target="_blank" rel="noopener">Microsoft To-Do</a><br><a href="https://whiteboard.microsoft.com/" target="_blank" rel="noopener">Microsoft Whiteboard</a><br><a href="https://online.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Online</a><br><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN, 我告诉你</a><br><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣(LeetCode)</a><br><a href="https://getavatars.app/" target="_blank" rel="noopener">Get an Avatar</a>  </p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo下的Markdown语法]]></title>
      <url>/2019/08/30/MarkdownSyntax/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转载自 <a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html</a> 并略微修改  </p>
</blockquote>
<h1 id="语法简明概述"><a href="#语法简明概述" class="headerlink" title="语法简明概述"></a>语法简明概述</h1><ol>
<li>分段 <code>两个回车</code></li>
<li>换行 <code>两个空格</code>+<code>回车</code></li>
<li>标题 <code>#</code>~<code>######</code>，<code>#</code>的个数表示几级标题，即表示一级标题到六级标题</li>
<li>强调 <code>**粗体**</code>，<code>__粗体__</code>，<code>*斜体*</code>，<code>_斜体_</code>，<code>***加粗斜体***</code>，<code>___加粗斜体___</code>，<code>~~删除线~~</code></li>
<li>引用 <code>&gt;</code> 注意后面紧跟个空格，<code>&gt;</code>的个数表示几级引用</li>
<li>表格 <code>-</code>和<code>|</code>分割行和列，<code>:</code>控制对齐方式</li>
<li>代码块 使用<code>```语言</code>代码内容<code>```</code></li>
<li>链接 <code>[文字](链接地址)</code></li>
<li>图片 <code>![图片说明](图片地址)</code>，地址可以是本地路径，也可以是网络地址</li>
<li>无序列表 <code>*</code>，<code>+</code>，<code>-</code>，选其中之一，注意后面紧跟个空格</li>
<li>有序列表 <code>1.</code>，<code>2.</code>，<code>3.</code>等，注意后面紧跟个空格</li>
<li>分隔线 <code>---</code>或<code>***</code>或<code>___</code>，<code>-</code>或<code>*</code>或<code>_</code>的个数三个或以上</li>
<li>半角空格<code>&amp;ensp;</code>或<code>&amp;#8194;</code></li>
<li>全角空格<code>&amp;emsp;</code>或<code>&amp;#8195;</code></li>
<li>不断行空格<code>&amp;nbsp;</code>或<code>&amp;#160;</code><a id="more"></a>

</li>
</ol>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">####### 没有七级标题，但会影响生成目录，目录行多出一行空行</span><br></pre></td></tr></table></figure>

<h1 id="内容强调"><a href="#内容强调" class="headerlink" title="内容强调"></a>内容强调</h1><h2 id="加粗、斜体"><a href="#加粗、斜体" class="headerlink" title="加粗、斜体"></a>加粗、斜体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字体 *斜体* 或 _斜体_ 显示</span><br><span class="line">字体 **加粗** 或 __加粗__ 显示</span><br><span class="line">字体 ***加粗斜体*** 或 ___加粗斜体___ 或以上任意两者组合 显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>斜体</em><br><strong>加粗</strong><br><strong><em>加粗斜体</em></strong>  </p>
</blockquote>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字体 ~~删除线~~ 显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p><del>删除线</del>  </p>
</blockquote>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用&lt;code&gt;内容&lt;/code&gt;或`内容`来强调内容</span><br><span class="line">在code中需用\来转义符号`</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>强调内容</code>  </p>
</blockquote>
<h2 id="引用显示"><a href="#引用显示" class="headerlink" title="引用显示"></a>引用显示</h2><h3 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每行都使用&gt;+空格+内容</span><br><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用内容  </p>
</blockquote>
<h3 id="省略使用"><a href="#省略使用" class="headerlink" title="省略使用"></a>省略使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 仅第一行加&gt;号</span><br><span class="line">后续内容自动变成引用内容</span><br><span class="line">两个回车换行结束引用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行加<code>&gt;</code><br>第二行无<code>&gt;</code><br>第三行无<code>&gt;</code>  </p>
</blockquote>
<p>第四行无<code>&gt;</code>  </p>
<h3 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 动物</span><br><span class="line">&gt;&gt; 水生动物</span><br><span class="line">&gt;&gt; 陆生动物</span><br><span class="line">&gt;&gt;&gt; 猴子</span><br><span class="line">&gt;&gt;&gt; 人</span><br><span class="line">&gt;&gt;&gt;&gt; 程序员</span><br><span class="line">&gt;&gt;&gt;&gt; 工程师</span><br><span class="line">&gt;&gt; 产品经理 <span class="comment">//没有空行间隔，忽略降级引用标记</span></span><br><span class="line">设计师 <span class="comment">//没有空行间隔，忽略降级引用标记</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; 两栖动物</span><br><span class="line">&gt;&gt;&gt; 鳄鱼</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动物  </p>
<blockquote>
<p>水生动物<br>陆生动物  </p>
<blockquote>
<p>猴子<br>人  </p>
<blockquote>
<p>程序员<br>工程师<br>产品经理<br>设计师  </p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>两栖动物  </p>
<blockquote>
<p>鳄鱼  </p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表格语法：</span><br><span class="line"> 列1 | 列2 | 列3</span><br><span class="line"> --- | --- | --- </span><br><span class="line">第一行|  1  | 2 </span><br><span class="line">第二行|  2  | 3</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th>列1</th>
<th>列2</th>
<th>列3</th>
</tr>
</thead>
<tbody><tr>
<td>第一行</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>第二行</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
</blockquote>
<p>使用冒号(:)来定义对齐方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|左对齐|右对齐|居中|</span><br><span class="line">|:---|---:|:-:|</span><br><span class="line">|一|1|①|</span><br><span class="line">|二|2|②|</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一</td>
<td align="right">1</td>
<td align="center">①</td>
</tr>
<tr>
<td align="left">二</td>
<td align="right">2</td>
<td align="center">②</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">代码块使用```[可选语言]开始，```结束，如：</span><br><span class="line">```cs</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private string _pro;</span><br><span class="line">    public string Pro</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _pro;</span><br><span class="line">        set =&gt; _pro = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _pro;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Pro</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _pro;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _pro = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h2><p>如何在<code>代码块</code>中打出<code>```</code><br>只要使用4个<code>`</code>包含3个<code>`</code>即可，想表示更多，最外层<code>+1</code>就行。</p>
<h1 id="链接插入"><a href="#链接插入" class="headerlink" title="链接插入"></a>链接插入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[文字](链接)</span><br><span class="line">[首页](https://tao-lol.github.io)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://tao-lol.github.io" target="_blank" rel="noopener">首页</a>  </p>
</blockquote>
<h1 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片链接)</span><br><span class="line">图片链接相对路径或网络地址皆可</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/Life%20Is%20Strange.jpg" alt="Life Is Strange" title class>
                <p>Life Is Strange</p>
            </figure>  
</blockquote>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*或-或+开头皆可</span><br><span class="line">* 无序列表1</span><br><span class="line">    * 无序列表1-1</span><br><span class="line">- 无序列表2</span><br><span class="line">+ 无序列表3</span><br><span class="line">    + 无序列表3-1</span><br><span class="line">    + 无序列表3-2</span><br><span class="line">        + 无序列表3-2-1</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>无序列表1<ul>
<li>无序列表1-1 <code>多于一级序列一(2?)个空格</code></li>
</ul>
</li>
</ul>
<ul>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3<ul>
<li>无序列表3-1</li>
<li>无序列表3-2<ul>
<li>无序列表3-2-1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动生成列表序号，最多两级</span><br><span class="line">1. 有序1</span><br><span class="line">1. 有序2</span><br><span class="line"> 1. 有序2-1</span><br><span class="line">  1. 有序2-1-1</span><br><span class="line"> 1. 有序2-2</span><br><span class="line">1. 有序3</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>有序1</li>
<li>有序2<ol>
<li>有序2-1 <code>多于一级序列一(3?)个空格</code><ol>
<li>有序2-1-1</li>
</ol>
</li>
<li>有序2-2</li>
</ol>
</li>
<li>有序3</li>
</ol>
</blockquote>
<h1 id="链接自动检测"><a href="#链接自动检测" class="headerlink" title="链接自动检测"></a>链接自动检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">百度：http://www.baidu.com/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>百度：<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>  </p>
</blockquote>
<h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三个或以上*或-或_</span><br><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
<hr>
<hr>
</blockquote>
<h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不断行空格 &amp;nbsp;</span><br><span class="line">半角空格 &amp;ensp;</span><br><span class="line">全角空格 &amp;emsp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个&nbsp;是&ensp;例&emsp;子</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2019/08/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
