<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[使用 .NET Core 创建 Windows 服务]]></title>
      <url>/2019/12/14/CreatingWindowsServicesInDotNetCore/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文：</p>
<ul>
<li>Part 1 - The “Microsoft” Way: <a href="https://dotnetcoretutorials.com/2019/09/19/creating-windows-services-in-net-core-part-1-the-microsoft-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/09/19/creating-windows-services-in-net-core-part-1-the-microsoft-way/</a>  </li>
<li>Part 2 - The “Topshelf” Way: <a href="https://dotnetcoretutorials.com/2019/09/27/creating-windows-services-in-net-core-part-2-the-topshelf-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/09/27/creating-windows-services-in-net-core-part-2-the-topshelf-way/</a>  </li>
<li>Part 3 – The “.NET Core Worker” Way: <a href="https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/</a></li>
</ul>
<p>作者：Dotnet Core Tutorials<br>译者：Lamond Lu  </p>
<p>译文：</p>
<ul>
<li>Part 1 - 使用官方推荐方式: <a href="https://www.cnblogs.com/lwqlun/p/11621186.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/11621186.html</a>  </li>
<li>Part 2 - 使用 Topshelf 方式: <a href="https://www.cnblogs.com/lwqlun/p/11625789.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/11625789.html</a>  </li>
<li>Part 3 - 使用 .NET Core 工作器方式: <a href="https://www.cnblogs.com/lwqlun/p/12038062.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/12038062.html</a>  </li>
</ul>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <img src="65831-20191005211343706-2050001309.png" alt title class>
                <p></p>
            </figure>

<h1 id="使用官方推荐方式"><a href="#使用官方推荐方式" class="headerlink" title="使用官方推荐方式"></a>使用官方推荐方式</h1><p>&emsp;&emsp;创建 Windows 服务来运行批处理任务或者运行后台任务，是一种非常常见的模式，但是由于云服务（Amazon Lambda, Azure WebJobs 以及 Azure Functions）的激增，你可能不会经常使用 Windows 服务了。个人而言，我非常喜欢使用 Azure WebJobs，因为我可以直接编写一个控制台程序，而不需要考虑如何云中运行它，一个批处理文件可以将其装换成一个自动化任务，并且可以保证 7 * 24 小时的运行。<br>&emsp;&emsp;但是也许你还没有使用云服务，或者你有一堆要作为 Windows 服务运行的旧版应用程序需要转换为 .NET Core，但是不能完全将他们转换为 “ 无服务器 ”（serverless）应用。 那么这边文章就是适合你的。<br>&emsp;&emsp;在许多方面，.NET Core 中的 Windows 服务和 .NET Framework 中的 Windows 服务完全相同。但是，在编写服务的时候，你可能会遇到一些小问题。此外，本文中，我们仅介绍 “ Microsoft ” 方式的 Windows 服务创建，在后续，我会继续介绍如何使用第三方库 TopShelf 来简化这个过程。  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;由于 Visual Studio 没有提供创建 Windows 服务的模板，所以我们需要通过创建控制台程序的方式来创建一个 Windows 服务。<br>创建完成之后，我们需要安装一个 Nuget 程序包，这个程序包会将一些 Windows 特定的 API 添加到 .NET Core 中，这些 API 实际上已经在完整框架中提供了，但是其中许多是 Windows 特有的，例如 Windows 服务。因此, 它们并没有包含在 .NET Core 的基础库中，但是可以通过将 Nuget 程序包的方式引入到 .NET Core 中。<br>&emsp;&emsp;下面我们就可以在 Package Manager Console 中输入以下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Windows.Compatibility</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&emsp;&emsp;以上引入的 Nuget 程序包中，最让我们感兴趣的是 <code>ServiceBase</code> 类。这是一个用于编写 Windows 服务的基类，它提供了一系列的事件钩子，包含服务启动、结束、暂停等。<br>&emsp;&emsp;下面呢，我们将在代码中创建一个类，这个类负责将一些简单的日志输出到一个临时文件中。我们将使用这个例子来了解其中的原理。我们的代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LoggingService</span> : <span class="title">ServiceBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> _logFileLocation = <span class="string">@"C:\temp\servicelog.txt"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="keyword">string</span> logMessage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));</span><br><span class="line">        File.AppendAllText(_logFileLocation, DateTime.UtcNow.ToString() + <span class="string">" : "</span> + logMessage + Environment.NewLine);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Starting"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnStart(args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Stopping"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnStop();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Pausing"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以这里你会注意到，我们的类是继承了 <code>ServiceBase</code> 类，并且我们重写了几个事件方法，输出了一些日志。在服务启动时，会触发 <code>OnStart</code> 事件，在服务终止的时候，会触发 <code>OnStop</code> 事件。这里我们不应该将过于繁重的任务放置在 <code>OnStart</code> 事件中来处理。<br>&emsp;&emsp;如果我们想从 <code>Main</code> 方式中启动这个服务，代码非常的简单。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ServiceBase.Run(<span class="keyword">new</span> LoggingService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上就是全部代码。  </p>
<h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>&emsp;&emsp;在发布服务的时候，我们不可能仅依靠 Visual Studio 来构建我们所需要的服务，我们还需要专门针对 Windows 运行时进行构建。为此，我们需要在项目根目录的命令提示符下运行以下命令。注意，这里我们传入了一个 <code>-r</code> 标记来告诉它要构建那个平台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;命令运行完毕之后，我们可以检查以下 <code>/bin/release/netcoreappX.X/publish</code> 目录，我们可以找到所有的发布代码，但是最重要的是，这里我们可以得到一个可执行的 exe 文件。如果我们不指定运行时，我们只会获得一个 .NET Core 的 dll 程序集，使用这个程序集，我们是没有办法创建 Windows 服务的。<br>&emsp;&emsp;现在我们可以将这个发布目录移动带其他的任何地方，但是现在我们就暂时使用当前的发布目录。<br>&emsp;&emsp;下一步，我们需要使用管理员角色打开一个命令提示符，然后输入一下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>SC</code> 命令是一个标准的 Windows 命令（与 .NET Core 无关），它可以用来安装 Windows 服务。这里我们将我们的测试服务命名为 <code>TestService</code>，更重要的是，我们通过 <code>BinPath</code> 参数指定了可执行 exe 文件。<br>&emsp;&emsp;运行之后，我们应该会得到以下结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SC] CreateService SUCCESS</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们要做的就是启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start TestService</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以查看一下我们的日志文件，查看服务的运行情况。<br>&emsp;&emsp;如果想要停止并删除服务，我们可以使用一下命令。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop TestService</span><br><span class="line">sc delete TestService</span><br></pre></td></tr></table></figure>

<h2 id="服务调试"><a href="#服务调试" class="headerlink" title="服务调试"></a>服务调试</h2><p>&emsp;&emsp;在这里，我真的认为，使用 “ Microsoft “ 的方式注定会失败。因为调试服务实在是太繁琐了。<br>&emsp;&emsp;首先，我们将 <code>ServiceBase</code> 中重写的方法设置为受保护，这意味着我们无法在类之外访问它们，这使得调试它们变得更加困难。这里我发现最好的方法是为每个事件提供一个 public 方法, 并在受保护方法中调用这些 public 方法来完成功能，这虽然有点混乱，</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStartPublic</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log(<span class="string">"Starting"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnStartPublic(args);</span><br><span class="line">    <span class="keyword">base</span>.OnStart(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是至少我们可以做如下了事情了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loggingService = <span class="keyword">new</span> LoggingService();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)   <span class="comment">//Some check to see if we are in debug mode (Either #IF Debug etc or an app setting)</span></span><br><span class="line">    &#123;</span><br><span class="line">        loggingService.OnStartPublic(<span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Just spin wait here. </span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Call stop here etc. </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ServiceBase.Run(<span class="keyword">new</span> LoggingService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你的另一个选择是，在调试模式下进行项目发布，安装服务，然后附加调试器。实际上，这是 Microsoft 建议你使用的方式，但是我认为这简直一团糟。  </p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>&emsp;&emsp;实际上，我们可以在这里做一些其他非常有用的事情， 比如我们可以通过创建一个 install.bat 批处理文件来为我们运行 SC Create 命令。但我认为，上面我们看到的调试问题，已经让我不再想使用这种方式了。幸运的是，有一个名为 <code>Topshelf</code> 的库可以帮助我们减轻很多麻烦，在本系列的下一部分中，我们将研究如何它。  </p>
<h1 id="使用-Topshelf-方式"><a href="#使用-Topshelf-方式" class="headerlink" title="使用 Topshelf 方式"></a>使用 Topshelf 方式</h1><p>&emsp;&emsp;在前一篇文章中，我给大家介绍了，如何基于微软推荐方式使用 .NET Core 创建 Windows 服务。我们发现使用这种方式，我们很容易就可以搭建和运行一个 Windows 服务，但是问题是使用这种方式，代码调试将非常困难。<br>&emsp;&emsp;那么现在就是 <code>Topshelf</code> 出场的时候了。<code>Topshelf</code> 是一个 .NET Standard 库，它消除了在 .NET Framework 和 .NET Core 中创建 Windows 服务的那些麻烦。  </p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;与微软推荐方式类似，这里 Visual Studio 并没有提供一个基于 <code>Topshelf</code> 创建 Windows 服务的模板，所以我们依然需要通过创建普通控制台程序的方式，来创建一个 Windows 服务。<br>&emsp;&emsp;然后，我们需要通过 Package Manager Console，运行以下命令，安装 <code>Topshelf</code> 类库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Topshelf</span><br></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>&emsp;&emsp;下面我们就来使用 <code>Topshelf</code> 重构之前的服务代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoggingService</span> : <span class="title">ServiceControl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> _logFileLocation = <span class="string">@"C:\temp\servicelog.txt"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="keyword">string</span> logMessage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));</span><br><span class="line">        File.AppendAllText(_logFileLocation, </span><br><span class="line">            DateTime.UtcNow.ToString() + <span class="string">" : "</span> + logMessage + Environment.NewLine);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Start</span>(<span class="params">HostControl hostControl</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Starting"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Stop</span>(<span class="params">HostControl hostControl</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Stopping"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码看起来是不是很简单？<br>&emsp;&emsp;这里我们的服务类继承了 <code>ServiceControl</code> 类（实际上并不需要，但是这可以为我们的工作打下良好的基础）。我们必须实现服务开始和服务结束两个方法，并且像以前一样记录日志。<br>&emsp;&emsp;在 <code>Program.cs</code> 文件的 <code>Main</code> 方法中，我们要写的代码也非常的简单。我们可以直接使用 <code>HostFactory.Run</code> 方法来启动服务。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HostFactory.Run(x =&gt; x.Service&lt;LoggingService&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来真是太简单了。但这并不是 <code>HostFactory</code> 类的唯一功能。这里我们还可以设置</p>
<ul>
<li>服务的名称</li>
<li>服务是否自动启动</li>
<li>服务崩溃之后的重启时间</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HostFactory.Run(x =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            x.Service&lt;LoggingService&gt;();</span><br><span class="line">            x.EnableServiceRecovery(r =&gt; r.RestartService(TimeSpan.FromSeconds(<span class="number">10</span>)));</span><br><span class="line">            x.SetServiceName(<span class="string">"TestService"</span>);</span><br><span class="line">            x.StartAutomatically();</span><br><span class="line">         &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里其实能说的东西很多，但是我建议你还是自己去看看 <code>Topshelf</code> 的文档，学习一下其他的配置选项。基本上你能使用 Windows 命令行完成的所有操作，都可以使用代码来设置：<a href="https://topshelf.readthedocs.io/en/latest/configuration/config_api.html" target="_blank" rel="noopener">https://topshelf.readthedocs.io/en/latest/configuration/config_api.html</a>  </p>
<h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>&emsp;&emsp;和之前一样，我们需要针对不同的 Windows 环境发布我们的服务。在 Windows 命令提示符下，我们可以在项目目录中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们就可以查看一下 <code>bin\Release\netcoreappX.X\win-x64\publish</code> 目录，我们会发现一个编译好的 exe，下面我们就会使用这个文件来安装服务。<br>&emsp;&emsp;在上一篇文章中，我们是使用 <code>SC</code> 命令来安装 Windows 服务的。使用 <code>Topshelf</code> 我们就不需要这么做了，<code>Topshelf</code> 提供了自己的命令行参数来安装服务。基本上使用代码能完成的配置，都可以使用命令行来完成。<br>&emsp;&emsp;你可以查看相关的文档：<a href="http://docs.topshelf-project.com/en/latest/overview/commandline.html" target="_blank" rel="noopener">http://docs.topshelf-project.com/en/latest/overview/commandline.html</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowsServiceExample.exe install</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里 <code>WindowsServiceExample.exe</code> 是我发布之后的 exe 文件。运行以上命令之后，服务应该就正常安装了！这里有一个小问题，我经常发现，即使配置了服务自动启动，但是服务安装之后，并不会触发启动操作。所有在服务安装之后，我们还需要通过以下命令来启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowsServiceExample.exe start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;在生产环境部署的时候，我的经验是在安装服务之后，等待 10 秒钟，再启动服务。</p>
</blockquote>
<h2 id="调试服务"><a href="#调试服务" class="headerlink" title="调试服务"></a>调试服务</h2><p>&emsp;&emsp;当我们是使用微软推荐方式的时候，我们会遇到了调试困难的问题。大多数情况下，无论是否在服务内部运行，我们都不得不使用命令行标志、<code>#IF DEBUG</code> 指令或者配置值来实现调试。然后使用 Hack 的方式在控制台程序中模拟服务。<br>&emsp;&emsp;因此，这就是为什么我们要使用 <code>Topshelf</code>。<br>&emsp;&emsp;如果我们的服务代码已经在 Visual Studio 中打开了，我们就可以直接启动调试。<code>Topshelf</code> 会模拟在控制台中启动服务。我们应该能在控制台中看到以下的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The TestService service is now running, press Control+C to exit.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这确实符合了我们的需求。它启动了我们的服务，并像真正的 Windows 服务一样在后台运行。我们可以像往常一样设置断点，基本上它遵循的流程和正常安装的服务一样。<br>&emsp;&emsp;我们可以通过 ctrl+c，来关闭我们的应用，但是在运行服务执行 Stop 方法之前，它是不能被关闭的，这使我们可以调试服务的关闭流程。与调试指令和配置标志相比，这要容易的多。<br>&emsp;&emsp;这里需要注意一个问题。如果你收到的以下内容的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The TestService service is running and must be stopped before running via the console</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这意味着你尝试调试的服务实际上已经作为 Windows 服务被安装在系统中了，你需要停止（不需要卸载）这个正在运行的服务，才可以正常调试。</p>
<h2 id="后续-1"><a href="#后续-1" class="headerlink" title="后续"></a>后续</h2><p>&emsp;&emsp;在上一篇中，有读者指出 .NET Core 中实际上已经提供了一种完全不同的方式运行 Windows 服务。它的实质是利用了 ASP.NET Core 中引入的 “ 托管服务 ” 模型，并允许它们作为 Windows 服务来运行，这真的是非常的棒。</p>
<h1 id="使用-NET-Core-工作器方式"><a href="#使用-NET-Core-工作器方式" class="headerlink" title="使用 .NET Core 工作器方式"></a>使用 .NET Core 工作器方式</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>&emsp;&emsp;这里首先你要确保你已经安装了 .NET Core 3.0 或以上版本。在我编写这篇文章的时候，.NET Core 3.1 刚刚发布，Visual Studio 应该会提示你升级到最新版本。但是如果你想要在 .NET Core 2.x 项目中使用这个方式，应该是行不通的。<br>&emsp;&emsp;如果你喜欢使用命令行创建项目，你就需要使用工作器（worker）类型创建项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new worker</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果你是一个和我一样喜欢使用 Visual Studio 的开发人员，那么你可以在 Visual Studio 中使用项目模板完成相同的功能。</p>
<figure class="image-box">
                <img src="65831-20191214083435124-1006535101.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;这样做将创建出一个包含两个文件的项目。其中 <code>Program.cs</code> 文件是应用的启动 “ 引导程序 ” 。另外一个文件是 <code>worker.cs</code> 文件，在这个文件中，你可以编写你的服务逻辑。<br>&emsp;&emsp;这看起来应该是相当的容易，但是为这个程序添加额外的并行后台服务，你还需要添加一个类，并让它继承 <code>BackgroundService</code> 类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyNewBackgroundWorker</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)    </span></span><br><span class="line"><span class="function"></span>    &#123;        </span><br><span class="line">        <span class="comment">//Do something.     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在 <code>Program.cs</code> 中，我们要做的只是把当前的 Worker 注册到服务集合（Service Collection）中即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureServices((hostContext, services) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    services.AddHostedService&lt;Worker&gt;();</span><br><span class="line">    services.AddHostedService&lt;MyNewBackgroundWorker&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实际上作为 “ 后台服务 ” 任务的运行程序，<code>AddHostedService</code> 方法已经在框架中存在了很长时间了。在之前我们已经完成的一篇关于<a href="https://dotnetcoretutorials.com/2019/01/13/hosted-services-in-asp-net-core/" target="_blank" rel="noopener"> ASP.NET Core 托管服务</a>的文章， 但是在当时场景中，我们托管是是整个应用，而非一个在你应用程序幕后运行的东西。  </p>
<h2 id="运行-调试我们的应用"><a href="#运行-调试我们的应用" class="headerlink" title="运行 / 调试我们的应用"></a>运行 / 调试我们的应用</h2><p>&emsp;&emsp;在默认的工作器（worker）模板中，已经包含了一个后台服务，这个服务可以将当前时间输出到控制台窗口。下面让我们点击 F5 来运行程序，看看我们能得到什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info: CoreWorkerService.Worker[0]      </span><br><span class="line">      Worker running at: 12/07/2019 08:20:30 +13:00</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]      </span><br><span class="line">      Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在我们启动程序之后，程序立刻就运行了！我们可以保持控制台的打开状态来调试应用，或者直接关闭窗口退出。相较于使用 “ Microsoft “ 方式来调试一个 Windows 服务，这简直就是天堂。<br>&emsp;&emsp;这里我们需要注意的另外一件事情是编写控制台程序的平台。在最后，我们不仅在控制台窗口输出了时间，还通过依赖注入创建了一个托管 worker。我们也可以使用依赖注入容器来注入仓储，配置环境变量，获取配置等。<br>&emsp;&emsp;但这里我们还没有做的事情是，将这个应用转换为 Windows 服务。  </p>
<h2 id="将我们的应用转换成-Windows-服务"><a href="#将我们的应用转换成-Windows-服务" class="headerlink" title="将我们的应用转换成 Windows 服务"></a>将我们的应用转换成 Windows 服务</h2><p>&emsp;&emsp;为了将应用转换成 Windows 服务，我们需要使用如下命令引入一个包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Extensions.Hosting.WindowsServices</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下一步，我们需要修改 <code>Program.cs</code> 文件，添加 <code>UseWindowsService()</code> 方法的调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt; </span><br><span class="line">    Host.CreateDefaultBuilder(args)    </span><br><span class="line">        .ConfigureServices((hostContext, services) =&gt;    </span><br><span class="line">        &#123;        </span><br><span class="line">            services.AddHostedService&lt;Worker&gt;();   </span><br><span class="line">         &#125;)</span><br><span class="line">         .UseWindowsService();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上就是所有需要变更的代码。<br>&emsp;&emsp;运行我们的程序，你会发现和之前的效果完全样。但是这里最大的区别是，我们可以将当前应用以 Windows 服务的形式安装了。<br>&emsp;&emsp;为了实现这一目的，我们需要发布当前项目。在当前项目目录中，我们可以运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们就可以借助标准的 Windows 服务安装器来安装当前服务了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当前，你也可以使用 Windows 服务安装器的其他命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start TestServicesc stop TestServicesc delete TestService</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后检查一下我们的服务面板。</p>
<figure class="image-box">
                <img src="65831-20191214083446395-754761263.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;服务已经正常工作了。</p>
<h2 id="在-Linux-中运行服务"><a href="#在-Linux-中运行服务" class="headerlink" title="在 Linux 中运行服务"></a>在 Linux 中运行服务</h2><p>&emsp;&emsp;老实说，我没有太多的Linux经验，但是终归是需要了解一下…<br>&emsp;&emsp;在 Linux 系统中, 如果你希望我们编写的 “ Windows ” 服务在 Linux 系统中作为服务运行，你需要做以下 2 步：</p>
<ul>
<li>使用 <code>Microsoft.Extensions.Hosting.Systemd</code> 替换之前的 <code>Microsoft.Extensions.Hosting.WindowsServices</code>。</li>
<li>使用 <code>UseSystemd()</code> 替换 <code>UseWindowsService()</code>。</li>
</ul>
<h1 id="Microsoft-vs-Topshelf-vs-NET-Core-Workers"><a href="#Microsoft-vs-Topshelf-vs-NET-Core-Workers" class="headerlink" title="Microsoft vs Topshelf vs .NET Core Workers"></a>Microsoft vs Topshelf vs .NET Core Workers</h1><p>&emsp;&emsp;到现在为止，我们已经介绍了借助 3 种不同的方式来创建 Windows 服务。<br>&emsp;&emsp;你可能会问 “ 好吧，那我到底应该选择哪一种 ？”<br>&emsp;&emsp;这里呢，我们可以首先把 “ Microsoft “ 这种老派学院式的方式抛弃。以为它的调试实在是太麻烦了，而且没有什么实际的用处。<br>&emsp;&emsp;然后剩下的就是 <code>Topshelf</code> 和 .NET Core 工作器两种方式了。在我看来，.NET Core 工作器，已经很好的融入 .NET Core 生态系统，如果你正在开发 ASP.NET Core 应用，那么使用 .NET Core 工作器就很有意义。最重要的是，当你创建一个后台服务的时候，你可以让它在一个 ASP.NET Core 网站中的任意位置运行，这非常的方便。但是缺点是安装。你必须使用 <code>SC</code> 命令来安装服务。这一部分 <code>Topshelf</code> 可能更胜一筹。<br>&emsp;&emsp;<code>Topshelf</code> 总体上将非常的友好，并且具有最好的安装方式，但是使用额外的库，也增加了学习的成本。<br>&emsp;&emsp;所以 <code>Topshelf</code> 和 .NET Core 工作器，大家可以自行选择，都是不错的方案。  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[I/O 中断原理]]></title>
      <url>/2019/12/14/IOInterruptionPrinciple/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/Jack-Blog/p/12038716.html" target="_blank" rel="noopener">https://www.cnblogs.com/Jack-Blog/p/12038716.html</a></p>
</blockquote>
<p>&emsp;&emsp;本篇文章会对中断操作的原理进行说明。  </p>
<a id="more"></a>

<h1 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h1><p>&emsp;&emsp;中断指当出现需要时，CPU 暂时停止当前程序的执行转而执行处理新情况的程序和执行过程。即在程序运行过程中，系统出现了一个必须由 CPU 立即处理的情况，此时，CPU 暂时中止程序的执行转而处理这个新的情况的过程就叫做中断。<br>&emsp;&emsp;我们知道 CPU 是按指令顺序进行执行的，操作系统每过大约 15ms 会发生一次线程调度（Windows 下），根据线程优先级先调度优先级高的线程。但是实际情况并没有那么简单，若我们接收到一个网络请求，如果要等当前线程执行完或 15ms 线程调度之后才去处理网络请求，网卡缓冲区很有可能会被占满，此时就发生了丢包。  </p>
<h1 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h1><p>&emsp;&emsp;中断分为硬件中断和软件中断。</p>
<h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p>&emsp;&emsp;硬件中断即为硬件发出的中断信号，如 I/O 中断和硬件失效中断。</p>
<ul>
<li>I/O 中断：由 I/O 控制器产生，用于发送信号通知操作完成等信号。</li>
<li>硬件失效中断：如掉电或存储器奇偶错之类的故障。</li>
</ul>
<h2 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h2><p>&emsp;&emsp;软件中断即为非硬件发出的中断信号，如程序中断和时钟中断。</p>
<ul>
<li>程序中断：一些指令产生的异常（如算数移除、除数为 0 等）。</li>
<li>时钟中断：由处理器内部的计时器产生，允许操作系统以一定规程执行函数。<blockquote>
<p>&emsp;&emsp;我们提到了操作系统每过大约 15ms 会进行一次线程调度，就是利用时钟中断来实现的。</p>
</blockquote>
</li>
</ul>
<h1 id="I-O中断流程"><a href="#I-O中断流程" class="headerlink" title="I/O中断流程"></a>I/O中断流程</h1><p>&emsp;&emsp;本篇文章还是主要解释前几篇文章提到的 I/O 中断进行解释说明，因此仅以 I/O 中断举例，但是中断的原理和流程都是相似的。<br>&emsp;&emsp;I/O 中断通过中断处理器执行中断操作。当外部设备的 I/O 模块准备好时，它会发送给 CPU 一个中断信号，CPU 则会 “ 立即 ” 做出响应，暂停当前程序的处理去服务该 I/O 设备的程序。</p>
<blockquote>
<p>&emsp;&emsp;也可能不是立即，比如同时存在多个中断，则根据实际的中断算法决定，是按中断先后顺序执行中断操作，还是按中断优先级执行。<br>&emsp;&emsp;I/O 中断时硬件中断，需要硬件支持来接收中断信号。</p>
</blockquote>
<h2 id="无中断"><a href="#无中断" class="headerlink" title="无中断"></a>无中断</h2><p>&emsp;&emsp;为了更好的说明中断带来的性能提升，我们先描述一下没有中断时程序如何处理 I/O 操作。</p>
<figure class="image-box">
                <img src="580757-20191214121306882-165841570.png" alt title class>
                <p></p>
            </figure>

<ul>
<li><p>当我们程序需要从硬盘读取一个文件时，会先检查内核缓存中是否有数据，若没有数据，则执行实际 I/O 操作。在 I/O 操作执行时，我们的用户线程将阻塞等待数据从硬盘写到内存中。对于用户来说线程是被阻塞的。</p>
</li>
<li><p>在实际的 I/O 操作过程中，若没有中断操作，CPU 会不断轮询检查 I/O 操作是否完成，若 I/O 操作没有完成则继续调度其他线程，过一会儿再来检查。若操作完成，CPU 将线程加入到线程就绪队列中并恢复线程上下文信息。</p>
</li>
<li><p>线程处于就绪队列，可以被操作系统调度从而继续执行读操作，此时会将数据从操作系统内核缓存读取到用户缓存中。</p>
<h2 id="有中断"><a href="#有中断" class="headerlink" title="有中断"></a>有中断</h2><figure class="image-box">
                <img src="580757-20191214121702241-973799984.png" alt title class>
                <p></p>
            </figure>
</li>
<li><p>当我们程序需要从硬盘读取一个文件时，会先检查内核缓存中是否有数据，若没有数据，则执行实际 I/O 操作。在 I/O 操作执行时，我们的用户线程将阻塞等待数据从硬盘写到内存中。对于用户来说线程是被阻塞的。</p>
</li>
<li><p>在实际的 I/O 操作过程中，CPU 向 I/O 模块（DMA 控制器）发送读指令，然后就去调度其他线程。</p>
</li>
<li><p>当 I/O 模块（DMA 控制器）I/O 执行完成后，会产生中断信号在通知 CPU，CPU 将线程加入到线程就绪队列中并恢复线程上下文信息。</p>
</li>
<li><p>线程处于就绪队列，可以被操作系统调度从而继续执行读操作，此时会将数据从操作系统内核缓存读取到用户缓存中。</p>
</li>
</ul>
<p>&emsp;&emsp;由此可知，有中断还是没有中断对于用户来说线程都是阻塞的，对于操作系统内核来说通过中断方式主动通知 CPU 的方式减少了线程轮询判断，提高了线程执行效率。<br>&emsp;&emsp;当然，为了进一步提高线程利用率，此时我们可以通过异步操作 API 执行 I/O 操作。<br>&emsp;&emsp;比如 .Net Framework 4.5 的 <code>async</code> 和 <code>await</code> 关键字，当调用异步操作后，API 内部保存了相关状态机信息（回调信息），线程继续执行其他操作，当操作系统内核读取数据完成时，线程调用回调方法恢复到 <code>await</code> 的后续操作。整个过程中线程不会因为阻塞带来导致性能损失。</p>
<h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><p>&emsp;&emsp;当 I/O 设备完成一次 I/O 操作时，发生以下事件：</p>
<ol>
<li>开始 I/O 操作前，处理器将当前处理的相关信息如指令地址、必要的状态信息等保存到栈中，使得中断后可以恢复执行。</li>
<li>I/O 操作完成后，设备给处理器发送一个中断信号。</li>
<li>处理器响应中断信号。</li>
<li>处理器对中断信号进行判断，若存在未响应的中断，则给产生中断信号的设备发送确认信号，确认信号使得设备取消它的中断信号。</li>
<li>处理器将控制前转移给中断程序中，中断程序从栈中获取之前保存的信息，使得能继续执行 I/O 完成时的后续操作。</li>
<li>处理器将中断程序入口地址载入到程序计数器中，使得处理器能继续执行下一个指令周期。</li>
</ol>
<h1 id="相关文献"><a href="#相关文献" class="headerlink" title="相关文献"></a>相关文献</h1><ol>
<li>《操作系统 - 精髓与设计原理》</li>
<li><a href="https://blog.csdn.net/flydream0/article/details/8589667" target="_blank" rel="noopener">时钟中断是 rt-thread 的线程调度器的驱动力</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用故事说透 HTTPS]]></title>
      <url>/2019/12/12/KnowHttpsThroughStory/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/MfvUuitrF8MN16nxyZNB8A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MfvUuitrF8MN16nxyZNB8A</a></p>
</blockquote>
<a id="more"></a>

<p>&emsp;&emsp;故事中的主演：</p>
<figure class="image-box">
                <img src="1.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小华今年上大一，这是她第一次离开父母，独自一人到北京上学。今天妈妈的生日，想了想要给妈妈一个祝福，便给妈妈发了条消息：</p>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;妈妈收到这条消息非常开心，女儿这么忙还能记得自己的生日，两个人便开始聊了起来。妈妈知道女儿一直省吃俭用，决定给女儿打点钱过去。</p>
<figure class="image-box">
                <img src="3.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小黑是个黑客，专搞一些“偷鸡摸狗”的事情，他已经监听了这对母女的对话。一直看着她们唠家常，都快睡着了。</p>
<figure class="image-box">
                <img src="4.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;直到看到母女提到钱的事情，立马打起精神，决定搞一笔。然后他截获了小华的消息，替换成自己精心准备的内容给小华的妈妈发过去了。</p>
<figure class="image-box">
                <img src="5.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小华的妈妈随后就把钱打给了小华，未曾想到母女二人的聊天内容尽在小黑的掌控之中。小黑拿到钱后就逃之夭夭了。</p>
<blockquote>
<p>&emsp;&emsp;HTTP 协议是建立在 TCP 之上的，TCP 是否安全决定了 HTTP 是否安全。HTTP的报文内容并未加密，容易被监听和篡改。小黑就监听了母女二人的聊天内容，并对内容进行了篡改，伪装成女儿进行聊天。所以 HTTP 有以下 3 个问题：</p>
<ol>
<li>内容未加密，容易被监听，都是明文传输；</li>
<li>无法验证内容的完整性，容易被篡改，也就是说不知道消息是不是被修改过；</li>
<li>无法验证对方的身份，我现在聊天的人是谁，可靠吗？</li>
</ol>
</blockquote>
<p>&emsp;&emsp;小华被骗后，心里很难过，把这件事告诉了她的计算机老师王大强。王老师听到被骗的经历，感到非常惊讶，消息为什么会被篡改呢！立马查看了她们使用的聊天软件，原来这个软件直接使用的是 TCP 协议，没有做安全措施。<br>&emsp;&emsp;研究完软件后，大强对小华说：“这款软件有问题，以后别用了，要用具有安全措施的软件，比如使用 TLS/SSL 协议的软件”。<br>&emsp;&emsp;小华说：“什么是 TLS/SSL 呢？”。大强看到小华诚恳的表情，决定把 HTTPS 的原理告诉她，但是想到她可能理解不了，然后决定剖析一下她和妈妈被骗的场景。<br>&emsp;&emsp;既然小华和她妈妈的聊天内容是明文传输的，那直接把内容加密不就完事了吗。小华和她妈妈就约定了一个密码，所有的内容都通过这个密码进行加密和解密。</p>
<figure class="image-box">
                <img src="6.webp" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;这种加密方式称为对称加密，加密解密都是通过同一个密码来操作，所以需要保证密码的安全，一旦泄露，后果很严重。</p>
</blockquote>
<p>&emsp;&emsp;小华立马觉察到事情的不妙，密码如何才能传给她妈妈呢。只能双方见面后来约定一个密码。但是她想到远在美国的爸爸，如果向他要钱的话，需要飞往美国把密码告诉他。这太麻烦了。<br>&emsp;&emsp;王大强老师说：“别急，还有更好的方法”。那就使用两个密钥，一个用来加密（称为私钥），另一个用来解密（称为公钥），使用私钥加密过的内容，只能通过公钥进行解密。私钥只有自己有，公钥可以丢给别人。</p>
<figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小华和妈妈，只把公钥交给对方就行。小华给妈妈发消息的时候，用妈妈的公钥进行加密，私钥只有妈妈有，也就是说只有妈妈能解密。</p>
<blockquote>
<p>&emsp;&emsp;这种加密方式称为非对称加密，会有二个钥匙，一个钥匙加密过的内容只能通过另一个钥匙进行解密。至于为啥要说<strong>公钥加密私钥解密</strong>，虽然两个钥匙都可以进行加密解密，但是公钥加密私钥解密这种说法不是更好理解吗？公钥被人都知道，私钥只有自己知道。</p>
</blockquote>
<p>&emsp;&emsp;小华想了想觉得还是有点不安全，假如她和妈妈进行交换公钥的时候，被小黑监听了。<br>&emsp;&emsp;小华把自己的公钥 <code>xiaohua_pub</code> 发给妈妈，中途被小黑掉包了，小黑把自己的公钥 <code>xiaohei_pub</code> 发给了小华的妈妈。这样小华妈妈发消息的时候就使用了小黑的公钥进行了加密，小黑获取到消息表可以用自己的私钥进行解密。</p>
<figure class="image-box">
                <img src="8.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;妈妈发送自己的公钥给小华的时候也被小黑掉包了，这时小黑就有了双方的公钥。</p>
<figure class="image-box">
                <img src="9.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;小黑监听到小华要求妈妈打钱的消息，对消息进行了篡改。</p>
<figure class="image-box">
                <img src="10.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;王大强老师听完小华的疑虑，竖起了大拇指，说道：“别急，听我慢慢解释”。<br>&emsp;&emsp;现在的问题是出在交换公钥的时候被小黑调包了，那接下来就需要解决这个问题。如何才能把公钥安全地送到对方手上。<br>&emsp;&emsp;这似乎是永远解不了的问题，毕竟公钥始终是要经过传输的。这似乎是一个鸡生蛋蛋生鸡的问题。后来小华想了想他平时网上购物的时候，以前总是担心怕付款了，商家跑路不给发货，自从有了淘宝这个第三方机构，毕竟阿里家大业大，值得信赖，即使商家跑路了可以找淘宝。<br>&emsp;&emsp;后来就出现了关于公钥的认证机构，这些认证机构很少，但非常权威，它会和电脑、浏览器等厂商达成信任关系，提前把认证机构的公钥安装到系统中，这样就不会涉及到传输的问题了。</p>
<figure class="image-box">
                <img src="11.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在聊天的过程中，小华发现消息发送和接收的时候很慢，后来发现因为是加密算法耗费比较长的时间。小华想了想，使用对称加密的时候，唯一的缺点是交换秘钥比较麻烦，但是速度非常快。那么可以通过非对称加密来传输对称加密的密钥，密钥传输成功后，使用对称加密来加密消息。</p>
<figure class="image-box">
                <img src="12.webp" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;到此，你理解如何保证通信安全了吗？</p>
<blockquote>
<p>&emsp;&emsp;HTTP 属于应用层协议，HTTPS 并不是一个新的协议，它只是比 HTTP 协议多了一层（TLS/SSL）来保证数据传输安全。TLS/SSL也属于协议，它的主要作用是保证数据传输安全。大多数使用的是 OpenSSL 来实现，比如 Node 中的 TLS 就是基于 OpenSSL 实现的。</p>
</blockquote>
<figure class="image-box">
                <img src="13.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;本文以故事的形式介绍了 HTTP 的不安全，保证 HTTPS 安全性的背后支持，包含数字证书、数字签名、对称加密、非对称加密的概念，当然光有理论还不行，需要实践才能更好地理解。大家加油。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为 WPF, UWP 及 Xamarin 实现一个简单的消息组件]]></title>
      <url>/2019/12/10/ASimpleMessageComponent/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/PfFN_U0Yd6G3tZqpr1AwXg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/PfFN_U0Yd6G3tZqpr1AwXg</a></p>
</blockquote>
<a id="more"></a>

<p>本文目录：</p>
<ol>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#介绍">介绍</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Message-消息">Message - 消息</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Subscription-订阅">Subscription - 订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#MessengerHub-消息总线">MessageHub - 消息总线</a><ol>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Subscribe-订阅">Subscribe - 订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Unsubscribe-取消订阅">Unsubscribe - 取消订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#Publish-发布">Publish - 发布</a></li>
</ol>
</li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#用法">用法</a><ol>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#从NuGet安装">从 NuGet 安装</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#创建-Message-类">创建 Message 类</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#订阅">订阅</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#发布-Message">发布 Message</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#参数">参数</a></li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#取消订阅">取消订阅</a></li>
</ol>
</li>
<li><a href="https://tao-lol.top/2019/12/10/ASimpleMessageComponent/#与-MvvmCross-Messenger-的差异">与 MvvmCross.Messenger 的差异</a></li>
</ol>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Sub-Pub 模式是一种常用的设计模式，用来在系统的不同组件中传递消息。发送消息的称为 Publisher，接收消息的称为 Subscriber。双方一般不需要知道对方的存在，由一个代理负责消息的传递。其结构如图所示：<br><img src="640.webp" alt=" "><br>&emsp;&emsp;最初的需求是我需要开发一个实现 Socket 发送/接收的WPF应用程序。首先，我应用 MVVM 模式创建了一个基本的 WPF 应用程序。然后，我创建了另一个项目来完成所有与 Socket 通信有关的工作。接下来，我必须将 Socket 项目集成到 ViewModel 项目中，以操作 Socket 连接。<br>&emsp;&emsp;显然，我们可以为此使用 <code>Event</code>。例如，我们可以有一个名为 <code>SocketServer</code> 的类，该类具有一个事件来接收 Socket 数据包，然后在 <code>ViewModel</code> 层中对其进行订阅。但这意味着我们必须在 <code>ViewModel</code> 层中创建 <code>SocketServer</code> 类的实例，该类将 <code>ViewModel</code> 层与 Socket 项目耦合在一起。我希望创建一个中间件以解耦它们。 这样，发布者和订阅者就不需要知道对方的存在了。<br>&emsp;&emsp;MvvmCross 提供了一个名为 <strong>Messenger</strong> 的插件以在 ViewModel 之间进行通信。但它依赖于某些 MvvmCross 组件，这意味着如果我想在其他项目中使用此插件，则必须引用 MvvmCross。这对我当前的情况而言并不理想，因为实际上，Socket 项目没有必要引用 MvvmCross。因此，我做了一个专注于发布/订阅模式的项目，并删除了对 MvvmCross 的依赖。现在，可以在任何 WPF，UWP 和 Xamarin 项目中重复使用它。我已将其发布到 GitHub 上：<a href="https://github.com/yanxiaodi/CoreMessenger" target="_blank" rel="noopener">https://github.com/yanxiaodi/CoreMessenger</a> ，并发布了 NuGet 包：<a href="https://www.nuget.org/packages/FunCoding.CoreMessenger/" target="_blank" rel="noopener">https://www.nuget.org/packages/FunCoding.CoreMessenger/</a> 。本文仅介绍该组件的实现细节，后面会再写一篇文章介绍如何使用 Azure DevOps 实现 CI/CD。<br>&emsp;&emsp;下面让我们了解一下 Sub-Pub 模式的一种实现方式。  </p>
<h1 id="Message-消息"><a href="#Message-消息" class="headerlink" title="Message - 消息"></a>Message - 消息</h1><p>&emsp;&emsp;Message 是在此系统中表示消息的抽象类：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">object</span> Sender &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Message</span>(<span class="params"><span class="keyword">object</span> sender</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Sender = sender ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们需要从该抽象类派生不同消息的实例。它有一个名为 <code>sender</code> 的参数，因此订阅者可以获取发送者的实例。但这并不是强制性的。  </p>
<h1 id="Subscription-订阅"><a href="#Subscription-订阅" class="headerlink" title="Subscription - 订阅"></a>Subscription - 订阅</h1><p>&emsp;&emsp;<code>BaseSubscription</code> 是订阅的基类。代码如下：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseSubscription</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> SubscriptionPriority Priority &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Tag &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Invoke</span>(<span class="params"><span class="keyword">object</span> message</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BaseSubscription</span>(<span class="params">SubscriptionPriority priority, <span class="keyword">string</span> tag</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Id = Guid.NewGuid();</span><br><span class="line">        Priority = priority;</span><br><span class="line">         Tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它有一个 <code>Id</code> 属性和一个 <code>tag</code> 属性，因此您可以放置一些标签来区分或分组订阅实例。<code>Priority</code> 属性是一个枚举类型，用于指示订阅的优先级，因此将按预期顺序调用订阅。订阅有两种类型，一是强引用订阅 <code>StrongSubscription</code>：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class StrongSubscription&lt;TMessage&gt; : BaseSubscription where TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Action&lt;TMessage&gt; _action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrongSubscription</span>(<span class="params">Action&lt;TMessage&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">        SubscriptionPriority priority, <span class="keyword">string</span> tag</span>): <span class="title">base</span>(<span class="params">priority, tag</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _action = action;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Invoke</span>(<span class="params"><span class="keyword">object</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> typedMessage = message <span class="keyword">as</span> TMessage;</span><br><span class="line">        <span class="keyword">if</span> (typedMessage == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Unexpected message <span class="subst">&#123;message.ToString()&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; _action?.Invoke(typedMessage));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它继承了 <code>BaseSubscription</code> 并覆盖了 <code>Invoke()</code> 方法。基本上，它具有一个名为 <code>_action</code> 的字段，该字段在创建实例时定义。当我们发布消息时，订阅将调用 <code>Invoke()</code> 方法来执行该 <code>_action</code> 。我们使用 <code>Task</code> 来包装动作，以便可以利用异步操作的优势。<br>&emsp;&emsp;这是名为 <code>WeakSubscription</code> 的另一种订阅：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class WeakSubscription&lt;TMessage&gt; : BaseSubscription where TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> WeakReference&lt;Action&lt;TMessage&gt;&gt; _weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakSubscription</span>(<span class="params">Action&lt;TMessage&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">        SubscriptionPriority priority, <span class="keyword">string</span> tag</span>) : <span class="title">base</span>(<span class="params">priority, tag</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _weakReference = <span class="keyword">new</span> WeakReference&lt;Action&lt;TMessage&gt;&gt;(action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">async</span> Task&lt;<span class="keyword">bool</span>&gt; <span class="title">Invoke</span>(<span class="params"><span class="keyword">object</span> message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> typedMessage = message <span class="keyword">as</span> TMessage;</span><br><span class="line">        <span class="keyword">if</span> (typedMessage == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">$"Unexpected message <span class="subst">&#123;message.ToString()&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Action&lt;TMessage&gt; action;</span><br><span class="line">        <span class="keyword">if</span> (!_weakReference.TryGetTarget(<span class="keyword">out</span> action))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> Task.Run(() =&gt; action?.Invoke(typedMessage));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它与强引用订阅的区别在于 action 存储在 <code>WeakReference</code> 字段中。您可以在这里了解更多信息： <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.weakreference-1" target="_blank" rel="noopener">WeakReference 类</a>。它用于表示类型化的弱引用，该弱引用引用一个对象，同时仍允许该对象被垃圾回收回收。在使用它之前，我们需要使用 <code>TryGetTarget(T)</code> 方法检查目标是否已由 GC 收集。如果此方法返回 false，则表示该引用已被 GC 收集。<br>&emsp;&emsp;如果使用 <code>StrongSubscription</code>，Messenger 将保留对回调方法的强引用，并且 Garbage Collection 将不会破坏订阅。在这种情况下，您需要明确取消订阅，以避免内存泄漏。否则，可以使用 <code>WeakSubscription</code>，当对象超出范围时，会自动删除订阅。  </p>
<h1 id="MessengerHub-消息总线"><a href="#MessengerHub-消息总线" class="headerlink" title="MessengerHub - 消息总线"></a>MessengerHub - 消息总线</h1><p>&emsp;&emsp;<code>MessengerHub</code> 是整个应用程序域中的一个单例实例。我们不需要使用依赖注入来创建实例，因为它的目的很明确，我们只有一个实例。这是实现单例模式的简单方法：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessengerHub</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;MessengerHub&gt; lazy = <span class="keyword">new</span> Lazy&lt;MessengerHub&gt;(() =&gt; <span class="keyword">new</span> MessengerHub());</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MessengerHub</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MessengerHub Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lazy.Value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.weakreference-1" target="_blank" rel="noopener">WeakReference 类</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.lazy-1" target="_blank" rel="noopener">Lazy&#60;T&#62; 类</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent.concurrentdictionary-2" target="_blank" rel="noopener">ConcurrentDictionary&#60;TKey,TValue&#62; 类</a></p>
</blockquote>
<p>&emsp;&emsp;<code>MessengerHub</code> 在其内部维护一个 <code>ConcurrentDictionary</code> 来管理订阅的实例，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;Type, ConcurrentDictionary&lt;Guid, BaseSubscription&gt;&gt; _subscriptions =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentDictionary&lt;Type, ConcurrentDictionary&lt;Guid, BaseSubscription&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该 <code>ConcurrentDictionary</code> 的 Key 是 <code>Message</code> 的类型，Value 是一个 <code>ConcurrentDictionary</code>，其中包含该特定 <code>Message</code> 的一组订阅。显然，一种类型可能具有多个订阅。  </p>
<h2 id="Subscribe-订阅"><a href="#Subscribe-订阅" class="headerlink" title="Subscribe - 订阅"></a>Subscribe - 订阅</h2><p>&emsp;&emsp;<code>MessageHub</code> 公开了几种重要的方法来订阅/取消订阅/发布消息。<br>&emsp;&emsp;<code>Subscribe()</code> 方法如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SubscriptionToken Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action,</span><br><span class="line">    ReferenceType referenceType = ReferenceType.Weak,</span><br><span class="line">    SubscriptionPriority priority = SubscriptionPriority.Normal, <span class="keyword">string</span> tag = <span class="literal">null</span>) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(action));</span><br><span class="line">    &#125;</span><br><span class="line">    BaseSubscription subscription = BuildSubscription(action, referenceType, priority, tag);</span><br><span class="line">    <span class="keyword">return</span> SubscribeInternal(action, subscription);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SubscriptionToken SubscribeInternal&lt;TMessage&gt;(Action&lt;TMessage&gt; action, BaseSubscription subscription)</span><br><span class="line">    <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_subscriptions.TryGetValue(<span class="keyword">typeof</span>(TMessage), <span class="keyword">out</span> <span class="keyword">var</span> messageSubscriptions))</span><br><span class="line">    &#123;</span><br><span class="line">        messageSubscriptions = <span class="keyword">new</span> ConcurrentDictionary&lt;Guid, BaseSubscription&gt;();</span><br><span class="line">        _subscriptions[<span class="keyword">typeof</span>(TMessage)] = messageSubscriptions;</span><br><span class="line">    &#125;</span><br><span class="line">    messageSubscriptions[subscription.Id] = subscription;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SubscriptionToken(subscription.Id, <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> UnsubscribeInternal&lt;TMessage&gt;(subscription.Id), action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们订阅消息时，会创建 <code>Subscription</code> 的实例并将其添加到字典中。根据您的选择，它可能是强引用或者弱引用。然后它将创建一个 <code>SubscriptionToken</code>，这是一个实现 <code>IDisposable</code> 接口来管理订阅的类：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SubscriptionToken</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Guid Id &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> Action _disposeMe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _dependentObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubscriptionToken</span>(<span class="params">Guid id, Action disposeMe, <span class="keyword">object</span> dependentObject</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Id = id;</span><br><span class="line">        _disposeMe = disposeMe;</span><br><span class="line">        _dependentObject = dependentObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dispose(<span class="literal">true</span>);</span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"><span class="keyword">bool</span> isDisposing</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDisposing)</span><br><span class="line">        &#123;</span><br><span class="line">            _disposeMe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们创建 <code>SubscriptionToken</code> 的实例时，实际上我们传递了一个方法来销毁自己-因此，当调用 <code>Dispose</code> 方法时，它将首先取消订阅。  </p>
<h2 id="Unsubscribe-取消订阅"><a href="#Unsubscribe-取消订阅" class="headerlink" title="Unsubscribe - 取消订阅"></a>Unsubscribe - 取消订阅</h2><p>&emsp;&emsp;取消订阅消息的方法如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Unsubscribe&lt;TMessage&gt;(SubscriptionToken subscriptionToken) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">await</span> UnsubscribeInternal&lt;TMessage&gt;(subscriptionToken.Id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">async</span> Task UnsubscribeInternal&lt;TMessage&gt;(Guid subscriptionId) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_subscriptions.TryGetValue(<span class="keyword">typeof</span>(TMessage), <span class="keyword">out</span> <span class="keyword">var</span> messageSubscriptions))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageSubscriptions.ContainsKey(subscriptionId))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = messageSubscriptions.TryRemove(subscriptionId, <span class="keyword">out</span> BaseSubscription <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码很容易理解。当我们取消订阅消息时，订阅将从字典中删除。  </p>
<h2 id="Publish-发布"><a href="#Publish-发布" class="headerlink" title="Publish - 发布"></a>Publish - 发布</h2><p>&emsp;&emsp;我们已经订阅了消息，并创建了存储在字典中的订阅实例。现在可以发布消息了。发布消息的方法如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Publish&lt;TMessage&gt;(TMessage message) <span class="keyword">where</span> TMessage : Message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (message == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(message));</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;BaseSubscription&gt; toPublish = <span class="literal">null</span>;</span><br><span class="line">    Type messageType = message.GetType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_subscriptions.TryGetValue(messageType, <span class="keyword">out</span> <span class="keyword">var</span> messageSubscriptions))</span><br><span class="line">    &#123;</span><br><span class="line">        toPublish = messageSubscriptions.Values.OrderByDescending(x =&gt; x.Priority).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toPublish == <span class="literal">null</span> || toPublish.Count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Guid&gt; deadSubscriptionIds = <span class="keyword">new</span> List&lt;Guid&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> subscription <span class="keyword">in</span> toPublish)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Execute the action for this message.</span></span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> subscription.Invoke(message);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">        &#123;</span><br><span class="line">            deadSubscriptionIds.Add(subscription.Id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deadSubscriptionIds.Any())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> PurgeDeadSubscriptions(messageType, deadSubscriptionIds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们发布一条消息时，<code>MessageHub</code> 将查询字典以检索该消息的订阅列表，然后循环执行操作。<br>&emsp;&emsp;需要注意的另一件事是，由于某些订阅可能是弱引用，因此需要检查执行结果。如果引用已经被 GC 收集，则执行结果会返回 false，这时候需要将该订阅从订阅列表中删除。  </p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="从NuGet安装"><a href="#从NuGet安装" class="headerlink" title="从NuGet安装"></a>从NuGet安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package FunCoding.CoreMessenger</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在整个应用程序域中，将 <code>MessengerHub.Instance</code> 用作单例模式。它提供了以下方法：  </p>
<ul>
<li><p>发布：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Publish&lt;TMessage&gt;(TMessage message)</span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SubscriptionToken Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action, ReferenceType referenceType = ReferenceType.Weak, SubscriptionPriority priority = SubscriptionPriority.Normal, <span class="keyword">string</span> tag = <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消订阅：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task Unsubscribe&lt;TMessage&gt;(SubscriptionToken subscriptionToken)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建-Message-类"><a href="#创建-Message-类" class="headerlink" title="创建 Message 类"></a>创建 <code>Message</code> 类</h2><p>&emsp;&emsp;首先，定义一个从 <code>Message</code> 继承的类，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestMessage</span> : <span class="title">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ExtraContent &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestMessage</span>(<span class="params"><span class="keyword">object</span> sender, <span class="keyword">string</span> content</span>) : <span class="title">base</span>(<span class="params">sender</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ExtraContent = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在组件A中创建 <code>Message</code> 的实例，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> TestMessage(<span class="keyword">this</span>, <span class="string">"Test Content"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p>&emsp;&emsp;定义一个 <code>SubscriptionToken</code> 实例来存储订阅。在组件 B 中订阅消息，如下所示：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HomeViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> SubscriptionToken _subscriptionTokenForTestMessage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HomeViewModel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _subscriptionTokenForTestMessage =</span><br><span class="line">            MessengerHub.Instance.Subscribe&lt;TestMessage&gt;(OnTestMessageReceived,</span><br><span class="line">            ReferenceType.Weak, SubscriptionPriority.Normal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTestMessageReceived</span>(<span class="params">TestMessage message</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">        System.Diagnostics.Debug.WriteLine(<span class="string">$"Received messages of type <span class="subst">&#123;message.GetType().ToString()&#125;</span>. Content: <span class="subst">&#123;message.Content&#125;</span>"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布-Message"><a href="#发布-Message" class="headerlink" title="发布 Message"></a>发布 <code>Message</code></h2><p>&emsp;&emsp;在组件 A 中发布消息：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">PublishMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> MessengerHub.Instance.Publish(<span class="keyword">new</span> TestMessage(<span class="keyword">this</span>, <span class="string">$"Hello World!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就是这么简单。  </p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&emsp;&emsp;<code>Subscribe</code> 方法的完整签名为：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SubscriptionToken Subscribe&lt;TMessage&gt;(Action&lt;TMessage&gt; action,  ReferenceType referenceType = ReferenceType.Weak, SubscriptionPriority priority = SubscriptionPriority.Normal,  <span class="keyword">string</span> tag = <span class="literal">null</span>) <span class="keyword">where</span> TMessage : Message</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;您可以指定以下参数：</p>
<ul>
<li><code>ReferenceType</code>。默认值为 <code>ReferenceType.Weak</code>，因此您不必担心内存泄漏。一旦 <code>SubscriptionToken</code> 实例超出范围，GC 便可以自动收集它（但不确定何时）。如果需要保留强引用，请将参数指定为 <code>ReferenceType.Strong</code>，以使 GC 无法收集它。</li>
<li><code>SubscriptionPriority</code>。默认值为 <code>SubscriptionPriority.Normal</code>。有时需要控制一个“消息”的订阅的执行顺序。在这种情况下，请为订阅指定不同的优先级以控制执行顺序。注意，该参数不适用于不同的 <code>Message</code>。</li>
<li><code>Tag</code>。为订阅指定一个标签，是可选的。</li>
</ul>
<h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p>&emsp;&emsp;您可以使用以下方法取消订阅：  </p>
<ul>
<li><p>使用 <code>Unsubscribe</code> 方法，如下所示：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> MessengerHub.Instance.Unsubscribe&lt;TestMessage&gt;(_subscriptionTokenForTestMessage);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>SubscriptionToken</code> 的 <code>Dispose</code> 方法：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_subscriptionTokenForTestMessage.Dispose();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&emsp;&emsp;在许多情况下，您不会直接调用这些方法。如果使用强订阅类型，则可能会导致内存泄漏问题。因此，建议使用 <code>ReferenceType.Weak</code>。请注意，如果令牌未存储在上下文中，则 GC 可能会立即收集它。例如：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MayNotEverReceiveAMessage</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> token = MessengerHub.Instance.Subscribe&lt;TestMessage&gt;((message) =&gt; &#123;</span><br><span class="line">        <span class="comment">// Do something here</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// token goes out of scope now</span></span><br><span class="line">    <span class="comment">// - so will be garbage collected *at some point*</span></span><br><span class="line">    <span class="comment">// - so the action may never get called</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与-MvvmCross-Messenger-的差异"><a href="#与-MvvmCross-Messenger-的差异" class="headerlink" title="与 MvvmCross.Messenger 的差异"></a>与 MvvmCross.Messenger 的差异</h1><p>&emsp;&emsp;如果您已经使用 <code>MvvmCross</code> 开发应用程序，并无需在 <code>ViewModel</code> 层之外传递消息，请直接使用 <code>MvvmCross.Messenger</code>。我仅实现了一些主要方法，没有提供 UI 线程调度的功能，并删除了对 MvvmCross 组件的依赖，因此只要您的项目目标 .NET Standard 2.0 以上，就可以在任何 WPF，UWP 和 Xamarin 项目中使用。另外，<code>Publish</code> 方法始终在后台运行，以避免阻塞 UI。但是您应该知道何时需要返回 UI 线程，尤其是当您需要与 UI 控件进行交互时。另一个区别是无需使用 DI 来创建 <code>MessageHub</code> 实例，该实例是所有应用程序域中的单例实例。如果解决方案包含需要相互通信的多个组件，则单例模式会比较简单，DI 将使其更加复杂。  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谈谈 .NET 对象生命周期]]></title>
      <url>/2019/12/10/DotNetObjectLifetime/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/MaMaNongNong/p/11945161.html" target="_blank" rel="noopener">https://www.cnblogs.com/MaMaNongNong/p/11945161.html</a></p>
</blockquote>
<a id="more"></a>

<h1 id="不用程序员操心的堆-—-托管堆"><a href="#不用程序员操心的堆-—-托管堆" class="headerlink" title="不用程序员操心的堆 — 托管堆"></a>不用程序员操心的堆 — 托管堆</h1><p>&emsp;&emsp;程序在计算机上跑着，就难免会占用内存资源来存储在程序运行过程中的数据，我们按照内存资源的存取方式将内存划分为<strong>堆内存</strong>和<strong>栈内存</strong>。  </p>
<p>&emsp;&emsp;<strong>栈内存</strong>，通常使用的场景是：<strong>对存取速度要求较高且数据量不大</strong>。  </p>
<p>&emsp;&emsp;典型的栈内存使用的例子就是函数栈，每一个函数被调用时都会被分配一块内存，这块内存被称为栈内存，以先进后出的方式存取数据，在函数执行过程中不断往函数栈中压入（PUSH）数据（值类型数据：int、float、对象的引用…），函数执行完后又将函数栈中的数据逐个弹出（POP）,由于是以操作栈的形式来存取，所以访问速度快。</p>
<figure class="image-box">
                <img src="1342524-20191129211615998-1924248009.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;<strong>堆内存</strong>，从字面意思上理解就好像是仓库里面可以存一堆破烂，你若是需要存点什么东西就尽管往里面一扔，仓库里有的是空间。事实确实也是如此，<strong>堆内存中可以存放大规格的数据（比如对象资源）</strong>，这些数据是不适合存放在栈中的，因为栈空间的容量有限，这就是<strong>堆内存相对于栈内存的好处：容量大</strong>。但是它的缺点也是显而易见的，那就是<strong>存取堆内存的数据相较于存取栈内存是非常慢的</strong>，试想一下，让你在仓库里的一堆破烂里去找你想要的东西是什么感觉。<br>&emsp;&emsp;（栈内存比堆内存详细参考：<a href="https://blog.csdn.net/boyxiaolong/article/details/8543676" target="_blank" rel="noopener">https://blog.csdn.net/boyxiaolong/article/details/8543676</a> ）</p>
<figure class="image-box">
                <img src="1342524-20191129211711033-1091141984.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;从内存分配方式上看，堆内存不同于栈内存，函数栈是在每一个函数被执行的时候被自动分配并且函数执行完成后自动回收，而如果你想使用堆内存，就得自己动手丰衣足食。<br>&emsp;&emsp;所以你会看到 C 语言程序员会这样去使用堆内存：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">//在堆内存中申请一块字节数为 int 字节数的堆内存，并返回指向该内存区域的指针</span></span><br><span class="line">*p = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放堆内存资源</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你还会看见 C++ 程序员这样写：  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car* bmw = <span class="keyword">new</span> Car(); <span class="comment">//创建一个 Car 类对象，在堆内存中存放对象数据，并返回指向对象资源的指针</span></span><br><span class="line"><span class="keyword">delete</span> bmw; <span class="comment">//释放堆内存资源</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，没有接触过 C/C++ 的小伙伴也不用惊慌，上面只不过是想让你知道在 C/C++ 语言中，程序员要是想使用堆内存，那就必须显式地编写分配和释放堆内存资源的代码。<br>&emsp;&emsp;有人问：<strong>使用完堆内存资源后没有手动释放它会有什么后果吗？</strong><br>&emsp;&emsp;答案是：<strong>由于堆内存资源使用者未及时释放内存会导致内存无法再次使用，从而造成内存资源的泄漏（浪费）。</strong>  </p>
<p>&emsp;&emsp;就在这个时候，C# 程序员笑了，只见他的手指非常轻盈优雅地在屏幕上敲出了下面这行代码：  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car bmw = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一旁围观的 C 程序员和 C++ 程序员惊呆了，他们不知道自己在敲代码的时候有没有像这样轻松过。C++ 程序员用手抚摸着他那锃光瓦亮的额头，突然眼睛里闪着光，喊道：“你还没有释放堆内存的资源呢，你这样是很危险的，会内存泄漏的，快，把释放堆内存的代码写上！”<br>&emsp;&emsp;C# 程序员似乎并不为所动，舒舒服服地靠在椅子上，用余光瞟了 C++ 程序员一眼，说：“不用慌，不用慌，这个对象在托管堆上放的好好的呢，不用我操心”，于是，C# 程序员便娓娓道来（呼呼大睡）…  </p>
<p>&emsp;&emsp;在 .NET 的世界，使用 new 关键字创建一个对象，首先对象资源被分配在托管堆中，然后 new 会返回一个指向堆上对象的引用，而不是真正的对象本身。如果在方法作用域中将引用变量声明为本地变量，这个引用变量保存在栈内，以供应用程序以后使用。</p>
<figure class="image-box">
                <img src="1342524-20191129204844737-1513276184.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;托管堆，顾名思义，就是托给别人管的堆，<strong>那么是谁在管理着这个堆上的对象资源呢</strong>？<br>&emsp;&emsp;答案是：<strong>CLR(Common Lanauage Runtime)，对象的实例化结束以后，GC(垃圾回收器)将会在对象不再需要时将其销毁。</strong><br>&emsp;&emsp;也就是说，通过允许垃圾收集器负责销毁对象，内存管理的麻烦就都交给 CLR 了，万事大吉。</p>
<figure class="image-box">
                <img src="1342524-20191208140136612-550090463.png" alt title class>
                <p></p>
            </figure>

<figure class="image-box">
                <img src="1342524-20191208140511470-318156524.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;看似问题好像都已水落石出，无非就是将堆内存资源回收交给了 CLR 去承担。难道你就不想知道的更多一点？比如接着而来的问题：<br>&emsp;&emsp;1、<strong>垃圾回收器如何判断一个对象什么时候不再需要？</strong><br>&emsp;&emsp;2、<strong>垃圾回收器又在什么时候会执行垃圾清理的操作？</strong><br>&emsp;&emsp;别急，带着问题慢慢往下看。</p>
<h1 id="CIL-的-new-指令-—-垃圾回收的触发者"><a href="#CIL-的-new-指令-—-垃圾回收的触发者" class="headerlink" title="CIL 的 new 指令 — 垃圾回收的触发者"></a>CIL 的 new 指令 — 垃圾回收的触发者</h1><p>&emsp;&emsp;C# 中的 <strong>new 关键字最终会被编译器翻译成 CIL 的 newobj 指令</strong>，让我们仔细查看一下 CIL newobj 指令的作用。</p>
<figure class="image-box">
                <img src="1342524-20191130210833848-114463754.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;首先，需要明白托管堆不仅仅是一个可由 CLR 访问的随机内存块。.NET 垃圾回收器是堆的“清洁工”，出于优化的目的它会压缩空闲的内存块（当需要时）。为了辅助压缩，托管堆会维护一个指针(通常被叫做下一个对象指针或者是新对象指针），这个指针用来标识下一个对象在堆中分配的地址。  </p>
<p>&emsp;&emsp;此外，newobj 指令通知 CLR 来执行下列的核心任务：</p>
<ol>
<li><strong>计算要分配的对象所需的全部内存（包括这个类型的数据成员和类型的基类所需的内存）。</strong></li>
<li><strong>检查托管堆来确保有足够的空间来放置所申请的对象。如果有足够的空间，会调用这个类型的构造函数，构造函数会返回一个指向内存中这个新对象的引用，这个新对象的地址刚好就是下一个对象指针上一次所指向的位置。</strong></li>
<li><strong>最后，在把引用返回给调用者之前，让下一个对象指针指向托管堆中下一个可用的位置。</strong></li>
</ol>
<p>&emsp;&emsp;下面的图解释了在托管堆上分配对象的细节。</p>
<figure class="image-box">
                <img src="1342524-20191129213725028-699571306.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 C# 中分配对象是一个很频繁的操作，照这样下去托管堆上的空间迟早会被挥霍完，所以，重点来了，<strong>如果 CLR 发现托管堆没有足够空间分配请求的类型时，它会执行一次垃圾回收来释放内存。</strong><br>&emsp;&emsp;当执行垃圾回收时，垃圾收集器临时挂起当前进程中的所有的活动线程来保证在回收过程中应用程序不会访问到堆。（一个线程是一个正在执行的程序中的执行路径）。一旦垃圾回收完成，挂起的线程又可以继续执行了。还好，.NET 垃圾回收器是高度优化过的，所以用户很少能察觉到应用程序中的短暂中断。<br>&emsp;&emsp;通过对 CIL 的 new 指令作用的解读，我们知道了：<strong>如果托管堆没有足够的空间分配一个请求的对象，则会执行一次垃圾回收。</strong>  </p>
<p>&emsp;&emsp;（讲到这里 C# 程序员停了下来，喝了口保温杯里的枸杞红枣大补茶🍵，清了清嗓子，继续开始解惑…）  </p>
<h1 id="应用程序根的作用-—-区分不可到达的对象"><a href="#应用程序根的作用-—-区分不可到达的对象" class="headerlink" title="应用程序根的作用 — 区分不可到达的对象"></a>应用程序根的作用 — 区分不可到达的对象</h1><p>&emsp;&emsp;现在让我们来讨论一下垃圾回收器怎样确定什么时候“<strong>不再需要</strong>”一个对象。为了理解细节，你需要知道应用程序根的概念。  </p>
<p>&emsp;&emsp;简单来说，一个根是一个引用，这个引用指向堆上面的一个对象的。严格来说，一个根可以有以下几种情况：</p>
<ul>
<li><strong>指向全局对象的引用（尽管 C# 不支持，但 CIL 代码允许分配全局对象）</strong></li>
<li><strong>指向任何静态对象</strong></li>
<li><strong>指向一个应用程序代码中的局部对象</strong></li>
<li><strong>指向传入到一个函数中的对象参数</strong></li>
<li><strong>指向等待被终结 ( finalized ) 的对象</strong></li>
<li><strong>任何一个指向对象的CPU寄存器</strong></li>
</ul>
<p>&emsp;&emsp;在一次垃圾回收的过程中，运行环境会检查托管堆上面的对象是否仍然是从应用程序根可到达的。为了检查可达，CLR 会建立一个代表堆上每个可达对象的图。对象图用来记录所有可达的对象。同时，注意垃圾回收器绝不会在图上标记一个对象两次，因此避免了烦人的循环引用。<br>&emsp;&emsp;假设托管堆上有名字为 A, B, C, D, E，F 和 G 的对象集合。在一次垃圾回收过程中，会检查这些对象（同时包括这些对象可能包含的内部对象引用）是否是根可达的。一旦图被建立起来，不可达的对象（在此是对象 C 和 F）被标记为垃圾。<br>&emsp;&emsp;下图是上述场景的一个可能的对象图（你可以把箭头读作依赖或者需要，例如 “ E 依赖于 G，间接依赖于 B， A 不依赖任何对象 ” 等）。</p>
<figure class="image-box">
                <img src="1342524-20191129213805497-1230427436.png" alt="（创建的对象图是用来决定哪些对象是应用程序根可达的。）" title class>
                <p>（创建的对象图是用来决定哪些对象是应用程序根可达的。）</p>
            </figure>

<p>&emsp;&emsp;一旦一个对象已经被标记为终结（此例子中是 C 和 F —— 在图中没有他俩），它在内存中就被清理掉了。在此时，堆上的剩余内存空间被压缩，这会导致 CLR 修改活动的应用程序根集合（和对应的指针）来指向正确的内存位置（这个操作是自动透明的）。最后，调整下一个对象指针来指向下一个可用的内存位置。<br>&emsp;&emsp;下图阐明了清除和压缩堆的过程。</p>
<figure class="image-box">
                <img src="1342524-20191129213816851-479935107.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;到这里，通过对应用程序根的作用的理解，我们知道了如何知道一个对象是“不再需要”的。<strong>通俗点来说就是，这个对象在应用程序中已经无需被访问了，成为了一座“孤岛”，自然也就不再需要它了。</strong>  </p>
<p>&emsp;&emsp;（为了让 C++ 程序员能更加理解 .NET 垃圾回收的奥妙，C# 程序员继续滔滔不绝…）  </p>
<h1 id="理解对象的代-—-垃圾回收过程的优化"><a href="#理解对象的代-—-垃圾回收过程的优化" class="headerlink" title="理解对象的代 — 垃圾回收过程的优化"></a>理解对象的代 — 垃圾回收过程的优化</h1><p>&emsp;&emsp;在尝试找到不可达的对象时，CLR 并不是检查托管堆上的每个对象。很明显，这样做会消耗大量时间，尤其在大型（例如现实中）程序中。<br>&emsp;&emsp;为了帮助优化这个过程，堆上的每个对象被分配到一个特殊的”代”。代这个概念背后的想法很简单：<strong>对象在堆上存活的时间越长，接下来它继续存在的可能性也就越大，即较旧的对象生存期长，较新的对象生存期短。</strong>例如，实现 Main() 的对象一直在内存中，直到程序结束。相反，最近才被放到堆中的对象（例如在一个函数范围里分配的对象）很可能很快就不可达。  </p>
<p>&emsp;&emsp;<strong>在堆上的每个对象属于以下的某一个代：</strong></p>
<ul>
<li><strong>Generation 0： 标识一个最近分配的还没有被标记为回收的对象</strong></li>
<li><strong>Generation 1： 标识一个经历了一次垃圾回收而存活下来的对象（例如，他被标记为回收，但由于堆空间够用而没有被清除掉）</strong></li>
<li><strong>Generation 2：标识一个经历了不止一轮垃圾回收而存活下来的对象。</strong></li>
</ul>
<p>&emsp;&emsp;垃圾回收器首先会检查 Generation 0 的所有对象。如果标记并清理这些对象（译者注：因为新对象的生存期往往较短，并且期望在执行回收时，应用程序不再使用第 0 级托管堆中的许多对象）后产生了足够使用的内存空间，任何存活下来的对象就被提升到 Generation 1。为了理解一个对象的代如何影响回收的过程，可以查看下图。下图解释了 Generation 0 中一次垃圾回收后，存活的对象被提升的过程。</p>
<figure class="image-box">
                <img src="1342524-20191129213837891-1016005857.png" alt="（Generation 0 中的存活对象被提升到 Generation 1）" title class>
                <p>（Generation 0 中的存活对象被提升到 Generation 1）</p>
            </figure>

<p>&emsp;&emsp;如果所有的 Generation 0 对象都被检查了，但是产生的内存空间仍然不够用，就检查一遍 Generation 1 中的所有对象的可达性并回收。存活下来的 Generation 1 对象被提升到 Generation 2。如果垃圾回收器仍然需要额外的内存，Generation 2 的对象就经历检查并被回收。此时，如果一个 Generation 2 的对象存活下来，它仍然是一个 Generation 2 的对象。<br>&emsp;&emsp;其实通过<strong>对象的代的设计是想达到这么一个效果：新对象（比如局部变量）会被很快回收，而老一些的对象（如一个应用程序对象）不会被经常骚扰</strong>。<br>&emsp;&emsp;<strong>说到底，对象代的设计就是为了优化垃圾回收的过程。</strong>  </p>
<p>&emsp;&emsp;“我还有最后一个问题”，C++ 程序员按耐不住心里一直的疑惑，说到：“你说了这么多都是再讲托管资源，难道 .NET 中就没有非托管资源吗？<strong>.NET又是怎么对非托管资源进行资源释放的呢</strong>？”。<br>&emsp;&emsp;”这个问题问的好！”，C# 程序员大笑，于是接着又开始解惑（吹B）…  </p>
<h1 id="构建可终结对象-—-非托管资源处理第一式"><a href="#构建可终结对象-—-非托管资源处理第一式" class="headerlink" title="构建可终结对象 — 非托管资源处理第一式"></a>构建可终结对象 — 非托管资源处理第一式</h1><p>&emsp;&emsp;以一名 C# 开发者的直觉告诉你，大多数的 C# 类都不需要显式的清理逻辑。原因很简单：如果类型使用了其他托管对象，一切都最终会被垃圾回收。<br>&emsp;&emsp;问：<strong>那在什么时候需要显式地清理呢</strong>？<br>&emsp;&emsp;答案是：<strong>在你使用非托管资源时（例如原始的操作系统文件句柄、原始的非托管数据连接或其他非托管资源)，才可能需要设计一个在用完后清理自身垃圾的类</strong>。<br>&emsp;&emsp;比如说下面这个类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在问题来了，我们要在适当的时机调用数据库连接类对象释放资源的方法(SqlConnection 类对象使用完后需要调用 Dispose() 方法释放资源)。<strong>这个适当的时机当然就是对象在被 CLR 进行垃圾回收的过程中，所以问题又来到了，有没有一个方法是在这个时机被调用，而且是可以被扩展的呢</strong>？<br>&emsp;&emsp;是的，我们可以利用 .NET 的基类 System.Object 中定义的名为 Finalize() 的虚方法，也叫作终结器方法，它是这样的：</p>
<figure class="image-box">
                <img src="1342524-20191208133108536-1104990529.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;看到这当然会很奇怪，不是说有 Finalize() 方法，在哪，逗我？莫惊讶，其实<strong>这里的 ~Object() 就是 Finalize()，只是一个语法糖罢了</strong>。<br>&emsp;&emsp;Finalize() 的调用将（最终）发生在一次”自然的”垃圾回收或用程序通过 GC.Collect() 强制回收的过程中，所以这样看来，终结器方法就是让类对象释放内部非托管资源的地方。Nice，现在我们可以像这样来编写清理非托管资源的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line"></span><br><span class="line">    ~SqlDbContext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样被构建的对象被叫做<strong>可终结对象</strong>。<br>&emsp;&emsp;有关于终结过程的细节，在《C# 与 .NET 4 高级程序设计（第 5 版）》书中是这样描述的：</p>
<figure class="image-box">
                <img src="1342524-20191208134332927-532737446.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;从以上的内容我们得知：<strong>通过 Finalize() 来清除非托管资源的时机只能是在 .NET 对象被垃圾回收的过程中，而且终结过程是一个消耗不小的动作。</strong><br>&emsp;&emsp;问题又来了：<strong>很多非托管资源都非常宝贵（如数据库和文件句柄），所以这些资源应该在使用完后尽快地被清除，而不能依靠垃圾回收的发生，那么这些资源应该以怎样的形式被显示地释放呢？</strong></p>
<figure class="image-box">
                <img src="1342524-20191208135319279-807399951.png" alt title class>
                <p></p>
            </figure>


<h1 id="构建可处置对象-—-非托管资源处理第二式"><a href="#构建可处置对象-—-非托管资源处理第二式" class="headerlink" title="构建可处置对象 — 非托管资源处理第二式"></a>构建可处置对象 — 非托管资源处理第二式</h1><p>&emsp;&emsp;除了重写 Finalize() 之外，类还可以实现 IDisposable 接口，它定义了一个名为 Dispose() 的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;它的使用方法就是：在类的 Dispose() 方法中编写非托管资源的释放的代码，程序员可以在这个对象不再需要的时候手动调用对象的 Dispose() 方法来达到及时释放非托管资源的目的。<br>&emsp;&emsp;于是你可以像这样来编写类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span>:<span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;采用这种方式来释放非托管资源的类被称作为<strong>可处置对象</strong>。<br>&emsp;&emsp;在这里还要补充一点，C# 提供了一个语法糖来简化调用 Dispose() 操作，如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SqlDbContext context = <span class="keyword">new</span> SqlDbContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在此作用域内使用 SqlDbContext 类对象 context</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//确保使用完后调用 Dispose() 方法</span></span><br><span class="line">    context.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段代码等同于下面这段代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> (SqlDbContext context = <span class="keyword">new</span> SqlDbContext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在此作用域内使用 SqlDbContext 类对象 context</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;C++ 程序员说：“你这还不是要自己手动调用，如果我忘记调用 Dispose() 那岂不是一切都玩完！”<br>&emsp;&emsp;C# 程序员冷笑一声，“非也，非也，我来传授你最后一招吧！”  </p>
<h1 id="非托管资源最强模式-—-双剑合璧"><a href="#非托管资源最强模式-—-双剑合璧" class="headerlink" title="非托管资源最强模式 — 双剑合璧"></a>非托管资源最强模式 — 双剑合璧</h1><p>&emsp;&emsp;人非圣贤，孰能无过。程序员也会有失手的时候，比如，忘记调用 Dispose() 方法…<br>&emsp;&emsp;这个时候就必须设计一个万无一失的方法，达到一个目的：就是不管有没有手动调用 Dispose()，非托管资源最终都应该被妥妥地释放掉。为了解决这个问题，我们可以如下去定义一个可处置对象类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SqlDbContext</span>:<span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...(其他被引用的对象实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类中包含的非托管资源（需要调用 Dispose() 函数进行资源的释放）</span></span><br><span class="line">    SqlConnection sqlConnection = <span class="keyword">new</span> SqlConnection(<span class="string">"..."</span>);  </span><br><span class="line"></span><br><span class="line">    ~SqlDbContext()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//这里清除非托管资源</span></span><br><span class="line">        <span class="keyword">this</span>.sqlConnection.Dispose();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过终结过程</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，这个类中即有终结方法的重写也有 Dispose() 方法，这样就能保证：<strong>程序员若忘记调用 Dispose() 方法释放非托管资源，那么对象就会在垃圾回收的过程中调用终结方法来释放非托管资源；若程序员调用了 Dispose() 方法，那么 GC.SuppressFinalize(this) 会保证在垃圾回收过程中不再会调用对象的终结方法，避免不必要的资源开销。</strong>可谓“双剑合璧”，保万无一失。  </p>
<p>&emsp;&emsp;话音刚落，C++ 程序员“噗通”一声跪倒在 C# 程序员面前，双手死死拉住 C# 程序员的裤子，”师父，收我为徒吧！我也要学 C#…”,C# 程序员不想自己的裤子被扯破，于是答应了他。掏出一本上古神书…</p>
<figure class="image-box">
                <img src="1342524-20191208145553447-24813107.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;哦，不，拿错了。。。应该是这本。。。</p>
<figure class="image-box">
                <img src="1342524-20191208145754410-945114997.png" alt title class>
                <p></p>
            </figure>

<p>&emsp;&emsp;全剧终…  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TCP 的 “三次握手” 和 “四次挥手”，到底是什么鬼？]]></title>
      <url>/2019/12/10/TcpHandshake/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/OYNDJ9tzfZCIdPMyts2jtw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OYNDJ9tzfZCIdPMyts2jtw</a></p>
</blockquote>
<a id="more"></a>

<h1 id="轻松了解-HTTP-协议"><a href="#轻松了解-HTTP-协议" class="headerlink" title="轻松了解 HTTP 协议"></a>轻松了解 HTTP 协议</h1><p>&emsp;&emsp;为什么要学习网络协议呢？为什么要学习计算机网络呢？显然这很重要，<strong>至少能够帮助你找到工作的原因之一</strong>，学习网络知识点太多太多，没有那么快就能记住。<br>&emsp;&emsp;理解的网络协议，应该从背景原理去着手。那么从现在开始请认真阅读了哦！适合人群，<strong>对计算机有相应的了解，入门软件技术的朋友</strong>。<br>&emsp;&emsp;从客户端发送请求，会是神马结果？<strong>正常情况的状态码为 2xx，错误的状态码为 4xx，或是 5xx 等情况。</strong><br>&emsp;&emsp;报错 404：<br><img src="1.webp" alt="报错404">  </p>
<figure class="image-box">
                <img src="2.webp" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;了解 Web，了解网络基础，了解 HTTP 协议，如何使用 HTTP 协议访问 Web，我们在电脑中的浏览器 Web 页面是如何查询的，网页浏览器中的地址栏中输入 url 地址，就可以显示页面，这也是我们了解的常识。  </p>
<h2 id="客户端、服务器"><a href="#客户端、服务器" class="headerlink" title="客户端、服务器"></a>客户端、服务器</h2><p>&emsp;&emsp;在浏览器中的地址栏内输入 URL，就可以看到 Web 页面，即是客户端在浏览器地址内输入 URL 之后，信息会被送到某处，然后从某处获得的回复，内容就会显示在 Web 页面上。<br>&emsp;&emsp;<strong>像这种通过发送请求获取服务器资源的 Web 浏览器等就叫做客户端</strong>。<br>&emsp;&emsp;我们所看到 Web 页面也不是凭空显示出来给我们看的，它是根据你在 Web 浏览器地址栏指定的 url 发送，Web浏览器从 Web 服务器获取文件资源等信息，然后在从服务器端返回在 Web 浏览器上显示出 Web 页面的。<br>&emsp;&emsp;抓住重点提炼：有两个主题，<strong>Web 浏览器作为客户端，一个为服务器，Web 浏览器通过指定的访问地址获取服务器上的资源，服务器使用 HTTP 协议的通信返回到 Web 浏览器。</strong><br>&emsp;&emsp;Web 是建立在 HTTP 协议上通信的，HTTP 为超文本传输协议作为规范（或是严谨说法，超文本转移协议），完成从客户端到服务器端等一系列工作流程，协议是指规则的约定。<br>&emsp;&emsp;抓住重点提炼：什么是客户端与服务端呢？简单来说，客户端就是个人使用的电脑，而服务器就是服务器，通过电脑访问服务器上的资源，用的就是 HTTP 网络协议。  </p>
<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>&emsp;&emsp;<strong>那么这里又问了什么是 HTTP 协议呢？</strong><br>&emsp;&emsp;HTTP 叫做超文本传输协议，它是 TCP/IP 协议的一个应用层协议，用于定义 Web 浏览器与 Web 服务器之间的交换数据的过程，客户端连上 web 服务器后，若想获得 web 服务器中的某个 web 资源，需要遵循一定的通讯格式，HTTP 协议用于定义客户端和 web 服务器端通讯的格式。<br><img src="3.webp" alt=" "><br>&emsp;&emsp;HTTP 的出现，在 1989 年，互联网是少数人的，为了致力于全世界的研究者们进行知识共享，诞生了 HTTP，有人提出了一种让远隔两地的研究者们共享知识的设想，借助多文档之间相互关联形成的超文本，连成可相互参阅的 WWW，万维网。<br>&emsp;&emsp;<strong>3 项www构建技术分别是：</strong>  </p>
<blockquote>
<ul>
<li>SGML：Standard Generalized Markup Language<br>标准通用标记语言  </li>
<li>HTML：HyperText Markup Language<br>超文本标记语言  </li>
<li>HTTP：HyperText Transfer Protocol<br>超文本传输协议  </li>
<li>URL：Uniform Resource Locator<br>统一资源定位符  </li>
</ul>
</blockquote>
<ol>
<li><strong>把 SGML 作为页面的文本标记语言的 HTML</strong></li>
<li><strong>作为文档传递协议的 HTTP</strong></li>
<li><strong>指定文档所在地址的 URL</strong></li>
</ol>
<p>&emsp;&emsp;HTTP 是因特网的多媒体信使，每天有多少图片，页面，文件，电影，音频文件和其他资源都在因特网上面，HTTP 可以从遍布世界的 Web 服务器上将这些信息快速，可靠地移到人们的 Web 浏览器上。<br>&emsp;&emsp;Web 客户端和服务器，Web 内容存储在 Web 服务器上的，所使用的是 HTTP 协议，如果 HTTP 客户端发出请求，服务器会提供因特网中的数据，客户端向服务器发送 HTTP 请求，服务器会在 HTTP 响应中回送所请求的数据。<br>&emsp;&emsp;<strong>HTTP 客户端和 HTTP 服务器共同构成了万维网的基本组件。</strong><br>&emsp;&emsp;Web 服务器是 Web 资源的存储库，Web 资源是 Web 内容的源头，Web 资源可以包含任意内容，所有一切内容都是 Web 资源提供的。<br><img src="4.webp" alt=" ">  </p>
<h2 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h2><p>&emsp;&emsp;每个 Web 服务器资源都是有一个名字的，因为这样客户端就可以选取它要的资源了，<strong>URI，服务器资源名，为统一资源标识符</strong>，URI 是名字一样，像因特网上的邮政地址，是世界范围内唯一的标识并定位信息资源。<strong>URI 分两种形式，为 URL 和 URN。</strong><br>&emsp;&emsp;<strong>URL 为统一资源定位符</strong>，是资源标识符最常见的形式，描述了一台特定服务器上某资源的特定位置，URN 为统一资源名，为大范围使用，它是作为特定内容的唯一名称使用的，与资源所在地无关。  </p>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>&emsp;&emsp;计算机与网络设备要相互通信，双方就必须基于相同的方法，不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为<strong>协议(protocol)</strong>。<br><img src="5.webp" alt=" "><br>&emsp;&emsp;TCP/IP 是互联网相关各类协议族的总称。TCP/IP 是指 TCP 和 IP 这两种协议。TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。<br><img src="6.webp" alt=" ">  </p>
<h1 id="TCP-IP-的分层管理"><a href="#TCP-IP-的分层管理" class="headerlink" title="TCP/IP 的分层管理"></a>TCP/IP 的分层管理</h1><p>&emsp;&emsp;TCP/IP 协议族按层次分别为 <strong>应用层</strong>，<strong>传输层</strong>，<strong>网络层</strong>，<strong>数据链路层</strong>，<strong>物理层</strong>。<strong>可以按照不同的模型分 4 层或者是 7 层。</strong>  </p>
<p>&emsp;&emsp;将 TCP/IP 分为 5 层，越靠下越接近硬件。  </p>
<ul>
<li><strong>应用层</strong>，应用程序收到传输层的数据后，接下来就是要进行解读，解读必须要先规定好格式，而应用层就是规定应用程序的数据格式，主要协议有 HTTP 等。</li>
<li><strong>传输层</strong>，该层为两台主机上的应用程序提供端到端的通信，传输层有两个传输协议为 TCP（传输控制协议）和 UDP（用户数据报协议），TCP 是一个可靠的面向连接的协议，UDP 是不可靠或者说无连接的协议。</li>
<li><strong>网络层</strong>，决定如何将数据从发送方到接收方，是建立主机到主机的通信。</li>
<li><strong>数据链路层</strong>，控制网络层与物理层之间的通信，主要功能是保证物理线路上进行可靠的数据传递。</li>
<li><strong>物理层</strong>，该层负责物理传输，与链路有关，也与传输的介质有关。</li>
</ul>
<figure class="image-box">
                <img src="7.webp" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;TCP/IP 协议分层之后，如果后期要对哪些地方进行设计修改，无需全部替换，只需要对变化的层进行替换即可。  </p>
<p>&emsp;&emsp;我们按照 4 层来说明，TCP/IP 协议族按层次分别分为以下：<strong>应用层</strong>，<strong>传输层</strong>，<strong>网络层</strong>，<strong>数据链路层</strong>。  </p>
<ul>
<li><strong>应用层</strong>，应用层决定了向用户提供应用服务时通信的活动，如 FTP，文件传输协议和 DNS 服务，HTTP 协议处于应用层。</li>
<li><strong>传输层</strong>，传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输，有 TCP 传输控制协议和 UDP 用户数据报协议。</li>
<li><strong>网络层</strong>，用来处理在网络上流动的数据包，规定哪条传输路线将数据包传送到对方计算机。</li>
<li><strong>链路层</strong>，用来处理连接网络的硬件部分，包含操作系统，硬件的设备驱动，NIC 等。</li>
</ul>
<p>&emsp;&emsp;以上内容过于概念，了解加理解：<br>&emsp;&emsp;那他们之间又是怎么通信的呢？<br><img src="8.webp" alt=" ">  </p>
<figure class="image-box">
                <img src="9.webp" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信，<strong>发送端会从应用层往下走</strong>，即应用层（HTTP 客户端），传输层（TCP），网络层（IP），链路层（网络），而<strong>接收端则是从链路层往上走的</strong>。<br>&emsp;&emsp;发送端在层与层之间进行传输的时候，<strong>每经过一层必须被打上该层所属的首部信息</strong>，反之，接收端在接收数据时，每经过一层，就会把对应的首部去掉，这种把信息包装起来的做法叫做“封装”。<br>&emsp;&emsp;由图看文字内容，这个相信大家一定看懂的了。  </p>
<p>&emsp;&emsp;传输层，TCP/UDP，传输控制协议和用户数据报协议，重点再说一次，<strong>TCP 是一种可靠的面向连接的协议</strong>，而 <strong>UDP 不是可靠的，或说是无连接的协议</strong>。<br>&emsp;&emsp;它们 TCP、UDP 都是传输层的协议，两个的区别是：<br>&emsp;&emsp;TCP 的可靠性是强的，它是可靠的，连接性，是面向连接的，报文，是面向字节流的，效率是，传输效率低，双工性，全双工，流量控制是滑动窗口，拥塞控制是慢开始，拥塞避免，快重传，快恢复的，传输速度是慢的，<strong>应用场景是对效率要求低，对准确性要求高或者要求有连接的场景</strong>。<br>&emsp;&emsp;UDP 的不是可靠的，无连接的，面向报文的，传输效率高的，一对一，一对多，多对一，多对多，流量控制，无，拥塞控制，无，但是传输速度是快的，<strong>应用场景是对效率要求高，对准确性要求低的</strong>。  </p>
<h2 id="TCP-IP-分层的好处"><a href="#TCP-IP-分层的好处" class="headerlink" title="TCP/IP 分层的好处"></a>TCP/IP 分层的好处</h2><p>&emsp;&emsp;如果互联网只有一个协议通信，某个地方需要修改，那么就必须要整个全部换掉，但是分层之后，只是需要把变动的层替换就行了。<br><img src="10.webp" alt=" ">  </p>
<h1 id="TCP-的三次握手与四次挥手"><a href="#TCP-的三次握手与四次挥手" class="headerlink" title="TCP 的三次握手与四次挥手"></a>TCP 的三次握手与四次挥手</h1><p>&emsp;&emsp;请看图，记住有三个箭头，四个对话框，就可以记住口诀：<br>&emsp;&emsp;三次握手与四次挥手：<br><img src="11.webp" alt=" ">  </p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>&emsp;&emsp;三次握手示意图：<br><img src="12.webp" alt="三次握手示意图"><br>&emsp;&emsp;<strong>三次握手过程：</strong>  </p>
<ol>
<li>第一次握手是在建立连接，客户端发送连接请求报文段，<strong>把标有 SYN 的数据包发给服务器端即为接收端</strong>。</li>
<li>第二次握手是服务器端即接收端收到客户端的SYN的报文段，<strong>同时发送标有 SYN/ACK 的数据包</strong>。</li>
<li>第三次握手是客户端收到服务器端的 SYN/ACK 的数据包后，<strong>向服务器端发送标有 ACK 的数据包</strong>。</li>
</ol>
<p>&emsp;&emsp;上面的解释看图片一起理解会更好懂得，之间的传输数据。  </p>
<p>&emsp;&emsp;TCP 的三次握手，那么你了解什么是 TCP 了吗？我相信有的人还记得，但是总会有人又忘记了，了解 TCP 头部报文，还有为什么是 TCP 的三次握手，而不是其他次数呢？在 TCP 三次握手过程中，有什么区别或者是说变化。<br>&emsp;&emsp;TCP，请记住中文名，传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层通信协议，TCP 的头部报文，你了解吗？不了解即可百度。  </p>
<h3 id="TCP-IP-TCP-的报文头"><a href="#TCP-IP-TCP-的报文头" class="headerlink" title="[TCP/IP] TCP 的报文头"></a>[TCP/IP] TCP 的报文头</h3><p>&emsp;&emsp;报文(message)是网络中交换与传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变。<br><img src="13.webp" alt=" "><br>&emsp;&emsp;让我们看看百度上面对“报文”的解释：  </p>
<blockquote>
<p><strong>报文的理解及作用</strong><br>&emsp;&emsp;报文就是在各个系统之间进行请求和响应时用来交换信息的，还需要遵守规定好的格式。<br>&emsp;&emsp;另外，应用报文多是多个系统之间需要通信的时候，比如银行的 ESB 系统到网关系统再到银联系统。在这中间报文就承担了装载数据，运输数据的功能，可能在这三个系统中报文的格式互不相同，但是承载的数据都是一样的。</p>
</blockquote>
<p>&emsp;&emsp;<strong>TCP 头部报文：</strong><br><img src="14.webp" alt="TCP 头部报文"><br>&emsp;&emsp;<strong>source port</strong>，源端口号，指向本地端口<br>&emsp;&emsp;<strong>destination port</strong>，目的端口号，指向远程端口<br>&emsp;&emsp;源端口号即是发送端的，接收端是目的端口号，源端口号从发送端依据某种规定发送到接收端的目的端口号，不同的应用程序都有者不同的端口，因为发送端会发送很多源端口号，对应接收端很多对应规则的目的端口号。  </p>
<p>&emsp;&emsp;Sequence Number，序列号<br>&emsp;&emsp;用于 TCP 通信过程中，分段序列进行字节流的传输，接收端会根据这个编号进行再排序确认。如排队每个人拿对应的号入口检查，进入后不会乱的就坐一样。  </p>
<p>&emsp;&emsp;TCP有6种状态表示：</p>
<ul>
<li>SYN (建立联机) </li>
<li>ACK (确认) </li>
<li>PSH (传送) </li>
<li>FIN (结束) </li>
<li>RST (重置) </li>
<li>URG (紧急)</li>
</ul>
<h3 id="分析-TCP-为啥三次握手"><a href="#分析-TCP-为啥三次握手" class="headerlink" title="分析 TCP 为啥三次握手"></a>分析 TCP 为啥三次握手</h3><p>&emsp;&emsp;首先客户端，服务端，TCP 三次握手：<br>&emsp;&emsp;握手过程中使用了 TCP 的标志，<strong>SYN 和 ACK</strong>。  </p>
<ol>
<li>初始化状态<br>客户端处于 close 关闭状态，服务器处于 Listen 监听状态。  </li>
<li>第一次握手<br>客户端发送<strong>请求报文将 SYN=1 同步序列号和初始化 seq=x 发送给服务端</strong>，服务端从初始化状态，创建连接，等待客户端，确认接收后的状态为 SYN_Receive。这个时候<strong>客户端处于等待状态为 SYN_Send</strong>。  </li>
<li>第二次握手<br>服务器接<strong>收到报文后（SYN=1，seq=x）</strong>收到请求后请求报文变为<strong>同步序列号 SYN=1，初始化序列号 seq=y，确认号 ACK=1，ack=x+1，服务器为 SYN_Receive 状态</strong>，发送端的状态为：SYN_Send。  </li>
<li>第三次握手<br>客户端收到服务端的数据包（收到响应后），然后发送同步序列号 ack=y+1 和数据包的序列号 seq=x+1 和 ACK=1 确认包作为应答<strong>（第三次握手：ACK=1, seq=x+1, ack=y+1）</strong>，客户端和服务端变化为 established 状态。  </li>
</ol>
<p>&emsp;&emsp;发送三封信息给女朋友，这三次握手主要是为了验证我这边和女朋友那边的发送/收信能力是没有问题的，证明连接是通的，可以正式发送信息。  </p>
<ol>
<li>第一次握手，我发送信息，女朋友收到了，此时女朋友就知道，我发送信息的能力和她自己的收信能力是没问题的。  </li>
<li>第二次握手，女朋友发送信息，我收到了，此时我明白，<strong>我的发送信息和接收信息是没有问题的</strong>，还是要进行第三次握手的，如果没有我的回音，女朋友还不知道自己的发送信息功能是否没有问题的。  </li>
<li>第三次握手，我发送信息，女朋友收到了，此时女朋友也确认了，我们两者之间的发送和收信都是没有问题的。  </li>
</ol>
<h3 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h3><figure class="image-box">
                <img src="15.webp" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;DNS 服务和HTTP协议一样位于应用层。提供域名到 IP 地址之间的解析服务。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。<br>&emsp;&emsp;<strong>各种协议与 HTTP 协议的关系</strong><br><img src="16.webp" alt="各种协议与HTTP协议的关系"><br>&emsp;&emsp;当客户端和服务端通过三次握手建立了 TCP 连接以后，当数据传送完毕，断开连接就需要进行 TCP 的四次挥手。  </p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>&emsp;&emsp;四次挥手如下所示：<br><img src="17.webp" alt="四次挥手示意图">  </p>
<ul>
<li>第一次挥手<br>客户端设置 seq 和 ACK ,向服务器发送一个 FIN=1 报文段。此时，<strong>（第一次挥手，FIN=1，seq=u）客户端进入 FIN_WAIT 状态</strong>，表示客户端没有数据要发送给服务端了。</li>
<li>第二次挥手<br>服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。</li>
<li>第三次挥手<br>服务端向客户端发送 FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</li>
<li>第四次挥手<br>客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。</li>
</ul>
<blockquote>
<p><strong>统一资源标识符</strong><br>&emsp;&emsp;URI 是 Uniform Resource Identifier 的缩写，规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文 环境来识别资源指定的访问方式。<br>&emsp;&emsp;URL（Uniform Resource Locator，统一资源定位符），URL 正是使用 Web 浏览器等 访问 Web 页面时需要输入的网页地址。  </p>
</blockquote>
<p>参考资料：《图解HTTP》</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RESTful 架构基础]]></title>
      <url>/2019/12/09/FoundationsOfRestfulArchitecture/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://dzone.com/refcardz/rest-foundations-restful" target="_blank" rel="noopener">https://dzone.com/refcardz/rest-foundations-restful</a></p>
</blockquote>
<p>&emsp;&emsp;REST（Representational State Transfer）架构风格是一种世界观，把信息提升为架构中的一等公民。通过 REST 可以实现系统的高性能、可伸缩、通用性、简单性、可修改性和可扩展等特性。这篇文章解释了主要的 HTTP 操作，对 HTTP 响应码进行描述，并列举相关开发库和框架。此外，本文还提供了额外的资源，对每个主题进行了更深入的探讨。  </p>
<a id="more"></a>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;REST 架构风格不是一种可以购买的技术，也不是一个可以添加到软件开发项目中的开发库。首先也是最重要的，REST 是一种世界观，把将信息提升为构建架构中的一等公民。<br>&emsp;&emsp;Roy Fielding 的博士论文“架构风格和基于网络的软件架构设计”介绍和整理了“RESTful”系统的思想和相关术语。这是一篇学术论文，虽然使用正式语言，但是仍然易于理解并且提供了实践基础。<br>&emsp;&emsp;总结一下，RESTful 通过体系结构的特定选择能从部署的系统中获得理想特性。尽管这种风格定义的约束细节并没有为所有场合设计，但是的确可以广泛适用。<br>&emsp;&emsp;由于 Web 对消费者偏好有多重影响，REST 风格的倡导者鼓励企业组织在其边界内使用相同原则，就像他们在面向外部客户的网页上做的那样。本文将讨论现代 REST Web 实现中的基本约束和属性。  </p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>&emsp;&emsp;REST 表示什么含义？以无状态方式传输、访问和操作文本数据。当正确部署后，REST 为互联网上不同应用程序之间提供了一致的互操作性。无状态（stateless）这个术语至关重要，它使得应用程序可以用不可知的方式进行通信。RESTful API 通过统一资源定位符地址（URL）公开服务。URL 名称将资源的区分为接受内容或返回内容。RFC 1738 中定义了 URL scheme，可以在这里找到: <a href="https://tools.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">https://tools.ietf.org/rfc/rfc1738.txt</a><br>&emsp;&emsp;RESTful URL 类似于下面这个 library API：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org/library</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实际公开的不一定是某种任意的服务，而是代表对消费者有价值的信息资源。URL 作为资源句柄，可以请求、更新或删除内容。<br>&emsp;&emsp;开始把服务发布到某个地方，然后开始与 REST 服务进行交互。返回的内容可能是 XML、JSON 格式，或者更确切地说是像 Atom 或自定义 MIME 类型等超媒体格式。虽然一般建议尽可能重用现有的格式，但是对正确设计的媒体类型正在变得越来越宽容。<br>&emsp;&emsp;需要请求资源的时候，客户机会发一个超文本传输协议（HTTP）GET 请求，例如在浏览器中键入一个 URL 然后点击回车，选择书签，或者点击锚引用链接。<br>&emsp;&emsp;通过编程方式与 RESTful API 交互，有数十个客户端 API 或工具可供选择。使用 curl 命令行工具，可以输入以下命令：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://fakelibrary.org/library</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的命令使用默认格式，但你可能不需要这种格式的信息。幸运的是 HTTP 有一种机制，可以指定返回信息的格式。在请求中指定 “Accept” 头，如果服务器支持这种格式，会以指定的格式返回。这个过程称为内容协商，这是 HTTP 中未被充分利用的功能之一，可以使用一个类似于上面例子中的 curl 命令来指定：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl –H &quot;Accept:application/json&quot; http://fakelibrary.org/library</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于资源名称与内容格式是独立的，从而让请求不同格式信息成为可能。虽然 REST 中的 “R” 的含义是 “表现”而非“资源”，但是应该在构建系统时允许客户端指定请求的内容格式，请牢记这一点。在我们的例子中 library API 可能包含以下 URL：  </p>
<ol>
<li><code>http://fakelibrary.org/library</code>：图书馆基本信息，搜索图书、DVD等相关资源基本功能的链接。</li>
<li><code>http://fakelibrary.org/book</code>：存放书籍的“信息空间”。从概念上说，这里可能会存放所有的书籍。显然，如果这个问题得到解决，我们不会希望返回所有图书，而是希望通过类别、搜索关键词等来检索图书。</li>
<li><code>http://fakelibrary.org/book/category/1234</code>：在书籍的信息空间里，我们可以指定类别浏览，例如成人小说、儿童书籍、园艺书籍等。使用杜威十进制图书分类法是可行的，但我们也可以想象自定义分组。问题的关键在于，这种“信息空间”可能是无限的，而且可能收到人们实际关心的信息类型影响。</li>
<li><code>http://fakelibrary.org/book/isbn/978-0596801687</code>：提到某本具体的书，应该包括书名、作者、出版商、系统中的拷贝数、可用拷贝数等信息。</li>
</ol>
<blockquote>
<p>译注：杜威十进制图书分类法由美国图书馆专家麦尔威·杜威发明，于1876年首次发表，历经22次的大改版。该分类法以三位数字代表分类码，共可分为10个大分类、100个中分类及1000个小分类。</p>
</blockquote>
<p>&emsp;&emsp;就图书馆用户而言，上面提到的这些 URL 可能就是只读的，但是图书馆员使用应用程序时实际上可以操作这些资源。<br>&emsp;&emsp;例如添加一本新书，可以向 main/book 地址 POST 一个 XML。使用 curl 提交，看起来可能像这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  curl –u username:password -d @book.xml -H &quot;Content-type: text/xml&quot; http://fakelibrary.org/book</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时，服务器可能会对提交的内容进行校验，创建与图书相关的记录，并返回响应代码 201 —— 表示已创建新资源。新资源的 URL 可以在响应的 Location 头中找到。<br>&emsp;&emsp;RESTful 请求一个重要特性：每次请求都包含了充足的状态信息来响应请求。这为服务器的可见性和无状态创造了条件，并为扩展系统和识别发送的请求内容提供了理想特性。对于缓存结果也非常有帮助。服务器地址和请求状态组合成可计算的 hash 键值，并形成一个结果集：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://fakelibrary.org + /book/isbn/978-0596801687</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来我们会先介绍 GET 请求。客户端在需要时发出 GET 请求获取指定资源。客户端可以在本地缓存请求结果，服务器可以在远程缓存结果，系统的中间层可以在请求链路中间缓存结果。这是一个与具体应用程序无关的特性，可以加入系统设计中。<br>&emsp;&emsp;正因为可以操作资源，也就意味着并不是每个人都可以这样做。我们完全可以建立一个防护模型，要求用户在操作前验证身份，证明他们具有该操作的授权。在本文的最后，将提供一些提升 RESTful 服务安全性的内容。  </p>
<h1 id="REST-和-SOAP-比怎么样？"><a href="#REST-和-SOAP-比怎么样？" class="headerlink" title="REST 和 SOAP 比怎么样？"></a>REST 和 SOAP 比怎么样？</h1><p>&emsp;&emsp;SOAP：简单对象访问协议（Simple Object Access Protocol）。是交换数据的一种协议规范，是一种轻量的、简单的、基于XML的协议。一条 SOAP 消息就是一个普通的 XML 文档，包含必需的 Envelope 元素、可选的 Header 元素、必需的 Body 元素和可选的 Fault 元素。<br>&emsp;&emsp;把 REST 与 SOAP 划等号是错误的。在这两者之间进行比较，带来的困扰远多于好处。简单来说，它们不是一回事。尽管可以用这两种方法解决许多架构问题，但是它们不能相互替换。<br>&emsp;&emsp;这种混淆很大程度上源于对 “REST 是通过 URL 调用 Web 服务”这句话的误解。这种观点与 RESTful 架构的功能相距甚远。如果不全面深入理解 RESTful 的架构实现，就很容易误解 REST 实践的本意。<br>&emsp;&emsp;利用 REST 的最佳方式，是<strong>将生产和消费过程中的信息与技术分离实现解耦</strong>，进而更好地管理系统，让架构具备以下特性：  </p>
<ul>
<li>高性能</li>
<li>可扩展</li>
<li>通用</li>
<li>简洁</li>
<li>可修改</li>
<li>可扩展</li>
</ul>
<p>&emsp;&emsp;这并不是说，基于 SOAP 构建的系统不能具备上述特性。而是当技术、组织或过程的复杂性造成不能在单个事务中完成请求的生命周期时，这种情况 SOAP 能够发挥最佳效果。  </p>
<h1 id="Richardson-成熟度模型"><a href="#Richardson-成熟度模型" class="headerlink" title="Richardson 成熟度模型"></a>Richardson 成熟度模型</h1><p>&emsp;&emsp;Leonard Richardson 引入了一种成熟度模型，部分阐述了 SOAP 与 REST 之间的区别，并提供一种对不同类型的系统进行分类的框架。许多人不恰当地称之为 “REST”。可以将这种分类看作系统中不同 Web 技术组件紧密程度的度量标准：包括信息资源、HTTP 作为应用层协议和作超媒体作为控制媒介。  </p>
<table>
<thead>
<tr>
<th>等级</th>
<th>采纳</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>基本上就是 SOAP。没有信息资源，HTTP 被用作传输协议，也没有超媒体的概念。结论，REST 和 SOAP 是两种不同的方案</td>
</tr>
<tr>
<td>1</td>
<td>用到 URL 但并不总是作为信息资源使用，所有内容都通过 GET 请求，包括更新服务器状态的请求。大多数人刚接触 REST 时构建的系统通常是这样的</td>
</tr>
<tr>
<td>2</td>
<td>使用 URL 表示信息资源。HTTP 作为应用层协议，有时也用作内容协商。大多数面向 Internet 的 “REST” Web 服务实际上位于这个级别，因为它们只支持非超媒体格式</td>
</tr>
<tr>
<td>3</td>
<td>使用 URL 表示信息资源。HTTP 作为应用层协议，也用来进行内容协商。使用超媒体进行客户端的交互</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;称其为“成熟度模型”似乎意味着应该只构建“成熟度”最高的系统。这种看法是不合适的。第 2 级是有价值的，从 2 级向 3 级转变通常只是采用了一种新的 MIME 类型。然而，从 0 级到 3 级的转变要困难得多，因此增量式升级转变通常也会增值。<br>&emsp;&emsp;首先，确定希望公开哪些信息资源。采用 HTTP 作为处理这些信息资源的应用协议，包括内容协商。接下来，当一切就绪时，使用基于超媒体的 MIME 类型，这样就可以充分享受 REST 的好处了。  </p>
<h1 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h1><p>&emsp;&emsp;动词是用来与服务器资源交互的方法或操作。RESTful 系统中有限的动词让刚接触该的使用者感到困惑和沮丧。看似武断和不必要的约束，目的是鼓励以应用程序无关的形式提供可预测的行为。通过明确、清晰地定义这些动词的行为，客户端可以在网络中断或故障时自主处理。<br>&emsp;&emsp;精心设计的 RESTful 系统主要使用 4 个 HTTP 动词。  </p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>&emsp;&emsp;GET 请求是最常用的 Web 动词。GET 请求将命名资源从服务器传输到客户端。尽管客户端不需要知道请求的资源内容，但是请求返回的结果是带元数据标记的字节流，这表明客户端应该知道如何解释资源。在 Web 中通常用 “text/html” 或 “application/xhtml+xml” 表示。正如之前提到的那样，只要服务器支持，客户端可以通过内容协商提前指定请求的返回格式。<br>&emsp;&emsp;GET 请求关键点之一，不要修改服务器端的任何内容。这是一个基本的安全要求，也是不熟悉 REST 的开发者犯的最大错误之一。你可能会遇到这样的 URL：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/res/action=update?data=1234</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不要这样做！ 由于 GET 请求安全性允许缓存请求，这会让正在构建的 RESTful 系统陷入混乱。GET 请求也意味着幂等性，即多次请求不会对系统产生任何影响。这是基于分布式基础设施的一个重要特性。如果进行 GET 请求时被打断，由于幂等性，客户端可以再次发起请求。这点非常重要。在设计良好的基础结构中，客户端可以从任意应用程序发起请求。虽然一定会有与应用程序相关的特定行为，但是加入与应用程序无关的行为越多，系统就会越有弹性，也更容易维护。  </p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>&emsp;&emsp;在辨别 POST 和 PUT 动词意图的时候，情况开始变得不那么清晰。根据定义，二者似乎都可以被客户端用来创建或更新服务器资源，然而它们的用途各有不同。<br>&emsp;&emsp;当无法预测请求创建的资源的标识时，客户端会使用 POST 请求。在新增雇员、下订单或提交表单的时候，我们无法预测服务器将如何命名正在创建的资源。这就是为什么将资源提交给类似 Servlet 这样的程序处理。接下来，服务器会接受请求、校验请求、验证用户凭据等。成功处理后，服务器将返回 201 HTTP 响应代码，其中包含一个 “Location” 头，代表新创建的资源的位置。<br>&emsp;&emsp;<strong>注意</strong>： 有些人将 POST 视为创建资源的 GET 会话。他们会对创建的资源通过 body 返回 200，而不是返回 201。这似乎是避免二次请求的一种快捷方式，但是这种做法混合了 POST 和 GET，让缓存资源的潜在影响变得微妙。尽量避免因为走捷径而牺牲大局。短期看这似乎是值得的，但随着时间的推移，这些捷径叠加起来可能会带来不利的影响。<br>&emsp;&emsp;POST 动词的另一个主要用途是“追加（Append）”资源信息，即增量编辑或部分更新，而不是提交完整的资源。这里应使用 PUT 操作。对已知资源使用 POST 更新，可用于向订单添加新送货地址或更新购物车中某个商品的数量。<br>&emsp;&emsp;由于是更新资源的部分信息，<strong>POST 既不安全也不幂等</strong>。<br>&emsp;&emsp;POST 的最后一种常见用法是提交查询。将查询的内容或表单内容进行 URL 编码后提交给服务执行查询。通常可以直接返回 POST 结果，因为没有与查询相关的标识。<br>&emsp;&emsp;<strong>注意</strong>： 建议将这样的查询转换为信息资源本身。如果采用 POST 查询，可以考虑采用 GET 请求，后者支持缓存。你可以与其他人分享这个链接。  </p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><p>&emsp;&emsp;由于 HTML 表单目前还不支持 PUT，许多开发人员基本上会忽略 PUT 动词。然而，PUT 有一个重要作用并且是 RESTful 系统完整愿景的一部分。<br>&emsp;&emsp;客户端可以向指定 URL 发 PUT 请求，服务器用请求中的数据执行覆盖操作。PUT 请求在某种程度上是等幂的，而 POST 更新不是。<br>&emsp;&emsp;如果客户端在 PUT 覆盖请求时被打断，由于重新发送覆盖操不会造成任何后果，因此可以再次发送。客户端具备管理状态能力，所以直接重发覆盖命令即可。<br>&emsp;&emsp;注意： 这种协议层处理并不意味着要取消更高级别（如应用层）的事务，但是同样地，它也是一种体系结构上理想的属性，可以在应用层以下使用。<br>&emsp;&emsp;如果客户端能够提前了解资源的标识，那么 PUT 也可用于创建资源。正如我们在 POST 部分中讨论的那样，通常不会出现这种情况。但是如果客户端能够控制服务器端信息空间，那么这种操作也是合理的。  </p>
<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><p>&emsp;&emsp;在公共网络上 DELETE 动词没有被广泛使用（谢天谢地!）。然而，对于控制信息空间非常有用，它是资源生命周期中非常有用的一部分。<br>&emsp;&emsp;DELETE 请求意在实现等幂。可能由于网络故障 DELETE 请求被打断，这时我们希望客户端继续尝试。第一次请求无论成功与否，资源都应该返回 204（无指定内容）。对之前已删除的资源或不存在的资源可能需要一些额外处理，两种情况都应该返回 404。一些安全策略要求为不存在的和已删除的资源返回 404，这样 DELETE 请求就不会泄漏有关资源是否存在的信息。<br>&emsp;&emsp;还有另外三个没有广泛使用但是有价值的动词。  </p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>&emsp;&emsp;HEAD 动词用来请求资源，但不实际检索。客户端可以通过 HEAD 检查资源是否存在，并检查资源相关的元数据。  </p>
<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>&emsp;&emsp;OPTIONS 动词也可以用来查询服务器相关资源的情况，方法是询问哪些其它动词可用于该资源。</p>
<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><p>&emsp;&emsp;最新的动词 PATCH 直到2010年才正式采纳为 HTTP 的一部分。旨在提供一种标准化方式来表示部分更新。PATCH 请求通过标准格式让交互的意图更明确。这是推荐使用 PATCH 而非 POST 的原因，尽管 POST 可以用于任何事情。IETF 发布了 RFC 文档，定义用于 PATCH 操作的 XML 和 JSON。<br>&emsp;&emsp;如果客户端 PATCH 请求的 header 中带 If-Match，则此部分为幂等更新。可以重试中断的请求，因为如果第一次请求成功，那么 If-Match header 会不同于新状态。如果相同，则未处理原始请求可应用 PATCH。  </p>
<h1 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h1><p>&emsp;&emsp;HTTP 响应码为我们在客户端和服务器之间的对话提供了丰富的请求状态信息。大多数人只熟悉一般意义上的 200、403、404 或者 500，但是还有更多有用的代码可供使用。这里表格并不全面，但是它们涵盖了许多在 RESTful 环境中应该考虑使用的最重要代码。数字可按照以下类别分组：  </p>
<ul>
<li>1XX：信息类</li>
<li>2XX：操作成功</li>
<li>3XX：重定向</li>
<li>4XX：客户端错误</li>
<li>5XX：服务器错误</li>
</ul>
<p>&emsp;&emsp;第一组响应码表明客户端的请求格式正确且处理成功。具体操作如下表所示：  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK。请求已成功执行，回应内容取决于所调用的动词</td>
</tr>
<tr>
<td>201</td>
<td>已创建。请求已成功执行，在执行过程中创建了一个新资源。响应 body 为空或包含所创建资源的 URI。响应中的 Location 头也应该指向 URI</td>
</tr>
<tr>
<td>202</td>
<td>已接受。请求有效并已接受，但尚未得到处理。可通过请求轮询，响应结果中 URI 提供状态更新。这种方式支持异步 REST 请求</td>
</tr>
<tr>
<td>204</td>
<td>没有请求的内容。请求已成功处理，但服务器没有任何响应结果，客户端不应更新显示</td>
</tr>
</tbody></table>
<p><strong>表1</strong>&emsp;成功的客户端请求  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>永久移除。请求的资源不再位于指定的 URI，新的 Location 应该在响应头中返回。只有 GET 或 HEAD 请求应当重定向到新位置。如果可能，客户端应该更新自己保存的书签</td>
</tr>
<tr>
<td>302</td>
<td>已找到。请求的资源已在其它临时位置找到，并应该在响应头中返回该位置。只有 GET 或 HEAD 请求应该重定向到新位置。客户端无需更新书签，因为资源会返回对应的 URL。</td>
</tr>
<tr>
<td>303</td>
<td>参见其他信息。该响应码被 W3C 技术架构小组（TAG）重新解释成一种对非网络可寻址资源的有效请求方式。这是语义化 Web 中的一个重要概念，可以向个人、概念、组织等提供 URI。能够在 Web 中找到和不能在 Web 中找到的资源是有区别的。如果客户端找到的响应码是 303 而不是 200，就能分辨这种差别。重定向的位置在响应的 Location 头中。头信息可能包含相关资源的文档引用，也可能包含相关资源的一些元数据</td>
</tr>
</tbody></table>
<p><strong>表2</strong>&emsp;客户端重定向请求  </p>
<p>&emsp;&emsp;表 3 中的响应代码表示客户端请求无效，如果条件不发生变化，重新请求仍无法处理。这些故障可能有请求格式错误、未授权的请求、请求的资源不存在等。  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>405</td>
<td>方法不允许</td>
</tr>
<tr>
<td>406</td>
<td>请求不接受</td>
</tr>
<tr>
<td>410</td>
<td>资源不存在</td>
</tr>
<tr>
<td>411</td>
<td>需要指定长度</td>
</tr>
<tr>
<td>412</td>
<td>前提条件失败</td>
</tr>
<tr>
<td>413</td>
<td>Entity 太大</td>
</tr>
<tr>
<td>414</td>
<td>URI 超长</td>
</tr>
<tr>
<td>415</td>
<td>不支持的媒体类型</td>
</tr>
<tr>
<td>417</td>
<td>预期失败</td>
</tr>
</tbody></table>
<p><strong>表3</strong>&emsp;客户端请求错误  </p>
<p>&emsp;&emsp;最后，表 4 中的响应代码表示服务器暂时无法处理客户端请求（可能仍然无效）。客户端应当在将来的某个时候重新请求。  </p>
<table>
<thead>
<tr>
<th>响应代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>内部服务器错误</td>
</tr>
<tr>
<td>501</td>
<td>未实现</td>
</tr>
<tr>
<td>503</td>
<td>服务不可用</td>
</tr>
</tbody></table>
<p><strong>表4</strong>&emsp;服务器处理请求错误</p>
<p>&emsp;&emsp;服务根据其自身功能要求具有不同程度的可扩展性。<br>&emsp;&emsp;<strong>注意</strong>： 试试响应代码 418，它会返回简洁有力的回复：”我是一个茶壶。”  </p>
<h2 id="REST-资源"><a href="#REST-资源" class="headerlink" title="REST 资源"></a>REST 资源</h2><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>&emsp;&emsp;Fielding 博士的论文《架构的风格与基于网络的软件架构设计》是对 RESTful 思想的主要介绍：<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener">http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm</a></p>
<h3 id="RFC-规范"><a href="#RFC-规范" class="headerlink" title="RFC 规范"></a>RFC 规范</h3><p>&emsp;&emsp;REST 常见用法的技术规范由国际互联网工程任务组（IETF）定义，按照请求评议（RFC）流程完善。规范由数字定义，并随着时间推移不时更新版本，以替换已经过时的文件。目前，这里有最新的相关 RFC 文件。  </p>
<h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p>&emsp;&emsp;RFC 3986 定义了 URI 命名方案的通用语法。URI 是一种命名方案，包含了对其他如网址、支持名字子空间等编码方案。网址：<a href="http://www.ietf.org/rfc/rfc3986.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3986.txt</a>  </p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>&emsp;&emsp;统一资源定位符（URL）是 URI 的一种形式，其中嵌入了充足的信息（通常是访问方案和地址），用于解析和定位资源。网址：<a href="http://www.ietf.org/rfc/rfc1738.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc1738.txt</a>  </p>
<h4 id="IRI"><a href="#IRI" class="headerlink" title="IRI"></a>IRI</h4><p>&emsp;&emsp;国际化资源标识符（IRI）在概念上是一个用 Unicode 编码的 URI，用于在 Web 上使用的标识符中支持世界上各种语言的字符。IETF 选择创建一个新的标准，而不是改变 URI 方案本身，以避免破坏现有的系统并明确区分这两种方法。那些支持 IRI 的人故意这样做。还定义了在 IRI 和 URI 之间进行转换的映射方案。网址：<a href="http://www.ietf.org/rfc/rfc3987.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc3987.txt</a>  </p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>&emsp;&emsp;HTTP 1.1 版本定义了一个应用程序协议，用于操作通常以超媒体格式表示的信息资源。虽然它是一个应用级协议，但通常不与应用程序绑定，由此产生了重要的体系结构优势。大多数人认为 HTTP 和超文本标记语言文（HTML）就是 “Web”，但是 HTTP 在非面向文档的系统开发中也很有用。网址：<a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc2616.txt</a>  </p>
<h4 id="PATCH-格式"><a href="#PATCH-格式" class="headerlink" title="PATCH 格式"></a>PATCH 格式</h4><p>&emsp;&emsp;JavaScript 对象表示法（JSON）Patch 网址：<a href="https://www.ietf.org/rfc/rfc6902.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc6902.txt</a><br>&emsp;&emsp;XML Patch 网址：<a href="https://www.ietf.org/rfc/rfc7351.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc7351.txt</a>  </p>
<h3 id="描述语言"><a href="#描述语言" class="headerlink" title="描述语言"></a>描述语言</h3><p>&emsp;&emsp;人们对使用各种语言来描述 API 非常感兴趣，通过描述语言可以更容易地编写客户端和服务器文档，甚至生成骨架代码。一些比较流行、有趣的描述语言包括：  </p>
<h4 id="RAML"><a href="#RAML" class="headerlink" title="RAML"></a>RAML</h4><p>&emsp;&emsp;RAML 是一种 YAML/JSON 语言，可以定义2级成熟度的 API。它支持可重用模式和特性，通过模式和特性实现功能 API 设计的标准化。网址：<a href="http://raml.org" target="_blank" rel="noopener">http://raml.org</a>  </p>
<h4 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h4><p>&emsp;&emsp;Swagger 是另一种 YAML / JSON 语言，支持定义2级成熟度的 API。它包含代码生成器、编辑器、 API 文档可视化功能，能够与其他服务集成的。网址：<a href="http://swagger.io" target="_blank" rel="noopener">http://swagger.io</a>  </p>
<h4 id="Apiary-io"><a href="#Apiary-io" class="headerlink" title="Apiary.io"></a>Apiary.io</h4><p>&emsp;&emsp;Apiary.io 是一个协作式的托管站点。它支持 Markdown 格式的 API 文档，可以围绕设计过程进行社交，并且支持模拟数据的托管实现，以便于在 API 实现之前对其进行测试。网址：<a href="http://apiary.io" target="_blank" rel="noopener">http://apiary.io</a>  </p>
<h4 id="Hydra-Cg"><a href="#Hydra-Cg" class="headerlink" title="Hydra-Cg"></a>Hydra-Cg</h4><p>&emsp;&emsp;Hydra-Cg 是一种超媒体描述语言，通过像 JSON-LD 这样的标准方便地实现数据关联和并其它数据源的交互。网址：<a href="http://www.hydra-cg.com" target="_blank" rel="noopener">http://www.hydra-cg.com</a>  </p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>&emsp;&emsp;有一些用于构建、生成和使用 RESTful 系统的库和框架。虽然任何 Web 服务器都可以配置成提供 REST API，但有了这些框架、库和环境可以让过程变得更容易。<br>&emsp;&emsp;以下概述了一些主流的环境：  </p>
<h4 id="JAX-RS"><a href="#JAX-RS" class="headerlink" title="JAX-RS"></a>JAX-RS</h4><p>&emsp;&emsp;JAX-RS 规范为 JEE 环境增加了对 REST 的支持。网址：<a href="https://jax-rs-spec.java.net" target="_blank" rel="noopener">https://jax-rs-spec.java.net</a>  </p>
<h4 id="Restlet"><a href="#Restlet" class="headerlink" title="Restlet"></a>Restlet</h4><p>&emsp;&emsp;Restlet API 是构建用于生产和消费 RESTful 系统的 Java API 先行者之一。它专注于为客户端和服务器生成一些非常干净、强大的 API。<br>&emsp;&emsp;Restlet Studio 是一个免费工具，能够在 RAML 和基于 swagger 的 API 描述之间进行转换，支持 Restlet、 Node 和 JAX-RS 服务器和客户端的骨架和 Stub 代码。网址：<a href="http://restlet.org" target="_blank" rel="noopener">http://restlet.org</a>  </p>
<h4 id="NetKernel"><a href="#NetKernel" class="headerlink" title="NetKernel"></a>NetKernel</h4><p>&emsp;&emsp;Netkernel 是一个比较有趣的 RESTful 系统。它基于微内核，是支持各种架构风格环境的代表。Netkernel 受益于在软件体系结构中采用 Web 的经济属性。你可以把它想象成“在内部引入 REST”。虽然任何基于 REST 的系统在外面看起来都一样，但在运行环境内部 NetKernel 看起来也一样。网址：<a href="http://netkernel.org" target="_blank" rel="noopener">http://netkernel.org</a>  </p>
<h4 id="Play"><a href="#Play" class="headerlink" title="Play"></a>Play</h4><p>&emsp;&emsp;两个主要的 Scala REST 框架之一。网址：<a href="https://www.playframework.com" target="_blank" rel="noopener">https://www.playframework.com</a>  </p>
<h4 id="Spray"><a href="#Spray" class="headerlink" title="Spray"></a>Spray</h4><p>&emsp;&emsp;两个主要的 Scala REST 框架之一。它设计成配合 Akka actor 模型一起工作。网址：<a href="http://spray.io" target="_blank" rel="noopener">http://spray.io</a>  </p>
<h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><p>&emsp;&emsp;两个主要的 Node.js REST 框架之一。网址：<a href="http://expressjs.com" target="_blank" rel="noopener">http://expressjs.com</a>  </p>
<h4 id="hapi"><a href="#hapi" class="headerlink" title="hapi"></a>hapi</h4><p>&emsp;&emsp;两个主要的 Node.js REST 框架之一。网址：<a href="http://hapijs.com" target="_blank" rel="noopener">http://hapijs.com</a>  </p>
<h4 id="Sinatra"><a href="#Sinatra" class="headerlink" title="Sinatra"></a>Sinatra</h4><p>&emsp;&emsp;Sinatra 是一个领域特定语言（DSL），用来在 Ruby 中创建 RESTful 应用程序。网址：<a href="http://www.sinatrarb.com" target="_blank" rel="noopener">http://www.sinatrarb.com</a>  </p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>&emsp;&emsp;通过浏览器调用 REST API 是可行的，但是还有其它客户端可用于测试和构建面向资源的系统。  </p>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><p>&emsp;&emsp;curl 是流行的库和命令行工具之一，支持在各种资源上调用各种协议。网址：<a href="https://curl.haxx.se" target="_blank" rel="noopener">https://curl.haxx.se</a>  </p>
<h4 id="httpie"><a href="#httpie" class="headerlink" title="httpie"></a>httpie</h4><p>&emsp;&emsp;httpie 是一个非常灵活和易用的客户端，支持通过 HTTP 与资源进行交互。网址：<a href="https://httpie.org" target="_blank" rel="noopener">https://httpie.org</a>  </p>
<h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>&emsp;&emsp;健全的 API 测试需要能够捕获和重播请求，支持各种身份验证和授权方案等功能。以前的命令行工具允许这样做，但 Postman 是一个较新的桌面应用程序，让这些工作对于开发团队来说变得更容易。网址：<a href="https://www.getpostman.com" target="_blank" rel="noopener">https://www.getpostman.com</a>  </p>
<h1 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h1><ul>
<li>“RESTful Web APIs”：Leonard Richardson、Mike Amundsen 和 Sam Ruby，2013，O’Reilly 出版社</li>
<li>“RESTful Web Services Cookbook”：Subbu Allamaraju，2010，O’Reilly 出版社</li>
<li>“REST in Practice”：Jim Webber、Savas Parastatidis 和 Ian Robinson，2010，O’Reilly 出版社。中文版《REST实战(中文版)》</li>
<li>“Restlet in Action” by Jerome Louvel and Thierry Boileau，2011，Manning 出版社</li>
<li>“Resource-Oriented Architecture Patterns for Webs of Data (Synthesis Lectures on the Semantic Web: Theory and Technology)”：Brian Sletten，2013，Morgan &amp; Claypool</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTPS 原理分析——带着疑问层层深入]]></title>
      <url>/2019/12/05/HttpsTheoryAnalysis/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://blog.leapmie.com/archives/418/" target="_blank" rel="noopener">https://blog.leapmie.com/archives/418/</a></p>
</blockquote>
<a id="more"></a>

<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>&emsp;&emsp;随着 HTTPS 建站的成本下降，现在大部分的网站都已经开始用上 HTTPS 协议。大家都知道 HTTPS 比 HTTP 安全，也听说过与 HTTPS 协议相关的概念有 SSL 、非对称加密、 CA证书等，但对于以下灵魂三拷问可能就答不上了：  </p>
<ol>
<li>为什么用了 HTTPS 就是安全的？</li>
<li>HTTPS 的底层原理如何实现？</li>
<li>用了 HTTPS 就一定安全吗？</li>
</ol>
<p>&emsp;&emsp;本文将层层深入，从原理上把 HTTPS 的安全性讲透。  </p>
<h1 id="HTTPS-的实现原理"><a href="#HTTPS-的实现原理" class="headerlink" title="HTTPS 的实现原理"></a>HTTPS 的实现原理</h1><p>&emsp;&emsp;大家可能都听说过 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实，HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。<br>&emsp;&emsp;HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：<br><img src="1378987910.png" alt=" ">  </p>
<h4 id="①-证书验证阶段"><a href="#①-证书验证阶段" class="headerlink" title="① 证书验证阶段"></a>① 证书验证阶段</h4><ol>
<li>浏览器发起 HTTPS 请求</li>
<li>服务端返回 HTTPS 证书</li>
<li>客户端验证证书是否合法，如果不合法则提示告警</li>
</ol>
<h4 id="②-数据传输阶段"><a href="#②-数据传输阶段" class="headerlink" title="② 数据传输阶段"></a>② 数据传输阶段</h4><ol>
<li>当证书验证合法后，在本地生成随机数</li>
<li>通过公钥加密随机数，并把加密后的随机数传输到服务端</li>
<li>服务端通过私钥对随机数进行解密</li>
<li>服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</li>
</ol>
<h2 id="为什么数据传输是用对称加密？"><a href="#为什么数据传输是用对称加密？" class="headerlink" title="为什么数据传输是用对称加密？"></a>为什么数据传输是用对称加密？</h2><p>&emsp;&emsp;首先，非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的；<br>&emsp;&emsp;另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密。  </p>
<h2 id="为什么需要-CA-认证机构颁发证书？"><a href="#为什么需要-CA-认证机构颁发证书？" class="headerlink" title="为什么需要 CA 认证机构颁发证书？"></a>为什么需要 CA 认证机构颁发证书？</h2><p>&emsp;&emsp;HTTP 协议被认为不安全是因为传输过程容易被监听者勾线监听、伪造服务器，而 HTTPS 协议主要解决的便是网络传输的安全性问题。<br>&emsp;&emsp;首先我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题。<br>&emsp;&emsp;“中间人攻击”的具体过程如下：<br><img src="2410496311.png" alt=" ">  </p>
<h4 id="过程原理："><a href="#过程原理：" class="headerlink" title="过程原理："></a>过程原理：</h4><ol>
<li>本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</li>
<li>中间人服务器返回中间人自己的证书</li>
<li>客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输</li>
<li>中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</li>
<li>中间人以客户端的请求内容再向正规网站发起请求</li>
<li>因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</li>
<li>中间人凭借与正规网站建立的对称加密算法对内容进行解密</li>
<li>中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</li>
<li>客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</li>
</ol>
<p>&emsp;&emsp;由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。  </p>
<h2 id="浏览器是如何确保-CA-证书的合法性？"><a href="#浏览器是如何确保-CA-证书的合法性？" class="headerlink" title="浏览器是如何确保 CA 证书的合法性？"></a>浏览器是如何确保 CA 证书的合法性？</h2><h3 id="1-证书包含什么信息？"><a href="#1-证书包含什么信息？" class="headerlink" title="1. 证书包含什么信息？"></a>1. 证书包含什么信息？</h3><ul>
<li>颁发机构信息</li>
<li>公钥</li>
<li>公司信息</li>
<li>域名</li>
<li>有效期</li>
<li>指纹</li>
<li>……</li>
</ul>
<h3 id="2-证书的合法性依据是什么？"><a href="#2-证书的合法性依据是什么？" class="headerlink" title="2. 证书的合法性依据是什么？"></a>2. 证书的合法性依据是什么？</h3><p>&emsp;&emsp;首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。  </p>
<h3 id="3-浏览器如何验证证书的合法性？"><a href="#3-浏览器如何验证证书的合法性？" class="headerlink" title="3. 浏览器如何验证证书的合法性？"></a>3. 浏览器如何验证证书的合法性？</h3><p>&emsp;&emsp;浏览器发起 HTTPS 请求时，服务器会返回网站的 SSL 证书，浏览器需要对证书做以下验证：  </p>
<ol>
<li>验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</li>
<li>判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；<br><img src="1148530856.png" alt=" ">  </li>
<li>判断证书是否被篡改。需要与 CA 服务器进行校验；</li>
<li>判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与 CA 服务器的交互，提高验证效率</li>
</ol>
<p>&emsp;&emsp;以上任意一步都满足的情况下浏览器才认为证书是合法的。  </p>
<blockquote>
<p>&emsp;&emsp;这里插一个我想了很久的但其实答案很简单的问题：<br>&emsp;&emsp;既然证书是公开的，如果要发起中间人攻击，我在官网上下载一份证书作为我的服务器证书，那客户端肯定会认同这个证书是合法的，如何避免这种证书冒用的情况？<br>&emsp;&emsp;其实这就是非加密对称中公私钥的用处，虽然中间人可以得到证书，但私钥是无法获取的，一份公钥是不可能推算出其对应的私钥，中间人即使拿到证书也无法伪装成合法服务端，因为无法对客户端传入的加密数据进行解密。  </p>
</blockquote>
<h3 id="4-只有认证机构可以生成证书吗？"><a href="#4-只有认证机构可以生成证书吗？" class="headerlink" title="4. 只有认证机构可以生成证书吗？"></a>4. 只有认证机构可以生成证书吗？</h3><p>&emsp;&emsp;如果需要浏览器不提示安全风险，那只能使用认证机构签发的证书。但浏览器通常只是提示安全风险，并不限制网站不能访问，所以从技术上谁都可以生成证书，只要有证书就可以完成网站的 HTTPS 传输。例如早期的 12306 采用的便是手动安装私有证书的形式实现 HTTPS 访问。<br><img src="1504265182.png" alt=" ">  </p>
<h2 id="本地随机数被窃取怎么办？"><a href="#本地随机数被窃取怎么办？" class="headerlink" title="本地随机数被窃取怎么办？"></a>本地随机数被窃取怎么办？</h2><p>&emsp;&emsp;证书验证是采用非对称加密实现，但是传输过程是采用对称加密，而其中对称加密算法中重要的随机数是由本地生成并且存储于本地的，HTTPS 如何保证随机数不会被窃取？<br>&emsp;&emsp;其实 HTTPS 并不包含对随机数的安全保证，HTTPS 保证的只是传输过程安全，而随机数存储于本地，本地的安全属于另一安全范畴，应对的措施有安装杀毒软件、反木马、浏览器升级修复漏洞等。  </p>
<h1 id="用了-HTTPS-会被抓包吗？"><a href="#用了-HTTPS-会被抓包吗？" class="headerlink" title="用了 HTTPS 会被抓包吗？"></a>用了 HTTPS 会被抓包吗？</h1><p>&emsp;&emsp;HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。<br>&emsp;&emsp;但是，正如前文所说，浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。  </p>
<h4 id="既然-HTTPS-不能防抓包，那-HTTPS-有什么意义？"><a href="#既然-HTTPS-不能防抓包，那-HTTPS-有什么意义？" class="headerlink" title="既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？"></a>既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？</h4><p>&emsp;&emsp;HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。  </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以下用简短的Q&amp;A形式进行全文总结：  </p>
<h4 id="Q-HTTPS-为什么安全？"><a href="#Q-HTTPS-为什么安全？" class="headerlink" title="Q: HTTPS 为什么安全？"></a>Q: HTTPS 为什么安全？</h4><p>A: 因为 HTTPS 保证了传输安全，防止传输过程被监听、防止数据被窃取，可以确认网站的真实性。</p>
<h4 id="Q-HTTPS-的传输过程是怎样的？"><a href="#Q-HTTPS-的传输过程是怎样的？" class="headerlink" title="Q: HTTPS 的传输过程是怎样的？"></a>Q: HTTPS 的传输过程是怎样的？</h4><p>A: 客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密。</p>
<h4 id="Q-为什么需要证书？"><a href="#Q-为什么需要证书？" class="headerlink" title="Q: 为什么需要证书？"></a>Q: 为什么需要证书？</h4><p>A: 防止”中间人“攻击，同时可以为网站提供身份证明。</p>
<h4 id="Q-使用-HTTPS-会被抓包吗？"><a href="#Q-使用-HTTPS-会被抓包吗？" class="headerlink" title="Q: 使用 HTTPS 会被抓包吗？"></a>Q: 使用 HTTPS 会被抓包吗？</h4><p>A: 会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。  </p>
<p>顺手 po 一张学习的过程图<br><img src="3247911170.jpg.png" alt=" ">  </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编程小知识]]></title>
      <url>/2019/12/01/ProgrammingTips/</url>
      <content type="html"><![CDATA[<p>&emsp;</p>
<a id="more"></a>

<h1 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h1><h2 id="ASP-NET-Core"><a href="#ASP-NET-Core" class="headerlink" title="ASP.NET Core"></a>ASP.NET Core</h2><h3 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h3><h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><h3 id="SignalR"><a href="#SignalR" class="headerlink" title="SignalR"></a>SignalR</h3><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><h3 id="Razor-Pages"><a href="#Razor-Pages" class="headerlink" title="Razor Pages"></a>Razor Pages</h3><h3 id="Blazor"><a href="#Blazor" class="headerlink" title="Blazor"></a>Blazor</h3><h3 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h3><h2 id="WPF"><a href="#WPF" class="headerlink" title="WPF"></a>WPF</h2><h2 id="Xamarin"><a href="#Xamarin" class="headerlink" title="Xamarin"></a>Xamarin</h2><h1 id="C-35"><a href="#C-35" class="headerlink" title="C&#35;"></a>C&#35;</h1><blockquote>
<p>构建某个类型的某个实例时系统所执行的操作：</p>
<ol>
<li>把存放静态变量的空间清零。</li>
<li>执行静态变量的初始化语句。</li>
<li>执行基类的静态构造函数。</li>
<li>执行（本类的）静态构造函数。</li>
<li>把存放实例变量的空间清零。</li>
<li>执行实例变量的初始化语句。</li>
<li>适当地执行基类的实例构造函数。</li>
<li>执行（本类的）实例构造函数。</li>
</ol>
<p>&emsp;&emsp;以后如果还要构造该类型的实例，那么会直接从第5步开始执行，因为类级别的初始化工作只执行一次就够了。此外，可以通过链式调用构造函数的办法来优化第6、7两步，使得编译器在制作程序码时不再生成重复的指令。</p>
</blockquote>
<blockquote>
<p>在类的继承体系中，位于根部的那个基类应该做到以下几点：</p>
<ul>
<li>实现 IDisposable 接口，以便释放资源。</li>
<li>如果本身含有非托管资源，那就添加 finalizer，以防客户端忘记调用 Dispose() 方法。若是没有非托管资源，则不用添加 finalizer。</li>
<li>Dispose 方法与 finalizer（如果有的话）都把释放资源的工作委派给虚方法，使得子类能够重写该方法，以释放它们自己的资源。</li>
</ul>
<p>继承体系中的子类应该做到以下几点：</p>
<ul>
<li>如果子类中有自己的资源需要释放，那就重写由基类所定义的那个虚方法，若是没有，则不用重写该方法。</li>
<li>如果子类自身的某个成员字段表示的是非托管资源，那么就实现 finalizer，若没有这样的字段，则不用实现 finalizer。</li>
<li>记得调用基类的同名函数。</li>
</ul>
</blockquote>
<blockquote>
<p>实现 IDisposable.Dispose() 方法时，要注意以下四点：</p>
<ol>
<li>把非托管资源全都释放掉。</li>
<li>把托管资源全都释放掉（这也包括不再订阅早前关注的那些事件）。</li>
<li>设定相关的状态标志，用以表示该对象已经清理过了。如果对象已经清理过了之后还有人要访问其中的公有成员，那么你可以通过此标志得知这一状况，从而令这些操作抛出 ObjectDisposedException。</li>
<li>阻止垃圾回收器重复清理该对象。这可以通过 GC.SuppressFinalize(this) 来完成。</li>
</ol>
</blockquote>
<blockquote>
<p>C# 提供了 4 种不同的函数，用来决定两个对象是否“相等”：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ReferenceEquals</span>(<span class="params"><span class="keyword">object</span> left, <span class="keyword">object</span> right</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> left, <span class="keyword">object</span> right</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> right</span>)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> ==(MyClass left, MyClass right);</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>&emsp;&emsp;.NET 中的每个对象都有哈希码，其哈希码由 System.Object.GetHashCode() 决定。如果要重写该方法，那么必须遵守下面 3 条规则：</p>
<ol>
<li>如果（实例版本的 Equals() 方法认定的）两个对象相等，那么这两个对象的哈希码也必须相同，否则，容器无法通过正确的哈希码来寻找相应的元素。</li>
<li>对于任何一个对象 A 来说，GetHashCode() 必须在实例层面上满足这样一种不变条件（或者说，在实例层面上具备这样一种固定的性质）—— 在 A 的生命期内，无论实例 A 在执行完 GetHashCode() 方法之后还执行过其他哪些方法，当它再度执行 GetHashCode() 时，必定返回与当初相同的值。这条性质用来确保容器总是能把 A 放在正确的桶中。</li>
<li>对于常见的输入值来说，哈希函数应该把这些值均匀地映射到各个整数上，而不应该使自己所输出的哈希码仅仅集中在几个整数上。如果每一个整数都能有相似的概率来充当对象的哈希码，那么基于哈希的容器就能够较为高效地运作。简单来说，就是要保证自己所实现的 GetHashCode() 能够让元素均匀地保存在容器的每一个桶中。此外，每个桶的元素个数也不宜太多。</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通俗易懂，什么是.NET? 什么是.NET Framework? 什么是.NET Core?]]></title>
      <url>/2019/11/28/WhatIsDotNet/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/1996V/p/9037603.html" target="_blank" rel="noopener">https://www.cnblogs.com/1996V/p/9037603.html</a></p>
</blockquote>
<p>&emsp;&emsp;什么是.NET？什么是.NET Framework?本文将从上往下，循序渐进的介绍一系列相关.NET的概念，先从类型系统开始讲起，我将通过跨语言操作这个例子来逐渐引入一系列.NET的相关概念，这主要包括：CLS、CTS(CLI)、FCL、Windows下CLR的相关核心组成、Windows下托管程序运行概念、什么是.NET Framework，.NET Core，.NET Standard及一些VS编译器相关杂项和相关阅读链接。完整的从上读到下则你可以理解个大概的.NET体系。</p>
<a id="more"></a>

<p><strong>目录</strong></p>
<ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET和C-是什么关系">.NET和C#是什么关系</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#跨语言和跨平台是什么">跨语言和跨平台是什么</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是跨语言互操作，什么是CLS">什么是跨语言互操作，什么是CLS</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#CLS异常">CLS异常</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CTS？">什么是CTS？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是类库？">什么是类库？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是基础类库BCL？">什么是基础类库BCL？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是框架类库FCL？">什么是框架类库FCL？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是基元类型？">什么是基元类型？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#System-Object的意义">System.Object的意义</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#计算机是如何运行程序的？">计算机是如何运行程序的？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CPU">什么是CPU？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是高级编程语言">什么是高级编程语言？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是托管代码，托管语言，托管模块？">什么是托管代码，托管语言，托管模块？</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#非托管的异常">非托管的异常</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CLR，-NET虚拟机？">什么是CLR，.NET虚拟机？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是CLR宿主进程，运行时主机？">什么是CLR宿主进程，运行时主机？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#Windows系统自带-NET-Framework">Windows系统自带.NET Framework</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework-4-0-30319">.NET Framework 4.0.30319</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework4-X覆盖更新">.NET Framework4.X覆盖更新</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何确认本机安装了哪些-NET-Framework和对应CLR的版本？">如何确认本机安装了哪些.NET Framework和对应CLR的版本？</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#什么是程序集">什么是程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#用csc-exe进行编译">用csc.exe进行编译</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET程序执行原理">.NET程序执行原理</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#JIT编译">JIT编译</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#AOT编译">AOT编译</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集的规则">程序集的规则</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集的加载方式">程序集的加载方式</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#强名称程序集">强名称程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#程序集搜索规则">程序集搜索规则</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目的依赖顺序">项目的依赖顺序</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#为什么Newtonsoft-Json版本不一致？">为什么Newtonsoft.Json版本不一致？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何在编译时加载两个相同的程序集？">如何在编译时加载两个相同的程序集</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何同时调用两个相同命名空间和类型的程序集？">如何同时调用两个相同命名空间和类型的程序集？</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#共享程序集GAC">共享程序集GAC</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#延伸">延伸</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#应用程序域">应用程序域</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#跨边界访问">跨边界访问</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#AppDomain和AppPool">AppDomain和AppPool</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#内存">内存</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#堆栈和堆的区别">堆栈和堆的区别</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#线程堆栈">线程堆栈</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#为什么值类型存储在栈上">为什么值类型存储在栈上</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#托管堆模型">托管堆模型</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#选class还是struct">选class还是struct</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#GC管理器">GC管理器</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#弱引用、弱事件">弱引用、弱事件</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#GC堆回收">GC堆回收</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#垃圾回收对性能的影响">垃圾回收对性能的影响</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#性能建议">性能建议</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET程序执行图">.NET程序执行图</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET的安全性">.NET的安全性</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#基于角色的安全性">基于角色的安全性</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#代码访问安全性">代码访问安全性</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET是什么">什么是.NET</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Framework是什么">什么是.NET Framework</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#如何在VS中调试-NET-Framework源代码">如何在VS中调试.NET Framework源代码</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Core是什么">什么是.NET Core</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET-Standard是什么">什么是.NET Standard</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#NET官方开源项目链接">.NET官方开源项目链接</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#Visual-Studio">Visual Studio</a><ul>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#sln解决方案">sln解决方案</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目模板">项目模板</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#csproj工程文件">csproj工程文件</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#项目属性杂项">项目属性杂项</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#IntelliTrace智能追溯">IntelliTrace智能追溯</a></li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#链接">链接</a></li>
</ul>
</li>
<li><a href="https://tao-lol.top/2019/11/28/WhatIsDotNet/#建议">建议</a></li>
</ul>
<h1 id="NET和C-是什么关系"><a href="#NET和C-是什么关系" class="headerlink" title=".NET和C#是什么关系"></a>.NET和C#是什么关系</h1><p>&emsp;&emsp;语言，是人们进行沟通表达的主要方式。编程语言，是人与机器沟通的表达方式。不同的编程语言，其侧重点不同。有的编程语言是为了科学计算而开发的，所以其语法和功能更偏向于函数式思想。有些则是为了开发应用程序而创立的，所以其语法和功能更为均衡全面。<br>&emsp;&emsp;微软公司是全球最大的电脑软件提供商，为了占据开发者市场，进而在2002年推出了Visual Studio(简称VS，是微软提供给开发者的工具集) .NET 1.0版本的开发者平台。而为了吸引更多的开发者涌入平台，微软还在2002年宣布推出一个特性强大并且与.NET平台无缝集成的编程语言，即C# 1.0正式版。<br>&emsp;&emsp;只要是.NET支持的编程语言，开发者就可以通过.NET平台提供的工具服务和框架支持便捷的开发应用程序。<br>&emsp;&emsp;C#就是为宣传.NET而创立的，它直接集成于Visual Studio .NET中，VB也在.NET 1.0发布后对其进行支持， 所以这两门语言与.NET平台耦合度很高，并且.NET上的技术大多都是以C#编程语言为示例，所以经常就.NET和C#混为一谈(实质上它们是相辅相成的两个概念)。<br>&emsp;&emsp;而作为一个开发者平台，它不仅仅是包含开发环境、技术框架、社区论坛、服务支持等，它还强调了平台的跨语言、跨平台编程的两个特性。  </p>
<h1 id="跨语言和跨平台是什么"><a href="#跨语言和跨平台是什么" class="headerlink" title="跨语言和跨平台是什么"></a>跨语言和跨平台是什么</h1><p>&emsp;&emsp;跨语言：即只要是面向.NET平台的编程语言(C#、Visual Basic、C++/CLI、Eiffel、F#、IronPython、IronRuby、PowerBuilder、Visual COBOL 以及 Windows PowerShell)，用其中一种语言编写的类型可以无缝地用在另一种语言编写的应用程序中的互操作性。<br>&emsp;&emsp;跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意有.NET框架实现的平台上，即代码不依赖于操作系统，也不依赖硬件环境。  </p>
<h1 id="什么是跨语言互操作，什么是CLS"><a href="#什么是跨语言互操作，什么是CLS" class="headerlink" title="什么是跨语言互操作，什么是CLS"></a>什么是跨语言互操作，什么是CLS</h1><p>&emsp;&emsp;每门语言在最初被设计时都有其在功能和语法上的定位，让不同的人使用擅长的语言去干合适的事，这在团队协作时尤为重要。<br>&emsp;&emsp;.NET平台上的跨语言是通过CLS这个概念来实现的，接下来我就以C#和VB来演示 什么是.NET中的跨语言互操作性。<br>&emsp;&emsp;通俗来说，虽然c#和vb是两个不同的语言，但此处c#写的类可以在vb中当做自家写的类一样正常使用。<br>&emsp;&emsp;比如我在vb中写了一个针对String的首字母大写的扩展方法，将其编译后的dll引用至C#项目中。<br><img src="1026815-20180626183857074-2096426398.png" alt=" "><br>&emsp;&emsp;在C#项目中，可以像自身代码一样正常使用来自vb这个dll的扩展方法。<br><img src="1026815-20180626183936496-928087425.png" alt=" "><br>&emsp;&emsp;现在有那么多面向对象语言，但不是所有编程语言都能这样直接互操作使用，而.NET平台支持的C#和VB之所以能这样无缝衔接，先读而后知，后文将会介绍缘由。不过虽然.NET平台提供了这样一个互操作的特性，但终究语言是不一样的，每个语言有其特色和差异处，在相互操作的时候就会难免遇到一些例外情况。<br>&emsp;&emsp;比如我在C#中定义了一个基类，类里面包含一个公开的指针类型的成员，我想在vb中继承这个类，并访问这个公开的成员。<br><img src="1026815-20180626184210340-127662462.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626184235037-299865363.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;但是vb语言因为其定位不需要指针，所以并没有C#中如int*这样的指针类型，所以在vb中访问一个该语言不支持的类型会报错的，会提示：字段的类型不受支持。<br>&emsp;&emsp;再比如，C#语言中，对类名是区分大小写的，我在C#中定义了两个类，一个叫BaseBusiness，另一个叫baseBusiness。我在vb中去继承这个BaseBusiness类。<br><img src="1026815-20180626184409472-1770998540.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626184415319-1635326718.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;如图，在vb中访问这个类会报错的，报:”BaseBusiness”不明确，这是因为在vb中对类名是不区分大小写的。在vb中，它认为它同时访问了两个一模一样的类，所以按照vb的规则这是不合理的。那么为了在vb调用c#的程序集中避免这些因语言的差异性而导致的错误，在编写c#代码的时候 就应该提前知道vb中的这些规则，来应付式的开发。<br>&emsp;&emsp;但是，如果我想不仅仅局限于C#和VB，我还想我编写的代码在.Net平台上通用的话，那么我还必须得知道.NET平台支持的每一种语言和我编写代码所使用的语言的差异，从而在编写代码中避免这些。<br>&emsp;&emsp;这几年编程语言层出不穷，在将来.NET可能还会支持更多的语言，如果说对一个开发者而言掌握所有语言的差异处这是不现实的，所以.NET专门为此参考每种语言并找出了语言间的共性，然后定义了一组规则，开发者都遵守这个规则来编码，那么代码就能被任意.NET平台支持的语言所通用。<br>&emsp;&emsp;而与其说是规则，不如说它是一组语言互操作的标准规范，它就是公共语言规范 - Common Language Specification ,简称CLS<br><img src="1026815-20180626184537026-621328968.png" alt=" "><br>&emsp;&emsp;CLS从类型、命名、事件、属性、数组等方面对语言进行了共性的定义及规范。这些东西被提交给欧洲计算机制造联合会ECMA，称为：共同语言基础设施。<br>&emsp;&emsp;就以类型而言，CLS定义了在C#语言中符合规范的类型和不符合的有：<br><img src="1026815-20180626190145917-2079608898.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180626190219058-1162748836.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;当然，就编码角度而言，我们不是必须要看那些详略的文档。为了方便开发者开发，.NET提供了一个特性，名叫：<code>CLSCompliantAttribute</code>，代码被<code>CLSCompliantAttribute</code>标记后，如果你写的代码不符合CLS规范的话，编译器就会给你一条警告。<br><img src="1026815-20180626184619698-1304394925.png" alt=" "><br>&emsp;&emsp;值得一提的是，CLS规则只是面向那些公开可被其它程序集访问的成员，如<code>public</code>、继承的<code>protected</code>，对于该程序集的内部成员如<code>private</code>、<code>internal</code>则不会执行该检测规则。也就是说，所适应的CLS遵从性规则，仅是那些公开的成员，而非私有实现。<br><img src="1026815-20180626184828785-553094494.png" alt=" "><br>&emsp;&emsp;那么有没有那种特殊情况，比如我通过反射技术来访问该程序集中，当前语言并不拥有的类型时会发生什么情况呢？<br>&emsp;&emsp;答案是可以尝试的，如用vb反射访问c#中的<code>char*</code>指针类型，即使vb中没有<code>char*</code>这种等价的指针类型，但mscorlib提供了针对指针类型的 <code>Pointer</code> 包装类供其访问，可以从运行时类携带的类型名称看到其原本的类型名。<br><img src="1026815-20180626184959109-1666010143.png" alt=" "><br>&emsp;&emsp;可以看到，该类中的元素是不符合CLS规范的。  </p>
<h2 id="CLS异常"><a href="#CLS异常" class="headerlink" title="CLS异常"></a>CLS异常</h2><p>&emsp;&emsp;提到特殊情况，还要说的一点就是异常处理。.NET框架组成中定义了异常类型系统，在编译器角度，所有catch捕获的异常都必须继承自<code>System.Exception</code>，如果你要调用一个 由不遵循此规范的语言 抛出其它类型的异常对象(C++允许抛出任何类型的异常，如C#调用C++代码，C++抛出一个string类型的异常)，在C#2.0之前Catch(Exception)是捕捉不了的，但之后的版本可以。<br>&emsp;&emsp;在后续版本中，微软提供了<code>System.Runtime.CompilerServices.RuntimeWrappedException</code>异常类，将那些不符合CLS的包含Exception的对象封装起来。并且可以通过<code>RuntimeCompatibilityAttribute</code>特性来过滤这些异常。<br>&emsp;&emsp;RuntimeWrappedException ：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimewrappedexception?view=netframework-4.7.2" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/api/system.runtime.compilerservices.runtimewrappedexception?view=netframework-4.7.2</a>  </p>
<h2 id="那么，这个段落总结一下，什么是CLS呢？"><a href="#那么，这个段落总结一下，什么是CLS呢？" class="headerlink" title="那么，这个段落总结一下，什么是CLS呢？"></a>那么，这个段落总结一下，什么是CLS呢？</h2><p>&emsp;&emsp;在面向.NET开发中，编写跨语言组件时所遵循的那些共性，那些规范就叫做 Common Langrage Specification简称 CLS，公共语言规范<br>&emsp;&emsp;官方CLS介绍：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/language-independence-and-language-independent-components" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/language-independence-and-language-independent-components</a>  </p>
<h1 id="什么是CTS？"><a href="#什么是CTS？" class="headerlink" title="什么是CTS？"></a>什么是CTS？</h1><p>&emsp;&emsp;如果理解了什么是CLS的话，那么你将很轻松理解什么是CTS。<br>&emsp;&emsp;假设你已经围绕着封装 继承 多态 这3个特性设计出了多款面向对象的语言，你发现大家都是面向对象，都能很好的将现实中的对象模型表达出来。除了语法和功能擅长不同，语言的定义和设计结构其实都差不多一回事。<br>&emsp;&emsp;比如，现实中你看到了一辆小汽车，这辆车里坐着两个人，那么如何用这门语言来表达这样的一个概念和场面？<br>&emsp;&emsp;首先要为这门语言横向定义一个“类型”的概念。接下来在程序中就可以这样表示：有一个汽车类型，有一个人类型，在一个汽车类型的对象内包含着两个人类型的对象，因为要表达出这个模型，你又引入了“对象”的概念 。而现在，你又看到，汽车里面的人做出了开车的这样一个动作，由此你又引入了“动作指令”这样一个概念。<br>&emsp;&emsp;接着，你又恍然大悟总结出一个定理，无论是什么样的“类型”，都只会存在这样一个特征，即活着的 带生命特征的(如人) 和 死的 没有生命特征的(如汽车) 这两者中的一个。最后，随着思想模型的成熟，你发现，这个“类型”就相当于一个富有主体特征的一组指令的集合。<br>&emsp;&emsp;好，然后你开始照葫芦画瓢。你参考其它程序语言，你发现大家都是用<code>class</code>来表示类的含义，用<code>struct</code>表示结构的含义，用<code>new</code>来表示 新建一个对象的含义，于是，你对这部分功能的语法也使用class和new关键字来表示。然后你又发现，他们还用很多关键字来更丰富的表示这些现实模型，比如<code>override</code>、<code>virtual</code>等。于是，在不断的思想升级和借鉴后，你对这个设计语言过程中思想的变化仔细分析，对这套语言体系给抽象归纳，最终总结出一套体系。<br>&emsp;&emsp;于是你对其它人这样说，我总结出了一门语言很多必要的东西如两种主要类别：值类别和引用类别，五个主要类型：类、接口、委托、结构、枚举，我还规定了，一个类型可以包含字段、属性、方法、事件等成员，我还指定了每种类型的可见性规则和类型成员的访问规则，等等等等，只要按照我这个体系来设计语言，设计出来的语言它能够拥有很多不错的特性，比如跨语言，跨平台等，C#和VB.net之所以能够这样就是因为这两门语言的设计符合我这个体系。  </p>
<h2 id="那么，什么是CTS呢？"><a href="#那么，什么是CTS呢？" class="headerlink" title="那么，什么是CTS呢？"></a>那么，什么是CTS呢？</h2><p>&emsp;&emsp;当你需要设计面向.Net的语言时所需要遵循一个体系(.Net平台下的语言都支持的一个体系)这个体系就是CTS（Common Type System 公共类型系统），它包括但不限于：  </p>
<ul>
<li>建立用于跨语言执行的框架。</li>
<li>提供面向对象的模型，支持在 .NET 实现上实现各种语言。 </li>
<li>定义处理类型时所有语言都必须遵守的一组规则(CLS)。 </li>
<li>提供包含应用程序开发中使用的基本基元数据类型（如 <code>Boolean</code>、<code>Byte</code>、<code>Char</code> 等）的库。  </li>
</ul>
<p>&emsp;&emsp;上文的CLS是CTS（Common Type System 公共类型系统）这个体系中的子集。<br>&emsp;&emsp;一个编程语言，如果它能够支持CTS，那么我们就称它为面向.NET平台的语言。<br>&emsp;&emsp;官方CTS介绍： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/common-type-system" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/common-type-system</a>  </p>
<blockquote>
<p>微软已经将CTS和.NET的一些其它组件，提交给ECMA以成为公开的标准，最后形成的标准称为CLI（Common Language Infrastructure）公共语言基础结构。<br>所以有的时候你见到的书籍或文章有的只提起CTS，有的只提起CLI，请不要奇怪，你可以宽泛的把他们理解成一个意思，CLI是微软将CTS等内容提交给国际组织计算机制造联合会ECMA的一个工业标准。  </p>
</blockquote>
<h1 id="什么是类库？"><a href="#什么是类库？" class="headerlink" title="什么是类库？"></a>什么是类库？</h1><p>&emsp;&emsp;在CTS中有一条就是要求基元数据类型的类库。我们先搞清什么是类库？类库就是类的逻辑集合，你开发工作中你用过或自己编写过很多工具类，比如搞Web的经常要用到的 JsonHelper、XmlHelper、HttpHelper 等等，这些类通常都会在命名为Tool、Utility等这样的项目中。 像这些类的集合我们可以在逻辑上称之为 “类库”，比如这些Helper我们统称为工具类库。  </p>
<h2 id="什么是基础类库BCL？"><a href="#什么是基础类库BCL？" class="headerlink" title="什么是基础类库BCL？"></a>什么是基础类库BCL？</h2><p>&emsp;&emsp;当你通过VS创建一个项目后，你这个项目就已经引用好了通过.NET下的语言编写好的一些类库。比如控制台中你直接就可以用<code>Console</code>类来输出信息，或者<code>using System.IO</code> 即可通过<code>File</code>类对文件进行读取或写入操作，这些类都是微软帮你写好的，不用你自己去编写，它帮你编写了一个面向.NET的开发语言中使用的基本的功能，这部分类，我们称之为BCL（Base Class Library）， 基础类库，它们大多都包含在<code>System</code>命名空间下。<br>&emsp;&emsp;基础类库BCL包含：基本数据类型，文件操作，集合，自定义属性，格式设置，安全属性，I/O流，字符串操作，事件日志等的类型  </p>
<h2 id="什么是框架类库FCL？"><a href="#什么是框架类库FCL？" class="headerlink" title="什么是框架类库FCL？"></a>什么是框架类库FCL？</h2><p>&emsp;&emsp;有关BCL的就不在此一一类举。.NET之大，发展至今，由微软帮助开发人员编写的类库越来越多，这让我们开发人员开发更加容易。由微软开发的类库统称为：FCL，Framework Class Library ，.NET框架类库，我上述所表达的BCL就是FCL中的一个基础部分，FCL中大部分类都是通过C#来编写的。<br>&emsp;&emsp;在FCL中，除了最基础的那部分BCL之外，还包含我们常见的 如 ： 用于网站开发技术的 ASP.NET类库，该子类包含webform/webpage/mvc，用于桌面开发的 WPF类库、WinForm类库，用于通信交互的WCF、asp.net web api、Web Service类库等等  </p>
<h1 id="什么是基元类型？"><a href="#什么是基元类型？" class="headerlink" title="什么是基元类型？"></a>什么是基元类型？</h1><p>&emsp;&emsp;像上文在CTS中提到了 基本基元数据类型，大家知道，每门语言都会定义一些基础的类型，比如C#通过 <code>int</code> 来定义整型，用 <code>string</code> 来定义 字符串 ，用 <code>object</code> 来定义 根类。当我们来描述这样一个类型的对象时可以有这两种写法，如图：<br><img src="1026815-20180626185607189-1458214346.png" alt=" "><br>&emsp;&emsp;我们可以看到，上边用首字母小写的蓝色体string、object能描述，用首字母大写的浅蓝色String、Object也能描述,这两种表述方式有何不同？<br>&emsp;&emsp;要知道，在vs默认的颜色方案中，蓝色体 代表关键字，浅蓝色体 代表类型。<br>&emsp;&emsp;那么这样也就意味着，由微软提供的FCL类库里面 包含了 一些用于描述数据类型的 基础类型，无论我们使用的是什么语言，只要引用了FCL，我们都可以通过new一个类的方式来表达数据类型。<br>&emsp;&emsp;如图：<br><img src="1026815-20180626185646714-1678378546.png" alt=" "><br>&emsp;&emsp;用new来创建这些类型的对象，但这样就太繁琐，所以C#就用 <code>int</code> 关键字来表示<code>System.Int32</code>，用 <code>string</code> 关键字来表示 <code>System.String</code> 等，所以我们才能这样去写。<br><img src="1026815-20180626185736390-1921725105.png" alt=" "><br>&emsp;&emsp;像这样被表述于编译器直接支持的类型叫做基元类型，它被直接映射于BCL中具体的类。<br>&emsp;&emsp;下面是部分面向.NET的语言的基元类型与对应的BCL的类别图：<br><img src="1026815-20180626190310924-274605711.png" alt=" ">  </p>
<h1 id="System-Object的意义"><a href="#System-Object的意义" class="headerlink" title="System.Object的意义"></a>System.Object的意义</h1><p>&emsp;&emsp;说起类型，这里要说CTS定义的一个非常重要的规则，就是类与类之间只能单继承，<code>System.Object</code>类是所有类型的根，任何类都是显式或隐式的继承于<code>System.Object</code>。<br>&emsp;&emsp;<code>System.Object</code>定义了类型的最基本的行为：用于实例比较的<code>Equals</code>系列方法、用于Hash表中Hash码的<code>GetHashCode</code>、用于Clr运行时获取的类型信息<code>GetType</code>、用于表示当前对象字符串的<code>ToString</code>、用于执行实例的浅复制<code>MemberwiseClone</code>、用于GC回收前操作的析构方法<code>Finalize</code> 这6类方法。<br>&emsp;&emsp;所以 Object不仅是C#语言的类型根、还是VB等所有面向.NET的语言的类型根，它是整个FCL的类型根。<br>&emsp;&emsp;当然，CTS定义了单继承，很多编程语言都满足这个规则，但也有语言是例外，如C++就不做继承限制，可以继承多个，C++/CLI作为C++在对.NET的CLI实现，如果在非托管编码中多继承那也可以，如果试图在托管代码中多继承，那就会报错。我前面已经举过这样特殊情况的例子，这也在另一方面反映出，各语言对CTS的支持并不是都如C#那样全面的，我们只需明记一点：对于符合CTS的那部分自然就按照CTS定义的规则来。 任何可遵循CTS的类型规范，同时又有.NET运行时的实现的编程语言就可以成为.NET中的一员。  </p>
<h1 id="计算机是如何运行程序的？"><a href="#计算机是如何运行程序的？" class="headerlink" title="计算机是如何运行程序的？"></a>计算机是如何运行程序的？</h1><p>&emsp;&emsp;接下来我要说什么是.NET的跨平台，并解释为什么能够跨语言。不过要想知道什么是跨平台，首先你得知道一个程序是如何在本机上运行的。  </p>
<h2 id="什么是CPU"><a href="#什么是CPU" class="headerlink" title="什么是CPU"></a>什么是CPU</h2><p>&emsp;&emsp;CPU,全称Central Processing Unit,叫做中央处理器,它是一块超大规模的集成电路，是计算机组成上必不可少的组成硬件，没了它，计算机就是个壳。<br>&emsp;&emsp;无论你编程水平怎样，你都应该先知道，CPU是一台计算机的运算核心和控制核心，CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码，执行指令。<br>&emsp;&emsp;我们运行一个程序，CPU就会不断的读取程序中的指令并执行，直到关闭程序。事实上，从电脑开机开始，CPU就一直在不断的执行指令直到电脑关机。  </p>
<h2 id="什么是高级编程语言"><a href="#什么是高级编程语言" class="headerlink" title="什么是高级编程语言"></a>什么是高级编程语言</h2><p>&emsp;&emsp;在计算机角度，每一种CPU类型都有自己可以识别的一套指令集，计算机不管你这个程序是用什么语言来编写的，其最终只认其CPU能够识别的二进制指令集。<br>&emsp;&emsp;在早期计算机刚发展的时代，人们都是直接输入01010101这样的没有语义的二进制指令来让计算机工作的，可读性几乎没有，没人愿意直接编写那些没有可读性、繁琐、费时，易出差错的二进制01代码，所以后来才出现了编程语言。<br>&emsp;&emsp;编程语言的诞生，使得人们编写的代码有了可读性，有了语义，与直接用01相比，更有利于记忆。<br>&emsp;&emsp;而前面说了，计算机最终只识别二进制的指令，那么，我们用编程语言编写出来的代码就必须要转换成供机器识别的指令。<br>&emsp;&emsp;就像这样：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">code: 1+2 </span><br><span class="line">function 翻译方法(参数:code) </span><br><span class="line">&#123; </span><br><span class="line">    ... </span><br><span class="line">    &quot;1&quot;=&gt;&quot;001&quot;; </span><br><span class="line">    &quot;2&quot;=&gt;&quot;002&quot;;</span><br><span class="line">    &quot;+&quot;=&gt;&quot;000&quot;; </span><br><span class="line">    return 能让机器识别的二进制代码; </span><br><span class="line">&#125; </span><br><span class="line">call 翻译方法(&quot;1+2&quot;) =&gt; &quot;001 000 002&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以从一门编程语言所编写的代码文件转换成能让本机识别的指令，这中间是需要一个翻译的过程。<br>&emsp;&emsp;而我们现在计算机上是运载着操作系统的，光翻译成机器指令也不行，还得让代码文件转化成可供操作系统执行的程序才行。<br>&emsp;&emsp;那么这些步骤，就是编程语言所对应的编译环节的工程了。这个翻译过程是需要工具来完成，我们把它叫做 编译器。<br>&emsp;&emsp;不同厂商的CPU有着不同的指令集，为了克服面向CPU的指令集的难读、难编、难记和易出错的缺点，后来就出现了面向特定CPU的特定汇编语言， 比如我打上这样的x86汇编指令 mov ax,bx ，然后用上用机器码做的汇编器，它将会被翻译成 1000100111011000 这样的二进制01格式的机器指令。<br>&emsp;&emsp;不同CPU架构上的汇编语言指令不同，而为了统一一套写法，同时又不失汇编的表达能力，C语言就诞生了。<br>&emsp;&emsp;用C语言写的代码文件，会被C编译器先转换成对应平台的汇编指令，再转成机器码，最后将这些过程中产生的中间模块链接成一个可以被操作系统执行的程序。<br>&emsp;&emsp;那么汇编语言和C语言比较，我们就不需要去阅读特定CPU的汇编码，我只需要写通用的C源码就可以实现程序的编写，我们用将更偏机器实现的汇编语言称为低级语言，与汇编相比，C语言就称之为高级语言。<br>&emsp;&emsp;在看看我们C#，我们在编码的时候都不需要过于偏向特定平台的实现，翻译过程也基本遵循这个过程。它的编译模型和C语言类似，都是属于这种间接转换的中间步骤，故而能够跨平台。<br>&emsp;&emsp;所以就类似于C/C#等这样的高级语言来说是不区分平台的，而在于其背后支持的这个 翻译原理 是否能支持其它平台。  </p>
<h1 id="什么是托管代码，托管语言，托管模块？"><a href="#什么是托管代码，托管语言，托管模块？" class="headerlink" title="什么是托管代码，托管语言，托管模块？"></a>什么是托管代码，托管语言，托管模块？</h1><p>&emsp;&emsp;作为一门年轻的语言，C#借鉴了许多语言的长处，与C比较，C#则更为高级。<br>&emsp;&emsp;往往一段简小的C#代码，其功能却相当于C的一大段代码，并且用C#语言你几乎不需要指针的使用，这也就意味着你几乎不需要进行人为的内存管控与安全考虑因素，也不需要多懂一些操作系统的知识，这让编写程序变得更加轻松和快捷。<br>&emsp;&emsp;如果说C#一段代码可以完成其它低级语言一大段任务，那么我们可以说它特性丰富或者类库丰富。而用C#编程不需要人为内存管控是怎么做到的呢？<br>&emsp;&emsp;.NET提供了一个垃圾回收器(GC)来完成这部分工作，当你创建类型的时候，它会自动给你分配所需要的这部分内存空间。就相当于，有一个专门的软件或进程，它会读取你的代码，然后当你执行这行代码的时候，它帮你做了内存分配工作。 这部分本该你做的工作，它帮你做了，这就是“托管”的概念。比如现实中 托管店铺、托管教育等这样的别人替你完成的概念。<br>&emsp;&emsp;因此，C#被称之为托管语言。C#编写的代码也就称之为托管代码,C#生成的模块称之为托管模块等。(对于托管的资源，是不需要也无法我们人工去干预的，但我们可以了解它的一些机制原理，在后文我会简单介绍。)<br>&emsp;&emsp;只要有比较，就会产生概念。那么在C#角度，那些脱离了.NET提供的诸如垃圾回收器这样的环境管制，就是对应的 非托管了。  </p>
<h2 id="非托管的异常"><a href="#非托管的异常" class="headerlink" title="非托管的异常"></a>非托管的异常</h2><p>&emsp;&emsp;我们编写的程序有的模块是由托管代码编写，有的模块则调用了非托管代码。在.NET Framework中也有一套基于此操作系统SEH的异常机制，理想的机制设定下我们可以直接通过<code>catch(e)</code>或<code>catch</code>来捕获指定的异常和框架设计人员允许我们捕获的异常。<br>&emsp;&emsp;而异常类型的级别也有大有小，有小到可以直接框架本身或用代码处理的，有大到需要操作系统的异常机制来处理。.NET会对那些能让程序崩溃的异常类型给进行标记，对于这部分异常，在.NET Framework 4.0之前允许开发人员在代码中自己去处理，但4.0版本之后有所变更，这些被标记的异常默认不会在托管环境中抛出(即无法catch到)，而是由操作系统的SEH机制去处理。<br>&emsp;&emsp;不过如果你仍然想在代码中捕获处理这样的异常也是可以的，你可以对需要捕获的方法上标记<code>[System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute]</code>特性，就可以在该方法内通过<code>catch</code>捕获到该类型的异常。你也可以通过在配置文件中添加运行时节点来对全局进行这样的一个配置：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">    &lt;legacyCorruptedStateExceptionsPolicy enabled=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HandleProcessCorruptedStateExceptions特性：<a href="https://msdn.microsoft.com/zh-cn/library/azure/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/azure/system.runtime.exceptionservices.handleprocesscorruptedstateexceptionsattribute.aspx</a><br>&emsp;&emsp;SEHException类：<a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.sehexception(v=vs.100).aspx</a><br>&emsp;&emsp;处理损坏状态异常博客专栏： <a href="https://msdn.microsoft.com/zh-cn/magazine/dd419661.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/magazine/dd419661.aspx</a>  </p>
<h1 id="什么是CLR，-NET虚拟机？"><a href="#什么是CLR，-NET虚拟机？" class="headerlink" title="什么是CLR，.NET虚拟机？"></a>什么是CLR，.NET虚拟机？</h1><p>&emsp;&emsp;实际上，.NET不仅提供了自动内存管理的支持，他还提供了一些列的如类型安全、应用程序域、异常机制等支持，这些 都被统称为CLR公共语言运行库。<br>&emsp;&emsp;CLR是.NET类型系统的基础，所有的.NET技术都是建立在此之上，熟悉它可以帮助我们更好的理解框架组件的核心、原理。<br>&emsp;&emsp;在我们执行托管代码之前，总会先运行这些运行库代码，通过运行库的代码调用，从而构成了一个用来支持托管程序的运行环境，进而完成诸如不需要开发人员手动管理内存，一套代码即可在各大平台跑的这样的操作。<br>&emsp;&emsp;这套环境及体系之完善，以至于就像一个小型的系统一样，所以通常形象的称CLR为”.NET虚拟机”。那么，如果以进程为最低端，进程的上面就是.NET虚拟机(CLR)，而虚拟机的上面才是我们的托管代码。换句话说，托管程序实际上是寄宿于.NET虚拟机中。  </p>
<h1 id="什么是CLR宿主进程，运行时主机？"><a href="#什么是CLR宿主进程，运行时主机？" class="headerlink" title="什么是CLR宿主进程，运行时主机？"></a>什么是CLR宿主进程，运行时主机？</h1><p>&emsp;&emsp;那么相对应的，容纳.NET虚拟机的进程就是CLR宿主进程了，该程序称之为运行时主机。<br>&emsp;&emsp;这些运行库的代码，全是由C/C++编写，具体表现为以 <code>mscoree.dll</code> 为代表的核心dll文件，该dll提供了N多函数用来构建一个CLR环境 ，最后当运行时环境构建完毕(一些函数执行完毕)后，调用<code>_CorDllMain</code>或<code>_CorExeMain</code>来查找并执行托管程序的入口方法(如控制台就是Main方法)。<br>&emsp;&emsp;如果你足够熟悉CLR，那么你完全可以在一个非托管程序中通过调用运行库函数来定制CLR并执行托管代码。<br>&emsp;&emsp;像SqlServer就集成了CLR，可以使用任何 .NET Framework 语言编写存储过程、触发器、用户定义类型、用户定义函数（标量函数和表值函数）以及用户定义的聚合函数。<br>&emsp;&emsp;有关CLR大纲介绍： <a href="https://msdn.microsoft.com/zh-cn/library/9x0wh2z3(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/9x0wh2z3(v=vs.85).aspx</a><br>&emsp;&emsp;CLR集成： <a href="https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/ms131052(v%3dsql.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/sql/sql-server-2008/ms131052(v%3dsql.100)</a><br>&emsp;&emsp;构造CLR的接口：<a href="https://msdn.microsoft.com/zh-cn/library/ms231039(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms231039(v=vs.85).aspx</a><br>&emsp;&emsp;适用于 .NET Framework 2.0 的宿主接口：<a href="https://msdn.microsoft.com/zh-cn/library/ms164336(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms164336(v=vs.85).aspx</a><br>&emsp;&emsp;选择CLR版本： <a href="https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/startup/supportedruntime-element" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/configure-apps/file-schema/startup/supportedruntime-element</a><br>&emsp;&emsp;所以C#编写的程序如果想运行就必须要依靠.NET提供的CLR环境来支持。 而CLR是.NET技术框架中的一部分，故只要在Windows系统中安装.NET Framework即可。  </p>
<h1 id="Windows系统自带-NET-Framework"><a href="#Windows系统自带-NET-Framework" class="headerlink" title="Windows系统自带.NET Framework"></a>Windows系统自带.NET Framework</h1><p>&emsp;&emsp;Windows系统默认安装的有.NET Framework，并且可以安装多个.NET Framework版本，你也不需要因此卸载，因为你使用的应用程序可能依赖于特定版本，如果你移除该版本，则应用程序可能会中断。<br>&emsp;&emsp;Microsoft .NET Framework百度百科下有windows系统默认安装的.NET版本<br><img src="1026815-20180626193928463-1860763399.png" alt=" "><br>&emsp;&emsp;图出自 <a href="https://baike.baidu.com/item/Microsoft%20.NET%20Framework/9926417?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/Microsoft%20.NET%20Framework/9926417?fr=aladdin</a>  </p>
<h1 id="NET-Framework-4-0-30319"><a href="#NET-Framework-4-0-30319" class="headerlink" title=".NET Framework 4.0.30319"></a>.NET Framework 4.0.30319</h1><p>&emsp;&emsp;在%SystemRoot%\Microsoft.NET下的Framework和Framework64文件夹中分别可以看到32位和64位的.NET Framework安装的版本。<br>&emsp;&emsp;我们点进去可以看到以.NET版本号为命名的文件夹，有2.0,3.0,3.5,4.0这几个文件夹。<br><img src="1026815-20180626190844595-825495686.png" alt=" ">  </p>
<h2 id="NET-Framework4-X覆盖更新"><a href="#NET-Framework4-X覆盖更新" class="headerlink" title=".NET Framework4.X覆盖更新"></a>.NET Framework4.X覆盖更新</h2><p>&emsp;&emsp;要知道.NET Framework版本目前已经迭代到4.7系列，电脑上明明安装了比4.0更高版本的.NET Framework，然而从文件夹上来看，最高不过4.0，这是为何？<br>&emsp;&emsp;原来自.NET Framework 4以来的所有.NET Framework版本都是直接在v4.0.30319文件夹上覆盖更新，并且无法安装以前的4.x系列的老版本，所以v4.0.30319这个目录中其实放的是你最后一次更新的NET Framework版本。<br>&emsp;&emsp;.NET Framework覆盖更新：<a href="https://docs.microsoft.com/en-us/dotnet/framework/install/guide-for-developers" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/install/guide-for-developers</a>  </p>
<h2 id="如何确认本机安装了哪些-NET-Framework和对应CLR的版本？"><a href="#如何确认本机安装了哪些-NET-Framework和对应CLR的版本？" class="headerlink" title="如何确认本机安装了哪些.NET Framework和对应CLR的版本？"></a>如何确认本机安装了哪些.NET Framework和对应CLR的版本？</h2><p>&emsp;&emsp;我们可以通过注册表等其它方式来查看安装的最新版本：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/migration-guide/how-to-determine-which-versions-are-installed</a> 。<br>&emsp;&emsp;不过如果不想那么复杂的话，还有种最直接简单的：<br>&emsp;&emsp;那就是进入该目录文件夹，随便找到几个文件对其右键，然后点击详细信息即可查看到对应的文件版本，可以依据文件版本估摸出.NET Framework版本，比如csc.exe文件。<br><img src="1026815-20180626191049347-855171658.png" alt=" ">  </p>
<h1 id="什么是程序集"><a href="#什么是程序集" class="headerlink" title="什么是程序集"></a>什么是程序集</h1><p>&emsp;&emsp;上文我介绍了编译器，即将源代码文件给翻译成一个计算机可识别的二进制程序。而在.NET Framework目录文件夹中就附带的有 用于C#语言的命令行形式的编译器<code>csc.exe</code> 和 用于VB语言的命令行形式的编译器<code>vbc.exe</code>。<br>&emsp;&emsp;我们通过编译器可以将后缀为<code>.cs(C#)</code>和<code>.vb(VB)</code>类型的文件编译成程序集。<br>&emsp;&emsp;程序集是一个抽象的概念，不同的编译选项会产生不同形式的程序集。以文件个数来区分的话，那么就分 单文件程序集(即一个文件)和多文件程序集(多个文件)。<br>&emsp;&emsp;而不论是单文件程序集还是多文件程序集，其总有一个核心文件，就是表现为后缀为<code>.dll</code>或<code>.exe</code>格式的文件。它们都是标准的PE格式的文件，主要由4部分构成：  </p>
<ol>
<li>PE头，即Windows系统上的可移植可执行文件的标准格式 </li>
<li>CLR头，它是托管模块特有的，它主要包括 <ol>
<li>程序入口方法</li>
<li>CLR版本号等一些标志</li>
<li>一个可选的强名称数字签名</li>
<li>元数据表，主要用来记录了在源代码中定义和引用的所有的类型成员(如方法、字段、属性、参数、事件…)的位置和其标志Flag(各种修饰符)<br>正是因为元数据表的存在，VS才能智能提示，反射才能获取MemberInfo，CLR扫描元数据表即可获得该程序集的相关重要信息，所以元数据表使得程序集拥有了自我描述的这一特性。clr2中，元数据表大概40多个，其核心按照用途分为3类： <ol>
<li>即用于记录在源代码中所定义的类型的定义表：ModuleDef、TypeDef、MethodDef、ParamDef、FieldDef、PropertyDef、EventDef，</li>
<li>引用了其它程序集中的类型成员的引用表：MemberRef、AssemblyRef、ModuleRef、TypeRef</li>
<li>用于描述一些杂项(如版本、发布者、语言文化、多文件程序集中的一些资源文件等)的清单表：AssemblyDef、FileDef、ManifestResourceDef、ExportedTypeDef</li>
</ol>
</li>
</ol>
</li>
<li>IL代码(也称MSIL，后来被改名为CIL：Common Intermediate Language通用中间语言)，是介于源代码和本机机器指令中间的代码，将通过CLR在不同的平台产生不同的二进制机器码。 </li>
<li>一些资源文件  </li>
</ol>
<p>&emsp;&emsp;多文件程序集的诞生场景有：比如我想为.exe绑定资源文件(如Icon图标)，或者我想按照功能以增量的方式来按需编译成.dll文件。 通常很少情况下才会将源代码编译成多文件程序集，并且在VS IDE中总是将源代码给编译成单文件的程序集(要么是.dll或.exe)，所以接下来我就以单文件程序集为例来讲解。  </p>
<h1 id="用csc-exe进行编译"><a href="#用csc-exe进行编译" class="headerlink" title="用csc.exe进行编译"></a>用csc.exe进行编译</h1><p>&emsp;&emsp;现在，我将演示一段文本是如何被csc.exe编译成一个可执行的控制台程序的。<br>&emsp;&emsp;我们新建个记事本，然后将下面代码复制上去。  </p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Net.Sockets;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span> rootDirectory = Environment.CurrentDirectory;</span><br><span class="line">        Console.WriteLine(<span class="string">"开始连接，端口号：8090"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        socket.Bind(<span class="keyword">new</span> System.Net.IPEndPoint(System.Net.IPAddress.Loopback, <span class="number">8090</span>));</span><br><span class="line">        socket.Listen(<span class="number">30</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Socket socketClient = socket.Accept();</span><br><span class="line">            Console.WriteLine(<span class="string">"新请求"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="keyword">int</span> length = socketClient.Receive(buffer, <span class="number">4096</span>, SocketFlags.None);</span><br><span class="line">            <span class="keyword">string</span> requestStr = Encoding.UTF8.GetString(buffer, <span class="number">0</span>, length);</span><br><span class="line">            Console.WriteLine(requestStr);</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">string</span>[] strs = requestStr.Split(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"\r\n"</span> &#125;, StringSplitOptions.None);</span><br><span class="line">            <span class="keyword">string</span> url = strs[<span class="number">0</span>].Split(<span class="string">' '</span>)[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] statusBytes, headerBytes, bodyBytes;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Path.GetExtension(url) == <span class="string">".jpg"</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> status = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">                statusBytes = Encoding.UTF8.GetBytes(status);</span><br><span class="line">                bodyBytes = File.ReadAllBytes(rootDirectory + url);</span><br><span class="line">                <span class="keyword">string</span> header = <span class="keyword">string</span>.Format(<span class="string">"Content-Type:image/jpg;\r\ncharset=UTF-8\r\nContent-Length:&#123;0&#125;\r\n"</span>, bodyBytes.Length);</span><br><span class="line">                headerBytes = Encoding.UTF8.GetBytes(header);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (url == <span class="string">"/"</span>)</span><br><span class="line">                    url = <span class="string">"默认页"</span>;</span><br><span class="line">                <span class="keyword">string</span> status = <span class="string">"HTTP/1.1 200 OK\r\n"</span>;</span><br><span class="line">                statusBytes = Encoding.UTF8.GetBytes(status);</span><br><span class="line">                <span class="keyword">string</span> body = <span class="string">"&lt;html&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;head&gt;"</span> +</span><br><span class="line">                        <span class="string">"&lt;title&gt;socket webServer  -- Login&lt;/title&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;/head&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;body&gt;"</span> +</span><br><span class="line">                       <span class="string">"&lt;div style=\"text-align:center\"&gt;"</span> +</span><br><span class="line">                           <span class="string">"当前访问"</span> + url +</span><br><span class="line">                       <span class="string">"&lt;/div&gt;"</span> +</span><br><span class="line">                    <span class="string">"&lt;/body&gt;"</span> +</span><br><span class="line">                <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">                bodyBytes = Encoding.UTF8.GetBytes(body);</span><br><span class="line">                <span class="keyword">string</span> header = <span class="keyword">string</span>.Format(<span class="string">"Content-Type:text/html;charset=UTF-8\r\nContent-Length:&#123;0&#125;\r\n"</span>, bodyBytes.Length);</span><br><span class="line">                headerBytes = Encoding.UTF8.GetBytes(header);</span><br><span class="line">            &#125;</span><br><span class="line">            socketClient.Send(statusBytes);</span><br><span class="line">            socketClient.Send(headerBytes);</span><br><span class="line">            socketClient.Send(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; (<span class="keyword">byte</span>)<span class="string">'\r'</span>, (<span class="keyword">byte</span>)<span class="string">'\n'</span> &#125;);</span><br><span class="line">            socketClient.Send(bodyBytes);</span><br><span class="line"></span><br><span class="line">            socketClient.Close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后关闭记事本，将之.txt的后缀改为.cs的后缀(后缀是用来标示这个文件是什么类型的文件，并不影响文件的内容)。<br>&emsp;&emsp;上述代码相当于Web中的http.sys伪实现，是建立了通信的socket服务端，并通过while循环来不断的监视获取包的数据实现最基本的监听功能，最终我们将通过csc.exe将该文本文件编译成一个控制台程序。<br>&emsp;&emsp;我已经在前面讲过BCL，基础类库。在这部分代码中，为了完成我想要的功能，我用到了微软已经帮我们实现好了的<code>String</code>数据类型系列类(.NET下的一些数据类型)、<code>Environment</code>类(提供有关当前环境和平台的信息以及操作它们的方法)、<code>Console</code>类(用于控制台输入输出等)、<code>Socket</code>系列类(对tcp协议抽象的接口)、<code>File</code>文件系列类(对文件目录等操作系统资源的一些操作)、<code>Encoding</code>类(字符流的编码)等<br>&emsp;&emsp;这些类，都属于BCL中的一部分，它们存在但不限于<code>mscorlib.dll</code>、<code>System.dll</code>、<code>System.core.dll</code>、<code>System.Data.dll</code>等这些程序集中。<br>&emsp;&emsp;附：不要纠结BCL到底存在于哪些dll中，总之，它是个物理分散，逻辑上的类库总称。<br>&emsp;&emsp;mscorlib.dll和System.dll的区别：<a href="https://stackoverflow.com/questions/402582/mscorlib-dll-system-dll" target="_blank" rel="noopener">https://stackoverflow.com/questions/402582/mscorlib-dll-system-dll</a><br>&emsp;&emsp;因为我用了这些类，那么按照编程规则我必须在代码中using这些类的命名空间，并通过<code>csc.exe</code>中的 <code>/r:dll</code>路径 命令来为生成的程序集注册元数据表(即以AssemblyRef为代表的程序集引用表)。<br>&emsp;&emsp;而这些代码引用了4个命名空间，但实际上它们只被包含在<code>mscorlib.dll</code>和<code>System.dll</code>中，那么我只需要在编译的时候注册这两个dll的信息就行了。<br>&emsp;&emsp;好，接下来我将通过<code>cmd</code>运行<code>csc.exe</code>编译器，再输入编译命令： <code>csc /out:D:\demo.exe D:\dic\demo.cs /r:D:\dic\System.dll</code>  </p>
<ul>
<li><code>/r</code>：是将引用dll中的类型数据注册到程序集中的元数据表中。  </li>
<li><code>/out</code>:是输出文件的意思，如果没有该命令则默认输出<code>{name}.exe</code>。  </li>
</ul>
<p>&emsp;&emsp;使用csc.exe编译生成： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe</a><br>&emsp;&emsp;csc编译命令行介绍：<a href="https://www.cnblogs.com/shuang121/archive/2012/12/24/2830874.html" target="_blank" rel="noopener">https://www.cnblogs.com/shuang121/archive/2012/12/24/2830874.html</a><br>&emsp;&emsp;总之，你除了要掌握基本的编译指令外，当你打上这行命令并按回车后，必须满足几个条件，1.是.cs后缀的c#格式文件，2.是 代码语法等检测分析必须正确，3.是 使用的类库必须有出处(引用的dll)，当然 因为我是编译为控制台程序，所以还必须得有个静态Main方法入口，以上缺一不可。<br>&emsp;&emsp;可以看出，这段命令我是将 位于D:\dic\的demo.cs文件给编译成 位于D:\名为demo.exe的控制台文件，并且因为在代码中使用到了System.dll，所以还需要通过/r注册该元数据表。<br>&emsp;&emsp;这里得注意为什么没有<code>/r:mscorlib.dll</code>,因为mscorlib.dll地位的特殊，所以csc总是对每个程序集进行mscorlib.dll的注册(自包含引用该dll),因此我们可以不用<code>/r:mscorlib.dll</code>这个引用命令，但为了演示效果我还是决定通过<code>/nostdlib</code>命令来禁止csc默认导入mscorlib.dll文件。<br>&emsp;&emsp;所以，最终命令是这样的： <code>csc D:\dic\demo.cs /r:D:\dic\mscorlib.dll /r:D:\dic\System.dll /nostdlib</code><br><img src="1026815-20180626192059660-977860665.png" alt=" "><br>&emsp;&emsp;因为没有指定输出文件<code>/out</code>选项， 所以会默认输出在与csc同一目录下名为demo.exe的文件。事实上，在csc的命令中，如果你没有指定路径，那么就默认采用在csc.exe的所在目录的相对路径。<br><img src="1026815-20180626192159540-608756226.png" alt=" "><br>&emsp;&emsp;而我们可以看到，在该目录下有许多程序集，其中就包含我们需要的System.dll和mscorlib.dll，所以我们完全可以直接<code>/r:mscorlib.dll /r:System.dll</code><br>&emsp;&emsp;而类似于System.dll、System.Data.dll这样使用非常频繁的程序集，我们其实不用每次编译的时候都去手动/r一下，对于需要重复劳动的编译指令，我们可以将其放在后缀为.rsp的指令文件中，然后在编译时直接调用文件即可执行里面的命令 <code>@ {name}.rsp</code>。<br><img src="1026815-20180626192239508-1912250944.png" alt=" "><br>&emsp;&emsp;csc.exe默认包含csc.rsp文件,我们可以用<code>/noconfig</code>来禁止默认包含，而csc.rsp里面已经写好了我们会经常用到的指令。<br>&emsp;&emsp;所以，最终我可以这样写 <code>csc D:\dic\demo.cs</code> 直接生成控制台应用程序。<br><img src="1026815-20180626193627595-1254138010.gif" alt=" ">  </p>
<h1 id="NET程序执行原理"><a href="#NET程序执行原理" class="headerlink" title=".NET程序执行原理"></a>.NET程序执行原理</h1><p>&emsp;&emsp;好的，现在我们已经有了一个demo.exe的可执行程序，它是如何被我们运行的？<br>&emsp;&emsp;C#源码被编译成程序集，程序集内主要是由一些元数据表和IL代码构成，我们双击执行该exe，Windows加载器将该exe(PE格式文件)给映射到虚拟内存中，程序集的相关信息都会被加载至内存中，并查看PE文件的入口点  (EntryPoint)并跳转至指定的mscoree.dll中的<code>_CorExeMain</code>函数，该函数会执行一系列相关dll来构造CLR环境，当CLR预热后调用该程序集的入口方法<code>Main()</code>，接下来由CLR来执行托管代码(IL代码)。  </p>
<h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>&emsp;&emsp;前面说了，计算机最终只识别二进制的机器码，在CLR下有一个用来将IL代码转换成机器码的引擎，称为Just In Time Compiler，简称JIT，CLR总是先将IL代码按需通过该引擎编译成机器指令再让CPU执行，在这期间CLR会验证代码和元数据是否类型安全(在对象上只调用正确定义的操作、标识与声称的要求一致、对类型的引用严格符合所引用的类型)，被编译过的代码无需JIT再次编译，而被编译好的机器指令是被存在内存当中，当程序关闭后再打开仍要重新JIT编译。  </p>
<h2 id="AOT编译"><a href="#AOT编译" class="headerlink" title="AOT编译"></a>AOT编译</h2><p>&emsp;&emsp;CLR的内嵌编译器是即时性的，这样的一个很明显的好处就是可以根据当时本机情况生成更有利于本机的优化代码，但同样的，每次在对代码编译时都需要一个预热的操作，它需要一个运行时环境来支持，这之间还是有消耗的。<br>&emsp;&emsp;而与即时编译所对应的，就是提前编译了，英文为Ahead of Time Compilation，简称AOT，也称之为静态编译。<br>&emsp;&emsp;在.NET中，使用<code>Ngen.exe</code>或者开源的<code>.NET Native</code>可以提前将代码编译成本机指令。<br>&emsp;&emsp;Ngen是将IL代码提前给全部编译成本机代码并安装在本机的本机映像缓存中，故而可以减少程序因JIT预热的时间，但同样的也会有很多注意事项，比如因JIT的丧失而带来的一些特性就没有了，如类型验证。Ngen仅是尽可能代码提前编译，程序的运行仍需要完整的CLR来支持。<br>&emsp;&emsp;.NET Native在将IL转换为本机代码的时候，会尝试消除所有元数据将依靠反射和元数据的代码替换为静态本机代码，并且将完整的CLR替换为主要包含垃圾回收器的重构运行时<code>mrt100_app.dll</code>。<br>&emsp;&emsp;.NET Native: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/net-native/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/net-native/</a><br>&emsp;&emsp;Ngen.exe：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator</a><br>&emsp;&emsp;Ngen与.NET Native比较：<a href="https://www.zhihu.com/question/27997478/answer/38978762" target="_blank" rel="noopener">https://www.zhihu.com/question/27997478/answer/38978762</a>  </p>
<hr>
<p>&emsp;&emsp;现在，我们可以通过<code>ILDASM</code>工具(一款查看程序集IL代码的软件，在Microsoft SDKs目录中的子目录中)来查看该程序集的元数据表和Main方法中间码。<br><img src="1026815-20180626194204408-1416829392.png" alt=" "><br>&emsp;&emsp;c#源码第一行代码：<code>string rootDirectory = Environment.CurrentDirectory</code>;被翻译成IL代码： <code>call string [mscorlib/*23000001*/]System.Environment/*01000004*/::get_CurrentDirectory() /* 0A000003 */</code><br>&emsp;&emsp;这句话意思是调用 <code>System.Environment</code>类的<code>get_CurrentDirectory()</code>方法(属性会被编译为一个私有字段+对应get/set方法)。<br>&emsp;&emsp;点击视图=&gt;元信息=&gt;显示，即可查看该程序集的元数据。<br>&emsp;&emsp;我们可以看到<code>System.Environment</code>标记值为01000004，在<code>TypeRef</code>类型引用表中找到该项:<br><img src="1026815-20180626194233787-1487817175.png" alt=" "><br>&emsp;&emsp;注意图，<code>TypeRefName</code>下面有该类型中被引用的成员，其标记值为0A000003，也就是<code>get_CurrentDirectory</code>了。<br>&emsp;&emsp;而从其<code>ResolutionScope</code>指向位于0x23000001而得之，该类型存在于mscorlib程序集。<br><img src="1026815-20180626194312588-1104904496.png" alt=" "><br>&emsp;&emsp;于是我们打开mscorlib.dll的元数据清单，可以在类型定义表(TypeDef)找到<code>System.Environment</code>,可以从元数据得知该类型的一些标志(Flags,常见的public、sealed、class、abstract)，也得知继承(Extends)于<code>System.Object</code>。在该类型定义下还有类型的相关信息，我们可以在其中找到<code>get_CurrentDirectory</code>方法。 我们可以得到该方法的相关信息，这其中表明了该方法位于0x0002b784这个相对虚地址(RVA)，接着JIT在新地址处理CIL，周而复始。<br>&emsp;&emsp;元数据在运行时的作用： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/metadata-and-self-describing-components#run-time-use-of-metadata" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/metadata-and-self-describing-components#run-time-use-of-metadata</a>  </p>
<h1 id="程序集的规则"><a href="#程序集的规则" class="headerlink" title="程序集的规则"></a>程序集的规则</h1><p>&emsp;&emsp;上文我通过ILDASM来描述CLR执行代码的方式，但还不够具体，还需要补充的是对于程序集的搜索方式。<br>&emsp;&emsp;对于System.Environment类型，它存在于mscorlib.dll程序集中，demo.exe是个独立的个体，它通过csc编译的时候只是注册了引用mscorlib.dll中的类型的引用信息，并没有记录mscorlib.dll在磁盘上的位置，那么，CLR怎么知道get_CurrentDirectory的代码？它是从何处读取mscorlib.dll的？<br>&emsp;&emsp;对于这个问题，.NET有个专门的概念定义，我们称为 程序集的加载方式。  </p>
<h2 id="程序集的加载方式"><a href="#程序集的加载方式" class="headerlink" title="程序集的加载方式"></a>程序集的加载方式</h2><p>&emsp;&emsp;对于自身程序集内定义的类型，我们可以直接从自身程序集中的元数据中获取，对于在其它程序集中定义的类型，CLR会通过一组规则来在磁盘中找到该程序集并加载在内存。<br>&emsp;&emsp;CLR在查找引用的程序集的位置时候，第一个判断条件是 判断该程序集是否被签名。<br>&emsp;&emsp;什么是签名？  </p>
<h2 id="强名称程序集"><a href="#强名称程序集" class="headerlink" title="强名称程序集"></a>强名称程序集</h2><p>&emsp;&emsp;就比如大家都叫张三，姓名都一样，喊一声张三不知道到底在叫谁。这时候我们就必须扩展一下这个名字以让它具有唯一性。<br>&emsp;&emsp;我们可以通过<code>sn.exe</code>或<code>VS</code>对项目右键属性在签名选项卡中采取RSA算法对程序集进行数字签名（加密：公钥加密，私钥解密。签名：私钥签名，公钥验证签名），会将构成程序集的所有文件通过哈希算法生成哈希值，然后通过非对称加密算法用私钥签名，最后公布公钥生成一串token，最终将生成一个由程序集名称、版本号、语言文化、公钥组成的唯一标识，它相当于一个强化的名称，即强名称程序集。<br>&emsp;&emsp;<code>mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</code><br>&emsp;&emsp;我们日常在VS中的项目默认都没有被签名，所以就是弱名称程序集。强名称程序集是具有唯一标识性的程序集，并且可以通过对比哈希值来比较程序集是否被篡改，不过仍然有很多手段和软件可以去掉程序集的签名。<br>&emsp;&emsp;需要值得注意的一点是：当你试图在已生成好的强名称程序集中引用弱名称程序集，那么你必须对弱名称程序集进行签名并在强名称程序集中重新注册。<br>&emsp;&emsp;之所以这样是因为一个程序集是否被篡改还要考虑到该程序集所引用的那些程序集，根据CLR搜索程序集的规则(下文会介绍)，没有被签名的程序集可以被随意替换，所以考虑到安全性，强名称程序集必须引用强名称程序集，否则就会报错：需要强名称程序集。<br>&emsp;&emsp;.NET Framework 4.5中对强签名的更改：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/enhanced-strong-naming" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/enhanced-strong-naming</a>  </p>
<h2 id="程序集搜索规则"><a href="#程序集搜索规则" class="headerlink" title="程序集搜索规则"></a>程序集搜索规则</h2><p>&emsp;&emsp;事实上，按照存储位置来说，程序集分为共享(全局)程序集和私有程序集。<br>&emsp;&emsp;CLR查找程序集的时候，会先判断该程序集是否被强签名，如果强签名了那么就会去共享程序集的存储位置(后文的GAC)去找，如果没找到或者该程序集没有被强签名，那么就从该程序集的同一目录下去寻找。<br>&emsp;&emsp;强名称程序集是先找到与程序集名称(VS中对项目右键属性应用程序-&gt;程序集名称)相等的文件名称，然后 按照唯一标识再来确认，确认后CLR加载程序集，同时会通过公钥效验该签名来验证程序集是否被篡改(如果想跳过验证可查阅<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/how-to-disable-the-strong-name-bypass-feature)，如果强名称程序集被篡改则报错。" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/how-to-disable-the-strong-name-bypass-feature)，如果强名称程序集被篡改则报错。</a><br>&emsp;&emsp;而弱名称程序集则直接按照与程序集名称相等的文件名称来找，如果还是没有找到就以该程序集名称为目录的文件夹下去找。总之，如果最终结果就是没找到那就会报<code>System.IO.FileNotFoundException</code>异常，即尝试访问磁盘上不存在的文件失败时引发的异常。<br>&emsp;&emsp;注意：此处文件名称和程序集名称是两个概念，不要模棱两可，文件CLR头内嵌程序集名称。<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;我有一个控制台程序，其路径为D:\Demo\Debug\demo.exe，通过该程序的元数据得知，其引用了一个程序集名称为aa的普通程序集，引用了一个名为bb的强名称程序集，该bb.dll的强名称标识为：xx001。<br>&emsp;&emsp;现在CLR开始搜索程序集aa，首先它会从demo.exe控制台的同一目录（也就是D:\Demo\Debug\）中查找程序集aa，搜索文件名为aa.dll的文件，如果没找到就在该目录下以程序集名称为目录的目录中查找，也就是会查 D:\Demo\Debug\aa\aa.dll，这也找不到那就报错。<br>&emsp;&emsp;然后CLR开始搜索程序集bb，CLR从demo.exe的元数据中发现bb是强名称程序集，其标识为:xx001。于是CLR会先从一个被定义为GAC的目录中去通过标识找，没找到的话剩下的寻找步骤就和寻找aa一样完全一致了。<br>&emsp;&emsp;当然，你也可以通过配置文件config中(配置文件存在于应用程序的同一目录中)人为增加程序集搜索规则：<br>&emsp;&emsp;1.在运行时<code>runtime</code>节点中，添加<code>privatePath</code>属性来添加搜索目录，不过只能填写相对路径：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;probing privatePath=&quot;relative1;relative2;&quot; /&gt; //程序集当前目录下的相对路径目录，用;号分割</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;2.如果程序集是强签名后的，那么可以通过<code>codeBase</code>来指定网络路径或本地绝对路径。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;dependentAssembly&gt;</span><br><span class="line">                    &lt;assemblyIdentity name=&quot;myAssembly&quot;</span><br><span class="line">                                      publicKeyToken=&quot;32ab4ba45e0a69a1&quot;</span><br><span class="line">                                      culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                    &lt;codeBase version=&quot;2.0.0.0&quot;</span><br><span class="line">                              href=&quot;http://www.litwareinc.com/myAssembly.dll&quot; /&gt;</span><br><span class="line">                &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，我们还可以在代码中通过<code>AppDomain</code>类中的几个成员来改变搜索规则，如<code>AssemblyResolve</code>事件、<code>AppDomainSetup</code>类等。<br>&emsp;&emsp;有关运行时节点的描述:<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/runtime-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/runtime-element</a>  </p>
<h2 id="项目的依赖顺序"><a href="#项目的依赖顺序" class="headerlink" title="项目的依赖顺序"></a>项目的依赖顺序</h2><p>&emsp;&emsp;如果没有通过config或者在代码中来设定CLR搜索程序集的规则，那么CLR就按照默认的也就是我上述所说的模式来寻找。<br>&emsp;&emsp;所以如果我们通过csc.exe来编译项目，引用了其它程序集的话，通常需要将那些程序集复制到同一目录下。故而每当我们通过VS编译器对项目右键重新生成项目(重新编译)时，VS都会将引用的程序集给复制一份到项目bin\输出目录Debug文件夹下，我们可以通过VS中对引用的程序集右键属性-复制本地 True/Flase 来决定这一默认行为。<br>&emsp;&emsp;值得一提的是，项目间的生成是有序生成的，它取决于项目间的依赖顺序。<br>&emsp;&emsp;比如Web项目引用BLL项目，BLL项目引用了DAL项目。那么当我生成Web项目的时候，因为我要注册Bll程序集，所以我要先生成Bll程序集，而BLL程序集又引用了Dal，所以又要先生成Dal程序集，所以程序集生成顺序就是Dal=&gt;BLL=&gt;Web，项目越多编译的时间就越久。<br>&emsp;&emsp;程序集之间的依赖顺序决定了编译顺序，所以在设计项目间的分层划分时不仅要体现出层级职责，还要考虑到依赖顺序。代码存放在哪个项目要有讲究，不允许出现互相引用的情况，比如A项目中的代码引用B，B项目中的代码又引用A。  </p>
<h2 id="为什么Newtonsoft-Json版本不一致？"><a href="#为什么Newtonsoft-Json版本不一致？" class="headerlink" title="为什么Newtonsoft.Json版本不一致？"></a>为什么Newtonsoft.Json版本不一致？</h2><p>&emsp;&emsp;而除了注意编译顺序外，我们还要注意程序集间的版本问题，版本间的错乱会导致程序的异常。<br>&emsp;&emsp;举个经典的例子：Newtonsoft.Json的版本警告，大多数人都知道通过版本重定向来解决这个问题，但很少有人会琢磨为什么会出现这个问题，找了一圈文章，没找到一个解释的。<br>&emsp;&emsp;比如：<br>&emsp;&emsp;A程序集引用了 C盘:\Newtonsoft.Json 6.0程序集<br>&emsp;&emsp;B程序集引用了 从Nuget下载下来的Newtonsoft.Json 10.0程序集<br>&emsp;&emsp;此时A引用B，就会报：发现同一依赖程序集的不同版本间存在无法解决的冲突 这一警告。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A：引用Newtonsoft.Json 6.0</span><br><span class="line">       Func()</span><br><span class="line">       &#123;</span><br><span class="line">           var obj= Newtonsoft.Json.Obj;</span><br><span class="line">           B.JsonObj();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">B: 引用Newtonsoft.Json 10.0</span><br><span class="line">       JsonObj()</span><br><span class="line">       &#123;</span><br><span class="line">           return  Newtonsoft.Json.Obj;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;A程序集中的Func方法调用了B程序集中的JsonObj方法，JsonObj方法又调用了Newtonsoft.Json 10.0程序集中的对象，那么当执行Func方法时程序就会异常，报<code>System.IO.FileNotFoundException</code>: 未能加载文件或程序集Newtonsoft.Json 10.0的错误。<br>&emsp;&emsp;这是为什么？  </p>
<ol>
<li>这是因为依赖顺序引起的。A引用了B，首先会先生成B，而B引用了 Newtonsoft.Json 10.0，那么VS就会将源引用文件(Newtonsoft.Json 10.0)复制到B程序集同一目录(bin/Debug)下，名为Newtonsoft.Json.dll文件，其内嵌程序集版本为10.0。  </li>
<li>然后A引用了B，所以会将B程序集和B程序集的依赖项(Newtonsoft.Json.dll)给复制到A的程序集目录下，而A又引用了C盘的Newtonsoft.Json 6.0程序集文件，所以又将C:\Newtonsoft.Json.dll文件给复制到自己程序集目录下。因为两个Newtonsoft.Json.dll重名，所以直接覆盖了前者，那么只保留了Newtonsoft.Json 6.0。  </li>
<li>当我们调用Func方法中的B.Convert()时候，CLR会搜索B程序集，找到后再调用 return Newtonsoft.Json.Obj 这行代码，而这行代码又用到了Newtonsoft.Json程序集，接下来CLR搜索Newtonsoft.Json.dll，文件名称满足，接下来CLR判断其标识，发现版本号是6.0，与B程序集清单里注册的10.0版本不符，故而才会报出异常：未能加载文件或程序集Newtonsoft.Json 10.0。  </li>
</ol>
<p>&emsp;&emsp;以上就是为何Newtonsoft.Json版本不一致会导致错误的原因，其也诠释了CLR搜索程序集的一个过程。<br>&emsp;&emsp;那么，如果我执意如此，有什么好的解决方法能让程序顺利执行呢？有，有2个方法。<br>&emsp;&emsp;第一种：通过<code>bindingRedirect</code>节点重定向，即当找到10.0的版本时，给定向到6.0版本  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">            &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">                &lt;dependentAssembly&gt;</span><br><span class="line">                    &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                      publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                      culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                    &lt;bindingRedirect oldVersion=&quot;10.0.0.0&quot;</span><br><span class="line">                                     newVersion=&quot;6.0.0.0&quot; /&gt;</span><br><span class="line">                &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何在编译时加载两个相同的程序集？"><a href="#如何在编译时加载两个相同的程序集？" class="headerlink" title="如何在编译时加载两个相同的程序集？"></a>如何在编译时加载两个相同的程序集？</h2><p>&emsp;&emsp;注意：我看过有的文章里写的一个AppDomain只能加载一个相同的程序集，很多人都以为不能同时加载2个不同版本的程序集，实际上CLR是可以同时加载Newtonsoft.Json 6.0和Newtonsoft.Json 10.0的。<br>&emsp;&emsp;第二种：对每个版本指定<code>codeBase</code>路径，然后分别放上不同版本的程序集，这样就可以加载两个相同的程序集。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;runtime&gt;</span><br><span class="line">        &lt;assemblyBinding xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;</span><br><span class="line">            &lt;dependentAssembly&gt;</span><br><span class="line">                &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                  publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                  culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                &lt;codeBase version=&quot;6.0.0.0&quot;</span><br><span class="line">                          href=&quot;D:\6.0\Newtonsoft.Json.dll&quot; /&gt;</span><br><span class="line">            &lt;/dependentAssembly&gt;</span><br><span class="line">            &lt;dependentAssembly&gt;</span><br><span class="line">                &lt;assemblyIdentity name=&quot;Newtonsoft.Json&quot;</span><br><span class="line">                                  publicKeyToken=&quot;30ad4fe6b2a6aeed&quot;</span><br><span class="line">                                  culture=&quot;neutral&quot; /&gt;</span><br><span class="line">                &lt;codeBase version=&quot;10.0.0.0&quot;</span><br><span class="line">                          href=&quot;D:\10.0\Newtonsoft.Json.dll&quot; /&gt;</span><br><span class="line">            &lt;/dependentAssembly&gt;</span><br><span class="line">        &lt;/assemblyBinding&gt;</span><br><span class="line">&lt;/runtime&gt;</span><br></pre></td></tr></table></figure>

<h2 id="如何同时调用两个相同命名空间和类型的程序集？"><a href="#如何同时调用两个相同命名空间和类型的程序集？" class="headerlink" title="如何同时调用两个相同命名空间和类型的程序集？"></a>如何同时调用两个相同命名空间和类型的程序集？</h2><p>&emsp;&emsp;除了程序集版本不同外，还有一种情况就是，我一个项目同时引用了程序集A和程序集B，但程序集A和程序集B中的命名空间和类型名称完全一模一样，这个时候我调用任意一个类型都无法区分它是来自于哪个程序集的，那么这种情况我们可以使用<code>extern alias</code>外部别名。<br>&emsp;&emsp;我们需要在所有代码前定义别名，extern alias a;extern alias b;，然后在VS中对引用的程序集右键属性-别名，分别将其更改为a和b(或在csc中通过<code>/r:{别名}={程序集}.dll</code>)。<br>&emsp;&emsp;在代码中通过 <code>{别名}::{命名空间}.{类型}</code>的方式来使用。<br>&emsp;&emsp;extern-alias介绍： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern-alias" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/extern-alias</a>  </p>
<h2 id="共享程序集GAC"><a href="#共享程序集GAC" class="headerlink" title="共享程序集GAC"></a>共享程序集GAC</h2><p>&emsp;&emsp;我上面说了这么多有关CLR加载程序集的细节和规则，事实上，类似于mscorlib.dll、System.dll这样的FCL类库被引用的如此频繁，它已经是我们.NET编程中必不可少的一部分，几尽每个项目都会引用，为了不再每次使用的时候都复制一份，所以计算机上有一个位置专门存储这些我们都会用到的程序集，叫做全局程序集缓存(Global Assembly Cache,GAC)，这个位置一般位于C:\Windows\Microsoft.NET\assembly和3.5之前版本的C:\Windows\assembly。<br>&emsp;&emsp;既然是共享存放的位置，那不可避免的会遇到文件名重复的情况，那么为了杜绝该类情况，规定在GAC中只能存在强名称程序集，每当CLR要加载强名称程序集时，会先通过标识去GAC中查找，而考虑到程序集文件名称一致但版本文化等复杂的情况，所以GAC有自己的一套目录结构。我们如果想将自己的程序集放入GAC中，那么就必须先签名，然后通过如gacutil.exe工具(其存在于命令行工具中 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/developer-command-prompt-for-vs中)来注册至GAC中，值得一提的是在将强名称程序集安装在GAC中，会效验签名。" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/tools/developer-command-prompt-for-vs中)来注册至GAC中，值得一提的是在将强名称程序集安装在GAC中，会效验签名。</a><br>&emsp;&emsp;GAC工具： <a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/gacutil-exe-gac-tool" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/framework/tools/gacutil-exe-gac-tool</a>  </p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>&emsp;&emsp;CLR是按需加载程序集的，没有执行代码也就没有调用相应的指令，没有相应的指令，CLR也不会对其进行相应的操作。 当我们执行<code>Environment.CurrentDirectory</code>这段代码的时候，CLR首先要获取Environment类型信息，通过自身元数据得知其存在mscorlib.dll程序集中，所以CLR要加载该程序集，而mscorlib.dll又由于其地位特殊，早在CLR初始化的时候就已经被类型加载器自动加载至内存中，所以这行代码可以直接在内存中读取到类型的方法信息。<br>&emsp;&emsp;在这个章节，我虽然描述了CLR搜索程序集的规则，但事实上，加载程序集读取类型信息远远没有这么简单，这涉及到了属于.NET Framework独有的”应用程序域”概念和内存信息的查找。<br>&emsp;&emsp;简单延伸两个问题，mscorlib.dll被加载在哪里？内存堆中又是什么样的一个情况？  </p>
<h1 id="应用程序域"><a href="#应用程序域" class="headerlink" title="应用程序域"></a>应用程序域</h1><p>&emsp;&emsp;传统非托管程序是直接承载在Windows进程中，托管程序是承载在.NET虚拟机CLR上的，而在CLR中管控的这部分资源中，被分成了一个个逻辑上的分区，这个逻辑分区被称为应用程序域，是.NET Framework中定义的一个概念。<br>&emsp;&emsp;因为堆内存的构建和删除都通过GC去托管，降低了人为出错的几率，在此特性基础上.NET强调在一个进程中通过CLR强大的管理建立起对资源逻辑上的隔离区域，每个区域的应用程序互不影响，从而让托管代码程序的安全性和健壮性得到了提升。<br>&emsp;&emsp;熟悉程序集加载规则和<code>AppDomain</code>是在.NET技术下进行插件编程的前提。<code>AppDomain</code>这部分概念并不复杂。<br>&emsp;&emsp;当启动一个托管程序时，最先启动的是<code>CLR</code>，在这过程中会通过代码初始化三个逻辑区域，最先是<code>SystemDomain</code>系统程序域，然后是<code>SharedDoamin</code>共享域，最后是<code>{程序集名称}Domain</code>默认域。<br>&emsp;&emsp;系统程序域里维持着一些系统构建项，我们可以通过这些项来监控并管理其它应用程序域等。共享域存放着其它域都会访问到的一些信息，当共享域初始化完毕后，会自动加载mscorlib.dll程序集至该共享域。而默认域则用储存自身程序集的信息，我们的主程序集就会被加载至这个默认域中，执行程序入口方法，在没有特殊动作外所产生的一切耗费都发生在该域。<br>&emsp;&emsp;我们可以在代码中创建和卸载应用程序域，域与域之间有隔离性，挂掉A域不会影响到B域，并且对于每一个加载的程序集都要指定域的，没有在代码中指定域的话，默认都是加载至默认域中。<br>&emsp;&emsp;<code>AppDomain</code>可以想象成组的概念，<code>AppDomain</code>包含了我们加载的一组程序集。我们通过代码卸载<code>AppDomain</code>，即同时卸载了该<code>AppDomain</code>中所加载的所有程序集在内存中的相关区域。<br>&emsp;&emsp;<code>AppDomain</code>的初衷是边缘隔离，它可以让程序不重新启动而长时间运行，围绕着该概念建立的体系从而让我们能够使用.NET技术进行插件编程。<br>&emsp;&emsp;当我们想让程序在不关闭不重新部署的情况下添加一个新的功能或者改变某一块功能，我们可以这样做：将程序的主模块仍默认加载至默认域，再创建一个新的应用程序域，然后将需要更改或替换的模块的程序集加载至该域，每当更改和替换的时候直接卸载该域即可。 而因为域的隔离性，我在A域和B域加载同一个程序集，那么A域和B域就会各存在内存地址不同但数据相同的程序集数据。  </p>
<h2 id="跨边界访问"><a href="#跨边界访问" class="headerlink" title="跨边界访问"></a>跨边界访问</h2><p>&emsp;&emsp;事实上，在开发中我们还应该注意跨域访问对象的操作(即在A域中的程序集代码直接调用B域中的对象)是与平常编程中有所不同的，一个域中的应用程序不能直接访问另一个域中的代码和数据，对于这样的在进程内跨域访问操作分两类。<br>&emsp;&emsp;一是按引用封送，需要继承<code>System.MarshalByRefObject</code>，传递的是该对象的代理引用，与源域有相同的生命周期。<br>&emsp;&emsp;二是按值封送，需要被<code>[Serializable]</code>标记，是通过序列化传递的副本，副本与源域的对象无关。<br>&emsp;&emsp;无论哪种方式都涉及到两个域直接的封送、解封，所以跨域访问调用不适用于过高频率。<br>&emsp;&emsp;(比如，原来你是这样调用对象： <code>var user=new User();</code> 现在你要这样：<code>var user=(User){应用程序域对象实例}.CreateInstanceFromAndUnwrap(&quot;Model.dll&quot;,&quot;Model.User&quot;);</code> )<br>&emsp;&emsp;值得注意的是，应用程序域是对程序集的组的划分，它与进程中的线程是两个一横一竖，方向不一样的概念，不应该将这2个概念放在一起比较。我们可以通过<code>Thread.GetDomain</code>来查看执行线程所在的域。<br>&emsp;&emsp;应用程序域在类库中是<code>System.AppDomain</code>类,部分重要的成员有：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">获取当前 System.Threading.Thread 的当前应用程序域</span><br><span class="line">public static AppDomain CurrentDomain &#123; get; &#125;</span><br><span class="line">使用指定的名称新建应用程序域</span><br><span class="line">public static AppDomain CreateDomain(string friendlyName);</span><br><span class="line">卸载指定的应用程序域。</span><br><span class="line">public static void Unload(AppDomain domain);</span><br><span class="line">指示是否对当前进程启用应用程序域的 CPU 和内存监视，开启后可以根据相关属性进行监控</span><br><span class="line">public static bool MonitoringIsEnabled &#123; get; set; &#125;</span><br><span class="line">当前域托管代码抛出异常时最先发生的一个事件，框架设计中可以用到</span><br><span class="line">public event EventHandler&lt;FirstChanceExceptionEventArgs&gt; FirstChanceException;</span><br><span class="line">当某个异常未被捕获时调用该事件，如代码里只catch了a异常，实际产生的是 b异常，那么b异常就没有捕捉到。</span><br><span class="line">public event UnhandledExceptionEventHandler UnhandledException;</span><br><span class="line">为指定的应用程序域属性分配指定值。该应用程序域的局部存储值，该存储不划分上下文和线程，均可通过GetData获取。</span><br><span class="line">public void SetData(string name, object data);</span><br><span class="line">如果想使用托管代码来覆盖CLR的默认行为https://msdn.microsoft.com/zh-cn/library/system.appdomainmanager(v=vs.85).aspx</span><br><span class="line">public AppDomainManager DomainManager &#123; get; &#125;</span><br><span class="line">返回域的配置信息，如在config中配置的节点信息</span><br><span class="line">public AppDomainSetup SetupInformation &#123; get; &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;应用程序域： <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/application-domains" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/application-domains</a>  </p>
<h2 id="AppDomain和AppPool"><a href="#AppDomain和AppPool" class="headerlink" title="AppDomain和AppPool"></a>AppDomain和AppPool</h2><p>&emsp;&emsp;注意：此处的<code>AppDomain</code>应用程序域 和 IIS中的<code>AppPool</code>应用程序池 是2个概念，AppPool是IIS独有的概念，它也相当于一个组的概念，对网站进行划组，然后对组进行一些如进程模型、CPU、内存、请求队列的高级配置。  </p>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>&emsp;&emsp;应用程序域把资源给隔离开，这个资源，主要指内存。那么什么是内存呢？<br>&emsp;&emsp;要知道，程序运行的过程就是电脑不断通过CPU进行计算的过程，这个过程需要读取并产生运算的数据，为此我们需要一个拥有足够容量能够快速与CPU交互的存储容器，这就是内存了。对于内存大小，32位处理器，寻址空间最大为2的32次方byte，也就是4G内存，除去操作系统所占用的公有部分，进程大概能占用2G内存，而如果是64位处理器，则是8T。<br>&emsp;&emsp;而在.NET中，内存区域分为堆栈和托管堆。  </p>
<h2 id="堆栈和堆的区别"><a href="#堆栈和堆的区别" class="headerlink" title="堆栈和堆的区别"></a>堆栈和堆的区别</h2><p>&emsp;&emsp;堆和堆栈就内存而言只不过是地址范围的区别。不过堆栈的数据结构和其存储定义让其在时间和空间上都紧密的存储，这样能带来更高的内存密度，能在CPU缓存和分页系统表现的更好。故而访问堆栈的速度总体来说比访问堆要快点。  </p>
<h2 id="线程堆栈"><a href="#线程堆栈" class="headerlink" title="线程堆栈"></a>线程堆栈</h2><p>&emsp;&emsp;操作系统会为每条线程分配一定的空间，Windwos为1M，这称之为线程堆栈。在CLR中的栈主要用来执行线程方法时，保存临时的局部变量和函数所需的参数及返回的值等，在栈上的成员不受GC管理器的控制，它们由操作系统负责分配，当线程走出方法后，该栈上成员采用后进先出的顺序由操作系统负责释放，执行效率高。<br>&emsp;&emsp;而托管堆则没有固定容量限制，它取决于操作系统允许进程分配的内存大小和程序本身对内存的使用情况，托管堆主要用来存放对象实例，不需要我们人工去分配和释放，其由GC管理器托管。  </p>
<h2 id="为什么值类型存储在栈上"><a href="#为什么值类型存储在栈上" class="headerlink" title="为什么值类型存储在栈上"></a>为什么值类型存储在栈上</h2><p>&emsp;&emsp;不同的类型拥有不同的编译时规则和运行时内存分配行为，我们应知道，C# 是一种强类型语言，每个变量和常量都有一个类型，在.NET中，每种类型又被定义为值类型或引用类型。<br>&emsp;&emsp;使用 <code>struct</code>、<code>enum</code> 关键字直接派生于<code>System.ValueType</code>定义的类型是值类型，使用 <code>class</code>、<code>interface</code>、<code>delagate</code> 关键字派生于<code>System.Object</code>定义的类型是引用类型。<br>&emsp;&emsp;对于在一个方法中产生的值类型成员，将其值分配在栈中。这样做的原因是因为值类型的值其占用固定内存的大小。<br>&emsp;&emsp;C#中<code>int</code>关键字对应BCL中的<code>Int32</code>，<code>short</code>对应<code>Int16</code>。<code>Int32</code>为2的32位，如果把32个二进制数排列开来，我们要求既能表达正数也能表达负数，所以得需要其中1位来表达正负，首位是0则为+，首位是1则为-，那么我们能表示数据的数就只有31位了，而0是介于-1和1之间的整数，所以对应的Int32能表现的就是2的31次方到2的31次方-1，即2147483647和-2147483648这个整数段。<br>&emsp;&emsp;1个字节=8位，32位就是4个字节，像这种以Int32为代表的值类型，本身就是固定的内存占用大小，所以将值类型放在内存连续分配的栈中。  </p>
<h2 id="托管堆模型"><a href="#托管堆模型" class="headerlink" title="托管堆模型"></a>托管堆模型</h2><p>&emsp;&emsp;而引用类型相比值类型就有点特殊，<code>newobj</code>创建一个引用类型，因其类型内的引用对象可以指向任何类型，故而无法准确得知其固定大小，所以像对于引用类型这种无法预知的容易产生内存碎片的动态内存，我们把它放到托管堆中存储。<br>&emsp;&emsp;托管堆由GC托管，其分配的核心在于堆中维护着一个<code>nextObjPtr</code>指针，我们每次实例(new)一个对象的时候，CLR将对象存入堆中，并在栈中存放该对象的起始地址，然后该指针都会根据该对象的大小来计算下一个对象的起始地址。不同于值类型直接在栈中存放值，引用类型则还需要在栈中存放一个代表(指向)堆中对象的值(地址)。<br>&emsp;&emsp;而托管堆又可以因存储规则的不同将其分类，托管堆可以被分为3类：  </p>
<ol>
<li>用于托管对象实例化的垃圾回收堆，又以存储对象大小分为小对象(&lt;85000byte)的GC堆(SOH，Small Object Heap)和用于存储大对象实例的(&gt;=85000byte)大对象堆(LOG，Larage Object Heap)。 </li>
<li>用于存储CLR组件和类型系统的加载(Loader)堆，其中又以使用频率分为经常访问的高频堆(里面包含有MethodTables方法表, MeghodDescs方法描述, FieldDescs方法描述和InterfaceMaps接口图)，和较低的低频堆，和Stub堆(辅助代码，如JIT编译后修改机器代码指令地址环节)。 </li>
<li>用于存储JIT代码的堆及其它杂项的堆。</li>
</ol>
<p>&emsp;&emsp;加载程序集就是将程序集中的信息给映射在加载堆，对产生的实例对象存放至垃圾回收堆。前文说过应用程序域是指通过CLR管理而建立起的逻辑上的内存边界，那么每个域都有其自己的加载堆，只有卸载应用程序域的时候，才会回收该域对应的加载堆。<br>&emsp;&emsp;而加载堆中的高频堆包含的有一个非常重要的数据结构表—方法表，每个类型都仅有一份方法表(MethodTables)，它是对象的第一个实例创建前的类加载活动的结果，它主要包含了我们所关注的3部分信息：  </p>
<ol>
<li>包含指向EEClass的一个指针。EEClass是一个非常重要的数据结构，当类加载器加载到该类型时会从元数据中创建出EEClass，EEClass里主要存放着与类型相关的表达信息。</li>
<li>包含指向各自方法的方法描述器(MethodDesc)的指针逻辑组成的线性表信息:继承的虚函数, 新虚函数, 实例方法, 静态方法。</li>
<li>包含指向静态字段的指针。</li>
</ol>
<p>&emsp;&emsp;那么，实例一个对象，CLR是如何将该对象所对应的类型行为及信息的内存位置(加载堆)关联起来的呢？<br>&emsp;&emsp;原来，在托管堆上的每个对象都有2个额外的供于CLR使用的成员，我们是访问不到的，其中一个就是类型对象指针，它指向位于加载堆中的方法表从而让类型的状态和行为关联了起来， 类型指针的这部分概念我们可以想象成obj.GetType()方法获得的运行时对象类型的实例。而另一个成员就是同步块索引，其主要用于2点：1.关联内置SyncBlock数组的项从而完成互斥锁等目的。 2.是对象Hash值计算的输入参数之一。<br><img src="1026815-20180626200740668-572794231.gif" alt=" "><br>&emsp;&emsp;上述gif是我简单画的一个图，可以看到对于方法中申明的值类型变量，其在栈中作为一块值表示，我们可以直接通过c#运算符sizeof来获得值类型所占byte大小。而方法中申明的引用类型变量，其在托管堆中存放着对象实例(对象实例至少会包含上述两个固定成员以及实例数据，可能)，在栈中存放着指向该实例的地址。<br>&emsp;&emsp;当我new一个引用对象的时候，会先分配同步块索引(也叫对象头字节)，然后是类型指针，最后是类型实例数据(静态字段的指针存在于方法表中)。会先分配对象的字段成员，然后分配对象父类的字段成员，接着再执行父类的构造函数，最后才是本对象的构造函数。这个多态的过程，对于CLR来说就是一系列指令的集合，所以不能纠结new一个子类对象是否会也会new一个父类对象这样的问题。而也正是因为引用类型的这样一个特征，我们虽然可以估计一个实例大概占用多少内存，但对于具体占用的大小，我们需要专门的工具来测量。<br>&emsp;&emsp;对于引用类型，u2=u1，我们在赋值的时候，实际上赋的是地址，那么我改动数据实际上是改动该地址指向的数据，这样一来，因为u2和u1都指向同一块区域，所以我对u1的改动会影响到u2，对u2的改动会影响到u1。如果我想互不影响，那么我可以继承<code>IClone</code>接口来实现内存克隆，已有的CLR实现是浅克隆方法，但也只能克隆值类型和String(string是个特殊的引用类型，对于string的更改，其会产生一个新实例对象)，如果对包含其它引用类型的这部分，我们可以自己通过其它手段实现深克隆，如序列化、反射等方式来完成。而如果引用类型中包含有值类型字段，那么该字段仍然分配在堆上。<br>&emsp;&emsp;对于值类型，a=b，我们在赋值的时候，实际上是新建了个值，那么我改动a的值那就只会改动a的值，改动b的值就只会改动b的值。而如果值类型(如struct)中包含的有引用类型，那么仍是同样的规则，引用类型的那部分实例在托管堆中，地址在栈上。<br>&emsp;&emsp;我如果将值类型放到引用类型中(如：object a=3)，会在栈中生成一个地址，在堆中生成该值类型的值对象，还会再生成这类型指针和同步块索引两个字段，这也就是常说装箱，反过来就是拆箱。每一次的这样的操作，都会涉及到内存的分布、拷贝，可见，装箱和拆箱是有性能损耗，因此应该减少值类型和引用类型之间转换的次数。<br>&emsp;&emsp;但对于引用类型间的子类父类的转换，仅是指令的执行消耗，几尽没有开销。  </p>
<h2 id="选class还是struct"><a href="#选class还是struct" class="headerlink" title="选class还是struct"></a>选class还是struct</h2><p>&emsp;&emsp;那么我到底是该new一个class呢还是选择struct呢？<br>&emsp;&emsp;通过上文知道对于class，用完之后对象仍然存在托管堆，占用内存。对于struct，用完之后直接由操作系统销毁。那么在实际开发中定义类型时，选择class还是struct就需要注意了，要综合应用场景来辨别。struct存在于栈上，栈和托管堆比较，最大的优势就是即用即毁。所以如果我们单纯的传递一个类型，那么选择struct比较合适。但须注意线程堆栈有容量限制，不可多存放超大量的值类型对象，并且因为是值类型直接传递副本，所以struct作为方法参数是线程安全的，但同样要避免装箱的操作。而相比较class，如果类型中还需要多一些封装继承多态的行为，那么class当然是更好的选择。  </p>
<h2 id="GC管理器"><a href="#GC管理器" class="headerlink" title="GC管理器"></a>GC管理器</h2><p>&emsp;&emsp;值得注意的是，当我new完一个对象不再使用的时候，这个对象在堆中所占用的内存如何处理？<br>&emsp;&emsp;在非托管世界中，可以通过代码手动进行释放，但在.NET中，堆完全由CLR托管，也就是说GC堆是如何具体来释放的呢？<br>&emsp;&emsp;当GC堆需要进行清理的时候，GC收集器就会通过一定的算法来清理堆中的对象，并且版本不同算法也不同。最主要的则为Mark-Compact标记-压缩算法。<br>&emsp;&emsp;这个算法的大概含义就是，通过一个图的数据结构来收集对象的根，这个根就是引用地址，可以理解为指向托管堆的这根关系线。当触发这个算法时，会检查图中的每个根是否可达，如果可达就对其标记，然后在堆上找到剩余没有标记(也就是不可达)的对象进行删除，这样，那些不在使用的堆中对象就删除了。<br>&emsp;&emsp;前面说了，因为<code>nextObjPtr</code>的缘故，在堆中分配的对象都是连续分配的，因为未被标记而被删除，那么经过删除后的堆就会显得支零破碎，那么为了避免空间碎片化，所以需要一个操作来让堆中的对象再变得紧凑、连续，而这样一个操作就叫做：Compact压缩。<br>&emsp;&emsp;而对堆中的分散的对象进行挪动后，还会修改这些被挪动对象的指向地址，从而得以正确的访问，最后重新更新一下<code>nextObjPtr</code>指针，周而复始。<br>&emsp;&emsp;而为了优化内存结构，减少在图中搜索的成本，GC机制又为每个托管堆对象定义了一个属性，将每个对象分成了3个等级，这个属性就叫做：代，0代、1代、2代。<br>&emsp;&emsp;每当new一个对象的时候，该对象都会被定义为第0代，当GC开始回收的时候，先从0代回收，在这一次回收动作之后，0代中没有被回收的对象则会被定义成第1代。当回收第1代的时候，第1代中没有被清理掉的对象就会被定义到第2代。<br>&emsp;&emsp;CLR初始化时会为0/1/2这三代选择一个预算的容量。0代通常以256 KB-4 MB之间的预算开始，1代的典型起始预算为512 KB-4 MB，2代不受限制，最大可扩展至操作系统进程的整个内存空间。<br>&emsp;&emsp;比如第0代为256K，第1代为2MB。我们不停的new对象，直到这些对象达到256k的时候，GC会进行一次垃圾回收，假设这次回收中回收了156k的不可达对象，剩余100k的对象没有被回收，那么这100k的对象就被定义为第1代。现在就变成了第0代里面什么都没有，第1代里放的有100k的对象。这样周而复始，GC清除的永远都只有第0代对象，除非当第一代中的对象累积达到了定义的2MB的时候，才会连同清理第1代，然后第1代中活着的部分再升级成第二代…<br>&emsp;&emsp;第二代的容量是没有限制，但是它有动态的阈值(因为等到整个内存空间已满以执行垃圾回收是没有意义的)，当达到第二代的阈值后会触发一次0/1/2代完整的垃圾收集。<br>&emsp;&emsp;也就是说，代数越长说明这个对象经历了回收的次数也就越多，那么也就意味着该对象是不容易被清除的。<br>&emsp;&emsp;这种分代的思想来将对象分割成新老对象，进而配对不同的清除条件，这种巧妙的思想避免了直接清理整个堆的尴尬。<br><img src="1026815-20180626200925015-777215609.gif" alt=" ">   </p>
<h2 id="弱引用、弱事件"><a href="#弱引用、弱事件" class="headerlink" title="弱引用、弱事件"></a>弱引用、弱事件</h2><p>&emsp;&emsp;GC收集器会在第0代饱和时开始回收托管堆对象，对于那些已经申明或绑定的不经访问的对象或事件，因为不经常访问而且还占内存(有点懒加载的意思)，所以即时对象可达，但我想在GC回收的时候仍然对其回收，当需要用到的时候再创建，这种情况该怎么办？<br>&emsp;&emsp;那么这其中就引入了两个概念：<br>&emsp;&emsp;<code>WeakReference</code>弱引用、<code>WeakEventManager</code>弱事件<br>&emsp;&emsp;对于这两个不区分语言的共同概念，大家可自行扩展百度，此处就不再举例。  </p>
<h2 id="GC堆回收"><a href="#GC堆回收" class="headerlink" title="GC堆回收"></a>GC堆回收</h2><p>&emsp;&emsp;那么除了通过new对象而达到代的阈(临界)值时，还有什么能够导致垃圾堆进行垃圾回收呢？ 还可能windows报告内存不足、CLR卸载AppDomain、CLR关闭等其它特殊情况。<br>&emsp;&emsp;或者，我们还可以自己通过代码调用。<br>&emsp;&emsp;.NET有GC来帮助开发人员管理内存，并且版本也在不断迭代。GC帮我们托管内存，但仍然提供了<code>System.GC</code>类让开发人员能够轻微的协助管理。 这其中有一个可以清理内存的方法(并没有提供清理某个对象的方法)：GC.Collect方法，可以对所有或指定代进行即时垃圾回收(如果想调试，需在release模式下才有效果)。这个方法尽量别用，因为它会扰乱代与代间的秩序，从而让低代的垃圾对象跑到生命周期长的高代中。<br>&emsp;&emsp;GC还提供了，判断当前对象所处代数、判断指定代数经历了多少次垃圾回收、获取已在托管堆中分配的字节数这样的三个方法，我们可以从这3个方法简单的了解托管堆的情况。<br>&emsp;&emsp;托管世界的内存不需要我们打理，我们无法从代码中得知具体的托管对象的大小，你如果想追求对内存最细微的控制，显然C#并不适合你，不过类似于有关内存把控的这部分功能模块，我们可以通过非托管语言来编写，然后通过.NET平台的P/Invoke或COM技术(微软为CLR定义了COM接口并在注册表中注册)来调用。<br>&emsp;&emsp;像FCL中的源码，很多涉及到操作系统的诸如 文件句柄、网络连接等外部extren的底层方法都是非托管语言编写的，对于这些非托管模块所占用的资源，我们可以通过隐式调用析构函数(<code>Finalize</code>)或者显式调用的<code>Dispose</code>方法通过在方法内部写上非托管提供的释放方法来进行释放。<br>&emsp;&emsp;像文中示例的socket就将释放资源的方法写入Dispose中，析构函数和Close方法均调用Dispose方法以此完成释放。事实上，在FCL中的使用了非托管资源的类大多都遵循IDispose模式。而如果你没有释放非托管资源直接退出程序，那么操作系统会帮你释放该程序所占的内存的。  </p>
<h2 id="垃圾回收对性能的影响"><a href="#垃圾回收对性能的影响" class="headerlink" title="垃圾回收对性能的影响"></a>垃圾回收对性能的影响</h2><p>&emsp;&emsp;还有一点，垃圾回收是对性能有影响的。<br>&emsp;&emsp;GC虽然有很多优化策略，但总之，只要当它开始回收垃圾的时候，为了防止线程在CLR检查期间对对象更改状态，所以CLR会暂停进程中的几乎所有线程(所以线程太多也会影响GC时间)，而暂停的时间就是应用程序卡死的时间，为此，对于具体的处理细节，GC提供了2种配置模式让我们选择。<br>&emsp;&emsp;第一种为：单CPU的工作站模式，专为单CPU处理器定做。这种模式会采用一系列策略来尽可能减少GC回收中的暂停时间。<br>&emsp;&emsp;而工作站模式又分为并发(或后台)与不并发两种，并发模式表现为响应时间快速，不并发模式表现为高吞吐量。<br>&emsp;&emsp;第二种为：多CPU的服务器模式，它会为每个CPU都运行一个GC回收线程，通过并行算法来使线程能真正同时工作，从而获得性能的提升。<br>&emsp;&emsp;我们可以通过在Config文件中更改配置来修改GC模式，如果没有进行配置，那么应用程序总是默认为单CPU的工作站的并发模式，并且如果机器为单CPU的话，那么配置服务器模式则无效。<br>&emsp;&emsp;如果在工作站模式中想禁用并发模式，则应该在config中运行时节点添加 <code>&lt;gcConcurrent enabled=&quot;false&quot; /&gt;</code><br>&emsp;&emsp;如果想更改至服务器模式，则可以添加 <code>&lt;gcServer enabled=&quot;true&quot; /&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;configuration&gt;</span><br><span class="line">        &lt;runtime&gt;</span><br><span class="line">            &lt;!--&lt;gcConcurrent enabled=&quot;true|false&quot;/&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;gcServer enabled=&quot;true|false&quot;/&gt;--&gt;</span><br><span class="line">        &lt;/runtime&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;gcConcurrent: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcconcurrent-element</a><br>&emsp;&emsp;gcServer: <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/configure-apps/file-schema/runtime/gcserver-element</a>  </p>
<h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><p>&emsp;&emsp;虽然我们可以选择适合的GC工作模式来改善垃圾回收时的表现，但在实际开发中我们更应该注意减少不必要的内存开销。<br>&emsp;&emsp;几个建议是，减换需要创建大量的临时变量的模式、考虑对象池、大对象使用懒加载、对固定容量的集合指定长度、注意字符串操作、注意高频率的隐式装箱操作、延迟查询、对于不需要面向对象特性的类用<code>static</code>、需要高性能操作的算法改用外部组件实现(p/invoke、com)、减少<code>throw</code>次数、注意匿名函数捕获的外部对象将延长生命周期、可以阅读GC相关运行时配置在高并发场景注意变换GC模式…<br>&emsp;&emsp;对于.NET中改善性能可延伸阅读 <a href="https://msdn.microsoft.com/zh-cn/library/ms973838.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms973838.aspx</a> 、 <a href="https://msdn.microsoft.com/library/ms973839.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/library/ms973839.aspx</a>  </p>
<h1 id="NET程序执行图"><a href="#NET程序执行图" class="headerlink" title=".NET程序执行图"></a>.NET程序执行图</h1><p>&emsp;&emsp;至此，.NET Framework上的三个重要概念，程序集、应用程序域、内存在本文讲的差不多了，我画了一张图简单的概述.NET程序的一个执行流程：<br><img src="1026815-20180627094402682-185765111.jpg" alt=" "><br>&emsp;&emsp;对于后文，我将单独的介绍一些其它杂项，首先是.NET平台的安全性。  </p>
<h1 id="NET的安全性"><a href="#NET的安全性" class="headerlink" title=".NET的安全性"></a>.NET的安全性</h1><p>&emsp;&emsp;.NET Framework中的安全机制分为 基于角色的安全机制 和 代码访问安全机制。  </p>
<h2 id="基于角色的安全性"><a href="#基于角色的安全性" class="headerlink" title="基于角色的安全性"></a>基于角色的安全性</h2><p>&emsp;&emsp;基于角色的安全机制作为传统的访问控制，其运用的非常广泛，如操作系统的安全策略、数据库的安全策略等等…它的概念就相当于我们经常做的那些RBAC权限管理系统一样，用户关联角色，角色关联权限，权限对应着操作。<br>&emsp;&emsp;整个机制的安全逻辑就和我们平时编写代码判断是一样的，大致可以分为两个步骤。<br>&emsp;&emsp;第一步就是创建一个主体，然后标识这个主体是什么身份(角色) ，第二步就是 身份验证，也就是if判断该身份是否可以这样操作。<br>&emsp;&emsp;而在.NET Framework中，这主体可以是Windows账户，也可以是自定义的标识，通过生成如当前线程或应用程序域使用的主体相关的信息来支持授权。<br>&emsp;&emsp;比如，构造一个代表当前登录账户的主体对象WindowsPrincipal，然后通过<code>AppDomain.CurrentDomain.SetThreadPrincipal(主体对象);</code>或<code>Thread.CurrentPrincipal</code>的set方法来设置应用程序域或线程的主体对象， 最后使用<code>System.Security.Permissions.PrincipalPermission</code>特性来标记在方法上来进行授权验证。<br><img src="1026815-20180627091948062-1470556345.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180627091950748-1063703508.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;如图，我当前登录账号名称为DemoXiaoZeng，然后通过<code>Thread.CurrentPrincipal</code>设置当前主体，执行aa方法，顺利打印111。如果检测到PrincipalPermission类中的Name属性值不是当前登录账号，那么就报错：对主体权限请求失败。<br><img src="1026815-20180627092034043-1822965136.png" alt=" "><br>&emsp;&emsp;在官方文档中有对.NET Framework基于角色的安全性的详细的介绍，感兴趣可以去了解 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/security/principal-and-identity-objects#principal-objects" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/security/principal-and-identity-objects#principal-objects</a>  </p>
<h2 id="代码访问安全性"><a href="#代码访问安全性" class="headerlink" title="代码访问安全性"></a>代码访问安全性</h2><p>&emsp;&emsp;在.NET Framework中还有一个安全策略，叫做 代码访问安全Code Access Security，也就是CAS了。<br>&emsp;&emsp;代码访问安全性在.NET Framework中是用来帮助限制代码对受保护资源和操作的访问权限。<br>&emsp;&emsp;举个例子，我通过创建一个<code>FileIOPermission</code>对象来限制对后续代码对D盘的文件和目录的访问，如果后续代码对D盘进行资源操作则报错。<br><img src="1026815-20180627092115880-961385890.png" alt=" "><br>&emsp;&emsp;<code>FileIOPermission</code>是代码控制访问文件和文件夹的能力。除了<code>FileIOPermission</code>外，还有如<code>PrintingPermission</code>代码控制访问打印机的权限、<code>RegistryPermission</code>代码控制操作注册表的权限、<code>SocketPermission</code>控制接受连接或启动Socket连接的权限。<br>&emsp;&emsp;对于这些通过代码来对受保护资源和操作的权限限制，也就是这些类名后缀为Permission的类，它们叫做 Permissions(权限)，都继承自<code>CodeAccessPermission</code>，都有如<code>Demand</code>，<code>Assert</code>，<code>Deny</code>，<code>PermitOnly</code>，<code>IsSubsetOf</code>，<code>Intersect</code>和<code>Union</code>这些方法，在MSDN上有完整的权限列表：<a href="https://msdn.microsoft.com/en-us/library/h846e9b3(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/h846e9b3(v=vs.100).aspx</a><br>&emsp;&emsp;为了确定代码是否有权访问某一资源或执行某一操作，CLR的安全系统将审核调用堆栈，以将每个调用方获得的权限与要求的权限进行比较。 如果调用堆栈中的任何调用方不具备要求的权限，则会引发安全性异常并拒绝访问。<br><img src="1026815-20180627092153838-808529507.png" alt=" "><br>&emsp;&emsp;图出自 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/misc/code-access-security" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/misc/code-access-security</a><br>&emsp;&emsp;而除了Permissions权限，代码访问安全性机制还有 权限集、证据、代码组、策略等概念。这些概念让CAS如此强大，但相应的，它们也让CAS变得复杂，必须为每个特定机器定义正确的<code>PermissionSet</code>和<code>Code Groups</code>才能设置成一个成功的CAS策略。<br>&emsp;&emsp;考虑到这层原因，Microsoft .NET安全小组决定从头开始重建代码访问安全性。在.NET Framework4.0之后，就不再使用之前的那套CAS模型了，而是使用.NET Framework 2.0中引入的安全透明模型，然后稍加修改，修改后的安全透明模型成为保护资源的标准方法，被称之为：安全透明度级别2<br>&emsp;&emsp;安全透明度2介绍：<a href="https://msdn.microsoft.com/en-us/library/dd233102(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd233102(v=vs.100).aspx</a><br>&emsp;&emsp;.NET Framework4.0的安全更改：<a href="https://msdn.microsoft.com/en-us/library/dd233103(v=vs.100).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd233103(v=vs.100).aspx</a><br>&emsp;&emsp;一个完整的CAS演示：<a href="https://www.codeproject.com/Articles/5724/Understanding-NET-Code-Access-Security" target="_blank" rel="noopener">https://www.codeproject.com/Articles/5724/Understanding-NET-Code-Access-Security</a><br>&emsp;&emsp;对于安全透明度级别2我将不再介绍，感兴趣的可以看我推荐的这2篇文章，对Level2的安全透明度介绍的比较详细，包括实践、迁移。<br>&emsp;&emsp;<a href="https://www.red-gate.com/simple-talk/dotnet/.net-framework/whats-new-in-code-access-security-in-.net-framework-4.0---part-i/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/dotnet/.net-framework/whats-new-in-code-access-security-in-.net-framework-4.0---part-i/</a><br>&emsp;&emsp;<a href="https://www.red-gate.com/simple-talk/dotnet/net-framework/whats-new-in-code-access-security-in-net-framework-4-0-part-2/" target="_blank" rel="noopener">https://www.red-gate.com/simple-talk/dotnet/net-framework/whats-new-in-code-access-security-in-net-framework-4-0-part-2/</a>  </p>
<hr>
<p>&emsp;&emsp;须注意：<br>&emsp;&emsp;.NET平台上的安全机制，仅仅是.NET平台上的，因此它只限制于托管代码，我们可以直接调用非托管代码或进程通信间接调用非托管代码等多个手段来突破对托管代码 操作资源的限制。<br>&emsp;&emsp;事实上，我们在平常项目中代码编写的安全机制(业务逻辑身份验证、项目框架验证)与这些平台级的安全机制没什么不同。我们可以理解为代码写的位置不一样，.NET安全机制是写在CLR组件中，而我们的安全机制是写在上层的代码中。这些平台级的标识更多的是和操作系统用户有关，而我们项目代码中的标识则是和在数据库中注册的用户有关， 大家都是通过if else来去判断，判断的主体和格局不一样，逻辑本质都是相同的。<br>&emsp;&emsp;NET Core不支持代码访问安全性和安全性透明性。  </p>
<h1 id="NET是什么"><a href="#NET是什么" class="headerlink" title=".NET是什么"></a>.NET是什么</h1><p>&emsp;&emsp;我在前文对.NET系统概述时，有的直接称.NET，有的称.NET Framework。那么准确来说什么是.NET?什么又是.NET Framework呢？<br>&emsp;&emsp;.NET是一个微软搭造的开发者平台，它主要包括：  </p>
<ul>
<li>1.支持(面向)该平台的编程语言(如C#、Visual Basic、C++/CLI、F#、IronPython、IronRuby…)，</li>
<li>2.用于该平台下开发人员的技术框架体系(.NET Framework、.NET Core、Mono、UWP等)，<ul>
<li>1.定义了通用类型系统，庞大的CTS体系 </li>
<li>2.用于支撑.NET下的语言运行时的环境：CLR </li>
<li>3..NET体系技术的框架库FCL </li>
</ul>
</li>
<li>3.用于支持开发人员开发的软件工具(即SDK，如VS2017、VS Code等)</li>
</ul>
<h2 id="NET-Framework是什么"><a href="#NET-Framework是什么" class="headerlink" title=".NET Framework是什么"></a>.NET Framework是什么</h2><p>&emsp;&emsp;事实上，像我上面讲的那些诸如程序集、GC、AppDomain这样的为CLR的一些概念组成，实质上指的是.NET Framework CLR。<br>&emsp;&emsp;.NET平台是微软为了占据开发市场而成立的，不是无利益驱动的纯技术平台的那种东西。基于该平台下的技术框架也因为 商业间的利益 从而和微软自身的Windows操作系统所绑定。所以虽然平台雄心和口号很大，但很多框架类库技术都是以Windows系统为蓝本，这样就导致，虽然.NET各方面都挺好，但是用.NET就必须用微软的东西，直接形成了技术-商业的绑定。<br>&emsp;&emsp;.NET Framework就是.NET 技术框架组成在Windows系统下的具体的实现，和Windows系统高度耦合，上文介绍的.NET系统，就是指.NET Framework。<br>&emsp;&emsp;部署.net Framework ：<a href="https://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/deployment/deployment-guide-for-developers</a><br>&emsp;&emsp;.NET Framework高级开发：<a href="https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/29eafad8(v%3dvs.90)" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2008/29eafad8(v%3dvs.90)</a><br>&emsp;&emsp;.NET Framework源码在线浏览：<a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">https://referencesource.microsoft.com/</a>  </p>
<h3 id="如何在VS中调试-NET-Framework源代码"><a href="#如何在VS中调试-NET-Framework源代码" class="headerlink" title="如何在VS中调试.NET Framework源代码"></a>如何在VS中调试.NET Framework源代码</h3><p>&emsp;&emsp;最为关键的是pdb符号文件，没得符号就调不了，对于符号我们从微软的符号服务器上下载(默认就已配置)，还得有源代码来调试。<br>&emsp;&emsp;点击工具-选项-调试-常规，如果你之前没有在该配置栏配置过，那么你就勾选 启用源服务器支持 、启用.net Framework源代码单步执行，然后将 要求源文件与原始版本完全匹配 给取消掉。<br>&emsp;&emsp;然后就是下载pdb符号文件了，如果想直接下载那么可以在调试-符号这栏 将Microsoft符号服务器给勾上 。如果想按需下载，那么在调试的时候，可以点击调试-窗口 选择 模块/调用堆栈 来选择自己想加载的去加载。<br>&emsp;&emsp;然后至 <a href="https://referencesource.microsoft.com/" target="_blank" rel="noopener">https://referencesource.microsoft.com/</a> 网站 点击右上角下载源代码。当你调试代码的时候，会提示你无可用源，这个时候你再将你下载下来的源码文件给浏览查找一下就可以了。<br><img src="1026815-20180627092252642-95078986.png" alt=" "><br>&emsp;&emsp;如何配置VS来调试.NET Framework源码： <a href="https://referencesource.microsoft.com/#q=web" target="_blank" rel="noopener">https://referencesource.microsoft.com/#q=web</a> 、 <a href="https://technet.microsoft.com/zh-cn/cc667410.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/cc667410.aspx</a><br>&emsp;&emsp;还一种方法是，下载.NET Reflector插件，该插件可以帮助我们在VS中直接调试dll，这种方式操作非常简单，不过该插件收费，具体的可以查看我之前写过的文章(群里有该插件的注册版)  </p>
<h2 id="NET-Core是什么"><a href="#NET-Core是什么" class="headerlink" title=".NET Core是什么"></a>.NET Core是什么</h2><p>&emsp;&emsp;有丑才有美，有低才有高，概念是比较中诞生的。.NET Core就是如此，它是其它操作系统的.NET Framework翻版实现。<br>&emsp;&emsp;操作系统不止Windows，还有Mac和类Linux等系统， .NET的实现 如果按操作系统来横向分割的话，可以分为 Windows系统下的 .NET Framework 和 兼容多个操作系统的 .NET Core。<br>&emsp;&emsp;我们知道，一个.NET程序运行核心在于.NET CLR，为了能让.NET程序在其它平台上运行，一些非官方社区和组织为此开发了在其它平台下的.NET实现（最为代表的是mono，其团队后来又被微软给合并了 ），但因为不是官方，所以在一些方面多少有些缺陷(如FCL)，后来微软官方推出了.NET Core，其开源在Github中，并被收录在NET基金会(.NET Foundation，由微软公司成立与赞助的独立自由软件组织，其目前收录包括.NET编译器平台(“Roslyn”)以及ASP.NET项目系列，.NET Core，Xamarin Forms以及其它流行的.NET开源框架)，旨在真正的 .NET跨平台。<br>&emsp;&emsp;.NET Core是.NET 技术框架组成在Windows.macOS.Linux系统下的具体的实现。<br>&emsp;&emsp;.NET Core是一个开源的项目，其由 Microsoft 和 GitHub 上的 .NET 社区共同维护，但 这份工作仍然是巨大的，因为在早期对.NET上的定义及最初的实现一直是以Windows系统为参照及载体，一些.NET机制实际上与Windows系统耦合度非常高，有些属于.NET自己体系内的概念，有些则属于Windows系统api的封装。 那么从Windows转到其它平台上，不仅要实现相应的CLR，还要舍弃或重写一部分BCL，因而，.NET Core在概念和在项目中的行为与我们平常有些不同。<br>&emsp;&emsp;比如，NET Core不支持AppDomains、远程处理、代码访问安全性 (CAS) 和安全透明度，任何有关该概念的库代码都应该被替换。<br>&emsp;&emsp;这部分代码它不仅指你项目中的代码，还指你项目中using的那些程序集代码，所以你会在github上看到很多开源项目都在跟进对.NET Core的支持,并且很多开发者也尝试学习.NET Core，这也是一种趋势。<br>&emsp;&emsp;.NET Core指南<a href="https://docs.microsoft.com/en-us/dotnet/core/" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/core/</a><br>&emsp;&emsp;.NET基金会：<a href="https://dotnetfoundation.org" target="_blank" rel="noopener">https://dotnetfoundation.org</a><br>&emsp;&emsp;.NET Core跨平台的行为变更：<a href="https://github.com/dotnet/corefx/wiki/ApiCompat" target="_blank" rel="noopener">https://github.com/dotnet/corefx/wiki/ApiCompat</a><br>&emsp;&emsp;微软宣布.NET开发环境将开源 ：<a href="https://news.cnblogs.com/n/508410/" target="_blank" rel="noopener">https://news.cnblogs.com/n/508410/</a>  </p>
<h2 id="NET-Standard是什么"><a href="#NET-Standard是什么" class="headerlink" title=".NET Standard是什么"></a>.NET Standard是什么</h2><p>&emsp;&emsp;值得一提的是微软还为BCL提出了一个标准，毕竟各式各样的平台，技术层出不穷，为了防止.NET在类库方面的碎片化，即提出了一套正式的 .NET API (.NET 的应用程序编程接口)规范，.NET Standard。<br>&emsp;&emsp;正如上面CLS一样，.NET Standard就类似于这样的一个概念，无论是哪个托管框架，我们遵循这个标准，就能始终保持在BCL的统一性，即我不需要关心我是用的.NET Framework还是.NET Core，只要该类被定义于.NET Standard中，我就一定能在对应支持的.NET Standard的版本的托管框架中找到它。<br><img src="1026815-20180627092519198-1182560984.png" alt=" "><br>&emsp;&emsp;.NET Standard： <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard#net-implementation-support" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard#net-implementation-support</a><br>&emsp;&emsp;.NET Standard开源代码：<a href="https://github.com/dotnet/standard" target="_blank" rel="noopener">https://github.com/dotnet/standard</a>  </p>
<h2 id="NET官方开源项目链接"><a href="#NET官方开源项目链接" class="headerlink" title=".NET官方开源项目链接"></a>.NET官方开源项目链接</h2><p>&emsp;&emsp;现在我将给出.NET相关的开源项目地址：<br>&emsp;&emsp;参与.NET和.NET开源项目的起点：<a href="https://github.com/Microsoft/dotnet" target="_blank" rel="noopener">https://github.com/Microsoft/dotnet</a>  </p>
<ul>
<li>.NET Core：<a href="https://github.com/dotnet/core" target="_blank" rel="noopener">https://github.com/dotnet/core</a></li>
<li>.NET Core文档：<a href="https://github.com/dotnet/docs" target="_blank" rel="noopener">https://github.com/dotnet/docs</a></li>
<li>ASP.NET Core：<a href="https://github.com/aspnet/home" target="_blank" rel="noopener">https://github.com/aspnet/home</a></li>
<li>ASP.NET Core文档：<a href="https://github.com/aspnet/Docs" target="_blank" rel="noopener">https://github.com/aspnet/Docs</a></li>
<li>EntityFramework Core框架:<a href="https://github.com/aspnet/EntityFrameworkCore" target="_blank" rel="noopener">https://github.com/aspnet/EntityFrameworkCore</a></li>
<li>ASP.NET Core MVC框架：<a href="https://github.com/aspnet/Mvc" target="_blank" rel="noopener">https://github.com/aspnet/Mvc</a></li>
<li>EntityFramework6:<a href="https://github.com/aspnet/EntityFramework6" target="_blank" rel="noopener">https://github.com/aspnet/EntityFramework6</a></li>
<li>.NET Framework源码：<a href="https://github.com/microsoft/referencesource" target="_blank" rel="noopener">https://github.com/microsoft/referencesource</a></li>
<li>.NET Core基类库：<a href="https://github.com/dotnet/corefx" target="_blank" rel="noopener">https://github.com/dotnet/corefx</a></li>
<li>.NET Core CLR：<a href="https://github.com/dotnet/coreclr" target="_blank" rel="noopener">https://github.com/dotnet/coreclr</a></li>
<li>Roslyn编译器：<a href="https://github.com/dotnet/roslyn" target="_blank" rel="noopener">https://github.com/dotnet/roslyn</a></li>
<li>MVC5、Web API2、Web Pages3框架源码：<a href="https://github.com/aspnet/AspNetWebStack" target="_blank" rel="noopener">https://github.com/aspnet/AspNetWebStack</a></li>
<li>.NET Standard：<a href="https://github.com/dotnet/standard" target="_blank" rel="noopener">https://github.com/dotnet/standard</a></li>
<li>KestrelHttpServer用于ASP.NET Core的跨平台Web服务器：<a href="https://github.com/aspnet/KestrelHttpServer" target="_blank" rel="noopener">https://github.com/aspnet/KestrelHttpServer</a></li>
<li>Visual Studio Code源码：<a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">https://github.com/Microsoft/vscode</a></li>
<li>一些优秀的.NET库、工具、框架、软件开源集合：<a href="https://github.com/quozd/awesome-dotnet" target="_blank" rel="noopener">https://github.com/quozd/awesome-dotnet</a></li>
<li>一些常用框架对ASP.NET Core和.NET Core的支持报告：<a href="https://github.com/jpsingleton/ANCLAFS" target="_blank" rel="noopener">https://github.com/jpsingleton/ANCLAFS</a> </li>
<li>一些.NET下用于支持开发的开源项目集合：<a href="https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md" target="_blank" rel="noopener">https://github.com/Microsoft/dotnet/blob/master/dotnet-developer-projects.md</a> </li>
<li>微软出品的分布式框架orleans：<a href="https://github.com/dotnet/orleans" target="_blank" rel="noopener">https://github.com/dotnet/orleans</a></li>
<li>ML.NET 用于.NET的开源和跨平台机器学习框架：<a href="https://github.com/dotnet/machinelearning" target="_blank" rel="noopener">https://github.com/dotnet/machinelearning</a></li>
</ul>
<h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><p>&emsp;&emsp;在文章最后，我还要简单的说下Visual Studio。<br>&emsp;&emsp;通过上文得知，只需要一个txt记事本+csc.exe我们就可以开发出一个.NET程序，那么与之相比，.NET提供的开发工具VS有什么不同呢？<br>&emsp;&emsp;我们用记事本+csc.exe来编写一个.NET程序只适合小打小闹，对于真正要开发一个项目而言，我们需要文件管理、版本管理、一个好的开发环境等。而vs ide则就是这样一个集成代码编辑、编译、调试、追踪、测试、部署、协作、插件扩展这样多个组件的集成开发环境，csc.exe的编译功能只是vs ide中的其中之一。使用vside开发可以节省大量的开发时间和成本。  </p>
<h2 id="sln解决方案"><a href="#sln解决方案" class="headerlink" title="sln解决方案"></a>sln解决方案</h2><p>&emsp;&emsp;当你用VS来新建一个项目时，VS会先为你新建一个整体的解决方案。这个解决方案表现为.sln和.suo后缀格式的文件，它们均是文本文件，对解决方案右键属性可以进行相应的修改，也可以直接用记事本打开。<br>&emsp;&emsp;在sln中，定义了解决方案的版本及环境，如包含的项目，方案启动项，生成或部署的一些项目配置等，你可以通过修改或重新定义sln来更改你的整个解决方案。<br>&emsp;&emsp;而suo则包含于解决方案建立关联的选项，相当于快照，储存了用户界面的自定义配置、调试器断点、观察窗口设置等这样的东西，它是隐藏文件，可删除但建议不要删除。<br>&emsp;&emsp;我们可以通过对比各版本之间的sln来修改sln,也可以使用网上的一些转换工具，也可以直接点击VS的文件-新建-从现有代码创建项目来让项目在不同VS版本间切换。<br>&emsp;&emsp;Visual Studio 2010 - # Visual Studio 4.0<br>&emsp;&emsp;Visual Studio 2012 - # Visual Studio 4.0<br>&emsp;&emsp;Visual Studio 2013 - # Visual Studio 12.00<br>&emsp;&emsp;Visual Studio 2015 - # Visual Studio 14<br>&emsp;&emsp;Visual Studio 2017 - # Visual Studio 15  </p>
<h2 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h2><p>&emsp;&emsp;VS使用项目模板来基于用户的选择而创建新的项目，也就是新建项目中的那些展示项(如mvc5项目/winform项目等等)，具体表现为包含<code>.vstemplate</code>及一些定义的关联文件这样的母版文件。将这些文件压缩为一个 <code>.zip</code> 文件并放在正确的文件夹中时，就会在展示项中予以显示。<br>&emsp;&emsp;用户可以创建或自定义项目模板，也可以选择现有的模板，比如我创建一个控制台项目就会生成一个在<code>.vstemplate</code>中定义好的<code>Program.cs</code>、<code>AssemblyInfo.cs</code>(程序集级别的特性)、<code>App.config</code>、<code>ico</code>、<code>csproj</code>文件<br><img src="1026815-20180627092814795-1540367679.png" alt=" ">  </p>
<h2 id="csproj工程文件"><a href="#csproj工程文件" class="headerlink" title="csproj工程文件"></a>csproj工程文件</h2><p>&emsp;&emsp;这里面，csproj是我们最常见的核心文件，CSharp Project，它是用于构建这个项目的工程文件。<br>&emsp;&emsp;csproj是基于xml格式的MSBuild项目文件，其仍然是文本文件，可以打开并修改定义了的工程构造的属性，比如选择性的添加或删除或修改包含在项目中的文件或引用、修改项目版本、将其转换为其它类型项目等。<br>&emsp;&emsp;MSBuild是微软定义的一个用于生成应用程序的平台(Microsoft Build Engine)，在这里为VS提供了项目的构造系统，在微软官方文档上有着详细的说明：<a href="https://msdn.microsoft.com/zh-cn/library/dd393573.aspx、https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/dd393573.aspx、https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild</a>  </p>
<h2 id="项目属性杂项"><a href="#项目属性杂项" class="headerlink" title="项目属性杂项"></a>项目属性杂项</h2><p>&emsp;&emsp;现在，简单说明一下csproj文件的一些核心元素。我们用vs新建一个控制台项目，然后对项目右键属性打开项目属性，在应用程序页我们可以定义：程序集名称(生成出来的程序集以程序集名称作为文件名，相当于csc中的/out)、默认命名空间(每次新建类里面显示的命名空间)、目标框架、应用程序类型、程序集信息(AssemblyInfo中的信息)、启动对象(可同时存在多个Main方法，需指定其中一个为入口对象)、程序集资源(一些可选的图标及文件)  </p>
<ol>
<li><p>在生成页有：  </p>
<ul>
<li>条件编译符号(全局的预编译#define指令，不用在每个文件头部定义，相当于csc中的/define)</li>
<li>定义DEBUG/TRACE常量(用于调试输出的定义变量，如智能追踪的时候可以输出该变量)</li>
<li>目标平台(指定当前面向什么处理器生成的程序集，相当于csc中的/platform。选择x86则生成的程序集生成32位程序，能在32/64位Intel处理器中使用。选择x64则生成64位，只能在64位系统中运行。选择Any CPU则32位系统生成32位，64位系统则生成64位。注意：编译平台和目标调用平台必须保持一致，否则报错。生成的32位程序集不能调用64位程序集，64位也不能调用32位)、首选32位(如果目标平台是Any CPU并且项目是应用程序类型，则生成的是32位程序集)</li>
<li>允许不安全代码(unsafe开关，在c#中进行指针编程，如调换a方法和b方法的地址)</li>
<li>优化代码(相当于csc中的/optimize，优化IL代码让调试难以进行，优化JIT代码)</li>
<li>输出路径(程序集输出目录，可选择填写相对路径目录或绝对路径目录)</li>
<li>XML文档文件(相当于csc中的/doc，为程序集生成文档注释文件，浏览对方程序集对象就可以看到相关注释，VS的智能提示技术就运用于此)</li>
<li>为COM互操作注册(指示托管应用程序将公开一个 COM 对象,使COM对象可以与托管应用程序进行交互)</li>
</ul>
</li>
<li><p>在高级生成设置中有:语言版本(可以选择C#版本)、调试信息(相当于csc中的/debug。选择none则不生成任何调试信息，无法调试。选择full则允许将调试器附加到运行程序，生成pdb调试文件。选择pdb-only，自.NET2.0开始与full选项完全相同，生成相同的pdb调试文件。)、文件对齐(指定输出文件中节的大小)、DLL基址(起点地址)  </p>
</li>
<li><p>在生成事件选项中可以设置生成前和生产后执行的命令行，我们可以执行一些命令。  </p>
</li>
<li><p>在调试选项中有一栏叫：启用Visual Studio承载进程，通过在vshost.exe中加载运行项目程序集，这个选项可以增加程序的调试性能，启用后会自动在输出目录生成{程序集名称}.vshost.exe这样一个文件，只有当当前项目不是启动项目的时候才能删除该文件。  </p>
</li>
</ol>
<h2 id="IntelliTrace智能追溯"><a href="#IntelliTrace智能追溯" class="headerlink" title="IntelliTrace智能追溯"></a>IntelliTrace智能追溯</h2><p>&emsp;&emsp;还要介绍一点VS的是，其IntelliTrace智能追溯功能，该功能最早存在于VS2010旗舰版，是我用的最舒服的一个功能。<br>&emsp;&emsp;简单介绍，该功能是用来辅助调试的，在调试时可以让开发人员了解并追溯代码所产生的一些事件，并且能够进行回溯以查看应用程序中发生的情形，它是一个非常强大的调试追踪器，它可以捕捉由你代码产生的事件，如异常事件、函数调用(从入口)、ADO.NET的命令(Sql查询语句…)、ASP.NET相关事件、代码发送的HTTP请求、程序集加载卸载事件、文件访问打开关闭事件、Winform/Webform/WPF动作事件、线程事件、环境变量、Console/Trace等输出…<br>&emsp;&emsp;我们可以通过在调试状态下点击调试菜单-窗口-显示诊断工具，或者直接按<code>Ctrl+Alt+F2</code>来唤起该功能窗口。<br><img src="1026815-20180627093009099-519860392.png" alt=" "><br>&emsp;&emsp;当然，VS还有其它强大的功能，我建议大家依次点完 菜单项中的 调试、体系结构、分析这三个大菜单里面的所有项，你会发现VS真是一个强大的IDE。比较实用且方便的功能举几个例子：<br>&emsp;&emsp;比如 从代码生成的序列图，该功能在vs2015之前的版本可以找到(<a href="https://msdn.microsoft.com/en-us/library/dd409377.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dd409377.aspx</a> 、<a href="https://www.zhihu.com/question/36413876" target="_blank" rel="noopener">https://www.zhihu.com/question/36413876</a>)<br><img src="1026815-20180627093037839-1150553069.png" alt=" "><br>&emsp;&emsp;比如 模块关系的代码图，可以看到各模块间的关系<br><img src="1026815-20180627093124326-512090758.png" alt=" "><br>&emsp;&emsp;比如 对解决方案的代码度量分析结果<br><img src="1026815-20180627093148912-1896119331.png" alt=" "><br>&emsp;&emsp;比如 调试状态下 函数调用的 代码图，我们可以看到MVC框架的函数管道模型<br><img src="1026815-20180627093233279-525978653.png" alt=" "><br>&emsp;&emsp;以及并行堆栈情况、加载的模块、线程的实际情况<br><img src="1026815-20180627093315515-525631630.png" alt=" ">  </p>
<figure class="image-box">
                <img src="1026815-20180627093342703-1181912035.png" alt title class>
                <p></p>
            </figure>  
<figure class="image-box">
                <img src="1026815-20180627093350454-462024400.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;还有如进程、内存、反汇编、寄存器等的功能，这里不再一一展示  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>&emsp;&emsp;有关解决方案：<a href="https://msdn.microsoft.com/zh-cn/library/b142f8e7(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/b142f8e7(v=vs.110).aspx</a><br>&emsp;&emsp;有关项目模板： <a href="https://msdn.microsoft.com/zh-cn/library/ms247121(v=vs.110).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/ms247121(v=vs.110).aspx</a><br>&emsp;&emsp;有关项目元素的说明介绍：<a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/16satcwx(v%3dvs.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/16satcwx(v%3dvs.100)</a><br>&emsp;&emsp;有关调试更多内容：<a href="https://docs.microsoft.com/zh-cn/visualstudio/debugger/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/debugger/</a><br>&emsp;&emsp;有关代码设计建议：<a href="https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-analysis-for-managed-code-warnings" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/code-quality/code-analysis-for-managed-code-warnings</a><br>&emsp;&emsp;有关IntelliTrace介绍：<a href="https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/dd264915(v%3dvs.100)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/visualstudio/visual-studio-2010/dd264915(v%3dvs.100)</a>  </p>
<h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><p>&emsp;&emsp;我热爱编程。<br>&emsp;&emsp;我知道大多数人对技术的积累都是来自于平常工作中，工作中用到的就去学，用不到就不学，学一年的知识，然后用个五六年。<br>&emsp;&emsp;我也能理解人的理想和追求不同，有的人可能就想平淡点生活。有的人可能是过了拼劲，习惯了安逸。有的人已经认命了。<br>&emsp;&emsp;而我现在也每天饱满工作没多少时间，但在下班之余我仍然坚持每天都看一看书。<br>&emsp;&emsp;想学没时间学，想拼不知道往哪拼。有埋汰自己脑袋笨的，有说自己不感兴趣的。有明明踌躇满志，但总三天捕鱼两天晒网的。我身边的朋友大多都这样。<br>&emsp;&emsp;我想说，尽管我们每个人的境遇、思想、规划不同，但我肯定大家大部分是出于生计而工作。<br>&emsp;&emsp;而出于生计，那就是为了自己。而既然是为了自己，那就别每天浑浑噩噩过，即使你因各种原因而没有斗志。<br>&emsp;&emsp;编程来不得虚的，如果你没走上管理，那么你的技术好就是好，不好就是不好，混不得，一分技术一分钱。自己不扎实，你运气就不可能太好。<br>&emsp;&emsp;技术是相通的，操作系统、通信、数据结构、协议标准、技术规范、设计模式，语言只是门工具。要知其然也要知其所以然，只知道1个梨+1个梨=2个梨，不知道1个苹果+1个苹果等于啥就悲剧了。<br>&emsp;&emsp;那怎样提升自己？肯定不能像之前那样被动的去学习了。<br>&emsp;&emsp;光靠工作中的积累带来的提升是没有多少。你不能靠1年的技术重复3年的劳动，自己不想提升就不能怨天尤人。<br>&emsp;&emsp;上班大家都一样，我认为成功与否取决于你的业余时间。你每天下班无论再苦都要花一个小时来学习，学什么都行，肯定能改变你的人生轨迹。<br>&emsp;&emsp;比如你每天下班后都用一小时来学一个概念或技术点，那么300天就是300个概念或者技术点，这是何等的恐怖。<br>&emsp;&emsp;当然，这里的学要有点小方法小技巧的。不能太一条道摸到黑的那种，虽然这样最终也能成功，并且印象还深刻，但是总归效率是有点低的。<br>&emsp;&emsp;比如你从网上下载个项目源码，你项目结构不知道，该项目运用技术栈也不太了解，就一点一点的开始解读。这是个提升的好方法，但这样很累，可以成功，但是很慢。见的多懂的少，往往会因为一个概念上的缺失而在一个细小的问题上浪费很长时间。或者说一直漫无目的的看博客来了解技术，那样获取的知识也不系统。<br>&emsp;&emsp;我的建议是读书，书分两类，一类是 讲底层概念的 一类是 讲上层技术实现的。<br>&emsp;&emsp;可以先从上层技术实现的书读起(如何连接数据库、如何写网页、如何写窗体这些)。在有一定编程经验后就从底层概念的书开始读，操作系统的、通信的、数据库的、.NET相关组成的这些…<br>&emsp;&emsp;读完之后再回过头读这些上层技术的书就会看的更明白更透彻，最后再琢磨git下来的项目就显得轻松了。<br>&emsp;&emsp;就.NET CLR组成这一块中文书籍比较少，由浅到深推荐的书有 你必须知道的.NET(挺通俗)，CLR C#(挺通俗，进阶必看)，如果你想进一步了解CLR，可以看看园子里 包建强 <a href="http://www.cnblogs.com/Jax/archive/2009/05/25/1488835.html" target="_blank" rel="noopener">http://www.cnblogs.com/Jax/archive/2009/05/25/1488835.html</a> 和中道学友 <a href="http://www.cnblogs.com/awpatp/archive/2009/11/11/1601397.html" target="_blank" rel="noopener">http://www.cnblogs.com/awpatp/archive/2009/11/11/1601397.html</a> 翻译的书籍及文章，当然如果你英语合格的话也可以直接阅读他们翻译的来源书籍，我这里有Expert .NET 2.0 IL Assembler的机器翻译版，同时我也建议从调试的方面入手，如 NET高级调试(好多.NET文件调试、反编译的文章都是参考这本书和Apress.Expert.dot.NET.2.0.IL.Assembler(这本书我有机器翻译版)的内容)或者看看Java的JVM的文章。<br>&emsp;&emsp;欢迎加群和我交流(书籍我都放在群文件里了)  </p>
<p>&emsp;&emsp;现在技术发展很快，我建议大家有基础的可以直接看官方文档，(详细链接我已经在各小节给出)以下是部分常用总链接：<br>&emsp;&emsp;asp.net指南：<a href="https://docs.microsoft.com/zh-cn/aspnet/#pivot=core" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/#pivot=core</a><br>&emsp;&emsp;Visual Studio IDE 指南：<a href="https://docs.microsoft.com/zh-cn/visualstudio/ide/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/ide/</a><br>&emsp;&emsp;C# 指南： <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/csharp/</a><br>&emsp;&emsp;.NET指南：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/</a><br>&emsp;&emsp;微软开发文档：<a href="https://docs.microsoft.com/zh-cn/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/</a><br>&emsp;&emsp;最后送给大家我经常做的两句话：  </p>
<ol>
<li>先问是不是，再问怎样做，最后我一定会问 为什么  </li>
<li>没人比谁差多少，相信自己，坚持不断努力，你也能成功  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
            <tag> dotNET </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图册]]></title>
      <url>/2019/11/10/Pictures/</url>
      <content type="html"><![CDATA[<p>&emsp;</p>
<a id="more"></a>


<h1 id="Nintendo-Switch"><a href="#Nintendo-Switch" class="headerlink" title="Nintendo Switch"></a>Nintendo Switch</h1><figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/NS20171101-20180501.jpg" alt="2017.11.01 - 2018.05.01" title class>
                <p>2017.11.01 - 2018.05.01</p>
            </figure>  
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/NS20171101-20190112.jpg" alt="2017.11.01 - 2019.01.12" title class>
                <p>2017.11.01 - 2019.01.12</p>
            </figure>  
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/NS20171101-20191101.jpg" alt="2017.11.01 - 2019.11.01" title class>
                <p>2017.11.01 - 2019.11.01</p>
            </figure>  

<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><figure class="image-box">
                <img src="设计模式.png" alt="设计模式" title class>
                <p>设计模式</p>
            </figure>  
<figure class="image-box">
                <img src="CQRS架构.png" alt="CQRS架构" title class>
                <p>CQRS架构</p>
            </figure>  ]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[在浏览器输入 URL 回车之后发生了什么]]></title>
      <url>/2019/09/06/WhatHappensWhenYouTypeURLIntoYourBrowserAndPressEnter/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="https://4ark.me/post/b6c7c0a2.html" target="_blank" rel="noopener">https://4ark.me/post/b6c7c0a2.html</a></p>
</blockquote>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;这个问题已经是老生常谈了，更是经常被作为面试的压轴题出现，网上也有很多文章，但最近闲的无聊，然后就自己做了一篇笔记，感觉比之前理解更透彻了。<br>&emsp;&emsp;这篇笔记是我这两天看了数十篇文章总结出来的，所以相对全面一点，但由于我是做前端的，所以会比较重点分析浏览器渲染页面那一部分，至于其他部分我会罗列出关键词，感兴趣的可以自行查阅  </p>
<p>&emsp;&emsp;<strong>注意</strong>：本文的步骤是建立在，请求的是一个简单的 HTTP 请求，没有 HTTPS、HTTP2、最简单的 DNS、没有代理、并且服务器没有任何问题的基础上，尽管这是不切实际的。  </p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol>
<li>URL 解析</li>
<li>DNS 查询</li>
<li>TCP 连接</li>
<li>处理请求</li>
<li>接受响应</li>
<li>渲染页面</li>
</ol>
<h1 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h1><h2 id="地址解析："><a href="#地址解析：" class="headerlink" title="地址解析："></a>地址解析：</h2><p>&emsp;&emsp;首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。</p>
<h2 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h2><p>&emsp;&emsp;由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。详见：<a href="https://www.barretlee.com/blog/2015/10/22/hsts-intro/" target="_blank" rel="noopener">你所不知道的 HSTS</a>。</p>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>&emsp;&emsp;浏览器还会进行一些额外的操作，比如安全检查、访问限制（之前国产浏览器限制 996.icu）。</p>
<h2 id="检查缓存"><a href="#检查缓存" class="headerlink" title="检查缓存"></a>检查缓存</h2><figure class="image-box">
                <img src="检查缓存.png" alt title class>
                <p></p>
            </figure>

<h1 id="二、DNS-查询"><a href="#二、DNS-查询" class="headerlink" title="二、DNS 查询"></a>二、DNS 查询</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><figure class="image-box">
                <img src="DNS查询.png" alt title class>
                <p></p>
            </figure>
<h2 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1. 浏览器缓存"></a>1. 浏览器缓存</h2><p>&emsp;&emsp;浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询。</p>
<h2 id="2-操作系统缓存"><a href="#2-操作系统缓存" class="headerlink" title="2. 操作系统缓存"></a>2. 操作系统缓存</h2><p>&emsp;&emsp;操作系统也有自己的 DNS缓存，但在这之前，会向检查域名是否存在本地的 Hosts 文件里，没有则向 DNS 服务器发送查询请求。</p>
<h2 id="3-路由器缓存"><a href="#3-路由器缓存" class="headerlink" title="3. 路由器缓存"></a>3. 路由器缓存</h2><p>&emsp;&emsp;路由器也有自己的缓存。</p>
<h2 id="4-ISP-DNS-缓存"><a href="#4-ISP-DNS-缓存" class="headerlink" title="4. ISP DNS 缓存"></a>4. ISP DNS 缓存</h2><p>&emsp;&emsp;ISP DNS 就是在客户端电脑上设置的首选 DNS 服务器，它们在大多数情况下都会有缓存。</p>
<h2 id="根域名服务器查询"><a href="#根域名服务器查询" class="headerlink" title="根域名服务器查询"></a>根域名服务器查询</h2><p>&emsp;&emsp;在前面所有步骤没有缓存的情况下，本地 DNS 服务器会将请求转发到互联网上的根域，下面这个图很好的诠释了整个流程：</p>
<figure class="image-box">
                <img src="DNS根域名服务器查询.png" alt title class>
                <p></p>
            </figure>

<blockquote>
<p>根域名服务器：<a href="https://zh.wikipedia.org/wiki/%E6%A0%B9%E7%B6%B2%E5%9F%9F%E5%90%8D%E7%A8%B1%E4%BC%BA%E6%9C%8D%E5%99%A8" target="_blank" rel="noopener">维基百科</a></p>
</blockquote>
<h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><ol>
<li>递归方式：一路查下去中间不返回，得到最终结果才返回信息（浏览器到本地DNS服务器的过程）</li>
<li>迭代方式，就是本地DNS服务器到根域名服务器查询的方式。</li>
<li>什么是 DNS 劫持</li>
<li>前端 dns-prefetch 优化</li>
</ol>
<h1 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h1><p>&emsp;&emsp;TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：<br><img src="TCP%E8%BF%9E%E6%8E%A5.png" alt=" "></p>
<h2 id="1-应用层：发送-HTTP-请求"><a href="#1-应用层：发送-HTTP-请求" class="headerlink" title="1. 应用层：发送 HTTP 请求"></a>1. 应用层：发送 HTTP 请求</h2><p>&emsp;&emsp;在前面的步骤我们已经得到服务器的 IP 地址，浏览器会开始构造一个 HTTP 报文，其中包括：</p>
<ul>
<li>请求报头（Request Header）：请求方法、目标地址、遵循的协议等等</li>
<li>请求主体（其他参数）</li>
</ul>
<p>&emsp;&emsp;其中需要注意的点：</p>
<ul>
<li>浏览器只能发送 GET、POST 方法，而打开网页使用的是 GET 方法</li>
</ul>
<h2 id="2-传输层：TCP-传输报文"><a href="#2-传输层：TCP-传输报文" class="headerlink" title="2. 传输层：TCP 传输报文"></a>2. 传输层：TCP 传输报文</h2><p>&emsp;&emsp;传输层会发起一条到达服务器的 TCP 连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接受时能够准确地还原报文信息。<br>&emsp;&emsp;在建立连接前，会先进行 TCP 三次握手。</p>
<blockquote>
<p>关于 TCP/IP 三次握手，网上已经有很多段子和图片生动地描述了。<br>相关知识点：<br>&emsp;&emsp;SYN 泛洪攻击</p>
</blockquote>
<h2 id="3-网络层：IP协议查询Mac地址"><a href="#3-网络层：IP协议查询Mac地址" class="headerlink" title="3. 网络层：IP协议查询Mac地址"></a>3. 网络层：IP协议查询Mac地址</h2><p>&emsp;&emsp;将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。<br>&emsp;&emsp;判断目标地址是否与当前地址处于同一网络中，是的话直接根据 Mac 地址发送，否则使用路由表查找下一跳地址，以及使用 ARP 协议查询它的 Mac 地址。</p>
<blockquote>
<p>注意：在 OSI 参考模型中 ARP 协议位于链路层，但在 TCP/IP 中，它位于网络层。</p>
</blockquote>
<h2 id="4-链路层：以太网协议"><a href="#4-链路层：以太网协议" class="headerlink" title="4. 链路层：以太网协议"></a>4. 链路层：以太网协议</h2><h3 id="以太网协议"><a href="#以太网协议" class="headerlink" title="以太网协议"></a>以太网协议</h3><p>&emsp;&emsp;根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两个部分：</p>
<ul>
<li>标头：数据包的发送者、接受者、数据类型</li>
<li>数据：数据包具体内容</li>
</ul>
<h3 id="Mac-地址"><a href="#Mac-地址" class="headerlink" title="Mac 地址"></a>Mac 地址</h3><p>&emsp;&emsp;以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另一块网卡，网卡的地址就是 Mac 地址。每一个 Mac 地址都是独一无二的，具备了一对一的能力。</p>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>&emsp;&emsp;发送数据的方法很原始，直接把数据通过 ARP 协议，向本网络的所有机器发送，接收方根据标头信息与自身 Mac 地址比较，一致就接受，否则丢弃。<br>&emsp;&emsp;<strong>注意</strong>：接收方回应是单播。</p>
<blockquote>
<p>相关知识点：<br>&emsp;&emsp;ARP 攻击</p>
</blockquote>
<h2 id="服务器接受请求"><a href="#服务器接受请求" class="headerlink" title="服务器接受请求"></a>服务器接受请求</h2><p>&emsp;&emsp;接受过程就是把以上步骤逆转过来，参见上图。</p>
<h1 id="四、服务器处理请求"><a href="#四、服务器处理请求" class="headerlink" title="四、服务器处理请求"></a>四、服务器处理请求</h1><h2 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h2><figure class="image-box">
                <img src="服务器处理请求.png" alt title class>
                <p></p>
            </figure>
<h2 id="HTTPD"><a href="#HTTPD" class="headerlink" title="HTTPD"></a>HTTPD</h2><p>&emsp;&emsp;最常见的 HTTPD 有 Linux 上常用的 Apache 和 Nginx，以及 Windows 上的 IIS。<br>&emsp;&emsp;它会监听得到的请求，然后开启一个子进程去处理这个请求。</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><p>&emsp;&emsp;接受 TCP 报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并且进行一些验证：</p>
<ul>
<li>验证是否配置虚拟主机</li>
<li>验证虚拟主机是否接受此方法</li>
<li>验证该用户可以使用该方法（根据 IP 地址、身份信息等）</li>
</ul>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>&emsp;&emsp;假如服务器配置了 HTTP 重定向，就会返回一个<code>301</code>永久重定向响应，浏览器就会根据响应，重新发送 HTTP 请求（重新执行上面的过程）。</p>
<blockquote>
<p>关于更多：<a href="https://www.cnblogs.com/workest/p/3891321.html" target="_blank" rel="noopener">详见这篇文章</a></p>
</blockquote>
<h2 id="URL-重写"><a href="#URL-重写" class="headerlink" title="URL 重写"></a>URL 重写</h2><p>&emsp;&emsp;然后会查看 URL 重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，则会直接把这个文件返回。<br>&emsp;&emsp;否则服务器会按照规则把请求重写到 一个 REST 风格的 URL 上。<br>&emsp;&emsp;然后根据动态语言的脚本，来决定调用什么类型的动态文件解释器来处理这个请求。<br>&emsp;&emsp;以 PHP 语言的 MVC 框架举例，它首先会初始化一些环境的参数，根据 URL 由上到下地去匹配路由，然后让路由所定义的方法去处理请求。</p>
<h1 id="五、浏览器接受响应"><a href="#五、浏览器接受响应" class="headerlink" title="五、浏览器接受响应"></a>五、浏览器接受响应</h1><p>&emsp;&emsp;浏览器接收到来自服务器的响应资源后，会对资源进行分析。<br>&emsp;&emsp;首先查看 Response header，根据不同状态码做不同的事（比如上面提到的重定向）。<br>&emsp;&emsp;如果响应资源进行了压缩（比如 gzip），还需要进行解压。<br>&emsp;&emsp;然后，对响应资源做缓存。<br>&emsp;&emsp;接下来，根据响应资源里的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types" target="_blank" rel="noopener">MIME</a> 类型去解析响应内容（比如 HTML、Image各有不同的解析方式）。</p>
<h1 id="六、渲染页面"><a href="#六、渲染页面" class="headerlink" title="六、渲染页面"></a>六、渲染页面</h1><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><figure class="image-box">
                <img src="浏览器内核.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;不同的浏览器内核，渲染过程也不完全相同，但大致流程都差不多。</p>
<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><figure class="image-box">
                <img src="渲染页面.png" alt title class>
                <p></p>
            </figure>
<h2 id="1-HTML-解析"><a href="#1-HTML-解析" class="headerlink" title="1. HTML 解析"></a>1. HTML 解析</h2><p>&emsp;&emsp;首先要知道浏览器解析是从上往下一行一行地解析的。  </p>
<p>解析的过程可以分为四个步骤：</p>
<h3 id="1-解码（encoding）"><a href="#1-解码（encoding）" class="headerlink" title="1. 解码（encoding）"></a>1. 解码（encoding）</h3><p>&emsp;&emsp;传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。</p>
<h3 id="2-预解析（pre-parsing）"><a href="#2-预解析（pre-parsing）" class="headerlink" title="2. 预解析（pre-parsing）"></a>2. 预解析（pre-parsing）</h3><p>&emsp;&emsp;预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如<code>img</code>标签的<code>src</code>属性，并将这个请求加到请求队列中。</p>
<h3 id="3-符号化（Tokenization）"><a href="#3-符号化（Tokenization）" class="headerlink" title="3. 符号化（Tokenization）"></a>3. 符号化（Tokenization）</h3><p>&emsp;&emsp;符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。<br>它通过一个状态机去识别符号的状态，比如遇到<code>&lt;</code>，<code>&gt;</code>状态都会产生变化。</p>
<h3 id="4-构建树（tree-construction）"><a href="#4-构建树（tree-construction）" class="headerlink" title="4. 构建树（tree construction）"></a>4. 构建树（tree construction）</h3><blockquote>
<p>注意：符号化和构建树是并行操作的，也就是说只要解析到一个开始标签，就会创建一个 DOM 节点。</p>
</blockquote>
<p>&emsp;&emsp;在上一步符号化中，解析器获得这些标记，然后以合适的方法创建<code>DOM</code>对象并把这些符号插入到<code>DOM</code>对象中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <img src="构建树.png" alt title class>
                <p></p>
            </figure>
<h3 id="浏览器容错进制"><a href="#浏览器容错进制" class="headerlink" title="浏览器容错进制"></a>浏览器容错进制</h3><p>&emsp;&emsp;你从来没有在浏览器看过类似”语法无效”的错误，这是因为浏览器去纠正错误的语法，然后继续工作。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>&emsp;&emsp;当整个解析的过程完成以后，浏览器会通过<code>DOMContentLoaded</code>事件来通知<code>DOM</code>解析完成。</p>
<h2 id="2-CSS-解析"><a href="#2-CSS-解析" class="headerlink" title="2. CSS 解析"></a>2. CSS 解析</h2><p>&emsp;&emsp;一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据<a href="https://drafts.csswg.org/css-syntax-3/" target="_blank" rel="noopener">语法规范</a>解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。</p>
<h3 id="CSS-匹配规则"><a href="#CSS-匹配规则" class="headerlink" title="CSS 匹配规则"></a>CSS 匹配规则</h3><p>&emsp;&emsp;在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：<code>div p { font-size :14px }</code>会先寻找所有的<code>p</code>标签然后判断它的父元素是否为<code>div</code>。<br>&emsp;&emsp;所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。</p>
<h2 id="3-渲染树"><a href="#3-渲染树" class="headerlink" title="3. 渲染树"></a>3. 渲染树</h2><p>&emsp;&emsp;其实这就是一个 DOM 树和 CSS 规则树合并的过程。</p>
<blockquote>
<p>注意：渲染树会忽略那些不需要渲染的节点，比如设置了<code>display:none</code>的节点。</p>
</blockquote>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>&emsp;&emsp;通过计算让任何尺寸值都减少到三个可能之一：<code>auto</code>、百分比、px，比如把<code>rem</code>转化为<code>px</code>。</p>
<h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>&emsp;&emsp;浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做<code>specificity</code>的公式，这个公式会通过：</p>
<ol>
<li>标签名、class、id</li>
<li>是否内联样式</li>
<li><code>!important</code> </li>
</ol>
<p>&emsp;&emsp;然后得出一个权重值，取最高的那个。</p>
<h3 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h3><p>&emsp;&emsp;当遇到一个<code>script</code>标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。<br>&emsp;&emsp;但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。  </p>
<p>&emsp;&emsp;所以我们知道：</p>
<ul>
<li>CSS 会阻塞 JS 执行</li>
<li>JS 会阻塞后面的 DOM 解析</li>
</ul>
<p>&emsp;&emsp;为了避免这种情况，应该以下原则：</p>
<ul>
<li>CSS 资源排在 JavaScript 资源前面</li>
<li>JS 放在 HTML 最底部，也就是 <code>&lt;/body&gt;</code>前</li>
</ul>
<p>&emsp;&emsp;另外，如果要改变阻塞模式，可以使用 defer 与 async，详见：<a href="https://github.com/xiaoyu2er/blog/issues/8" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="4-布局与绘制"><a href="#4-布局与绘制" class="headerlink" title="4. 布局与绘制"></a>4. 布局与绘制</h2><p>&emsp;&emsp;确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。<br>&emsp;&emsp;然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。</p>
<h2 id="5-合并渲染层"><a href="#5-合并渲染层" class="headerlink" title="5. 合并渲染层"></a>5. 合并渲染层</h2><p>&emsp;&emsp;把以上绘制的所有图片合并，最终输出一张图片。</p>
<h2 id="6-回流与重绘"><a href="#6-回流与重绘" class="headerlink" title="6. 回流与重绘"></a>6. 回流与重绘</h2><h3 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流(reflow)"></a>回流(reflow)</h3><p>&emsp;&emsp;当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从html标签开始递归往下，重新计算位置和大小。<br>&emsp;&emsp;reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。</p>
<h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h3><p>&emsp;&emsp;改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。<br>&emsp;&emsp;每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。<br>&emsp;&emsp;回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。  </p>
<p>&emsp;&emsp;比如：</p>
<ul>
<li><code>display:none</code> 会触发回流，而 <code>visibility:hidden</code> 只会触发重绘。</li>
</ul>
<h2 id="7-JavaScript-编译执行"><a href="#7-JavaScript-编译执行" class="headerlink" title="7. JavaScript 编译执行"></a>7. JavaScript 编译执行</h2><h3 id="大致流程-2"><a href="#大致流程-2" class="headerlink" title="大致流程"></a>大致流程</h3><figure class="image-box">
                <img src="JavaScript编译运行.png" alt title class>
                <p></p>
            </figure>  

<p>可以分为三个阶段：</p>
<h3 id="1-词法分析"><a href="#1-词法分析" class="headerlink" title="1. 词法分析"></a>1. 词法分析</h3><p>&emsp;&emsp;JS 脚本加载完毕后，会首先进入语法分析阶段，它首先会分析代码块的语法是否正确，不正确则抛出“语法错误”，停止执行。  </p>
<p>&emsp;&emsp;几个步骤：</p>
<ul>
<li>分词，例如将<code>var a = 2</code>，分成<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code>这样的词法单元。</li>
<li>解析，将词法单元转换成抽象语法树（AST）。</li>
<li>代码生成，将抽象语法树转换成机器指令。</li>
</ul>
<h3 id="2-预编译"><a href="#2-预编译" class="headerlink" title="2. 预编译"></a>2. 预编译</h3><p>&emsp;&emsp;JS 有三种运行环境：</p>
<ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval</li>
</ul>
<p>&emsp;&emsp;每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。</p>
<h4 id="创建执行上下文"><a href="#创建执行上下文" class="headerlink" title="创建执行上下文"></a>创建执行上下文</h4><p>&emsp;&emsp;创建执行上下文的过程中，主要做了以下三件事：</p>
<ul>
<li>创建变量对象<ul>
<li>参数、函数、变量</li>
</ul>
</li>
<li>建立作用域链<ul>
<li>确认当前执行环境是否能访问变量</li>
</ul>
</li>
<li>确定 This 指向</li>
</ul>
<h3 id="3-执行"><a href="#3-执行" class="headerlink" title="3. 执行"></a>3. 执行</h3><h4 id="JS-线程"><a href="#JS-线程" class="headerlink" title="JS 线程"></a>JS 线程</h4><figure class="image-box">
                <img src="JS线程.png" alt title class>
                <p></p>
            </figure>  
<p>&emsp;&emsp;虽然 JS 是单线程的，但实际上参与工作的线程一共有四个：</p>
<blockquote>
<p>其中三个只是协助，只有 JS 引擎线程是真正执行的</p>
</blockquote>
<ul>
<li>JS 引擎线程：也叫 JS 内核，负责解析执行 JS 脚本程序的主线程，例如 V8 引擎</li>
<li>事件触发线程：属于浏览器内核线程，主要用于控制事件，例如鼠标、键盘等，当事件被触发时，就会把事件的处理函数推进事件队列，等待 JS 引擎线程执行</li>
<li>定时器触发线程：主要控制<code>setInterval</code>和<code>setTimeout</code>，用来计时，计时完毕后，则把定时器的处理函数推进事件队列中，等待 JS 引擎线程。</li>
<li>HTTP 异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。</li>
</ul>
<p>&emsp;&emsp;<strong>注：浏览器对同一域名的并发连接数是有限的，通常为 6 个。</strong></p>
<h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p>&emsp;&emsp;分为：</p>
<ul>
<li>同步任务：按照顺序执行，只有前一个任务完成后，才能执行后一个任务</li>
<li>异步任务：不直接执行，只有满足触发条件时，相关的线程将该异步任务推进任务队列中，等待JS引擎主线程上的任务执行完毕时才开始执行，例如异步Ajax、DOM事件，setTimeout等。</li>
</ul>
<h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p>&emsp;&emsp;微任务是ES6和Node环境下的，主要 API 有：<code>Promise</code>，<code>process.nextTick</code>。<br>&emsp;&emsp;微任务的执行在宏任务的同步任务之后，在异步任务之前。<br><img src="%E5%BE%AE%E4%BB%BB%E5%8A%A1.png" alt=" ">  </p>
<h4 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>); <span class="comment">// 宏任务 异步</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>); <span class="comment">// 宏任务 同步</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>) <span class="comment">// 微任务</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>) <span class="comment">// 宏任务 同步</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码输出顺序为：1,3,5,4,2</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">what-happens-when-zh_CN</a></li>
<li><a href="https://alistapart.com/article/tags-to-dom/" target="_blank" rel="noopener">Tags to DOM</a></li>
<li><a href="https://heyingye.github.io/2018/04/16/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_rendering_engine" target="_blank" rel="noopener">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
<li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li>
<li><a href="https://heyingye.github.io/2018/03/19/js%E5%BC%95%E6%93%8E%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/#%E9%A2%84%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5" target="_blank" rel="noopener">js引擎的执行过程（一）</a></li>
<li>还有一些找不到了。。。。。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[行为型(Behavioral) 设计模式]]></title>
      <url>/2019/09/05/BehavioralDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>模板方法模式(Template Method) <a href="http://www.cnblogs.com/zhili/p/TemplateMethodPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/TemplateMethodPattern.html</a><br>命令模式(Command) <a href="http://www.cnblogs.com/zhili/p/CommandPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/CommandPattern.html</a><br>迭代器模式(Iterator) <a href="http://www.cnblogs.com/zhili/p/IteratorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/IteratorPattern.html</a><br>观察者模式(Observer) <a href="http://www.cnblogs.com/zhili/p/ObserverPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ObserverPattern.html</a><br>中介者模式(Mediator) <a href="http://www.cnblogs.com/zhili/p/MediatorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/MediatorPattern.html</a><br>状态者模式(State) <a href="http://www.cnblogs.com/zhili/p/StatePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/StatePattern.html</a><br>策略者模式(Strategy) <a href="http://www.cnblogs.com/zhili/p/StragetyPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/StragetyPattern.html</a><br>责任链模式(Chain of Responsibiliy) <a href="http://www.cnblogs.com/zhili/p/ChainOfResponsibity.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ChainOfResponsibity.html</a><br>访问者模式(Visitor) <a href="http://www.cnblogs.com/zhili/p/VistorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/VistorPattern.html</a><br>备忘录模式(Memento) <a href="http://www.cnblogs.com/zhili/p/MementoPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/MementoPattern.html</a><br>解释器模式(Interpreter)<br>空对象模式(Null Object)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[结构型(Structural) 设计模式]]></title>
      <url>/2019/09/05/StructuralDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>适配器模式(Adapter) <a href="http://www.cnblogs.com/zhili/p/AdapterPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/AdapterPattern.html</a><br>桥接模式(Bridge) <a href="http://www.cnblogs.com/zhili/p/BridgePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/BridgePattern.html</a><br>装饰者模式(Decorator) <a href="http://www.cnblogs.com/zhili/p/DecoratorPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/DecoratorPattern.html</a><br>组合模式(Composite) <a href="http://www.cnblogs.com/zhili/p/CompositePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/CompositePattern.html</a><br>外观模式(Facade) <a href="http://www.cnblogs.com/zhili/p/FacadePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FacadePattern.html</a><br>亨元模式(Flyweight) <a href="http://www.cnblogs.com/zhili/p/FlyweightPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FlyweightPattern.html</a><br>代理模式(Proxy) <a href="http://www.cnblogs.com/zhili/p/ProxyPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/ProxyPattern.html</a><br>私有类数据模式(Private Class Data)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[创建型(Creational) 设计模式]]></title>
      <url>/2019/09/05/CreationalDesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>单例模式(Singleton) <a href="http://www.cnblogs.com/zhili/p/SingletonPatterm.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/SingletonPatterm.html</a><br>简单工厂模式(Factory) <a href="http://www.cnblogs.com/zhili/p/SimpleFactory.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/SimpleFactory.html</a><br>工厂方法模式(Factory Method) <a href="http://www.cnblogs.com/zhili/p/FactoryMethod.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/FactoryMethod.html</a><br>抽象工厂模式(Abstract Factory) <a href="http://www.cnblogs.com/zhili/p/AbstractFactory.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/AbstractFactory.html</a><br>建造者模式(Builder) <a href="http://www.cnblogs.com/zhili/p/BuilderPattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/BuilderPattern.html</a><br>原型模式(Prototype) <a href="http://www.cnblogs.com/zhili/p/PrototypePattern.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhili/p/PrototypePattern.html</a><br>对象池模式(Object Pool)   </p>
</blockquote>
<a id="more"></a>

]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计原则]]></title>
      <url>/2019/09/03/DesignPrinciples/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简介：<a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/DesignPatternSummery.html</a><br>第一篇：<a href="https://www.cnblogs.com/shoshana-kong/p/8847893.html" target="_blank" rel="noopener">https://www.cnblogs.com/shoshana-kong/p/8847893.html</a><br>第二篇：<a href="https://www.cnblogs.com/www-zsl187-com/p/8821885.html" target="_blank" rel="noopener">https://www.cnblogs.com/www-zsl187-com/p/8821885.html</a>  </p>
</blockquote>
<p>1、开放 - 封闭原则 ( Open-Closed Principle, OCP )<br>&emsp;&emsp;通俗：对扩展开发，对修改关闭<br>&emsp;&emsp;开闭原则（Open-Closed Principle, OCP）强调的是：一个软件实体（指的类、函数、模块等）应该对扩展开放，对修改关闭。即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。<br>&emsp;&emsp;符合开闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。  </p>
<p>2、单一职责原则 ( Single Responsibility Principle )<br>&emsp;&emsp;通俗：一个类只做一件事<br>&emsp;&emsp;就一个类而言，应该只有一个引起它变化的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会影响到其他的职责，另外，把多个职责耦合在一起，也会影响复用性。  </p>
<p>3、里氏替换原则 ( Liskov Substitution Principle )<br>&emsp;&emsp;通俗：子类不能去修改父类的功能<br>&emsp;&emsp;里氏代替原则（Liskov Substitution Principle, LSP）指的是子类必须替换掉它们的父类型。也就是说，在软件开发过程中，子类替换父类后，程序的行为是一样的。只有当子类替换掉父类后，此时软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。  </p>
<p>4、迪米特法则 / 最少知识原则 ( Law Of Demeter )<br>&emsp;&emsp;通俗：高内聚，低耦合<br>&emsp;&emsp;迪米特法则（Law of Demeter，LoD）又叫最少知识原则（Least Knowledge Principle，LKP），指的是一个对象应当对其他对象有尽可能少的了解。也就是说，一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。<br>&emsp;&emsp;关于迪米特法则其他的一些表述有：只与你直接的朋友们通信；不要跟“陌生人”说话。  </p>
<p>5、依赖倒置原则 ( Dependence Inversion Principle )<br>&emsp;&emsp;通俗：类似 IOC，采用接口编程<br>&emsp;&emsp;依赖倒置（Dependence Inversion Principle, DIP）原则指的是抽象不应该依赖于细节，细节应该依赖于抽象，也就是提出的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。  </p>
<p>6、接口隔离原则 ( Interface Segregation Principle )<br>&emsp;&emsp;通俗：细节接口<br>&emsp;&emsp;接口隔离原则（Interface Segregation Principle, ISP）指的是使用多个专门的接口比使用单一的总接口要好。也就是说不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。过于臃肿的接口是对接口的一种污染。  </p>
<p>7、合成 / 聚合原则 ( Composite / Aggregate Reuse Principle, CARP )<br>&emsp;&emsp;通俗：避免使用继承<br>&emsp;&emsp;合成复用原则（Composite Reuse Principle, CRP）就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分。新对象通过向这些对象的委派达到复用已用功能的目的。简单地说，就是要尽量使用合成/聚合，尽量不要使用继承。  </p>
<a id="more"></a>

<h1 id="第一篇"><a href="#第一篇" class="headerlink" title="第一篇"></a>第一篇</h1><p>&emsp;&emsp;开放-封闭原则具有理想主义的色彩，他是面向对象设计的终极目标。其他几条则可以看做是开放-封闭原则的实现方法。设计模式就是实现了这些原则，从而达到了代码复用，增加可维护性的目的。  </p>
<h2 id="一-开放-封闭原则"><a href="#一-开放-封闭原则" class="headerlink" title="一.开放 - 封闭原则"></a>一.开放 - 封闭原则</h2><p>&emsp;&emsp;概念：一个软件实体如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。模块应该尽量在不修改原代码的情况下进行扩展。<br>　　在软件周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给代码引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需求变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有代码来实现变化。<br>　　开放封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是<strong>可维护、可扩展、可复用、灵活性好</strong>。开发人员应该仅对程序中呈现的频繁变化的那些部分作出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。<br>　　注意事项：<br>　　1. 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的 public 方法。<br>　　2. 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类<br>　　3. 抽象层尽量保持稳定，一旦确定不允许修改。  </p>
<h2 id="二-单一职责原则"><a href="#二-单一职责原则" class="headerlink" title="二.单一职责原则"></a>二.单一职责原则</h2><p>&emsp;&emsp;概念：<strong>就一个类而言，应该仅有一个引起它变化的原因</strong>。<br>　　当我们在做编程的时候，很自然地会一个一个类加上各种各样的功能。这样意味着，<strong>无论任何需求要来，你都需要更改这个类</strong>，这样其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。如果一个类承担的职责过多，就等于把这些职责耦合起来，一个职责变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到很多意想不到的破坏。  </p>
<h2 id="三-依赖倒转原则"><a href="#三-依赖倒转原则" class="headerlink" title="三.依赖倒转原则"></a>三.依赖倒转原则</h2><p>&emsp;&emsp;概念：依赖倒转原则是程序要<strong>依赖于抽象接口，不要依赖于具体实现。简单的来说就是要求对抽象进行编程，不要对实现进行编程</strong>，这样就降低了客户与实现模块的耦合。<br>　　有时候为了代码复用，一般会把常用的代码写成函数或类库。这样开发新项目的时候直接用就行了。比如做项目的时候大多要访问数据库，所以我们把访问数据库的代码写成了函数。每次做项目去调用这些函数。那么问题来了，我们要做新项目的时候，发现业务逻辑高层模块都是一样的，但客户却希望使用不同的数据库或存储方式，这时就出现了麻烦。我们希望能再次利用这些高层模块，但是高层模块都是与低层的访问数据库绑定在一起，没办法复用这些高层的模块。所以不管是高层模块和底层模块都应该依赖于抽象，具体一点就是接口或者抽象类，只要接口是稳定的，那么任何一个更改都不用担心。<br>　　注意事项：<br>　　1. 高层模块不应该依赖于低层模块。两个都应该依赖抽象。<br>　　2. 抽象不应该依赖细节。细节应依赖于抽象。  </p>
<h2 id="四-迪米特法则（也称为最少知识原则）"><a href="#四-迪米特法则（也称为最少知识原则）" class="headerlink" title="四.迪米特法则（也称为最少知识原则）"></a>四.迪米特法则（也称为最少知识原则）</h2><p>&emsp;&emsp;概念：一个软件实体应当尽可能地少与其他实体发生相互作用。每一个软件单位对其他软件单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果有真的需要建立联系的，也希望能通过他的友元类来转达。因此，应用迪米特法则有可能造成一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互关系，这在一定程度上增加了系统的复杂度。  </p>
<h2 id="五-接口隔离原则"><a href="#五-接口隔离原则" class="headerlink" title="五.接口隔离原则"></a>五.接口隔离原则</h2><p>&emsp;&emsp;概念：客户端不应该依赖他不需要的接口，类间的依赖关系应建立在最小的接口上。<br>　　接口隔离原则的核心定义，<strong>不出现臃肿的接口</strong>，但是“小”是有限度的，首先就是不能违反单一职责原则。  </p>
<h2 id="六-合成-聚合复用原则"><a href="#六-合成-聚合复用原则" class="headerlink" title="六.合成 / 聚合复用原则"></a>六.合成 / 聚合复用原则</h2><p>&emsp;&emsp;概念：合成 / 聚合复用原则经常又叫做合成复用原则，就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过这些对象的委派达到复用已有功能的目的。他的设计原则是：<strong>要尽量使用合成 / 聚合，尽量不要使用继承</strong>。  </p>
<h2 id="七-里氏代换原则"><a href="#七-里氏代换原则" class="headerlink" title="七.里氏代换原则"></a>七.里氏代换原则</h2><p>&emsp;&emsp;概念：里氏代换原则是面向对象设计的基本原则之一。即任何基类可以出现的地方，子类一定可以出现。里氏代换原则是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能被真正复用，而衍生类也能够在积累的基础上增加新的行为，里氏代换原则是对 “ 开 - 闭 ” 原则的补充。实现 “ 开 - 闭 ” 原则的关键步骤就是抽象化。在基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<br>　　当满足继承的时候，父类肯定存在非私有的成员，子类肯定是得到了父类的这些非私有成员（假设，父类的成员全部是私有的，那么子类没办法从父类继承任何成员，也就不存在继承的额概念了）。既然子类继承了父类的这些非私有成员，那么父类对象也就可以在子类对象中调用这些非私有成员。所以，子类对象可以替换父类对象的位置。<br>　　在里氏代换原则下，<strong>当需求有变化时，只需继承，而别的东西不会改变</strong>。由于里氏代换原则才使得开放封闭称为可能。这样使得子类在父类无需修改就可以扩展。  </p>
<h1 id="第二篇"><a href="#第二篇" class="headerlink" title="第二篇"></a>第二篇</h1><h2 id="1-开闭原则-Open-Closed-Principle-OCP"><a href="#1-开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="1. 开闭原则(Open-Closed Principle, OCP)"></a>1. 开闭原则(Open-Closed Principle, OCP)</h2><p>&emsp;&emsp;<strong>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：软件实体如同你租住的房子一般，你可以向里面添加东西，但是却很难修改这个房间。<strong>扩展开放</strong>就相当于你向租住的房子里放置家具，充实这个房子的功能。<strong>修改关闭</strong>就好比是房子的已经存在的物件，道理上你是没有这个改变他们的能力，实际是你在付出代价之后可以更改。<strong>但</strong>绝对的修改关闭是不可能的。就好比如水龙头、下水管道、灯泡等这些房子存在的基本物件损坏一样，不可避免的，所以需要提前做好准备避免。而在软件中避免就是<strong>创建抽象来隔离以后发生同类的变化</strong>。<br>&emsp;&emsp;<strong>开放-封闭原则，可以保证以前代码的正确性，因为没有修改以前代码，所以可以保证开发人员专注于将设计放在新扩展的代码上。</strong><br>&emsp;&emsp;简单的用一句经典的话来说：过去的事已成历史，是不可修改的，因为时光不可倒流，但现在或明天计划做什么，是可以自己决定（即扩展）的。  </p>
<h2 id="2-单一职责原则（Single-Responsibility-Principle）"><a href="#2-单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="2. 单一职责原则（Single Responsibility Principle）"></a>2. 单一职责原则（Single Responsibility Principle）</h2><p>&emsp;&emsp;<strong>定义：即一个类只负责一项职责，应该仅有一个引起它变化的原因。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：你有一个带茶漏的茶杯（即类）用来喝茶和喝水（即两种职责）。有一天你想将奶茶倒入这个茶杯，但由于奶茶有珍珠，茶杯有茶漏，为了将珍珠也放入茶杯中，你将茶漏取出（改变了茶杯的功能），此时的茶杯就不能用来喝茶，所以该茶杯的职责也就被改变。为了避免这种改变你准备了茶杯和水杯，喝茶就用茶杯，喝水就用水杯。这就符合单一职责原则，一个类（杯子）只负责一种职责（喝茶或者喝水）。  </p>
<p>&emsp;&emsp;<strong>单一职责的优点</strong>：  </p>
<ol>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；  </li>
<li>提高类的可读性，提高系统的可维护性；  </li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。  </li>
</ol>
<p>&emsp;&emsp;<strong>需要说明的一点</strong>是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。  </p>
<h2 id="3-里氏替换原则（Liskov-Substitution-Principle）"><a href="#3-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="3. 里氏替换原则（Liskov Substitution Principle）"></a>3. 里氏替换原则（Liskov Substitution Principle）</h2><p>&emsp;&emsp;<strong>定义：子类型必须能够替换掉它们的父类型。</strong><br>&emsp;&emsp;<strong>个人解释</strong>：如果父类型是鸟，子类型是企鹅，在生物学中企鹅归属于鸟，但是企鹅不会飞，在编程的世界中，企鹅就无法归属于鸟，即企鹅不能继承鸟类。<br>&emsp;&emsp;只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>&emsp;&emsp;正是有里氏代换原则，使得继承复用成为了可能。<strong>正是由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展，不然还谈什么扩展开放，修改关闭呢？</strong><br>&emsp;&emsp;<strong>里氏替换原则通俗的来讲就是</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。  </p>
<p>&emsp;&emsp;<strong>它包含以下4层含义：</strong>  </p>
<ol>
<li><strong>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</strong>  </li>
<li><strong>子类中可以增加自己特有的方法。</strong>  </li>
<li><strong>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</strong>  </li>
<li><strong>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</strong>  </li>
</ol>
<h2 id="4-迪米特法则（Law-Of-Demeter）"><a href="#4-迪米特法则（Law-Of-Demeter）" class="headerlink" title="4. 迪米特法则（Law Of Demeter）"></a>4. 迪米特法则（Law Of Demeter）</h2><p>&emsp;&emsp;<strong>定义：迪米特法则又叫最少知道原则，即一个对象应该对其他对象保持最少的了解。</strong><br>&emsp;&emsp;<strong>解释</strong>：迪米特法则其根本思想是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说信息的隐藏促进了软件的复用。<br>&emsp;&emsp;软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。而迪米特法则就是解决低耦合的方法。<br>&emsp;&emsp;<strong>个人解释</strong>：迪米特法则有个简单的方法叫做：只与直接的朋友通信。朋友关系在编程中就是耦合关系，耦合的方式就像现实世界中交朋友一样有多种，例如：依赖，关联，组合，聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。  </p>
<h2 id="5-依赖倒置原则（Dependence-Inversion-Principle）"><a href="#5-依赖倒置原则（Dependence-Inversion-Principle）" class="headerlink" title="5. 依赖倒置原则（Dependence Inversion Principle）"></a>5. 依赖倒置原则（Dependence Inversion Principle）</h2><p>&emsp;&emsp;<strong>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。中心思想是面向接口编程。</strong>  </p>
<p>&emsp;&emsp;在实际编程中，我们一般需要做到如下3点：  </p>
<ol>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。  </li>
<li>变量的声明类型尽量是抽象类或接口。  </li>
<li>使用继承时遵循里氏替换原则。  </li>
</ol>
<p>&emsp;&emsp;<strong>依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</strong>  </p>
<h2 id="6-接口隔离原则（Interface-Segregation-Principle）"><a href="#6-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="6. 接口隔离原则（Interface Segregation Principle）"></a>6. 接口隔离原则（Interface Segregation Principle）</h2><p>&emsp;&emsp;<strong>定义：我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</strong><br>&emsp;&emsp;<strong>解释</strong>：在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。就好比术业有专攻一样。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。  </p>
<p>&emsp;&emsp;采用接口隔离原则对接口进行约束时，要注意以下几点：  </p>
<ol>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。  </li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。  </li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。  </li>
</ol>
<p>&emsp;&emsp;<strong>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</strong>  </p>
<h2 id="7-合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#7-合成-聚合原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="7. 合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)"></a>7. 合成/聚合原则(Composite/Aggregate Reuse Principle,CARP)</h2><p>&emsp;&emsp;<strong>定义：尽量的使用合成和聚合，而不是继承关系达到复用的目的。换句话说，就是能用合成/聚合的地方，绝不用继承。</strong>  </p>
<p>&emsp;&emsp;<strong>为什么要尽量使用合成/聚合而不使用类继承？</strong>  </p>
<ol>
<li>对象的继承关系在编译时就定义好了，所以无法在运行时改变从父类继承的子类的实现  </li>
<li>子类的实现和它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化  </li>
<li>当你复用子类的时候，如果继承下来的实现不适合解决新的问题，则父类必须重写或者被其它更适合的类所替换，这种依赖关系限制了灵活性，并最终限制了复用性。  </li>
</ol>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>/2019/08/30/DesignPatterns/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简介：<a href="https://www.cnblogs.com/www-zsl187-com/p/8834734.html" target="_blank" rel="noopener">https://www.cnblogs.com/www-zsl187-com/p/8834734.html</a><br>正文：<a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhili/p/DesignPatternSummery.html</a>  </p>
</blockquote>
<p>一、创建型模式<br>1、抽象工厂模式(Abstract factory pattern): 提供一个接口, 用于创建相关或依赖对象的家族, 而不需要指定具体类.<br>2、生成器模式(Builder pattern): 使用生成器模式封装一个产品的构造过程, 并允许按步骤构造. 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示.<br>3、工厂模式(factory method pattern): 定义了一个创建对象的接口, 但由子类决定要实例化的类是哪一个. 工厂方法让类把实例化推迟到子类.<br>4、原型模式(prototype pattern): 当创建给定类的实例过程很昂贵或很复杂时, 就使用原型模式.<br>5、单例模式(Singleton pattern): 确保一个类只有一个实例, 并提供全局访问点.<br>6、多例模式(Multition pattern): 在一个解决方案中结合两个或多个模式, 以解决一般或重复发生的问题.<br>二、结构型模式<br>1、适配器模式(Adapter pattern): 将一个类的接口, 转换成客户期望的另一个接口. 适配器让原本接口不兼容的类可以合作无间. 对象适配器使用组合, 类适配器使用多重继承.<br>2、桥接模式(Bridge pattern): 使用桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变.<br>3、组合模式(composite pattern): 允许你将对象组合成树形结构来表现”整体/部分”层次结构. 组合能让客户以一致的方式处理个别对象以及对象组合.<br>4、装饰者模式(decorator pattern): 动态地将责任附加到对象上, 若要扩展功能, 装饰者提供了比继承更有弹性的替代方案.<br>5、外观模式(facade pattern): 提供了一个统一的接口, 用来访问子系统中的一群接口. 外观定义了一个高层接口, 让子系统更容易使用.<br>6、亨元模式(Flyweight Pattern): 如想让某个类的一个实例能用来提供许多”虚拟实例”, 就使用蝇量模式.<br>7、代理模式(Proxy pattern): 为另一个对象提供一个替身或占位符以控制对这个对象的访问.<br>三、行为型模式<br>1、责任链模式(Chain of responsibility pattern): 通过责任链模式, 你可以为某个请求创建一个对象链. 每个对象依序检查此请求并对其进行处理或者将它传给链中的下一个对象.<br>2、命令模式(Command pattern): 将”请求”封闭成对象, 以便使用不同的请求,队列或者日志来参数化其他对象. 命令模式也支持可撤销的操作.<br>3、解释器模式(Interpreter pattern): 使用解释器模式为语言创建解释器.<br>4、迭代器模式(iterator pattern): 提供一种方法顺序访问一个聚合对象中的各个元素, 而又不暴露其内部的表示.<br>5、中介者模式(Mediator pattern) : 使用中介者模式来集中相关对象之间复杂的沟通和控制方式.<br>6、备忘录模式(Memento pattern): 当你需要让对象返回之前的状态时(例如, 你的用户请求”撤销”), 你使用备忘录模式.<br>7、观察者模式(observer pattern): 在对象之间定义一对多的依赖, 这样一来, 当一个对象改变状态, 依赖它的对象都会收到通知, 并自动更新.<br>8、状态模式(State pattern): 允许对象在内部状态改变时改变它的行为, 对象看起来好象改了它的类.<br>9、策略模式(strategy pattern): 定义了算法族, 分别封闭起来, 让它们之间可以互相替换, 此模式让算法的变化独立于使用算法的客户.<br>10、模板方法模式(Template pattern): 在一个方法中定义一个算法的骨架, 而将一些步骤延迟到子类中. 模板方法使得子类可以在不改变算法结构的情况下, 重新定义算法中的某些步骤.<br>11、访问者模式(visitor pattern): 当你想要为一个对象的组合增加新的能力, 且封装并不重要时, 就使用访问者模式.  </p>
<a id="more"></a>

<h1 id="一、创建型模式"><a href="#一、创建型模式" class="headerlink" title="一、创建型模式"></a>一、创建型模式</h1><p>&emsp;&emsp;创建型模式就是用来创建对象的模式，抽象了实例化的过程。所有的创建型模式都有两个共同点。第一，它们都将系统使用哪些具体类的信息封装起来；第二，它们隐藏了这些类的实例是如何被创建和组织的。创建型模式包括单例模式、工厂方法模式、抽象工厂模式、建造者模式和原型模式。  </p>
<ul>
<li>单例模式：解决的是实例化对象的个数的问题，比如抽象工厂中的工厂、对象池等，除了Singleton之外，其他创建型模式解决的都是 new 所带来的耦合关系。  </li>
<li>抽象工厂：创建一系列相互依赖对象，并能在运行时改变系列。  </li>
<li>工厂方法：创建单个对象，在Abstract Factory有使用到。  </li>
<li>原型模式：通过拷贝原型来创建新的对象。  </li>
</ul>
<p>&emsp;&emsp;工厂方法、抽象工厂、建造者都需要一个额外的工厂类来负责实例化“一个对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。<br>&emsp;&emsp;下面详细介绍下它们。  </p>
<h2 id="1-1-单例模式"><a href="#1-1-单例模式" class="headerlink" title="1.1  单例模式"></a>1.1  单例模式</h2><p>&emsp;&emsp;单例模式指的是确保某一个类只有一个实例，并提供一个全局访问点。解决的是实体对象个数的问题，而其他的建造者模式都是解决new所带来的耦合关系问题。其实现要点有：  </p>
<ul>
<li>类只有一个实例。问：如何保证呢？答：通过私有构造函数来保证类外部不能对类进行实例化  </li>
<li>提供一个全局的访问点。问：如何实现呢？答：创建一个返回该类对象的静态方法  </li>
</ul>
<p>&emsp;&emsp;单例模式的结构图如下所示：  </p>
<p><img src="%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="1-2-工厂方法模式"><a href="#1-2-工厂方法模式" class="headerlink" title="1.2 工厂方法模式"></a>1.2 工厂方法模式</h2><p>&emsp;&emsp;工厂方法模式指的是定义一个创建对象的工厂接口，由其子类决定要实例化的类，将实际创建工作推迟到子类中。它强调的是”单个对象“的变化。其实现要点有：  </p>
<ul>
<li>定义一个工厂接口。问：如何实现呢？答：声明一个工厂抽象类  </li>
<li>由其具体子类创建对象。问：如何去实现呢？答：创建派生于工厂抽象类，即由具体工厂去创建具体产品，既然要创建产品，自然需要产品抽象类和具体产品类了。  </li>
</ul>
<p>&emsp;&emsp;其具体的UML结构图如下所示：  </p>
<p><img src="%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<p>&emsp;&emsp;在工厂方法模式中，工厂类与具体产品类具有平行的等级结构，它们之间是一一对应关系。  </p>
<h2 id="1-3-抽象工厂模式"><a href="#1-3-抽象工厂模式" class="headerlink" title="1.3 抽象工厂模式"></a>1.3 抽象工厂模式</h2><p>&emsp;&emsp;抽象工厂模式指的是提供一个创建一系列相关或相互依赖对象的接口，使得客户端可以在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象，强调的是”系列对象“的变化。其实现要点有：  </p>
<ul>
<li>提供一系列对象的接口。问：如何去实现呢？答：提供多个产品的抽象接口  </li>
<li>创建多个产品族中的多个产品对象。问：如何做到呢？答：每个具体工厂创建一个产品族中的多个产品对象，多个具体工厂就可以创建多个产品族中的多个对象了。  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="1-4-建造者模式"><a href="#1-4-建造者模式" class="headerlink" title="1.4 建造者模式"></a>1.4 建造者模式</h2><p>&emsp;&emsp;建造者模式指的是将一个产品的内部表示与产品的构造过程分割开来，从而可以使一个建造过程生成具体不同的内部表示的产品对象。强调的是产品的构造过程。其实现要点有：  </p>
<ul>
<li>将产品的内部表示与产品的构造过程分割开来。问：如何把它们分割开呢？答：不要把产品的构造过程放在产品类中，而是由建造者类来负责构造过程，产品的内部表示放在产品类中，这样不就分割开了嘛。  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="1-5-原型工厂模式"><a href="#1-5-原型工厂模式" class="headerlink" title="1.5 原型工厂模式"></a>1.5 原型工厂模式</h2><p>&emsp;&emsp;原型模式指的是通过给出一个原型对象来指明所要创建的对象类型，然后用复制的方法来创建出更多的同类型对象。其实现要点有：  </p>
<ul>
<li>给出一个原型对象。问：如何办到呢？答：很简单嘛，直接给出一个原型类就好了。  </li>
<li>通过复制的方法来创建同类型对象。问：又是如何实现呢？答：.NET可以直接调用MemberwiseClone方法来实现浅拷贝  </li>
</ul>
<p>&emsp;&emsp;具体的UML结构图如下所示：  </p>
<p><img src="%E5%8E%9F%E5%9E%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h1 id="二、结构型模式"><a href="#二、结构型模式" class="headerlink" title="二、结构型模式"></a>二、结构型模式</h1><p>&emsp;&emsp;结构型模式，顾名思义讨论的是类和对象的结构 ，主要用来处理类或对象的组合。它包括两种类型，一是类结构型模式，指的是采用继承机制来组合接口或实现；二是对象结构型模式，指的是通过组合对象的方式来实现新的功能。它包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。  </p>
<ul>
<li>适配器模式注重转换接口，将不吻合的接口适配对接   </li>
<li>桥接模式注重分离接口与其实现，支持多维度变化   </li>
<li>组合模式注重统一接口，将“一对多”的关系转化为“一对一”的关系   </li>
<li>装饰者模式注重稳定接口，在此前提下为对象扩展功能   </li>
<li>外观模式注重简化接口，简化组件系统与外部客户程序的依赖关系   </li>
<li>享元模式注重保留接口，在内部使用共享技术对对象存储进行优化   </li>
<li>代理模式注重假借接口，增加间接层来实现灵活控制  </li>
</ul>
<h2 id="2-1-适配器模式"><a href="#2-1-适配器模式" class="headerlink" title="2.1 适配器模式"></a>2.1 适配器模式</h2><p>&emsp;&emsp;适配器模式意在转换接口，它能够使原本不能在一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如DataAdapter类就应用了适配器模式。适配器模式包括类适配器模式和对象适配器模式，具体结构如下图所示，左边是类适配器模式，右边是对象适配器模式。  </p>
<p><img src="%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.jpg" alt=" "></p>
<h2 id="2-2-桥接模式"><a href="#2-2-桥接模式" class="headerlink" title="2.2 桥接模式"></a>2.2 桥接模式</h2><p>&emsp;&emsp;桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化，桥接模式的结构图如下所示。  </p>
<p><img src="%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-3-装饰者模式"><a href="#2-3-装饰者模式" class="headerlink" title="2.3 装饰者模式"></a>2.3 装饰者模式</h2><p>&emsp;&emsp;装饰者模式又称包装（Wrapper）模式，它可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。具体的结构图如下所示。  </p>
<p><img src="%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="2-4-组合模式"><a href="#2-4-组合模式" class="headerlink" title="2.4 组合模式"></a>2.4 组合模式</h2><p>&emsp;&emsp;组合模式又称为部分—整体模式。组合模式将对象组合成树形结构，用来表示整体与部分的关系。组合模式使得客户端将单个对象和组合对象同等对待。如在.NET中WinForm中的控件，TextBox、Label等简单控件继承与Control类，同时GroupBox这样的组合控件也是继承于Control类。组合模式的具体结构图如下所示。  </p>
<p><img src="%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-5-外观模式"><a href="#2-5-外观模式" class="headerlink" title="2.5 外观模式"></a>2.5 外观模式</h2><p>&emsp;&emsp;在系统中，客户端经常需要与多个子系统进行交互，这样导致客户端会随着子系统的变化而变化，此时可以使用外观模式把客户端与各个子系统解耦。外观模式指的是为子系统中的一组接口提供一个一致的门面，它提供了一个高层接口，这个接口使子系统更加容易使用。如电信的客户专员，你可以让客户专员来完成冲话费，修改套餐等业务，而不需要自己去与各个子系统进行交互。具体类结构图如下所示：  </p>
<p><img src="%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-6-享元模式"><a href="#2-6-享元模式" class="headerlink" title="2.6 享元模式"></a>2.6 享元模式</h2><p>&emsp;&emsp;在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。<br>&emsp;&emsp;享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，String类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。更多内容参考博文：<a href="http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html" target="_blank" rel="noopener">http://www.cnblogs.com/artech/archive/2010/11/25/internedstring.html</a> 。享元模式的具体结构图如下所示。  </p>
<p><img src="%E4%BA%A8%E5%85%83%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="2-7-代理模式"><a href="#2-7-代理模式" class="headerlink" title="2.7 代理模式"></a>2.7 代理模式</h2><p>&emsp;&emsp;在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。<br>&emsp;&emsp;代理模式指的是给某一个对象提供一个代理，并由代理对象控制对原对象的访问。具体的结构图如下所示。  </p>
<p><img src="%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<p>&emsp;&emsp;注：外观模式、适配器模式和代理模式区别？<br>&emsp;&emsp;解答：这三个模式的相同之处是，它们都是作为客户端与真实被使用的类或系统之间的一个中间层，起到让客户端间接调用真实类的作用，不同之处在于，所应用的场合和意图不同。<br>&emsp;&emsp;代理模式与外观模式主要区别在于，代理对象无法直接访问对象，只能由代理对象提供访问，而外观对象提供对各个子系统简化访问调用接口，而适配器模式则不需要虚构一个代理者，目的是复用原有的接口。外观模式是定义新的接口，而适配器则是复用一个原有的接口。<br>&emsp;&emsp;另外，它们应用设计的不同阶段，外观模式用于设计的前期，因为系统需要前期就需要依赖于外观，而适配器应用于设计完成之后，当发现设计完成的类无法协同工作时，可以采用适配器模式。然而很多情况下在设计初期就要考虑适配器模式的使用，如涉及到大量第三方应用接口的情况；代理模式是模式完成后，想以服务的方式提供给其他客户端进行调用，此时其他客户端可以使用代理模式来对模块进行访问。<br>&emsp;&emsp;总之，代理模式提供与真实类一致的接口，旨在用来代理类来访问真实的类，外观模式旨在简化接口，适配器模式旨在转换接口。  </p>
<h1 id="三、行为型模式"><a href="#三、行为型模式" class="headerlink" title="三、行为型模式"></a>三、行为型模式</h1><p>&emsp;&emsp;行为型模式是对在不同对象之间划分责任和算法的抽象化。行为模式不仅仅关于类和对象，还关于它们之间的相互作用。行为型模式又分为类的行为模式和对象的行为模式两种。  </p>
<ul>
<li>类的行为模式——使用继承关系在几个类之间分配行为。  </li>
<li>对象的行为模式——使用对象聚合的方式来分配行为。  </li>
</ul>
<p>&emsp;&emsp;行为型模式包括11种模式：模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、状态模式、策略模式、责任链模式、访问者模式、解释器模式和备忘录模式。  </p>
<ul>
<li>模板方法模式：封装算法结构，定义算法骨架，支持算法子步骤变化。  </li>
<li>命令模式：注重将请求封装为对象，支持请求的变化，通过将一组行为抽象为对象，实现行为请求者和行为实现者之间的解耦。  </li>
<li>迭代器模式：注重封装特定领域变化，支持集合的变化，屏蔽集合对象内部复杂结构，提供客户程序对它的透明遍历。  </li>
<li>观察者模式：注重封装对象通知，支持通信对象的变化，实现对象状态改变，通知依赖它的对象并更新。  </li>
<li>中介者模式：注重封装对象间的交互，通过封装一系列对象之间的复杂交互，使他们不需要显式相互引用，实现解耦。  </li>
<li>状态模式：注重封装与状态相关的行为，支持状态的变化，通过封装对象状态，从而在其内部状态改变时改变它的行为。  </li>
<li>策略模式：注重封装算法，支持算法的变化，通过封装一系列算法，从而可以随时独立于客户替换算法。  </li>
<li>责任链模式：注重封装对象责任，支持责任的变化，通过动态构建职责链，实现事务处理。  </li>
<li>访问者模式：注重封装对象操作变化，支持在运行时为类结构添加新的操作，在类层次结构中，在不改变各类的前提下定义作用于这些类实例的新的操作。  </li>
<li>备忘录模式：注重封装对象状态变化，支持状态保存、恢复。  </li>
<li>解释器模式：注重封装特定领域变化，支持领域问题的频繁变化，将特定领域的问题表达为某种语法规则下的句子，然后构建一个解释器来解释这样的句子，从而达到解决问题的目的。  </li>
</ul>
<h2 id="3-1-模板方法模式"><a href="#3-1-模板方法模式" class="headerlink" title="3.1 模板方法模式"></a>3.1 模板方法模式</h2><p>&emsp;&emsp;在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。<br>&emsp;&emsp;模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。具体的结构图如下所示（以生活中做菜为例子实现的模板方法结构图）。  </p>
<p><img src="%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="以生活中做菜为例子实现的模板方法结构图"></p>
<h2 id="3-2-命令模式"><a href="#3-2-命令模式" class="headerlink" title="3.2 命令模式"></a>3.2 命令模式</h2><p>&emsp;&emsp;命令模式属于对象的行为模式，命令模式把一个请求或操作封装到一个对象中，通过对命令的抽象化来使得发出命令的责任和执行命令的责任分隔开。命令模式的实现可以提供命令的撤销和恢复功能。具体的结构图如下所示。  </p>
<p><img src="%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.gif" alt=" "></p>
<h2 id="3-3-迭代器模式"><a href="#3-3-迭代器模式" class="headerlink" title="3.3 迭代器模式"></a>3.3 迭代器模式</h2><p>&emsp;&emsp;迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。<br>&emsp;&emsp;迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。具体的结构图如下所示。  </p>
<p><img src="%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-4-观察者模式"><a href="#3-4-观察者模式" class="headerlink" title="3.4 观察者模式"></a>3.4 观察者模式</h2><p>&emsp;&emsp;在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。<br>&emsp;&emsp;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。具体结构图如下所示：  </p>
<p><img src="%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-5-中介者模式"><a href="#3-5-中介者模式" class="headerlink" title="3.5 中介者模式"></a>3.5 中介者模式</h2><p>&emsp;&emsp;在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。<br>&emsp;&emsp;中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。具体的结构图如下所示：  </p>
<p><img src="%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-6-状态模式"><a href="#3-6-状态模式" class="headerlink" title="3.6 状态模式"></a>3.6 状态模式</h2><p>&emsp;&emsp;每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。<br>&emsp;&emsp;状态模式——允许一个对象在其内部状态改变时自动改变其行为，对象看起来就像是改变了它的类。具体的结构图如下所示：  </p>
<p><img src="%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-7-策略模式"><a href="#3-7-策略模式" class="headerlink" title="3.7 策略模式"></a>3.7 策略模式</h2><p>&emsp;&emsp;在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的CalculateTax()方法，在该方法体内需要对税收类型进行判断，通过if-else语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改CalculateTax方法来多添加一个判断语句，这样明白违背了“开放——封闭”原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。<br>&emsp;&emsp;策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。下面是策略模式的结构图：  </p>
<p><img src="%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt=" ">
　　</p>
<h2 id="3-8-责任链模式"><a href="#3-8-责任链模式" class="headerlink" title="3.8 责任链模式"></a>3.8 责任链模式</h2><p>&emsp;&emsp;在现实生活中，有很多请求并不是一个人说了就算的，例如面试时的工资，低于1万的薪水可能技术经理就可以决定了，但是1万~1万5的薪水可能技术经理就没这个权利批准，可能需要请求技术总监的批准。<br>&emsp;&emsp;责任链模式——某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。具体结构图如下所示：  </p>
<p><img src="%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-9-访问者模式"><a href="#3-9-访问者模式" class="headerlink" title="3.9 访问者模式"></a>3.9 访问者模式</h2><p>&emsp;&emsp;访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。具体结构图如下所示：  </p>
<p><img src="%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-10-备忘录模式"><a href="#3-10-备忘录模式" class="headerlink" title="3.10 备忘录模式"></a>3.10 备忘录模式</h2><p>&emsp;&emsp;生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。具体的结构图如下所示：  </p>
<p><img src="%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
<h2 id="3-11-解释器模式"><a href="#3-11-解释器模式" class="headerlink" title="3.11 解释器模式"></a>3.11 解释器模式</h2><p>&emsp;&emsp;解释器模式是一个比较少用的模式，所以我自己也没有对该模式进行深入研究，在生活中，英汉词典的作用就是实现英文和中文互译，这就是解释器模式的应用。<br>&emsp;&emsp;解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。具体的结构图如下所示：  </p>
<p><img src="%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt=" "></p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[More Effective C# 书目录]]></title>
      <url>/2019/08/30/MoreEffectiveCSharpContents/</url>
      <content type="html"><![CDATA[<blockquote>
<p>书名：More Effective C# : 改善 C# 代码的 50 个有效方法（原书第 2 版）<br>作者：[ 美 ] 比尔·瓦格纳 ( Bill Wagner )<br>译者：爱飞翔<br>出版：机械工业出版社  </p>
</blockquote>
<p>适用于 <strong>C# 7.0</strong></p>
<a id="more"></a>

<hr>
<h2 id="第1章-处理各种类型的数据"><a href="#第1章-处理各种类型的数据" class="headerlink" title="第1章 处理各种类型的数据"></a>第1章 处理各种类型的数据</h2><h3 id="第1条：使用属性而不是可直接访问的数据成员"><a href="#第1条：使用属性而不是可直接访问的数据成员" class="headerlink" title="第1条：使用属性而不是可直接访问的数据成员"></a>第1条：使用属性而不是可直接访问的数据成员</h3><h3 id="第2条：尽量采用隐式属性来表示可变的数据"><a href="#第2条：尽量采用隐式属性来表示可变的数据" class="headerlink" title="第2条：尽量采用隐式属性来表示可变的数据"></a>第2条：尽量采用隐式属性来表示可变的数据</h3><h3 id="第3条：尽量把值类型设计成不可变的类型"><a href="#第3条：尽量把值类型设计成不可变的类型" class="headerlink" title="第3条：尽量把值类型设计成不可变的类型"></a>第3条：尽量把值类型设计成不可变的类型</h3><h3 id="第4条：注意值类型与引用类型之间的区别"><a href="#第4条：注意值类型与引用类型之间的区别" class="headerlink" title="第4条：注意值类型与引用类型之间的区别"></a>第4条：注意值类型与引用类型之间的区别</h3><h3 id="第5条：确保-0-可以当成值类型的有效状态使用"><a href="#第5条：确保-0-可以当成值类型的有效状态使用" class="headerlink" title="第5条：确保 0 可以当成值类型的有效状态使用"></a>第5条：确保 0 可以当成值类型的有效状态使用</h3><h3 id="第6条：确保属性能够像数据那样运用"><a href="#第6条：确保属性能够像数据那样运用" class="headerlink" title="第6条：确保属性能够像数据那样运用"></a>第6条：确保属性能够像数据那样运用</h3><h3 id="第7条：用元组来限制类型的作用范围"><a href="#第7条：用元组来限制类型的作用范围" class="headerlink" title="第7条：用元组来限制类型的作用范围"></a>第7条：用元组来限制类型的作用范围</h3><h3 id="第8条：在匿名类型中定义局部函数"><a href="#第8条：在匿名类型中定义局部函数" class="headerlink" title="第8条：在匿名类型中定义局部函数"></a>第8条：在匿名类型中定义局部函数</h3><h3 id="第9条：理解相等的不同概念及它们之间的关系"><a href="#第9条：理解相等的不同概念及它们之间的关系" class="headerlink" title="第9条：理解相等的不同概念及它们之间的关系"></a>第9条：理解相等的不同概念及它们之间的关系</h3><h3 id="第10条：留意-GetHashCode-方法的使用陷阱"><a href="#第10条：留意-GetHashCode-方法的使用陷阱" class="headerlink" title="第10条：留意 GetHashCode() 方法的使用陷阱"></a>第10条：留意 GetHashCode() 方法的使用陷阱</h3><hr>
<h2 id="第2章-API-设计"><a href="#第2章-API-设计" class="headerlink" title="第2章 API 设计"></a>第2章 API 设计</h2><h3 id="第11条：不要在-API-中提供转换运算符"><a href="#第11条：不要在-API-中提供转换运算符" class="headerlink" title="第11条：不要在 API 中提供转换运算符"></a>第11条：不要在 API 中提供转换运算符</h3><h3 id="第12条：尽量用可选参数来取代方法重载"><a href="#第12条：尽量用可选参数来取代方法重载" class="headerlink" title="第12条：尽量用可选参数来取代方法重载"></a>第12条：尽量用可选参数来取代方法重载</h3><h3 id="第13条：尽量缩减类型的可见范围"><a href="#第13条：尽量缩减类型的可见范围" class="headerlink" title="第13条：尽量缩减类型的可见范围"></a>第13条：尽量缩减类型的可见范围</h3><h3 id="第14条：优先考虑定义并实现接口，而不是继承"><a href="#第14条：优先考虑定义并实现接口，而不是继承" class="headerlink" title="第14条：优先考虑定义并实现接口，而不是继承"></a>第14条：优先考虑定义并实现接口，而不是继承</h3><h3 id="第15条：理解接口方法与虚方法之间的区别"><a href="#第15条：理解接口方法与虚方法之间的区别" class="headerlink" title="第15条：理解接口方法与虚方法之间的区别"></a>第15条：理解接口方法与虚方法之间的区别</h3><h3 id="第16条：用-Event-模式来实现通知功能"><a href="#第16条：用-Event-模式来实现通知功能" class="headerlink" title="第16条：用 Event 模式来实现通知功能"></a>第16条：用 Event 模式来实现通知功能</h3><h3 id="第17条：不要把类的内部对象通过引用返回给外界"><a href="#第17条：不要把类的内部对象通过引用返回给外界" class="headerlink" title="第17条：不要把类的内部对象通过引用返回给外界"></a>第17条：不要把类的内部对象通过引用返回给外界</h3><h3 id="第18条：优先考虑重写相关的方法，而不是创建事件处理程序"><a href="#第18条：优先考虑重写相关的方法，而不是创建事件处理程序" class="headerlink" title="第18条：优先考虑重写相关的方法，而不是创建事件处理程序"></a>第18条：优先考虑重写相关的方法，而不是创建事件处理程序</h3><h3 id="第19条：不要重载基类中定义的方法"><a href="#第19条：不要重载基类中定义的方法" class="headerlink" title="第19条：不要重载基类中定义的方法"></a>第19条：不要重载基类中定义的方法</h3><h3 id="第20条：了解事件机制为何会提升对象在运行期的耦合程度"><a href="#第20条：了解事件机制为何会提升对象在运行期的耦合程度" class="headerlink" title="第20条：了解事件机制为何会提升对象在运行期的耦合程度"></a>第20条：了解事件机制为何会提升对象在运行期的耦合程度</h3><h3 id="第21条：不要把事件声明成-virtual"><a href="#第21条：不要把事件声明成-virtual" class="headerlink" title="第21条：不要把事件声明成 virtual"></a>第21条：不要把事件声明成 virtual</h3><h3 id="第22条：尽量把重载方法创建得清晰、简洁而完备"><a href="#第22条：尽量把重载方法创建得清晰、简洁而完备" class="headerlink" title="第22条：尽量把重载方法创建得清晰、简洁而完备"></a>第22条：尽量把重载方法创建得清晰、简洁而完备</h3><h3 id="第23条：让-partial-类的构造函数、mutator-方法和事件处理程序调用适当的-partial-方法"><a href="#第23条：让-partial-类的构造函数、mutator-方法和事件处理程序调用适当的-partial-方法" class="headerlink" title="第23条：让 partial 类的构造函数、mutator 方法和事件处理程序调用适当的 partial 方法"></a>第23条：让 partial 类的构造函数、mutator 方法和事件处理程序调用适当的 partial 方法</h3><h3 id="第24条：尽量不要实现-ICloneable-接口，以便留出更多的设计空间"><a href="#第24条：尽量不要实现-ICloneable-接口，以便留出更多的设计空间" class="headerlink" title="第24条：尽量不要实现 ICloneable 接口，以便留出更多的设计空间"></a>第24条：尽量不要实现 ICloneable 接口，以便留出更多的设计空间</h3><h3 id="第25条：数组类型的参数应该用-params-加以修饰"><a href="#第25条：数组类型的参数应该用-params-加以修饰" class="headerlink" title="第25条：数组类型的参数应该用 params 加以修饰"></a>第25条：数组类型的参数应该用 params 加以修饰</h3><h3 id="第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错"><a href="#第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错" class="headerlink" title="第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错"></a>第26条：在迭代器与异步方法中定义局部函数，以便尽早地报错</h3><hr>
<h2 id="第3章-基于任务的异步编程"><a href="#第3章-基于任务的异步编程" class="headerlink" title="第3章 基于任务的异步编程"></a>第3章 基于任务的异步编程</h2><h3 id="第27条：使用异步方法执行异步工作"><a href="#第27条：使用异步方法执行异步工作" class="headerlink" title="第27条：使用异步方法执行异步工作"></a>第27条：使用异步方法执行异步工作</h3><h3 id="第28条：不要编写返回值类型为-void-的异步方法"><a href="#第28条：不要编写返回值类型为-void-的异步方法" class="headerlink" title="第28条：不要编写返回值类型为 void 的异步方法"></a>第28条：不要编写返回值类型为 void 的异步方法</h3><h3 id="第29条：不要把同步方法与异步方法组合起来使用"><a href="#第29条：不要把同步方法与异步方法组合起来使用" class="headerlink" title="第29条：不要把同步方法与异步方法组合起来使用"></a>第29条：不要把同步方法与异步方法组合起来使用</h3><h3 id="第30条：使用异步方法以避免线程分配和上下文切换"><a href="#第30条：使用异步方法以避免线程分配和上下文切换" class="headerlink" title="第30条：使用异步方法以避免线程分配和上下文切换"></a>第30条：使用异步方法以避免线程分配和上下文切换</h3><h3 id="第31条：避免不必要的上下文编组"><a href="#第31条：避免不必要的上下文编组" class="headerlink" title="第31条：避免不必要的上下文编组"></a>第31条：避免不必要的上下文编组</h3><h3 id="第32条：通过-Task-对象来安排异步工作"><a href="#第32条：通过-Task-对象来安排异步工作" class="headerlink" title="第32条：通过 Task 对象来安排异步工作"></a>第32条：通过 Task 对象来安排异步工作</h3><h3 id="第33条：考虑实现任务取消协议"><a href="#第33条：考虑实现任务取消协议" class="headerlink" title="第33条：考虑实现任务取消协议"></a>第33条：考虑实现任务取消协议</h3><h3 id="第34条：缓存泛型异步方法的返回值"><a href="#第34条：缓存泛型异步方法的返回值" class="headerlink" title="第34条：缓存泛型异步方法的返回值"></a>第34条：缓存泛型异步方法的返回值</h3><hr>
<h2 id="第4章-并行处理"><a href="#第4章-并行处理" class="headerlink" title="第4章 并行处理"></a>第4章 并行处理</h2><h3 id="第35条：了解-PLINQ-是怎样实现并行算法的"><a href="#第35条：了解-PLINQ-是怎样实现并行算法的" class="headerlink" title="第35条：了解 PLINQ 是怎样实现并行算法的"></a>第35条：了解 PLINQ 是怎样实现并行算法的</h3><h3 id="第36条：编写并行算法时要考虑异常状况"><a href="#第36条：编写并行算法时要考虑异常状况" class="headerlink" title="第36条：编写并行算法时要考虑异常状况"></a>第36条：编写并行算法时要考虑异常状况</h3><h3 id="第37条：优先使用线程池而不是创建新的线程"><a href="#第37条：优先使用线程池而不是创建新的线程" class="headerlink" title="第37条：优先使用线程池而不是创建新的线程"></a>第37条：优先使用线程池而不是创建新的线程</h3><h3 id="第38条：考虑使用-BackgroundWorker-在线程之间通信"><a href="#第38条：考虑使用-BackgroundWorker-在线程之间通信" class="headerlink" title="第38条：考虑使用 BackgroundWorker 在线程之间通信"></a>第38条：考虑使用 BackgroundWorker 在线程之间通信</h3><h3 id="第39条：学会在-XAML-环境下执行跨线程调用"><a href="#第39条：学会在-XAML-环境下执行跨线程调用" class="headerlink" title="第39条：学会在 XAML 环境下执行跨线程调用"></a>第39条：学会在 XAML 环境下执行跨线程调用</h3><h3 id="第40条：首先考虑用-lock-实现同步"><a href="#第40条：首先考虑用-lock-实现同步" class="headerlink" title="第40条：首先考虑用 lock() 实现同步"></a>第40条：首先考虑用 lock() 实现同步</h3><h3 id="第41条：尽量缩减锁定范围"><a href="#第41条：尽量缩减锁定范围" class="headerlink" title="第41条：尽量缩减锁定范围"></a>第41条：尽量缩减锁定范围</h3><h3 id="第42条：不要在加了锁的区域内调用未知的方法"><a href="#第42条：不要在加了锁的区域内调用未知的方法" class="headerlink" title="第42条：不要在加了锁的区域内调用未知的方法"></a>第42条：不要在加了锁的区域内调用未知的方法</h3><hr>
<h2 id="第5章-动态编程"><a href="#第5章-动态编程" class="headerlink" title="第5章 动态编程"></a>第5章 动态编程</h2><h3 id="第43条：了解动态编程的优点及缺点"><a href="#第43条：了解动态编程的优点及缺点" class="headerlink" title="第43条：了解动态编程的优点及缺点"></a>第43条：了解动态编程的优点及缺点</h3><h3 id="第44条：通过动态编程技术更好地运用泛型参数的运行期类型"><a href="#第44条：通过动态编程技术更好地运用泛型参数的运行期类型" class="headerlink" title="第44条：通过动态编程技术更好地运用泛型参数的运行期类型"></a>第44条：通过动态编程技术更好地运用泛型参数的运行期类型</h3><h3 id="第45条：使用-DynamicObject-和-IDynamicMetaObjectProvider-实现数据驱动的动态类型"><a href="#第45条：使用-DynamicObject-和-IDynamicMetaObjectProvider-实现数据驱动的动态类型" class="headerlink" title="第45条：使用 DynamicObject 和 IDynamicMetaObjectProvider 实现数据驱动的动态类型"></a>第45条：使用 DynamicObject 和 IDynamicMetaObjectProvider 实现数据驱动的动态类型</h3><h3 id="第46条：学会正确使用-Expression-API"><a href="#第46条：学会正确使用-Expression-API" class="headerlink" title="第46条：学会正确使用 Expression API"></a>第46条：学会正确使用 Expression API</h3><h3 id="第47条：尽量减少公有-API-中的动态对象"><a href="#第47条：尽量减少公有-API-中的动态对象" class="headerlink" title="第47条：尽量减少公有 API 中的动态对象"></a>第47条：尽量减少公有 API 中的动态对象</h3><hr>
<h2 id="第6章-加入全球-C-社区"><a href="#第6章-加入全球-C-社区" class="headerlink" title="第6章 加入全球 C# 社区"></a>第6章 加入全球 C# 社区</h2><h3 id="第48条：最流行的写法不一定最合适"><a href="#第48条：最流行的写法不一定最合适" class="headerlink" title="第48条：最流行的写法不一定最合适"></a>第48条：最流行的写法不一定最合适</h3><h3 id="第49条：与大家一起制定规范并编写代码"><a href="#第49条：与大家一起制定规范并编写代码" class="headerlink" title="第49条：与大家一起制定规范并编写代码"></a>第49条：与大家一起制定规范并编写代码</h3><h3 id="第50条：考虑用分析器自动检查代码质量"><a href="#第50条：考虑用分析器自动检查代码质量" class="headerlink" title="第50条：考虑用分析器自动检查代码质量"></a>第50条：考虑用分析器自动检查代码质量</h3><hr>
<h2 id="中英文词汇对照表"><a href="#中英文词汇对照表" class="headerlink" title="中英文词汇对照表"></a>中英文词汇对照表</h2>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Effective C# 书目录]]></title>
      <url>/2019/08/30/EffectiveCSharpContents/</url>
      <content type="html"><![CDATA[<blockquote>
<p>书名：Effective C# : 改善 C# 代码的 50 个有效方法（原书第 3 版）<br>作者：[ 美 ] 比尔·瓦格纳 ( Bill Wagner )<br>译者：爱飞翔<br>出版：机械工业出版社  </p>
</blockquote>
<p>适用于 <strong>C# 6.0</strong></p>
<a id="more"></a>

<hr>
<h2 id="第1章-C-语言的编程习惯"><a href="#第1章-C-语言的编程习惯" class="headerlink" title="第1章 C# 语言的编程习惯"></a>第1章 C# 语言的编程习惯</h2><h3 id="第1条：优先使用隐式类型的局部变量"><a href="#第1条：优先使用隐式类型的局部变量" class="headerlink" title="第1条：优先使用隐式类型的局部变量"></a>第1条：优先使用隐式类型的局部变量</h3><h3 id="第2条：考虑用-readonly-代替-const"><a href="#第2条：考虑用-readonly-代替-const" class="headerlink" title="第2条：考虑用 readonly 代替 const"></a>第2条：考虑用 readonly 代替 const</h3><h3 id="第3条：优先考虑-is-或-as-运算符，尽量少用强制类型转换"><a href="#第3条：优先考虑-is-或-as-运算符，尽量少用强制类型转换" class="headerlink" title="第3条：优先考虑 is 或 as 运算符，尽量少用强制类型转换"></a>第3条：优先考虑 is 或 as 运算符，尽量少用强制类型转换</h3><h3 id="第4条：用内插字符串取代-string-Format"><a href="#第4条：用内插字符串取代-string-Format" class="headerlink" title="第4条：用内插字符串取代 string.Format()"></a>第4条：用内插字符串取代 string.Format()</h3><h3 id="第5条：用-FormattableString-取代专门为特定区域而写的字符串"><a href="#第5条：用-FormattableString-取代专门为特定区域而写的字符串" class="headerlink" title="第5条：用 FormattableString 取代专门为特定区域而写的字符串"></a>第5条：用 FormattableString 取代专门为特定区域而写的字符串</h3><h3 id="第6条：不要用表示符号名称的硬字符串来调用-API"><a href="#第6条：不要用表示符号名称的硬字符串来调用-API" class="headerlink" title="第6条：不要用表示符号名称的硬字符串来调用 API"></a>第6条：不要用表示符号名称的硬字符串来调用 API</h3><h3 id="第7条：用委托表示回调"><a href="#第7条：用委托表示回调" class="headerlink" title="第7条：用委托表示回调"></a>第7条：用委托表示回调</h3><h3 id="第8条：用-null-条件运算符调用事件处理程序"><a href="#第8条：用-null-条件运算符调用事件处理程序" class="headerlink" title="第8条：用 null 条件运算符调用事件处理程序"></a>第8条：用 null 条件运算符调用事件处理程序</h3><h3 id="第9条：尽量避免装箱与取消装箱这两种操作"><a href="#第9条：尽量避免装箱与取消装箱这两种操作" class="headerlink" title="第9条：尽量避免装箱与取消装箱这两种操作"></a>第9条：尽量避免装箱与取消装箱这两种操作</h3><h3 id="第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用-new-修饰符"><a href="#第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用-new-修饰符" class="headerlink" title="第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用 new 修饰符"></a>第10条：只有在应对新版基类与现有子类之间的冲突时才应该使用 new 修饰符</h3><hr>
<h2 id="第2章-NET-的资源管理"><a href="#第2章-NET-的资源管理" class="headerlink" title="第2章 .NET 的资源管理"></a>第2章 .NET 的资源管理</h2><h3 id="第11条：理解并善用-NET-的资源管理机制"><a href="#第11条：理解并善用-NET-的资源管理机制" class="headerlink" title="第11条：理解并善用 .NET 的资源管理机制"></a>第11条：理解并善用 .NET 的资源管理机制</h3><h3 id="第12条：声明字段时，尽量直接为其设定初始值"><a href="#第12条：声明字段时，尽量直接为其设定初始值" class="headerlink" title="第12条：声明字段时，尽量直接为其设定初始值"></a>第12条：声明字段时，尽量直接为其设定初始值</h3><h3 id="第13条：用适当的方式初始化类中的静态成员"><a href="#第13条：用适当的方式初始化类中的静态成员" class="headerlink" title="第13条：用适当的方式初始化类中的静态成员"></a>第13条：用适当的方式初始化类中的静态成员</h3><h3 id="第14条：尽量删减重复的初始化逻辑"><a href="#第14条：尽量删减重复的初始化逻辑" class="headerlink" title="第14条：尽量删减重复的初始化逻辑"></a>第14条：尽量删减重复的初始化逻辑</h3><h3 id="第15条：不要创建无谓的对象"><a href="#第15条：不要创建无谓的对象" class="headerlink" title="第15条：不要创建无谓的对象"></a>第15条：不要创建无谓的对象</h3><h3 id="第16条：绝对不要在构造函数里面调用虚函数"><a href="#第16条：绝对不要在构造函数里面调用虚函数" class="headerlink" title="第16条：绝对不要在构造函数里面调用虚函数"></a>第16条：绝对不要在构造函数里面调用虚函数</h3><h3 id="第17条：实现标准的-dispose-模式"><a href="#第17条：实现标准的-dispose-模式" class="headerlink" title="第17条：实现标准的 dispose 模式"></a>第17条：实现标准的 dispose 模式</h3><hr>
<h2 id="第3章-合理地运用泛型"><a href="#第3章-合理地运用泛型" class="headerlink" title="第3章 合理地运用泛型"></a>第3章 合理地运用泛型</h2><h3 id="第18条：只定义刚好够用的约束条件"><a href="#第18条：只定义刚好够用的约束条件" class="headerlink" title="第18条：只定义刚好够用的约束条件"></a>第18条：只定义刚好够用的约束条件</h3><h3 id="第19条：通过运行期类型检查实现特定的泛型算法"><a href="#第19条：通过运行期类型检查实现特定的泛型算法" class="headerlink" title="第19条：通过运行期类型检查实现特定的泛型算法"></a>第19条：通过运行期类型检查实现特定的泛型算法</h3><h3 id="第20条：通过-IComparable-lt-T-gt-及-IComparer-lt-T-gt-定义顺序关系"><a href="#第20条：通过-IComparable-lt-T-gt-及-IComparer-lt-T-gt-定义顺序关系" class="headerlink" title="第20条：通过 IComparable&lt;T&gt; 及 IComparer&lt;T&gt; 定义顺序关系"></a>第20条：通过 IComparable&lt;T&gt; 及 IComparer&lt;T&gt; 定义顺序关系</h3><h3 id="第21条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持"><a href="#第21条：创建泛型类时，总是应该给实现了-IDisposable-的类型参数提供支持" class="headerlink" title="第21条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持"></a>第21条：创建泛型类时，总是应该给实现了 IDisposable 的类型参数提供支持</h3><h3 id="第22条：考虑支持泛型协变与逆变"><a href="#第22条：考虑支持泛型协变与逆变" class="headerlink" title="第22条：考虑支持泛型协变与逆变"></a>第22条：考虑支持泛型协变与逆变</h3><h3 id="第23条：用委托要求类型参数必须提供某种方法"><a href="#第23条：用委托要求类型参数必须提供某种方法" class="headerlink" title="第23条：用委托要求类型参数必须提供某种方法"></a>第23条：用委托要求类型参数必须提供某种方法</h3><h3 id="第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"><a href="#第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本" class="headerlink" title="第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本"></a>第24条：如果有泛型方法，就不要再创建针对基类或接口的重载版本</h3><h3 id="第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"><a href="#第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类" class="headerlink" title="第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类"></a>第25条：如果不需要把类型参数所表示的对象设为实例字段，那么应该优先考虑创建泛型方法，而不是泛型类</h3><h3 id="第26条：实现泛型接口的同时，还应该实现非泛型接口"><a href="#第26条：实现泛型接口的同时，还应该实现非泛型接口" class="headerlink" title="第26条：实现泛型接口的同时，还应该实现非泛型接口"></a>第26条：实现泛型接口的同时，还应该实现非泛型接口</h3><h3 id="第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"><a href="#第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现" class="headerlink" title="第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现"></a>第27条：只把必备的契约定义在接口中，把其他功能留给扩展方法去实现</h3><h3 id="第28条：考虑通过扩展方法增强已构造类型的功能"><a href="#第28条：考虑通过扩展方法增强已构造类型的功能" class="headerlink" title="第28条：考虑通过扩展方法增强已构造类型的功能"></a>第28条：考虑通过扩展方法增强已构造类型的功能</h3><hr>
<h2 id="第4章-合理地运用-LINQ"><a href="#第4章-合理地运用-LINQ" class="headerlink" title="第4章 合理地运用 LINQ"></a>第4章 合理地运用 LINQ</h2><h3 id="第29条：优先考虑提供迭代器方法，而不要返回集合"><a href="#第29条：优先考虑提供迭代器方法，而不要返回集合" class="headerlink" title="第29条：优先考虑提供迭代器方法，而不要返回集合"></a>第29条：优先考虑提供迭代器方法，而不要返回集合</h3><h3 id="第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句"><a href="#第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句" class="headerlink" title="第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句"></a>第30条：优先考虑通过查询语句来编写代码，而不要使用循环语句</h3><h3 id="第31条：把针对序列的-API-设计得更加易于拼接"><a href="#第31条：把针对序列的-API-设计得更加易于拼接" class="headerlink" title="第31条：把针对序列的 API 设计得更加易于拼接"></a>第31条：把针对序列的 API 设计得更加易于拼接</h3><h3 id="第32条：将迭代逻辑与操作、谓词及函数解耦"><a href="#第32条：将迭代逻辑与操作、谓词及函数解耦" class="headerlink" title="第32条：将迭代逻辑与操作、谓词及函数解耦"></a>第32条：将迭代逻辑与操作、谓词及函数解耦</h3><h3 id="第33条：等真正用到序列中的元素时再去生成"><a href="#第33条：等真正用到序列中的元素时再去生成" class="headerlink" title="第33条：等真正用到序列中的元素时再去生成"></a>第33条：等真正用到序列中的元素时再去生成</h3><h3 id="第34条：考虑通过函数参数来放松耦合关系"><a href="#第34条：考虑通过函数参数来放松耦合关系" class="headerlink" title="第34条：考虑通过函数参数来放松耦合关系"></a>第34条：考虑通过函数参数来放松耦合关系</h3><h3 id="第35条：绝对不要重载扩展方法"><a href="#第35条：绝对不要重载扩展方法" class="headerlink" title="第35条：绝对不要重载扩展方法"></a>第35条：绝对不要重载扩展方法</h3><h3 id="第36条：理解查询表达式与方法调用之间的映射关系"><a href="#第36条：理解查询表达式与方法调用之间的映射关系" class="headerlink" title="第36条：理解查询表达式与方法调用之间的映射关系"></a>第36条：理解查询表达式与方法调用之间的映射关系</h3><h3 id="第37条：尽量采用惰性求值的方式来查询，而不要及早求值"><a href="#第37条：尽量采用惰性求值的方式来查询，而不要及早求值" class="headerlink" title="第37条：尽量采用惰性求值的方式来查询，而不要及早求值"></a>第37条：尽量采用惰性求值的方式来查询，而不要及早求值</h3><h3 id="第38条：考虑用-lambda-表达式来代替方法"><a href="#第38条：考虑用-lambda-表达式来代替方法" class="headerlink" title="第38条：考虑用 lambda 表达式来代替方法"></a>第38条：考虑用 lambda 表达式来代替方法</h3><h3 id="第39条：不要在-Func-与-Action-中抛出异常"><a href="#第39条：不要在-Func-与-Action-中抛出异常" class="headerlink" title="第39条：不要在 Func 与 Action 中抛出异常"></a>第39条：不要在 Func 与 Action 中抛出异常</h3><h3 id="第40条：掌握尽早执行与延迟执行之间的区别"><a href="#第40条：掌握尽早执行与延迟执行之间的区别" class="headerlink" title="第40条：掌握尽早执行与延迟执行之间的区别"></a>第40条：掌握尽早执行与延迟执行之间的区别</h3><h3 id="第41条：不要把开销较大的资源捕获到闭包中"><a href="#第41条：不要把开销较大的资源捕获到闭包中" class="headerlink" title="第41条：不要把开销较大的资源捕获到闭包中"></a>第41条：不要把开销较大的资源捕获到闭包中</h3><h3 id="第42条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别"><a href="#第42条：注意-IEnumerable-与-IQueryable-形式的数据源之间的区别" class="headerlink" title="第42条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别"></a>第42条：注意 IEnumerable 与 IQueryable 形式的数据源之间的区别</h3><h3 id="第43条：用-Single-及-First-来明确地验证你对查询结果所做的假设"><a href="#第43条：用-Single-及-First-来明确地验证你对查询结果所做的假设" class="headerlink" title="第43条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设"></a>第43条：用 Single() 及 First() 来明确地验证你对查询结果所做的假设</h3><h3 id="第44条：不要修改绑定变量"><a href="#第44条：不要修改绑定变量" class="headerlink" title="第44条：不要修改绑定变量"></a>第44条：不要修改绑定变量</h3><hr>
<h2 id="第5章-合理地运用异常"><a href="#第5章-合理地运用异常" class="headerlink" title="第5章 合理地运用异常"></a>第5章 合理地运用异常</h2><h3 id="第45条：考虑在方法约定遭到违背时抛出异常"><a href="#第45条：考虑在方法约定遭到违背时抛出异常" class="headerlink" title="第45条：考虑在方法约定遭到违背时抛出异常"></a>第45条：考虑在方法约定遭到违背时抛出异常</h3><h3 id="第46条：利用-using-及-try-finally-来清理资源"><a href="#第46条：利用-using-及-try-finally-来清理资源" class="headerlink" title="第46条：利用 using 及 try / finally 来清理资源"></a>第46条：利用 using 及 try / finally 来清理资源</h3><h3 id="第47条：专门针对应用程序创建异常"><a href="#第47条：专门针对应用程序创建异常" class="headerlink" title="第47条：专门针对应用程序创建异常"></a>第47条：专门针对应用程序创建异常</h3><h3 id="第48条：优先考虑做出强异常保证"><a href="#第48条：优先考虑做出强异常保证" class="headerlink" title="第48条：优先考虑做出强异常保证"></a>第48条：优先考虑做出强异常保证</h3><h3 id="第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"><a href="#第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑" class="headerlink" title="第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑"></a>第49条：考虑用异常筛选器来改写先捕获异常再重新抛出的逻辑</h3><h3 id="第50条：合理利用异常筛选器的副作用来实现某些效果"><a href="#第50条：合理利用异常筛选器的副作用来实现某些效果" class="headerlink" title="第50条：合理利用异常筛选器的副作用来实现某些效果"></a>第50条：合理利用异常筛选器的副作用来实现某些效果</h3><hr>
<h2 id="中英文词汇对照表"><a href="#中英文词汇对照表" class="headerlink" title="中英文词汇对照表"></a>中英文词汇对照表</h2>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页书签]]></title>
      <url>/2019/08/30/Bookmarks/</url>
      <content type="html"><![CDATA[<p>&emsp; </p>
<a id="more"></a>

<p><a href="https://tao-lol.top/">tao-lol</a></p>
<h1 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h1><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/index" target="_blank" rel="noopener">.NET API 浏览器</a><br><a href="https://try.dot.net/" target="_blank" rel="noopener">try.dot.net</a>  </p>
<h2 id="微软官方文档"><a href="#微软官方文档" class="headerlink" title="微软官方文档"></a>微软官方文档</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/" target="_blank" rel="noopener">.NET</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/" target="_blank" rel="noopener">.NET Standard</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/" target="_blank" rel="noopener">.NET Framework</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/core/" target="_blank" rel="noopener">.NET Core</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/" target="_blank" rel="noopener">C#</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/" target="_blank" rel="noopener">ASP.NET Core</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/razor-pages/" target="_blank" rel="noopener">Razor Pages</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/" target="_blank" rel="noopener">MVC</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/blazor/" target="_blank" rel="noopener">Blazor</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/web-api/" target="_blank" rel="noopener">Web API</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/signalr/" target="_blank" rel="noopener">SignalR</a><br><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/" target="_blank" rel="noopener">gRPC</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/" target="_blank" rel="noopener">WPF</a><br><a href="https://docs.microsoft.com/zh-cn/xamarin/" target="_blank" rel="noopener">Xamarin</a><br><a href="https://docs.microsoft.com/zh-cn/ef/core/" target="_blank" rel="noopener">Entity Framework Core</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/machine-learning/" target="_blank" rel="noopener">ML.NET</a><br><a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md" target="_blank" rel="noopener">Microsoft REST API Guidelines</a><br><a href="https://docs.microsoft.com/zh-cn/azure/devops/" target="_blank" rel="noopener">Azure Devops</a><br><a href="https://docs.microsoft.com/en-us/azure/architecture/" target="_blank" rel="noopener">Azure Architecture</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/" target="_blank" rel="noopener">MicroServices</a><br><a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a>  </p>
<h2 id="第三方组件"><a href="#第三方组件" class="headerlink" title="第三方组件"></a>第三方组件</h2><h3 id="代码增强"><a href="#代码增强" class="headerlink" title="代码增强"></a>代码增强</h3><p><a href="https://github.com/App-vNext/Polly/wiki" target="_blank" rel="noopener">Polly</a><br><a href="https://fluentvalidation.net/start" target="_blank" rel="noopener">FluentValidation</a><br><a href="https://github.com/scottksmith95/LINQKit" target="_blank" rel="noopener">LINQKit</a>  </p>
<h3 id="音频视频"><a href="#音频视频" class="headerlink" title="音频视频"></a>音频视频</h3><p><a href="https://trac.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>  </p>
<h3 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h3><p><a href="docs.identityserver.io/">IdentityServer4</a><br><a href="https://identitymodel.readthedocs.io/" target="_blank" rel="noopener">IdentityModel</a><br><a href="http://docs.supersocket.net/" target="_blank" rel="noopener">SuperSocket</a>  </p>
<h3 id="应用程序接口"><a href="#应用程序接口" class="headerlink" title="应用程序接口"></a>应用程序接口</h3><p><a href="https://swagger.io/docs/" target="_blank" rel="noopener">Swagger</a><br><a href="https://github.com/domaindrivendev/Swashbuckle" target="_blank" rel="noopener">SwashBuckle</a><br><a href="https://github.com/RicoSuter/NSwag/wiki" target="_blank" rel="noopener">NSwag</a><br><a href="https://ocelot.readthedocs.io/" target="_blank" rel="noopener">Ocelot</a><br><a href="https://github.com/reactiveui/refit" target="_blank" rel="noopener">Refit</a><br><a href="https://github.com/stefanprodan/AspNetCoreRateLimit/wiki" target="_blank" rel="noopener">AspNetCoreRateLimit</a>  </p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><a href="http://unitycontainer.org/" target="_blank" rel="noopener">Unity</a><br><a href="https://autofac.readthedocs.io/" target="_blank" rel="noopener">Autofac</a><br><a href="https://github.com/jbogard/MediatR/wiki" target="_blank" rel="noopener">MediatR</a><br><a href="https://github.com/dotnet-state-machine/stateless" target="_blank" rel="noopener">Stateless</a>  </p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p><a href="https://redis.io/documentation" target="_blank" rel="noopener">Redis</a><br><a href="https://docs.mongodb.com/" target="_blank" rel="noopener">mongoDB</a><br><a href="https://docs.microsoft.com/zh-cn/sql/sql-server/" target="_blank" rel="noopener">SQL Server</a><br><a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">MySQL</a><br><a href="https://www.sqlite.org/docs.html" target="_blank" rel="noopener">SQLite</a>  </p>
<h3 id="对象关系映射（ORM）"><a href="#对象关系映射（ORM）" class="headerlink" title="对象关系映射（ORM）"></a>对象关系映射（ORM）</h3><p><a href="docs.automapper.org/">AutoMapper</a><br><a href="https://github.com/2881099/FreeSql/wiki" target="_blank" rel="noopener">FreeSql</a><br><a href="https://github.com/StackExchange/Dapper" target="_blank" rel="noopener">Dapper</a><br><a href="https://github.com/2881099/csredis" target="_blank" rel="noopener">CSRedis</a><br><a href="https://stackexchange.github.io/StackExchange.Redis/" target="_blank" rel="noopener">StackExchange.Redis</a><br><a href="https://docs.mongodb.com/ecosystem/drivers/csharp/" target="_blank" rel="noopener">MongoDB.Driver</a>  </p>
<h3 id="导入导出格式文件"><a href="#导入导出格式文件" class="headerlink" title="导入导出格式文件"></a>导入导出格式文件</h3><p><a href="https://github.com/JanKallman/EPPlus/wiki" target="_blank" rel="noopener">EPPlus</a><br><a href="https://joshclose.github.io/CsvHelper/getting-started" target="_blank" rel="noopener">CSVHelper</a><br><a href="https://www.newtonsoft.com/json/help/" target="_blank" rel="noopener">Json.NET</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.xml.xmlreader" target="_blank" rel="noopener">XmlReader</a><br><a href="https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmlwriter" target="_blank" rel="noopener">XmlWriter</a><br><a href="https://anglesharp.github.io/docs.html" target="_blank" rel="noopener">AngleSharp</a><br><a href="https://github.com/rdvojmoc/DinkToPdf" target="_blank" rel="noopener">DinkToPdf</a>  </p>
<h3 id="后台任务"><a href="#后台任务" class="headerlink" title="后台任务"></a>后台任务</h3><p><a href="https://www.quartz-scheduler.net/documentation/index.html" target="_blank" rel="noopener">Quartz.NET</a><br><a href="docs.topshelf-project.com/">Topshelf</a><br><a href="https://docs.hangfire.io/" target="_blank" rel="noopener">Hangfire</a>  </p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><a href="https://www.rabbitmq.com/documentation.html" target="_blank" rel="noopener">RabbitMQ</a><br><a href="https://github.com/EasyNetQ/EasyNetQ/wiki/Introduction" target="_blank" rel="noopener">EasyNetQ</a><br><a href="https://masstransit-project.com/MassTransit/" target="_blank" rel="noopener">MassTransit</a>  </p>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p><a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener">Consul</a><br><a href="https://github.com/ctripcorp/apollo/wiki" target="_blank" rel="noopener">Apollo</a>  </p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p><a href="https://github.com/serilog/serilog/wiki" target="_blank" rel="noopener">Serilog</a><br><a href="https://github.com/NLog/NLog/wiki" target="_blank" rel="noopener">NLog</a>  </p>
<h3 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html" target="_blank" rel="noopener">Elasticsearch</a><br><a href="https://www.elastic.co/guide/en/kibana/current/index.html" target="_blank" rel="noopener">Kibana</a><br><a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">Logstash</a><br><a href="https://github.com/apache/skywalking/tree/master/docs" target="_blank" rel="noopener">SkyWalking</a>  </p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><a href="https://github.com/nunit/docs/wiki" target="_blank" rel="noopener">NUnit</a><br><a href="https://xunit.net/#documentation" target="_blank" rel="noopener">xUnit</a><br><a href="https://github.com/moq/moq4/wiki" target="_blank" rel="noopener">Moq</a><br><a href="https://nsubstitute.github.io/help.html" target="_blank" rel="noopener">NSubstitute</a><br><a href="https://shouldly.readthedocs.io/" target="_blank" rel="noopener">Shouldly</a><br><a href="https://fluentassertions.com/introduction" target="_blank" rel="noopener">FluentAssertions</a>  </p>
<h3 id="托管部署"><a href="#托管部署" class="headerlink" title="托管部署"></a>托管部署</h3><p><a href="https://git-scm.com/doc" target="_blank" rel="noopener">Git</a><br><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker</a><br><a href="https://github.com/jesseduffield/lazydocker" target="_blank" rel="noopener">LazyDocker</a><br><a href="https://helm.sh/" target="_blank" rel="noopener">Helm</a><br><a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener">Kubernetes</a><br><a href="https://github.com/rancher/k3s" target="_blank" rel="noopener">K3s</a>  </p>
<h3 id="集成架构"><a href="#集成架构" class="headerlink" title="集成架构"></a>集成架构</h3><p><a href="http://prismlibrary.github.io/docs/" target="_blank" rel="noopener">Prism</a><br><a href="https://docs.abp.io/zh-Hans/abp/master/" target="_blank" rel="noopener">ABP</a><br><a href="http://cap.dotnetcore.xyz/user-guide/zh/getting-started/quick-start/" target="_blank" rel="noopener">CAP</a><br><a href="https://github.com/dotnetcore/surging" target="_blank" rel="noopener">Surging</a><br><a href="http://dotnet.github.io/orleans/Documentation/" target="_blank" rel="noopener">Orleans</a><br><a href="https://github.com/dapr/dapr/wiki" target="_blank" rel="noopener">Dapr</a>  </p>
<h3 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h3><p><a href="https://angular.io/docs" target="_blank" rel="noopener">Angular</a><br><a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a><br><a href="https://zh-hans.reactjs.org/docs/" target="_blank" rel="noopener">React</a><br><a href="https://datatables.net/manual/" target="_blank" rel="noopener">DataTables</a><br><a href="https://github.com/alyssaxuu/flowy" target="_blank" rel="noopener">Flowy</a><br><a href="https://github.com/apache/incubator-echarts" target="_blank" rel="noopener">ECharts</a><br><a href="https://getbootstrap.com/docs/" target="_blank" rel="noopener">Bootstrap</a><br><a href="https://ng-bootstrap.github.io/#/getting-started" target="_blank" rel="noopener">NG-Bootstrap</a><br><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design of React</a><br><a href="https://ng.ant.design/docs/introduce/zh" target="_blank" rel="noopener">Ant Design of Angular</a><br><a href="https://vue.ant.design/docs/vue/introduce/" target="_blank" rel="noopener">Ant Design of Vue</a><br><a href="https://material.angular.io/components/categories" target="_blank" rel="noopener">Angular Material</a>  </p>
<h3 id="WPF-UI"><a href="#WPF-UI" class="headerlink" title="WPF UI"></a>WPF UI</h3><p><a href="https://github.com/MahApps/MahApps.Metro/wiki" target="_blank" rel="noopener">MahApps.Metro</a><br><a href="https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit/wiki" target="_blank" rel="noopener">MaterialDesignInXamlToolkit</a><br><a href="https://github.com/spiegelp/MaterialDesignExtensions/wiki" target="_blank" rel="noopener">MaterialDesignExtensions</a><br><a href="https://github.com/Panuon/PanuonUI.Silver" target="_blank" rel="noopener">PanuonUI.Silver</a><br><a href="https://github.com/ButchersBoy/Dragablz/wiki" target="_blank" rel="noopener">Dragablz</a><br><a href="https://lvcharts.net/App/examples/wpf/start" target="_blank" rel="noopener">LiveCharts</a><br><a href="https://reactiveui.net/docs/" target="_blank" rel="noopener">ReactiveUI</a>  </p>
<h3 id="游戏设计"><a href="#游戏设计" class="headerlink" title="游戏设计"></a>游戏设计</h3><p><a href="https://docs.unity3d.com/Manual/" target="_blank" rel="noopener">Unity3D</a>  </p>
<h3 id="图标符号"><a href="#图标符号" class="headerlink" title="图标符号"></a>图标符号</h3><p><a href="https://icons8.com/icons" target="_blank" rel="noopener">Icons8</a><br><a href="https://pattern.flaticon.com/" target="_blank" rel="noopener">FlatIcon</a><br><a href="https://materialdesignicons.com/" target="_blank" rel="noopener">Material Design Icons</a><br><a href="https://www.iconfont.cn/" target="_blank" rel="noopener">IconFont 阿里巴巴矢量图标库</a><br><a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a><br><a href="https://realfavicongenerator.net/" target="_blank" rel="noopener">Favicon</a><br><a href="https://unicode-table.com/" target="_blank" rel="noopener">Unicode</a>  </p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p><a href="https://docs.microsoft.com/zh-cn/sql/t-sql/" target="_blank" rel="noopener">T-SQL</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">HTML</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">CSS</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript</a><br><a href="https://api.jquery.com/" target="_blank" rel="noopener">jQuery</a><br><a href="https://www.typescriptlang.org/docs/" target="_blank" rel="noopener">TypeScript</a><br><a href="https://docs.python.org/" target="_blank" rel="noopener">Python</a><br><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">Rust</a><br><a href="https://docs.microsoft.com/en-us/powershell/" target="_blank" rel="noopener">PowerShell</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式</a>  </p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">HTTP</a><br><a href="https://visualgo.net/" target="_blank" rel="noopener">VisuAlgo</a><br><a href="https://www.connectionstrings.com/" target="_blank" rel="noopener">ConnectionStrings</a><br><a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">TypeScript Types Search</a>  </p>
<h2 id="中文教程"><a href="#中文教程" class="headerlink" title="中文教程"></a>中文教程</h2><p><a href="http://manual.phpv.net/regular_expression.html" target="_blank" rel="noopener">正则表达式30分钟入门教程</a><br><a href="https://learnku.com/docs/tutorial/3.7.0" target="_blank" rel="noopener">Python官方文档：入门教程 3.7.0</a><br><a href="https://linux.vbird.org/" target="_blank" rel="noopener">鳥哥的 Linux 私房菜</a><br><a href="https://www.cnblogs.com/abcdwxc/archive/2007/10/30/942834.html" target="_blank" rel="noopener">C#设计模式（23种设计模式）</a><br><a href="https://www.cnblogs.com/zhili/p/DesignPatternSummery.html" target="_blank" rel="noopener">C#设计模式总结</a><br><a href="https://www.cnblogs.com/fatbird/p/SortAlgorithm.html" target="_blank" rel="noopener">8种主要排序算法的C#实现</a><br><a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">JavaScript教程 - 网道</a><br><a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a><br><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程</a><br><a href="https://www.cnblogs.com/ZaraNet/p/10323105.html" target="_blank" rel="noopener">.NET Core IdentityServer4实战 - zaraNet</a><br><a href="https://www.cnblogs.com/stulzq/p/8119928.html" target="_blank" rel="noopener">IdentityServer4 中文文档与实战 - 晓晨Master</a><br><a href="https://www.cnblogs.com/viter/p/10474091.html" target="_blank" rel="noopener">Asp.NETCore轻松学系列阅读指引目录 - Ron Liang</a><br><a href="https://www.cnblogs.com/MrHSR/category/1368488.html" target="_blank" rel="noopener">asp.net Core系列篇 - 花阴偷移</a><br><a href="https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html" target="_blank" rel="noopener">.NET Core微服务架构系列文章索引目录 - Edison Zhou</a><br><a href="https://www.cnblogs.com/edisonchou/p/4820676.html" target="_blank" rel="noopener">.NET全栈开发工程师学习路径 - Edison Zhou</a><br><a href="https://www.cnblogs.com/edisonchou/p/3843287.html" target="_blank" rel="noopener">博文资源汇总 - Edison Zhou</a><br><a href="https://rachel53461.wordpress.com/2011/05/08/simplemvvmexample/" target="_blank" rel="noopener">A Simple MVVM Example</a><br><a href="https://www.cnblogs.com/youring2/p/quartz_net.html" target="_blank" rel="noopener">Quartz.Net使用教程</a>  </p>
<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><h2 id="Steam"><a href="#Steam" class="headerlink" title="Steam"></a>Steam</h2><p><a href="https://store.steampowered.com/" target="_blank" rel="noopener">Steam</a><br><a href="https://store.steampowered.com/account/registerkey" target="_blank" rel="noopener">在Steam上激活产品</a><br><a href="https://steamdb.info/" target="_blank" rel="noopener">SteamDB</a><br><a href="https://isthereanydeal.com/" target="_blank" rel="noopener">IsThereAnyDeal</a><br><a href="https://www.steamcardexchange.net/index.php?showcase" target="_blank" rel="noopener">Steam Card Exchange Showcase</a><br><a href="https://steam.design/" target="_blank" rel="noopener">Steam.Design</a><br><a href="https://steamsignature.com/" target="_blank" rel="noopener">Steam Signature</a><br><a href="https://github.com/JustArchiNET/ArchiSteamFarm" target="_blank" rel="noopener">ArchiSteamFarm</a>  </p>
<h2 id="Wiki"><a href="#Wiki" class="headerlink" title="Wiki"></a>Wiki</h2><p><a href="https://minecraft-zh.gamepedia.com/Minecraft_Wiki" target="_blank" rel="noopener">Minecraft Wiki</a><br><a href="https://terraria.gamepedia.com/Terraria_Wiki" target="_blank" rel="noopener">Terraria Wiki</a><br><a href="https://starbounder.org/Starbound_Wiki" target="_blank" rel="noopener">StarBound Wiki</a><br><a href="https://zh.stardewvalleywiki.com/Stardew_Valley_Wiki" target="_blank" rel="noopener">Stardew Valley 中文维基</a><br><a href="http://xinglugu.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">星露谷物语中文维基 - 灰机Wiki</a><br><a href="http://transformice.wikia.com/wiki/Transformice_Wiki" target="_blank" rel="noopener">Transformice Wiki</a><br><a href="https://wiki.52poke.com/" target="_blank" rel="noopener">神奇宝贝百科</a><br><a href="https://game8.jp/splatoon-2" target="_blank" rel="noopener">スプラトゥーン2攻略Wiki</a><br><a href="https://splatoonwiki.org/" target="_blank" rel="noopener">Splatoon Wiki</a><br><a href="https://www.ssbwiki.com/" target="_blank" rel="noopener">SmashWiki</a><br><a href="https://vstab.com/s/eso/" target="_blank" rel="noopener">上古卷轴Online中文网</a><br><a href="http://octopath.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">八方旅人中文维基</a><br><a href="https://zh.moegirl.org/雀魂麻将" target="_blank" rel="noopener">雀魂麻将 - 萌娘百科</a><br><a href="http://139.199.75.237/TTT/" target="_blank" rel="noopener">Tetris T-SPIN 教程</a><br><a href="https://www.ffxiv.cn/" target="_blank" rel="noopener">最终幻想14中文攻略站 素素</a><br><a href="https://ff14.huijiwiki.com/wiki/首页" target="_blank" rel="noopener">最终幻想14中文维基 灰机Wiki</a><br><a href="https://www.ffxivsc.cn/" target="_blank" rel="noopener">光之收藏家 - 最终幻想14幻化站</a>  </p>
<h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p><a href="https://osu.ppy.sh/" target="_blank" rel="noopener">OSU</a><br><a href="https://zh.jstris.jezevec10.com/" target="_blank" rel="noopener">Jstris</a><br><a href="http://farter.cn/tetr.js/" target="_blank" rel="noopener">Tetr.js</a><br><a href="https://majsoul.com/" target="_blank" rel="noopener">雀魂麻将</a><br><a href="https://taiko.bui.pm/" target="_blank" rel="noopener">太鼓ウェブ</a><br><a href="https://www.oldmanemu.net/" target="_blank" rel="noopener">OldmanEmu</a><br><a href="https://www.mmgal.com/" target="_blank" rel="noopener">MyGalgame</a><br><a href="https://www.nintendo.co.jp/software/switch/" target="_blank" rel="noopener">Nintendo Switchソフトウェア｜任天堂</a><br><a href="https://www.nintendo.com/games/switch/" target="_blank" rel="noopener">Switch Games - Nintendo Game Store</a>  </p>
<h1 id="动漫影视书籍"><a href="#动漫影视书籍" class="headerlink" title="动漫影视书籍"></a>动漫影视书籍</h1><h2 id="漫画"><a href="#漫画" class="headerlink" title="漫画"></a>漫画</h2><p><a href="https://mangakakalot.com/page" target="_blank" rel="noopener">Mangakakalot</a><br><a href="https://www.dmzj.com/" target="_blank" rel="noopener">动漫之家</a><br><a href="http://www.zerobyw4.com/" target="_blank" rel="noopener">zero搬运网</a><br><a href="https://www.manhuadb.com/" target="_blank" rel="noopener">漫画DB</a>  </p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a href="https://www.acfun.cn/" target="_blank" rel="noopener">AcFun</a><br><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a><br><a href="http://www.fjisu.tv/" target="_blank" rel="noopener">飞极速在线</a><br><a href="http://www.imomoe.io/" target="_blank" rel="noopener">樱花动漫</a><br><a href="www.dilidili.name/">嘀哩嘀哩</a><br><a href="https://mikanani.me/" target="_blank" rel="noopener">蜜柑计划</a>  </p>
<h2 id="电视剧"><a href="#电视剧" class="headerlink" title="电视剧"></a>电视剧</h2><p><a href="https://gaoqing.fm/" target="_blank" rel="noopener">高清电台</a><br><a href="http://www.ttmeiju.me/" target="_blank" rel="noopener">天天美剧</a>  </p>
<h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><p><a href="https://www.dytt89.com" target="_blank" rel="noopener">电影天堂</a><br><a href="http://www.mxroom.com/" target="_blank" rel="noopener">百度云资源论坛</a>  </p>
<h2 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h2><p><a href="https://bookfere.com/" target="_blank" rel="noopener">书伴 Kindle伴侣</a><br><a href="http://www.pixvol.com/" target="_blank" rel="noopener">Kindle漫画</a><br><a href="https://www.wuxiaworld.com/" target="_blank" rel="noopener">WuXiaWorld</a>  </p>
<h2 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h2><p><a href="https://www.pixiv.net/" target="_blank" rel="noopener">Pixiv</a><br><a href="http://yuc.wiki/" target="_blank" rel="noopener">YuC’s AnimeList</a><br><a href="http://bangumi.tv/" target="_blank" rel="noopener">Bangumi 番组计划</a><br><a href="https://www.equestriacn.com/" target="_blank" rel="noopener">小马中国 | EquestriaCN</a><br><a href="https://japari-cn.com/" target="_blank" rel="noopener">加帕里图书馆 - 兽娘动物园中文维基</a>  </p>
<h1 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h1><p><a href="https://keylol.com/forum.php" target="_blank" rel="noopener">其乐（SteamCN 蒸汽动力）</a><br><a href="https://www.gamersky.com/" target="_blank" rel="noopener">游民星空</a><br><a href="https://www.cnbeta.com/" target="_blank" rel="noopener">cnBeta</a><br><a href="https://www.ithome.com/" target="_blank" rel="noopener">IT之家</a><br><a href="https://t.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩动态</a><br><a href="https://m.weibo.cn/" target="_blank" rel="noopener">新浪微博</a><br><a href="https://steamcommunity.com/id/tao-lol/home/" target="_blank" rel="noopener">Steam好友动态</a><br><a href="https://www.amazon.cn/Kindle电子书/b?ie=UTF8&node=116169071&ref_=nav_topnav_giftcert" target="_blank" rel="noopener">Kindle电子书</a><br><a href="https://www.oschina.net/news/industry" target="_blank" rel="noopener">开源中国资讯</a><br><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a><br><a href="https://github.com/" target="_blank" rel="noopener">Github</a><br><a href="https://dev.azure.com/tao-lol/" target="_blank" rel="noopener">Azure DevOps</a><br><a href="https://wx.qq.com/" target="_blank" rel="noopener">微信网页版</a><br><a href="https://weread.qq.com/" target="_blank" rel="noopener">微信读书</a>  </p>
<h1 id="其它-2"><a href="#其它-2" class="headerlink" title="其它"></a>其它</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://antecer.gitee.io/amusingkeypad/" target="_blank" rel="noopener">AmusingKeypad</a><br><a href="https://github.com/Y2Z/monolith" target="_blank" rel="noopener">Monolith</a><br><a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a><br><a href="https://www.urlgot.com/" target="_blank" rel="noopener">urlgot</a><br><a href="https://www.toolfk.com/" target="_blank" rel="noopener">TOOLFK - 程序员开发工具</a><br><a href="http://www.alltoall.net/" target="_blank" rel="noopener">在线格式转换 All2All</a><br><a href="https://qxk.bnu.edu.cn/" target="_blank" rel="noopener">汉字全息资源应用系统</a><br><a href="https://dillinger.io/" target="_blank" rel="noopener">Online Markdown Editor - Dillinger</a><br><a href="https://markdownapp.now.sh/" target="_blank" rel="noopener">Markdown Editor</a><br><a href="https://todo.microsoft.com/" target="_blank" rel="noopener">Microsoft To-Do</a><br><a href="https://whiteboard.microsoft.com/" target="_blank" rel="noopener">Microsoft Whiteboard</a><br><a href="https://online.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Online</a><br><a href="https://getavatars.app/" target="_blank" rel="noopener">Get an Avatar</a>  </p>
<h2 id="梯子"><a href="#梯子" class="headerlink" title="梯子"></a>梯子</h2><p><a href="https://bwh1.net/" target="_blank" rel="noopener">BandwagonHost</a><br><a href="https://shadowsky.world/" target="_blank" rel="noopener">ShadowSky</a><br><a href="https://www.v2ray.com/" target="_blank" rel="noopener">V2Ray</a>  </p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">百度</a><br><a href="https://cn.bing.com/" target="_blank" rel="noopener">Bing</a><br><a href="https://www.google.com/" target="_blank" rel="noopener">Google</a>  </p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣 LeetCode</a><br><a href="https://www.sololearn.com/" target="_blank" rel="noopener">SoloLearn</a><br><a href="https://www.w3cschool.cn/" target="_blank" rel="noopener">W3Cschool</a><br><a href="https://easychen.gitee.io/foxdict/" target="_blank" rel="noopener">Fox Dict</a><br><a href="http://www.kekenet.com/" target="_blank" rel="noopener">可可英语</a><br><a href="https://studyspanish.com/" target="_blank" rel="noopener">StudySpanish</a>  </p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><a href="https://www.coolapk.com/" target="_blank" rel="noopener">酷安网</a><br><a href="https://apkpure.com/" target="_blank" rel="noopener">APKPure</a><br><a href="https://play.google.com/" target="_blank" rel="noopener">Google Play</a><br><a href="https://www.appinn.com/" target="_blank" rel="noopener">小众软件</a><br><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN, 我告诉你</a>  </p>
<h2 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h2><p><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a><br><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a><br><a href="https://stocksnap.io/" target="_blank" rel="noopener">StockSnap.io</a><br><a href="http://streetwill.co/" target="_blank" rel="noopener">StreetWill</a><br><a href="https://gratisography.com/" target="_blank" rel="noopener">Gratisography</a><br><a href="https://www.textures.com/" target="_blank" rel="noopener">textures</a><br><a href="https://pixabay.com/" target="_blank" rel="noopener">pixabay</a><br><a href="https://www.lifeofpix.com/" target="_blank" rel="noopener">Life Of Pix</a><br><a href="https://www.hippopx.com/" target="_blank" rel="noopener">Hippo px</a><br><a href="https://www.colorhub.me/" target="_blank" rel="noopener">Color Hub</a><br><a href="https://www.pinterest.com/" target="_blank" rel="noopener">Pinterest</a><br><a href="https://visualhunt.com/" target="_blank" rel="noopener">VisualHunt</a><br><a href="http://cupcake.nilssonlee.se/" target="_blank" rel="noopener">Cupcake</a><br><a href="https://wall.alphacoders.com/" target="_blank" rel="noopener">Wallpaper Abyss</a><br><a href="https://wallpapersite.com/" target="_blank" rel="noopener">WallpaperSite</a><br><a href="https://wallpaperscraft.com/" target="_blank" rel="noopener">WallpapersCraft</a><br><a href="https://wallhaven.cc/" target="_blank" rel="noopener">WallHaven</a><br><a href="https://www.ssyer.com/" target="_blank" rel="noopener">SSYER|沙沙野</a>  </p>
<h2 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h2><p><a href="https://www.amap.com/" target="_blank" rel="noopener">高德地图</a><br><a href="https://map.baidu.com/" target="_blank" rel="noopener">百度地图</a><br><a href="https://www.google.com/maps" target="_blank" rel="noopener">Google 地图</a>  </p>
<h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p><a href="https://www.jd.com/" target="_blank" rel="noopener">京东</a><br><a href="https://www.taobao.com/" target="_blank" rel="noopener">淘宝</a><br><a href="https://www.tmall.com/" target="_blank" rel="noopener">天猫</a><br><a href="https://www.amazon.cn/" target="_blank" rel="noopener">亚马逊</a>  </p>
<h2 id="比价"><a href="#比价" class="headerlink" title="比价"></a>比价</h2><p><a href="http://www.xitie.com/" target="_blank" rel="noopener">西贴 网上商品历史价格</a><br><a href="https://www.smzdm.com/" target="_blank" rel="noopener">什么值得买</a>  </p>
<h2 id="运营商"><a href="#运营商" class="headerlink" title="运营商"></a>运营商</h2><p><a href="https://www.10086.cn/" target="_blank" rel="noopener">中国移动</a><br><a href="https://www.189.cn/" target="_blank" rel="noopener">中国电信</a><br><a href="https://www.10010.com/" target="_blank" rel="noopener">中国联通</a>  </p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p><a href="https://homenew.console.aliyun.com/" target="_blank" rel="noopener">阿里云控制台</a><br><a href="https://console.cloud.tencent.com/" target="_blank" rel="noopener">腾讯云控制台</a>  </p>
<h2 id="其它-3"><a href="#其它-3" class="headerlink" title="其它"></a>其它</h2><p><a href="http://www.chongdiantou.com/" target="_blank" rel="noopener">充电头网</a>  </p>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo下的Markdown语法]]></title>
      <url>/2019/08/30/MarkdownSyntax/</url>
      <content type="html"><![CDATA[<blockquote>
<p>转载自 <a href="https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html" target="_blank" rel="noopener">https://www.ofind.cn/blog/HEXO/HEXO下的Markdown语法(GFM)写博客.html</a> 并略微修改  </p>
</blockquote>
<h1 id="语法简明概述"><a href="#语法简明概述" class="headerlink" title="语法简明概述"></a>语法简明概述</h1><ol>
<li>分段 <code>两个回车</code></li>
<li>换行 <code>两个空格</code>+<code>回车</code></li>
<li>标题 <code>#</code>~<code>######</code>，<code>#</code>的个数表示几级标题，即表示一级标题到六级标题</li>
<li>强调 <code>**粗体**</code>，<code>__粗体__</code>，<code>*斜体*</code>，<code>_斜体_</code>，<code>***加粗斜体***</code>，<code>___加粗斜体___</code>，<code>~~删除线~~</code></li>
<li>引用 <code>&gt;</code> 注意后面紧跟个空格，<code>&gt;</code>的个数表示几级引用</li>
<li>表格 <code>-</code>和<code>|</code>分割行和列，<code>:</code>控制对齐方式</li>
<li>代码块 使用<code>```语言</code>代码内容<code>```</code></li>
<li>链接 <code>[文字](链接地址)</code></li>
<li>图片 <code>![图片说明](图片地址)</code>，地址可以是本地路径，也可以是网络地址</li>
<li>无序列表 <code>*</code>，<code>+</code>，<code>-</code>，选其中之一，注意后面紧跟个空格</li>
<li>有序列表 <code>1.</code>，<code>2.</code>，<code>3.</code>等，注意后面紧跟个空格</li>
<li>分隔线 <code>---</code>或<code>***</code>或<code>___</code>，<code>-</code>或<code>*</code>或<code>_</code>的个数三个或以上</li>
<li>半角空格<code>&amp;ensp;</code>或<code>&amp;#8194;</code></li>
<li>全角空格<code>&amp;emsp;</code>或<code>&amp;#8195;</code></li>
<li>不断行空格<code>&amp;nbsp;</code>或<code>&amp;#160;</code><a id="more"></a>

</li>
</ol>
<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">####### 没有七级标题，但会影响生成目录，目录行多出一行空行</span><br></pre></td></tr></table></figure>

<h1 id="内容强调"><a href="#内容强调" class="headerlink" title="内容强调"></a>内容强调</h1><h2 id="加粗、斜体"><a href="#加粗、斜体" class="headerlink" title="加粗、斜体"></a>加粗、斜体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">字体 *斜体* 或 _斜体_ 显示</span><br><span class="line">字体 **加粗** 或 __加粗__ 显示</span><br><span class="line">字体 ***加粗斜体*** 或 ___加粗斜体___ 或以上任意两者组合 显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>斜体</em><br><strong>加粗</strong><br><strong><em>加粗斜体</em></strong>  </p>
</blockquote>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字体 ~~删除线~~ 显示</span><br></pre></td></tr></table></figure>

<blockquote>
<p><del>删除线</del>  </p>
</blockquote>
<h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用&lt;code&gt;内容&lt;/code&gt;或`内容`来强调内容</span><br><span class="line">在code中需用\来转义符号`</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>强调内容</code>  </p>
</blockquote>
<h2 id="引用显示"><a href="#引用显示" class="headerlink" title="引用显示"></a>引用显示</h2><h3 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每行都使用&gt;+空格+内容</span><br><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用内容  </p>
</blockquote>
<h3 id="省略使用"><a href="#省略使用" class="headerlink" title="省略使用"></a>省略使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 仅第一行加&gt;号</span><br><span class="line">后续内容自动变成引用内容</span><br><span class="line">两个回车换行结束引用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一行加<code>&gt;</code><br>第二行无<code>&gt;</code><br>第三行无<code>&gt;</code>  </p>
</blockquote>
<p>第四行无<code>&gt;</code>  </p>
<h3 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; 动物</span><br><span class="line">&gt;&gt; 水生动物</span><br><span class="line">&gt;&gt; 陆生动物</span><br><span class="line">&gt;&gt;&gt; 猴子</span><br><span class="line">&gt;&gt;&gt; 人</span><br><span class="line">&gt;&gt;&gt;&gt; 程序员</span><br><span class="line">&gt;&gt;&gt;&gt; 工程师</span><br><span class="line">&gt;&gt; 产品经理 <span class="comment">//没有空行间隔，忽略降级引用标记</span></span><br><span class="line">设计师 <span class="comment">//没有空行间隔，忽略降级引用标记</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; 两栖动物</span><br><span class="line">&gt;&gt;&gt; 鳄鱼</span><br></pre></td></tr></table></figure>

<blockquote>
<p>动物  </p>
<blockquote>
<p>水生动物<br>陆生动物  </p>
<blockquote>
<p>猴子<br>人  </p>
<blockquote>
<p>程序员<br>工程师<br>产品经理<br>设计师  </p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>两栖动物  </p>
<blockquote>
<p>鳄鱼  </p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">表格语法：</span><br><span class="line"> 列1 | 列2 | 列3</span><br><span class="line"> --- | --- | --- </span><br><span class="line">第一行|  1  | 2 </span><br><span class="line">第二行|  2  | 3</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th>列1</th>
<th>列2</th>
<th>列3</th>
</tr>
</thead>
<tbody><tr>
<td>第一行</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>第二行</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
</blockquote>
<p>使用冒号(:)来定义对齐方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|左对齐|右对齐|居中|</span><br><span class="line">|:---|---:|:-:|</span><br><span class="line">|一|1|①|</span><br><span class="line">|二|2|②|</span><br></pre></td></tr></table></figure>

<blockquote>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一</td>
<td align="right">1</td>
<td align="center">①</td>
</tr>
<tr>
<td align="left">二</td>
<td align="right">2</td>
<td align="center">②</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">代码块使用```[可选语言]开始，```结束，如：</span><br><span class="line">```cs</span><br><span class="line">public class Test</span><br><span class="line">&#123;</span><br><span class="line">    private string _pro;</span><br><span class="line">    public string Pro</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; _pro;</span><br><span class="line">        set =&gt; _pro = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> _pro;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Pro</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _pro;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _pro = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特别提示"><a href="#特别提示" class="headerlink" title="特别提示"></a>特别提示</h2><p>如何在<code>代码块</code>中打出<code>```</code><br>只要使用4个<code>`</code>包含3个<code>`</code>即可，想表示更多，最外层<code>+1</code>就行。</p>
<h1 id="链接插入"><a href="#链接插入" class="headerlink" title="链接插入"></a>链接插入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[文字](链接)</span><br><span class="line">[首页](https://tao-lol.github.io)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://tao-lol.github.io" target="_blank" rel="noopener">首页</a>  </p>
</blockquote>
<h1 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片说明](图片链接)</span><br><span class="line">图片链接相对路径或网络地址皆可</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="image-box">
                <img src="https://storebucket1-1258003678.cos.ap-guangzhou.myqcloud.com/Life%20Is%20Strange.jpg" alt="Life Is Strange" title class>
                <p>Life Is Strange</p>
            </figure>  
</blockquote>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*或-或+开头皆可</span><br><span class="line">* 无序列表1</span><br><span class="line">    * 无序列表1-1</span><br><span class="line">- 无序列表2</span><br><span class="line">+ 无序列表3</span><br><span class="line">    + 无序列表3-1</span><br><span class="line">    + 无序列表3-2</span><br><span class="line">        + 无序列表3-2-1</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>无序列表1<ul>
<li>无序列表1-1 <code>多于一级序列一(2?)个空格</code></li>
</ul>
</li>
</ul>
<ul>
<li>无序列表2</li>
</ul>
<ul>
<li>无序列表3<ul>
<li>无序列表3-1</li>
<li>无序列表3-2<ul>
<li>无序列表3-2-1</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">自动生成列表序号，最多两级</span><br><span class="line">1. 有序1</span><br><span class="line">1. 有序2</span><br><span class="line"> 1. 有序2-1</span><br><span class="line">  1. 有序2-1-1</span><br><span class="line"> 1. 有序2-2</span><br><span class="line">1. 有序3</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>有序1</li>
<li>有序2<ol>
<li>有序2-1 <code>多于一级序列一(3?)个空格</code><ol>
<li>有序2-1-1</li>
</ol>
</li>
<li>有序2-2</li>
</ol>
</li>
<li>有序3</li>
</ol>
</blockquote>
<h1 id="链接自动检测"><a href="#链接自动检测" class="headerlink" title="链接自动检测"></a>链接自动检测</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">百度：http://www.baidu.com/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>百度：<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>  </p>
</blockquote>
<h1 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三个或以上*或-或_</span><br><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure>

<blockquote>
<hr>
<hr>
<hr>
</blockquote>
<h1 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不断行空格 &amp;nbsp;</span><br><span class="line">半角空格 &amp;ensp;</span><br><span class="line">全角空格 &amp;emsp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个&nbsp;是&ensp;例&emsp;子</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2019/08/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
