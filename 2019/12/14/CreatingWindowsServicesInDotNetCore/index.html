<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>使用 .NET Core 创建 Windows 服务 | Blog | tao-lol</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="CSharp,dotNET">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">濤</h5>
          <a href="mailto:tao-lol@qq.com" title="tao-lol@qq.com" class="mail">
            
              <span>t</span>
            
              <span>a</span>
            
              <span>o</span>
            
              <span>-</span>
            
              <span>l</span>
            
              <span>o</span>
            
              <span>l</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/Tao-lol" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>使用 .NET Core 创建 Windows 服务</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">使用 .NET Core 创建 Windows 服务</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-14T12:50:51.000Z" itemprop="datePublished" class="page-time">
  2019-12-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-CreatingWindowsServicesInDotNetCore"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">使用 .NET Core 创建 Windows 服务</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-14 20:50:51" datetime="2019-12-14T12:50:51.000Z"  itemprop="datePublished">2019-12-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <blockquote>
<p>作者：Dotnet Core Tutorials<br>原文：</p>
<ul>
<li>Part 1 - The “Microsoft” Way: <a href="https://dotnetcoretutorials.com/2019/09/19/creating-windows-services-in-net-core-part-1-the-microsoft-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/09/19/creating-windows-services-in-net-core-part-1-the-microsoft-way/</a>  </li>
<li>Part 2 - The “Topshelf” Way: <a href="https://dotnetcoretutorials.com/2019/09/27/creating-windows-services-in-net-core-part-2-the-topshelf-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/09/27/creating-windows-services-in-net-core-part-2-the-topshelf-way/</a>  </li>
<li>Part 3 – The “.NET Core Worker” Way: <a href="https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/" target="_blank" rel="noopener">https://dotnetcoretutorials.com/2019/12/07/creating-windows-services-in-net-core-part-3-the-net-core-worker-way/</a></li>
</ul>
<p>译者：Lamond Lu<br>译文：</p>
<ul>
<li>Part 1 - 使用官方推荐方式: <a href="https://www.cnblogs.com/lwqlun/p/11621186.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/11621186.html</a>  </li>
<li>Part 2 - 使用 Topshelf 方式: <a href="https://www.cnblogs.com/lwqlun/p/11625789.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/11625789.html</a>  </li>
<li>Part 3 - 使用 .NET Core 工作器方式: <a href="https://www.cnblogs.com/lwqlun/p/12038062.html" target="_blank" rel="noopener">https://www.cnblogs.com/lwqlun/p/12038062.html</a>  </li>
</ul>
</blockquote>
<a id="more"></a>

<figure class="image-box">
                <a rel=使用 .NET Core 创建 Windows 服务 href="65831-20191005211343706-2050001309.png" title="" data-fancybox="images"><img src="65831-20191005211343706-2050001309.png" alt title class></a>
                <p></p>
            </figure>

<h1 id="使用官方推荐方式"><a href="#使用官方推荐方式" class="headerlink" title="使用官方推荐方式"></a>使用官方推荐方式</h1><p>&emsp;&emsp;创建 Windows 服务来运行批处理任务或者运行后台任务，是一种非常常见的模式，但是由于云服务（Amazon Lambda, Azure WebJobs 以及 Azure Functions）的激增，你可能不会经常使用 Windows 服务了。个人而言，我非常喜欢使用 Azure WebJobs，因为我可以直接编写一个控制台程序，而不需要考虑如何云中运行它，一个批处理文件可以将其装换成一个自动化任务，并且可以保证 7 * 24 小时的运行。<br>&emsp;&emsp;但是也许你还没有使用云服务，或者你有一堆要作为 Windows 服务运行的旧版应用程序需要转换为 .NET Core，但是不能完全将他们转换为 “ 无服务器 ”（serverless）应用。 那么这边文章就是适合你的。<br>&emsp;&emsp;在许多方面，.NET Core 中的 Windows 服务和 .NET Framework 中的 Windows 服务完全相同。但是，在编写服务的时候，你可能会遇到一些小问题。此外，本文中，我们仅介绍 “ Microsoft ” 方式的 Windows 服务创建，在后续，我会继续介绍如何使用第三方库 TopShelf 来简化这个过程。  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;由于 Visual Studio 没有提供创建 Windows 服务的模板，所以我们需要通过创建控制台程序的方式来创建一个 Windows 服务。<br>创建完成之后，我们需要安装一个 Nuget 程序包，这个程序包会将一些 Windows 特定的 API 添加到 .NET Core 中，这些 API 实际上已经在完整框架中提供了，但是其中许多是 Windows 特有的，例如 Windows 服务。因此, 它们并没有包含在 .NET Core 的基础库中，但是可以通过将 Nuget 程序包的方式引入到 .NET Core 中。<br>&emsp;&emsp;下面我们就可以在 Package Manager Console 中输入以下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Windows.Compatibility</span><br></pre></td></tr></table></figure>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>&emsp;&emsp;以上引入的 Nuget 程序包中，最让我们感兴趣的是 <code>ServiceBase</code> 类。这是一个用于编写 Windows 服务的基类，它提供了一系列的事件钩子，包含服务启动、结束、暂停等。<br>&emsp;&emsp;下面呢，我们将在代码中创建一个类，这个类负责将一些简单的日志输出到一个临时文件中。我们将使用这个例子来了解其中的原理。我们的代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">LoggingService</span> : <span class="title">ServiceBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> _logFileLocation = <span class="string">@"C:\temp\servicelog.txt"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="keyword">string</span> logMessage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));</span><br><span class="line">        File.AppendAllText(_logFileLocation, DateTime.UtcNow.ToString() + <span class="string">" : "</span> + logMessage + Environment.NewLine);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Starting"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnStart(args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStop</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Stopping"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnStop();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnPause</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Pausing"</span>);</span><br><span class="line">        <span class="keyword">base</span>.OnPause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所以这里你会注意到，我们的类是继承了 <code>ServiceBase</code> 类，并且我们重写了几个事件方法，输出了一些日志。在服务启动时，会触发 <code>OnStart</code> 事件，在服务终止的时候，会触发 <code>OnStop</code> 事件。这里我们不应该将过于繁重的任务放置在 <code>OnStart</code> 事件中来处理。<br>&emsp;&emsp;如果我们想从 <code>Main</code> 方式中启动这个服务，代码非常的简单。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ServiceBase.Run(<span class="keyword">new</span> LoggingService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上就是全部代码。  </p>
<h2 id="服务部署"><a href="#服务部署" class="headerlink" title="服务部署"></a>服务部署</h2><p>&emsp;&emsp;在发布服务的时候，我们不可能仅依靠 Visual Studio 来构建我们所需要的服务，我们还需要专门针对 Windows 运行时进行构建。为此，我们需要在项目根目录的命令提示符下运行以下命令。注意，这里我们传入了一个 <code>-r</code> 标记来告诉它要构建那个平台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;命令运行完毕之后，我们可以检查以下 <code>/bin/release/netcoreappX.X/publish</code> 目录，我们可以找到所有的发布代码，但是最重要的是，这里我们可以得到一个可执行的 exe 文件。如果我们不指定运行时，我们只会获得一个 .NET Core 的 dll 程序集，使用这个程序集，我们是没有办法创建 Windows 服务的。<br>&emsp;&emsp;现在我们可以将这个发布目录移动带其他的任何地方，但是现在我们就暂时使用当前的发布目录。<br>&emsp;&emsp;下一步，我们需要使用管理员角色打开一个命令提示符，然后输入一下命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>SC</code> 命令是一个标准的 Windows 命令（与 .NET Core 无关），它可以用来安装 Windows 服务。这里我们将我们的测试服务命名为 <code>TestService</code>，更重要的是，我们通过 <code>BinPath</code> 参数指定了可执行 exe 文件。<br>&emsp;&emsp;运行之后，我们应该会得到以下结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SC] CreateService SUCCESS</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们要做的就是启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start TestService</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以查看一下我们的日志文件，查看服务的运行情况。<br>&emsp;&emsp;如果想要停止并删除服务，我们可以使用一下命令。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc stop TestService</span><br><span class="line">sc delete TestService</span><br></pre></td></tr></table></figure>

<h2 id="服务调试"><a href="#服务调试" class="headerlink" title="服务调试"></a>服务调试</h2><p>&emsp;&emsp;在这里，我真的认为，使用 “ Microsoft “ 的方式注定会失败。因为调试服务实在是太繁琐了。<br>&emsp;&emsp;首先，我们将 <code>ServiceBase</code> 中重写的方法设置为受保护，这意味着我们无法在类之外访问它们，这使得调试它们变得更加困难。这里我发现最好的方法是为每个事件提供一个 public 方法, 并在受保护方法中调用这些 public 方法来完成功能，这虽然有点混乱，</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStartPublic</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log(<span class="string">"Starting"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OnStartPublic(args);</span><br><span class="line">    <span class="keyword">base</span>.OnStart(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是至少我们可以做如下了事情了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loggingService = <span class="keyword">new</span> LoggingService();</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>)   <span class="comment">//Some check to see if we are in debug mode (Either #IF Debug etc or an app setting)</span></span><br><span class="line">    &#123;</span><br><span class="line">        loggingService.OnStartPublic(<span class="keyword">new</span> <span class="keyword">string</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Just spin wait here. </span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Call stop here etc. </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ServiceBase.Run(<span class="keyword">new</span> LoggingService());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你的另一个选择是，在调试模式下进行项目发布，安装服务，然后附加调试器。实际上，这是 Microsoft 建议你使用的方式，但是我认为这简直一团糟。  </p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>&emsp;&emsp;实际上，我们可以在这里做一些其他非常有用的事情， 比如我们可以通过创建一个 install.bat 批处理文件来为我们运行 SC Create 命令。但我认为，上面我们看到的调试问题，已经让我不再想使用这种方式了。幸运的是，有一个名为 <code>Topshelf</code> 的库可以帮助我们减轻很多麻烦，在本系列的下一部分中，我们将研究如何它。  </p>
<h1 id="使用-Topshelf-方式"><a href="#使用-Topshelf-方式" class="headerlink" title="使用 Topshelf 方式"></a>使用 Topshelf 方式</h1><p>&emsp;&emsp;在前一篇文章中，我给大家介绍了，如何基于微软推荐方式使用 .NET Core 创建 Windows 服务。我们发现使用这种方式，我们很容易就可以搭建和运行一个 Windows 服务，但是问题是使用这种方式，代码调试将非常困难。<br>&emsp;&emsp;那么现在就是 <code>Topshelf</code> 出场的时候了。<code>Topshelf</code> 是一个 .NET Standard 库，它消除了在 .NET Framework 和 .NET Core 中创建 Windows 服务的那些麻烦。  </p>
<h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;与微软推荐方式类似，这里 Visual Studio 并没有提供一个基于 <code>Topshelf</code> 创建 Windows 服务的模板，所以我们依然需要通过创建普通控制台程序的方式，来创建一个 Windows 服务。<br>&emsp;&emsp;然后，我们需要通过 Package Manager Console，运行以下命令，安装 <code>Topshelf</code> 类库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Topshelf</span><br></pre></td></tr></table></figure>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>&emsp;&emsp;下面我们就来使用 <code>Topshelf</code> 重构之前的服务代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoggingService</span> : <span class="title">ServiceControl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">string</span> _logFileLocation = <span class="string">@"C:\temp\servicelog.txt"</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Log</span>(<span class="params"><span class="keyword">string</span> logMessage</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Directory.CreateDirectory(Path.GetDirectoryName(_logFileLocation));</span><br><span class="line">        File.AppendAllText(_logFileLocation, </span><br><span class="line">            DateTime.UtcNow.ToString() + <span class="string">" : "</span> + logMessage + Environment.NewLine);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Start</span>(<span class="params">HostControl hostControl</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Starting"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Stop</span>(<span class="params">HostControl hostControl</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Log(<span class="string">"Stopping"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码看起来是不是很简单？<br>&emsp;&emsp;这里我们的服务类继承了 <code>ServiceControl</code> 类（实际上并不需要，但是这可以为我们的工作打下良好的基础）。我们必须实现服务开始和服务结束两个方法，并且像以前一样记录日志。<br>&emsp;&emsp;在 <code>Program.cs</code> 文件的 <code>Main</code> 方法中，我们要写的代码也非常的简单。我们可以直接使用 <code>HostFactory.Run</code> 方法来启动服务。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HostFactory.Run(x =&gt; x.Service&lt;LoggingService&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来真是太简单了。但这并不是 <code>HostFactory</code> 类的唯一功能。这里我们还可以设置</p>
<ul>
<li>服务的名称</li>
<li>服务是否自动启动</li>
<li>服务崩溃之后的重启时间</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HostFactory.Run(x =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            x.Service&lt;LoggingService&gt;();</span><br><span class="line">            x.EnableServiceRecovery(r =&gt; r.RestartService(TimeSpan.FromSeconds(<span class="number">10</span>)));</span><br><span class="line">            x.SetServiceName(<span class="string">"TestService"</span>);</span><br><span class="line">            x.StartAutomatically();</span><br><span class="line">         &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里其实能说的东西很多，但是我建议你还是自己去看看 <code>Topshelf</code> 的文档，学习一下其他的配置选项。基本上你能使用 Windows 命令行完成的所有操作，都可以使用代码来设置：<a href="https://topshelf.readthedocs.io/en/latest/configuration/config_api.html" target="_blank" rel="noopener">https://topshelf.readthedocs.io/en/latest/configuration/config_api.html</a>  </p>
<h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>&emsp;&emsp;和之前一样，我们需要针对不同的 Windows 环境发布我们的服务。在 Windows 命令提示符下，我们可以在项目目录中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们就可以查看一下 <code>bin\Release\netcoreappX.X\win-x64\publish</code> 目录，我们会发现一个编译好的 exe，下面我们就会使用这个文件来安装服务。<br>&emsp;&emsp;在上一篇文章中，我们是使用 <code>SC</code> 命令来安装 Windows 服务的。使用 <code>Topshelf</code> 我们就不需要这么做了，<code>Topshelf</code> 提供了自己的命令行参数来安装服务。基本上使用代码能完成的配置，都可以使用命令行来完成。<br>&emsp;&emsp;你可以查看相关的文档：<a href="http://docs.topshelf-project.com/en/latest/overview/commandline.html" target="_blank" rel="noopener">http://docs.topshelf-project.com/en/latest/overview/commandline.html</a> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowsServiceExample.exe install</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里 <code>WindowsServiceExample.exe</code> 是我发布之后的 exe 文件。运行以上命令之后，服务应该就正常安装了！这里有一个小问题，我经常发现，即使配置了服务自动启动，但是服务安装之后，并不会触发启动操作。所有在服务安装之后，我们还需要通过以下命令来启动服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowsServiceExample.exe start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;在生产环境部署的时候，我的经验是在安装服务之后，等待 10 秒钟，再启动服务。</p>
</blockquote>
<h2 id="调试服务"><a href="#调试服务" class="headerlink" title="调试服务"></a>调试服务</h2><p>&emsp;&emsp;当我们是使用微软推荐方式的时候，我们会遇到了调试困难的问题。大多数情况下，无论是否在服务内部运行，我们都不得不使用命令行标志、<code>#IF DEBUG</code> 指令或者配置值来实现调试。然后使用 Hack 的方式在控制台程序中模拟服务。<br>&emsp;&emsp;因此，这就是为什么我们要使用 <code>Topshelf</code>。<br>&emsp;&emsp;如果我们的服务代码已经在 Visual Studio 中打开了，我们就可以直接启动调试。<code>Topshelf</code> 会模拟在控制台中启动服务。我们应该能在控制台中看到以下的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The TestService service is now running, press Control+C to exit.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这确实符合了我们的需求。它启动了我们的服务，并像真正的 Windows 服务一样在后台运行。我们可以像往常一样设置断点，基本上它遵循的流程和正常安装的服务一样。<br>&emsp;&emsp;我们可以通过 ctrl+c，来关闭我们的应用，但是在运行服务执行 Stop 方法之前，它是不能被关闭的，这使我们可以调试服务的关闭流程。与调试指令和配置标志相比，这要容易的多。<br>&emsp;&emsp;这里需要注意一个问题。如果你收到的以下内容的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The TestService service is running and must be stopped before running via the console</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这意味着你尝试调试的服务实际上已经作为 Windows 服务被安装在系统中了，你需要停止（不需要卸载）这个正在运行的服务，才可以正常调试。</p>
<h2 id="后续-1"><a href="#后续-1" class="headerlink" title="后续"></a>后续</h2><p>&emsp;&emsp;在上一篇中，有读者指出 .NET Core 中实际上已经提供了一种完全不同的方式运行 Windows 服务。它的实质是利用了 ASP.NET Core 中引入的 “ 托管服务 ” 模型，并允许它们作为 Windows 服务来运行，这真的是非常的棒。</p>
<h1 id="使用-NET-Core-工作器方式"><a href="#使用-NET-Core-工作器方式" class="headerlink" title="使用 .NET Core 工作器方式"></a>使用 .NET Core 工作器方式</h1><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>&emsp;&emsp;这里首先你要确保你已经安装了 .NET Core 3.0 或以上版本。在我编写这篇文章的时候，.NET Core 3.1 刚刚发布，Visual Studio 应该会提示你升级到最新版本。但是如果你想要在 .NET Core 2.x 项目中使用这个方式，应该是行不通的。<br>&emsp;&emsp;如果你喜欢使用命令行创建项目，你就需要使用工作器（worker）类型创建项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet new worker</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果你是一个和我一样喜欢使用 Visual Studio 的开发人员，那么你可以在 Visual Studio 中使用项目模板完成相同的功能。</p>
<figure class="image-box">
                <a rel=使用 .NET Core 创建 Windows 服务 href="65831-20191214083435124-1006535101.png" title="" data-fancybox="images"><img src="65831-20191214083435124-1006535101.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;这样做将创建出一个包含两个文件的项目。其中 <code>Program.cs</code> 文件是应用的启动 “ 引导程序 ” 。另外一个文件是 <code>worker.cs</code> 文件，在这个文件中，你可以编写你的服务逻辑。<br>&emsp;&emsp;这看起来应该是相当的容易，但是为这个程序添加额外的并行后台服务，你还需要添加一个类，并让它继承 <code>BackgroundService</code> 类：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyNewBackgroundWorker</span> : <span class="title">BackgroundService</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> Task <span class="title">ExecuteAsync</span>(<span class="params">CancellationToken stoppingToken</span>)    </span></span><br><span class="line"><span class="function"></span>    &#123;        </span><br><span class="line">        <span class="comment">//Do something.     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在 <code>Program.cs</code> 中，我们要做的只是把当前的 Worker 注册到服务集合（Service Collection）中即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.ConfigureServices((hostContext, services) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    services.AddHostedService&lt;Worker&gt;();</span><br><span class="line">    services.AddHostedService&lt;MyNewBackgroundWorker&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;实际上作为 “ 后台服务 ” 任务的运行程序，<code>AddHostedService</code> 方法已经在框架中存在了很长时间了。在之前我们已经完成的一篇关于<a href="https://dotnetcoretutorials.com/2019/01/13/hosted-services-in-asp-net-core/" target="_blank" rel="noopener"> ASP.NET Core 托管服务</a>的文章， 但是在当时场景中，我们托管是是整个应用，而非一个在你应用程序幕后运行的东西。  </p>
<h2 id="运行-调试我们的应用"><a href="#运行-调试我们的应用" class="headerlink" title="运行 / 调试我们的应用"></a>运行 / 调试我们的应用</h2><p>&emsp;&emsp;在默认的工作器（worker）模板中，已经包含了一个后台服务，这个服务可以将当前时间输出到控制台窗口。下面让我们点击 F5 来运行程序，看看我们能得到什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">info: CoreWorkerService.Worker[0]      </span><br><span class="line">      Worker running at: 12/07/2019 08:20:30 +13:00</span><br><span class="line">info: Microsoft.Hosting.Lifetime[0]      </span><br><span class="line">      Application started. Press Ctrl+C to shut down.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在我们启动程序之后，程序立刻就运行了！我们可以保持控制台的打开状态来调试应用，或者直接关闭窗口退出。相较于使用 “ Microsoft “ 方式来调试一个 Windows 服务，这简直就是天堂。<br>&emsp;&emsp;这里我们需要注意的另外一件事情是编写控制台程序的平台。在最后，我们不仅在控制台窗口输出了时间，还通过依赖注入创建了一个托管 worker。我们也可以使用依赖注入容器来注入仓储，配置环境变量，获取配置等。<br>&emsp;&emsp;但这里我们还没有做的事情是，将这个应用转换为 Windows 服务。  </p>
<h2 id="将我们的应用转换成-Windows-服务"><a href="#将我们的应用转换成-Windows-服务" class="headerlink" title="将我们的应用转换成 Windows 服务"></a>将我们的应用转换成 Windows 服务</h2><p>&emsp;&emsp;为了将应用转换成 Windows 服务，我们需要使用如下命令引入一个包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.Extensions.Hosting.WindowsServices</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下一步，我们需要修改 <code>Program.cs</code> 文件，添加 <code>UseWindowsService()</code> 方法的调用。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt; </span><br><span class="line">    Host.CreateDefaultBuilder(args)    </span><br><span class="line">        .ConfigureServices((hostContext, services) =&gt;    </span><br><span class="line">        &#123;        </span><br><span class="line">            services.AddHostedService&lt;Worker&gt;();   </span><br><span class="line">         &#125;)</span><br><span class="line">         .UseWindowsService();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上就是所有需要变更的代码。<br>&emsp;&emsp;运行我们的程序，你会发现和之前的效果完全样。但是这里最大的区别是，我们可以将当前应用以 Windows 服务的形式安装了。<br>&emsp;&emsp;为了实现这一目的，我们需要发布当前项目。在当前项目目录中，我们可以运行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet publish -r win-x64 -c Release</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们就可以借助标准的 Windows 服务安装器来安装当前服务了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc create TestService BinPath=C:\full\path\to\publish\dir\WindowsServiceExample.exe</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当前，你也可以使用 Windows 服务安装器的其他命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start TestServicesc stop TestServicesc delete TestService</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后检查一下我们的服务面板。</p>
<figure class="image-box">
                <a rel=使用 .NET Core 创建 Windows 服务 href="65831-20191214083446395-754761263.png" title="" data-fancybox="images"><img src="65831-20191214083446395-754761263.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;服务已经正常工作了。</p>
<h2 id="在-Linux-中运行服务"><a href="#在-Linux-中运行服务" class="headerlink" title="在 Linux 中运行服务"></a>在 Linux 中运行服务</h2><p>&emsp;&emsp;老实说，我没有太多的Linux经验，但是终归是需要了解一下…<br>&emsp;&emsp;在 Linux 系统中, 如果你希望我们编写的 “ Windows ” 服务在 Linux 系统中作为服务运行，你需要做以下 2 步：</p>
<ul>
<li>使用 <code>Microsoft.Extensions.Hosting.Systemd</code> 替换之前的 <code>Microsoft.Extensions.Hosting.WindowsServices</code>。</li>
<li>使用 <code>UseSystemd()</code> 替换 <code>UseWindowsService()</code>。</li>
</ul>
<h1 id="Microsoft-vs-Topshelf-vs-NET-Core-Workers"><a href="#Microsoft-vs-Topshelf-vs-NET-Core-Workers" class="headerlink" title="Microsoft vs Topshelf vs .NET Core Workers"></a>Microsoft vs Topshelf vs .NET Core Workers</h1><p>&emsp;&emsp;到现在为止，我们已经介绍了借助 3 种不同的方式来创建 Windows 服务。<br>&emsp;&emsp;你可能会问 “ 好吧，那我到底应该选择哪一种 ？”<br>&emsp;&emsp;这里呢，我们可以首先把 “ Microsoft “ 这种老派学院式的方式抛弃。以为它的调试实在是太麻烦了，而且没有什么实际的用处。<br>&emsp;&emsp;然后剩下的就是 <code>Topshelf</code> 和 .NET Core 工作器两种方式了。在我看来，.NET Core 工作器，已经很好的融入 .NET Core 生态系统，如果你正在开发 ASP.NET Core 应用，那么使用 .NET Core 工作器就很有意义。最重要的是，当你创建一个后台服务的时候，你可以让它在一个 ASP.NET Core 网站中的任意位置运行，这非常的方便。但是缺点是安装。你必须使用 <code>SC</code> 命令来安装服务。这一部分 <code>Topshelf</code> 可能更胜一筹。<br>&emsp;&emsp;<code>Topshelf</code> 总体上将非常的友好，并且具有最好的安装方式，但是使用额外的库，也增加了学习的成本。<br>&emsp;&emsp;所以 <code>Topshelf</code> 和 .NET Core 工作器，大家可以自行选择，都是不错的方案。  </p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-12-19T15:15:56.286Z" itemprop="dateUpdated">2019-12-19 23:15:56</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/12/14/CreatingWindowsServicesInDotNetCore/" target="_blank" rel="external">https://tao-lol.top/2019/12/14/CreatingWindowsServicesInDotNetCore/</a>
        
    </div>
    <footer>
        <a href="https://tao-lol.top">
            <img src="/img/avatar.jpg" alt="濤">
            濤
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSharp/">CSharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dotNET/">dotNET</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tao-lol.top/2019/12/14/CreatingWindowsServicesInDotNetCore/&title=《使用 .NET Core 创建 Windows 服务》 — Blog&pic=https://tao-lol.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tao-lol.top/2019/12/14/CreatingWindowsServicesInDotNetCore/&title=《使用 .NET Core 创建 Windows 服务》 — Blog&source=
作者：Dotnet Core Tutorials原文：

Part 1 - The “Microsoft” Way: https://dotnetcor..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/12/18/SyncIOAndAsyncIO/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Windows 内核原理 - 同步 I/O 与异步 I/O</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/12/14/IOInterruptionPrinciple/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">I/O 中断原理</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#使用官方推荐方式"><span class="post-toc-number">1.</span> <span class="post-toc-text">使用官方推荐方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#安装"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">安装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#代码"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#服务部署"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">服务部署</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#服务调试"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">服务调试</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#后续"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">后续</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#使用-Topshelf-方式"><span class="post-toc-number">2.</span> <span class="post-toc-text">使用 Topshelf 方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#安装-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">安装</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#代码-1"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">代码</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#部署服务"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">部署服务</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#调试服务"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">调试服务</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#后续-1"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">后续</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#使用-NET-Core-工作器方式"><span class="post-toc-number">3.</span> <span class="post-toc-text">使用 .NET Core 工作器方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#安装步骤"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">安装步骤</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#运行-调试我们的应用"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">运行 / 调试我们的应用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#将我们的应用转换成-Windows-服务"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">将我们的应用转换成 Windows 服务</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#在-Linux-中运行服务"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">在 Linux 中运行服务</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Microsoft-vs-Topshelf-vs-NET-Core-Workers"><span class="post-toc-number">4.</span> <span class="post-toc-text">Microsoft vs Topshelf vs .NET Core Workers</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://tao-lol.top" target="_blank">Home</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/hexojs/hexo" target="_blank">Hexo</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">Mellow</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                濤 &copy; 2018 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tao-lol.top/2019/12/14/CreatingWindowsServicesInDotNetCore/&title=《使用 .NET Core 创建 Windows 服务》 — Blog&pic=https://tao-lol.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tao-lol.top/2019/12/14/CreatingWindowsServicesInDotNetCore/&title=《使用 .NET Core 创建 Windows 服务》 — Blog&source=
作者：Dotnet Core Tutorials原文：

Part 1 - The “Microsoft” Way: https://dotnetcor..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACqUlEQVR42u3aQYojMRAEQP//07vXhcG9mVWS8UD0yWC7pdBBJVL1esXPn/Xz73vevfPduD8/H37w8PDwjk7952+eJ7d/2/M881Hw8PDwbvPyTTnZrNupP096Ni4eHh7ed/LaYpAfppPyg4eHh/dbeM/b/Woq8ULg4eHhfQPv1HE2jyHyUjGLPPDw8PDu8fJbpO/5fOV+Dw8PD+9CQ0AyzOaSLD+sR7PFw8PDu8DLN9wWP1uaTeD7dmnw8PDwjvLaELbelEfgU41feHh4ePd47ZBt8DprO8ivyt4WDDw8PLwLvDYLnW33++KRxLtDKh4eHl7JS/6QxwRtOJtf/OfB8atdDzw8PLySl8Bmw+fH4rwg1WEEHh4e3gVeEjqcXYI8tjhQHvDw8PA+wjvQJFq+v81Oiks7PDw8vGu8vAmgbTLIA99ZOfnPYuHh4eFd5uURQF4wktaBdtL5guLh4eHd4OVXX22skAeyZ4tQfQGGh4eHt+Dtj9ebxZpFIdE88fDw8I7y2pj1VGSQL+Km/QsPDw/vBi8/+LbVpo13N4sStSDg4eHhXeO1DQH51f7scxsZT7/Gw8PDW86/OEa3TVTPBWY20Tw0wcPDwzvFawGzdqvZUs6CYDw8PLzP8NqIdrZYbevqJqrAw8PD+wxvtpXnbQeziDaJm+uJ4uHh4a15Lfv21DdtB0XrFR4eHt4hXttGkAe7bdmYRbqv5EYODw8Pb8TbHItnkWtyCG4vzN5+i4eHh3eBd6pDqY2DN0fzpAjVDx4eHl7J2xx22yFnAfGqMODh4eFd47VNV7OCMWsXaA/oeHh4eN/Ge/5N3jKVv21WqPDw8PC+k7dZiPygnN9n1U1XeHh4eAtefvDNg4BT3Q0HCgMeHh7eUd5+yFmwO1vQfXiBh4eHt+D9BUSjIhaBkK8AAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
