<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>.NET Core 3.1 中的 Json 互操作最全解读 | Blog | tao-lol</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="CSharp,dotNET">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">濤</h5>
          <a href="mailto:tao-lol@qq.com" title="tao-lol@qq.com" class="mail">
            
              <span>t</span>
            
              <span>a</span>
            
              <span>o</span>
            
              <span>-</span>
            
              <span>l</span>
            
              <span>o</span>
            
              <span>l</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/Tao-lol" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>.NET Core 3.1 中的 Json 互操作最全解读</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">.NET Core 3.1 中的 Json 互操作最全解读</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-30T05:38:21.000Z" itemprop="datePublished" class="page-time">
  2019-12-30
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-UsingSystemTextJsonInNetCore31"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">.NET Core 3.1 中的 Json 互操作最全解读</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-30 13:38:21" datetime="2019-12-30T05:38:21.000Z"  itemprop="datePublished">2019-12-30</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <blockquote>
<p><a href="https://mp.weixin.qq.com/s/OSPxIGiJ1rRw1Sz-kZqgvQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OSPxIGiJ1rRw1Sz-kZqgvQ</a>  </p>
</blockquote>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;本文将会全面介绍 System.Text.Json 和 Newtonsoft.Json 的相同和异同之处，方便需要的同学做迁移使用。</p>
<h1 id="文档比较"><a href="#文档比较" class="headerlink" title="文档比较"></a>文档比较</h1><h2 id="几个重要的对象"><a href="#几个重要的对象" class="headerlink" title="几个重要的对象"></a>几个重要的对象</h2><p>&emsp;&emsp;在 System.Text.Json 中，有几个重量级的对象，所有的 JSON 互操作，都是围绕这几个对象进行，只要理解了他们各自的用途用法，就基本上掌握了 JSON 和实体对象的互操作。</p>
<h3 id="JsonDocument"><a href="#JsonDocument" class="headerlink" title="JsonDocument"></a>JsonDocument</h3><p>&emsp;&emsp;提供用于检查 JSON 值的结构内容，而不自动实例化数据值的机制。JsonDocument 有一个属性 RootElement，提供对JSON文档根元素的访问，RootElement 是一个 JsonElement 对象。</p>
<h3 id="JsonElement"><a href="#JsonElement" class="headerlink" title="JsonElement"></a>JsonElement</h3><p>&emsp;&emsp;提供对 JSON 值的访问，在 System.Text.Json 中，大到一个对象、数组，小到一个属性、值，都可以通过 JsonElement 进行互操作。</p>
<h3 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="JsonProperty"></a>JsonProperty</h3><p>&emsp;&emsp;JSON 中最小的单元，提供对属性、值的访问。</p>
<h3 id="JsonSerializer"><a href="#JsonSerializer" class="headerlink" title="JsonSerializer"></a>JsonSerializer</h3><p>&emsp;&emsp;提供 JSON 互操作的静态类，提供了一系列 Serializer / Deserialize 的互操作的方法，其中还有一些异步/流式操作方法。</p>
<h3 id="JsonSerializerOptions"><a href="#JsonSerializerOptions" class="headerlink" title="JsonSerializerOptions"></a>JsonSerializerOptions</h3><p>&emsp;&emsp;与上面的 JsonSerializer 配合使用，提供自定义的个性化互操作选项，包括命名、枚举转换、字符转义、注释规则、自定义转换器等等操作选项。</p>
<h3 id="Utf8JsonWriter-Utf8JsonReader"><a href="#Utf8JsonWriter-Utf8JsonReader" class="headerlink" title="Utf8JsonWriter / Utf8JsonReader"></a>Utf8JsonWriter / Utf8JsonReader</h3><p>&emsp;&emsp;这两个对象是整个 System.Text.Json 的核心对象，所有的JSON互操作几乎都是通过这两个对象进行，他们提供的高性能的底层读写操作。</p>
<h2 id="初始化一个简单的-JSON-对象"><a href="#初始化一个简单的-JSON-对象" class="headerlink" title="初始化一个简单的 JSON 对象"></a>初始化一个简单的 JSON 对象</h2><p>&emsp;&emsp;在 System.Text.Json 中，并未提供像 JToken 那样非常便捷的创建对象的操作，想要创建一个 JSON 对象，其过程是比较麻烦的，请看下面的代码，进行对比：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Newtonsoft.Json.Linq;</span></span><br><span class="line">JToken root = <span class="keyword">new</span> JObject();</span><br><span class="line">root[<span class="string">"Name"</span>] = <span class="string">"Ron"</span>;</span><br><span class="line">root[<span class="string">"Money"</span>] = <span class="number">4.5</span>;</span><br><span class="line">root[<span class="string">"Age"</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">string</span> jsonText = root.ToString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.Text.Json</span></span><br><span class="line"><span class="keyword">string</span> json = <span class="keyword">string</span>.Empty;</span><br><span class="line"><span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (Utf8JsonWriter writer = <span class="keyword">new</span> Utf8JsonWriter(ms))</span><br><span class="line">    &#123;</span><br><span class="line">        writer.WriteStartObject();</span><br><span class="line">        writer.WriteString(<span class="string">"Name"</span>, <span class="string">"Ron"</span>);</span><br><span class="line">        writer.WriteNumber(<span class="string">"Money"</span>, <span class="number">4.5</span>);</span><br><span class="line">        writer.WriteNumber(<span class="string">"Age"</span>, <span class="number">30</span>);</span><br><span class="line">        writer.WriteEndObject();</span><br><span class="line">        writer.Flush();</span><br><span class="line">    &#125;</span><br><span class="line">    json = Encoding.UTF8.GetString(ms.ToArray());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;System.Text.Json 的操作便利性在这方面目前处于一个比较弱的状态，不过，从这里也可以看出，可能官方并不希望我们去直接操作 JSON 源，而是通过操作实体对象以达到操作 JSON 的目的，也可能对互操作是性能比较自信的表现吧。</p>
<h2 id="封装和加载"><a href="#封装和加载" class="headerlink" title="封装和加载"></a>封装和加载</h2><p>&emsp;&emsp;在对 JSON 文档进行包装的用法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> jToken = Newtonsoft.Json.Linq.JToken.Parse(json);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我发现 MS 这帮人很喜欢使用 Document 这个词,包括 XmlDocument / XDocument 等等。</p>
<h2 id="查找元素（对象）"><a href="#查找元素（对象）" class="headerlink" title="查找元素（对象）"></a>查找元素（对象）</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> obj = jDoc.RootElement[<span class="number">0</span>];<span class="comment">// 这里会报错，索引仅支持 Array 类型的JSON文档</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jToken = Newtonsoft.Json.Linq.JToken.Parse(json);</span><br><span class="line"><span class="keyword">var</span> name = jToken[<span class="string">"name"</span>];</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你看，到查找元素环节就体现出差异了，JsonDocuemnt 索引仅支持 Array 类型的JSON文档，而 JToken 则支持 object 类型的索引（充满想象），用户体验高下立判。那我们不禁要提问了，如何在 JsonDocument 中查找元素？答案如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> enumerate = jDoc.RootElement.EnumerateObject();</span><br><span class="line"><span class="keyword">while</span> (enumerate.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (enumerate.Current.Name == <span class="string">"name"</span>)</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125;:&#123;1&#125;"</span>, enumerate.Current.Name, enumerate.Current.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从上面的代码来看，JsonElement 存在两个迭代器，分别是 EnumerateArray 和 EnumerateObject；通过迭代器，你可以实现查找元素的需求。你看，MS 关上了一扇门，然后又为了打开了一扇窗，还是很人性化的了。在 System.Text.Json 中，一切对象都是 Element，Object / Array / Property，都是 Element，这个概念和 XML 一致，但是和 Newtonsoft.Json 不同，这是需要注意的地方。<br>&emsp;&emsp;你也可以选择不迭代，直接获取对象的属性，比如使用下面的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> age = jDoc.RootElement.GetProperty(<span class="string">"age"</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段代码将抛出异常，因为属性 age 不存在，通常情况下，我们会立即想用一个 ContainsKey 来作一个判断，但是很可惜，JsonElement 并未提供该方法，而是提供了一个 TryGetProperty 方法；所以，除非你明确知道 json 对象中的属性，否则一般情况下，建议使用 TryGetProperty 进行取值。<br>&emsp;&emsp;就算是这样，使用 GetProperty / TryGetProperty 得到的值，还是一个 JsonElement 对象，并不是你期望的“值”。所以 JsonElement 很人性化的提供了各种 GetIntxx / GetString 方法，但是就算如此，还是可能产生意外，思考下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">"&#123;\"name\":\"Ron\",\"money\":4.5,\"age\":null&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> jDoc = System.Text.Json.JsonDocument.Parse(json);</span><br><span class="line"><span class="keyword">var</span> property = jDoc.RootElement.GetProperty(<span class="string">"age"</span>);</span><br><span class="line"><span class="keyword">var</span> age = property.GetInt32();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码，最后一行将抛出异常，因为你尝试从一个 null 到 int32 的类型转换，怎么解决这种问题呢，又回到了 JsonElement 上面来，他又提供了一个对值进行检查的方法：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (property.ValueKind == JsonValueKind.Number)   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> age = property.GetInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个时候，程序运行良好，JsonValueKind 枚举提供了一系列的类型标识，为了进一步缩小内存使用率，Json 团队用心良苦的将枚举值声明为：byte 类型（够抠）</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> JsonValueKind : <span class="keyword">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Undefined = <span class="number">0</span>,</span><br><span class="line">    Object = <span class="number">1</span>,</span><br><span class="line">    Array = <span class="number">2</span>,</span><br><span class="line">    String = <span class="number">3</span>,</span><br><span class="line">    Number = <span class="number">4</span>,</span><br><span class="line">    True = <span class="number">5</span>,</span><br><span class="line">    False = <span class="number">6</span>,</span><br><span class="line">    Null = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看到这里，你是不是有点想念 Newtonsoft.Json 了呢？别着急，下面我给大家介绍一个宝贝 System.Json.dll。</p>
<h2 id="System-Json"><a href="#System-Json" class="headerlink" title="System.Json"></a>System.Json</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>&emsp;&emsp;System.Json 提供了对 JSON 对象序列化的基础支持，但是也是有限的支持，请看下图：</p>
<figure class="image-box">
                <a rel=.NET Core 3.1 中的 Json 互操作最全解读 href="1.webp" title="" data-fancybox="images"><img src="1.webp" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;System.Json 目前已合并到 .NETCore-3.1 中，如果你希望使用他，需要单独引用：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Install-Package System.Json -Version <span class="number">4.7</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个 JSON 互操作包提供了几个常用的操作类型，从下面的操作类不难看出，提供的支持是非常有限的，而且效率上也不好说。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.Json.JsonArray</span><br><span class="line">System.Json.JsonObject</span><br><span class="line">System.Json.JsonPrimitive</span><br><span class="line">System.Json.JsonValue</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先，JsonObject 是实现 IDictionary 接口，并在内部维护一个 SortedDictionary 字典，所以他具备字典类的一切操作，比如索引等等，JsonArray 就更简单，也是一样的实现 IList 接口，然后同样的在内部维护一个 List 链表，以实现数组功能，对象的序列化都是通过 JsonValue 进行操作，序列化的方式也是非常的简单，就是对对像进行迭代，唯一值得称道的地方是，采用了流式处理。</p>
<h4 id="使用-System-Json-操作上面的查找过程如下"><a href="#使用-System-Json-操作上面的查找过程如下" class="headerlink" title="使用 System.Json 操作上面的查找过程如下"></a>使用 System.Json 操作上面的查找过程如下</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = System.Json.JsonObject.Parse(<span class="string">"&#123;\"name\":\"ron\"&#125;"</span>);</span><br><span class="line"><span class="keyword">if</span> (obj.ContainsKey(<span class="string">"age"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> age = obj[<span class="string">"age"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;令人遗憾的是，虽然 System.Json 已经合并到 .NETCore-3.1 的路线图中；但是，System.Text.Json 不提供对 System.Json 的互操作性，我们期待以后 System.Text.Json 也能提供 System.Json 的操作便利性。</p>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>&emsp;&emsp;基本知识已经介绍完成，下面我们进入 System.Text.Json 的内部世界一探究竟。</p>
<h3 id="互操作"><a href="#互操作" class="headerlink" title="互操作"></a>互操作</h3><p>&emsp;&emsp;思考下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Age"</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">user = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;目前为止，上面的代码工作良好。让我们对上面的代码稍作修改，将 JSON 字符串进行一个转小写的操作后再进行反序列化的操作：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"money"</span>:<span class="number">4.5</span>,<span class="string">"age"</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">user = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的代码可以正常运行，也不会抛出异常，你可以得到一个完整的 user 对象；但是，user 对象的属性值将会丢失！这是因为 System.Text.Json 默认采用的是区分大小写匹配的方式，为了解决这个问题，我们需要引入序列化操作个性化设置，请参考下面的代码，启用忽略大小写的设置：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"money"</span>:<span class="number">4.5</span>,<span class="string">"age"</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions()   </span><br><span class="line">&#123;</span><br><span class="line">    PropertyNameCaseInsensitive = <span class="literal">true</span>   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">user = JsonSerializer.Deserialize&lt;UserInfo&gt;(json,options);</span><br></pre></td></tr></table></figure>

<h3 id="格式化-JSON"><a href="#格式化-JSON" class="headerlink" title="格式化 JSON"></a>格式化 JSON</h3><p>&emsp;&emsp;现在你可以选择对序列化的 JSON 文本进行美化，而不是输出上面的压缩后的 JSON 文本，为了实现美化的效果，你仅仅需要在序列化的时候加入一个 WriteIndented 设置：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.WriteIndented = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="string">"你好，欢迎！"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"Ron"</span>,</span><br><span class="line">  <span class="string">"Money"</span>: <span class="number">4.5</span>,</span><br><span class="line">  <span class="string">"Age"</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">"Remark"</span>: <span class="string">"\u4F60\u597D\uFF0C\u6B22\u8FCE\uFF01"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你看，就是这么简单，但是你也发现了，上面的 Remark 属性在序列化后，中文被转义了，这就是接下来要解决的问题。</p>
<h3 id="字符转义的问题"><a href="#字符转义的问题" class="headerlink" title="字符转义的问题"></a>字符转义的问题</h3><p>&emsp;&emsp;在默认情况下，System.Text.Json 序列化程序对所有非 ASCII 字符进行转义；这就是中文被转义的根本原因。但是在内部，他又允许你自定义控制字符集的转义行为，这个设置就是：Encoder，比如下面的代码，对中文进行转义的例外设置，需要创建一个 TextEncoderSettings 对象，并将 UnicodeRanges.All 加入允许例外范围内，并使用 JavaScriptEncoder 根据 TextEncoderSettings 创建一个 JavaScriptEncoder 对象即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encoderSettings = <span class="keyword">new</span> TextEncoderSettings();</span><br><span class="line">encoderSettings.AllowRanges(UnicodeRanges.All);</span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.Encoder = JavaScriptEncoder.Create(encoderSettings);</span><br><span class="line">options.WriteIndented = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="string">"你好，欢迎！"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"Name"</span>: <span class="string">"Ron"</span>,</span><br><span class="line">  <span class="string">"Money"</span>: <span class="number">4.5</span>,</span><br><span class="line">  <span class="string">"Age"</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">"Remark"</span>: <span class="string">"你好，欢迎！"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;还有另外一种模式，可以不必设置例外而达到不转义的效果，这个模式就是 “非严格 JSON” 模式，将上面的 JavaScriptEncoder.Create(encoderSettings) 替换为下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;</span><br></pre></td></tr></table></figure>

<h3 id="序列化相关-异步-流式"><a href="#序列化相关-异步-流式" class="headerlink" title="序列化相关 - 异步/流式"></a>序列化相关 - 异步/流式</h3><p>&emsp;&emsp;System.Text.Josn 提供了一系列丰富的 JSON 互操作，这其中包含异步和流式处理，这点也是和 Newtonsoft.Json 最大的不同，但不管是那种方式，都要牢记，最后都是通过下面的两个类来实现：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.Text.Json.Utf8JsonReader</span><br><span class="line">System.Text.Json.Utf8JsonWriter</span><br></pre></td></tr></table></figure>

<h3 id="自定义-JSON-名称和值"><a href="#自定义-JSON-名称和值" class="headerlink" title="自定义 JSON 名称和值"></a>自定义 JSON 名称和值</h3><p>&emsp;&emsp;在默认情况下，输出的 JSON 属性名称保持和实体对象相同，包括大小写的都是一致的，枚举类型在默认情况下被序列化为数值类型。System.Text.JSON 提供了一系列的设置和扩展来帮助开发者实现各种自定义的需求。下面的代码可以设置默认的 JSON 属性名称，这个设置和 Newtonsoft.Json 基本一致。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;UserInfo 的 属性 Name 在输出为 JSON 的时候，其字段名称将为：name，其他属性保持大小写不变。</p>
<h3 id="对所有属性设置为-camel-大小写"><a href="#对所有属性设置为-camel-大小写" class="headerlink" title="对所有属性设置为 camel 大小写"></a>对所有属性设置为 camel 大小写</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    PropertyNamingPolicy = JsonNamingPolicy.CamelCase</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jsonSerializer.Serialize(user, options);</span><br></pre></td></tr></table></figure>

<h3 id="自定义名称策略"><a href="#自定义名称策略" class="headerlink" title="自定义名称策略"></a>自定义名称策略</h3><p>&emsp;&emsp;比如我们的系统，目前采用全小写的模式，那么我可以自定义一个转换器，并应用到序列化行为中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LowerCaseNamingPolicy</span> : <span class="title">JsonNamingPolicy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ConvertName</span>(<span class="params"><span class="keyword">string</span> name</span>)</span> =&gt; name.ToLower();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line"><span class="comment">// 应用策略</span></span><br><span class="line">options.PropertyNamingPolicy = <span class="keyword">new</span> LowerCaseNamingPolicy();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br></pre></td></tr></table></figure>

<h3 id="将枚举序列化为名称字符串而不是数值"><a href="#将枚举序列化为名称字符串而不是数值" class="headerlink" title="将枚举序列化为名称字符串而不是数值"></a>将枚举序列化为名称字符串而不是数值</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line"><span class="comment">// 添加转换器</span></span><br><span class="line">options.Converters.Add(<span class="keyword">new</span> JsonStringEnumConverter());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br></pre></td></tr></table></figure>

<h2 id="排除不需要序列化的属性"><a href="#排除不需要序列化的属性" class="headerlink" title="排除不需要序列化的属性"></a>排除不需要序列化的属性</h2><p>&emsp;&emsp;在默认情况下，所有公共属性将被序列化为 JSON。但是，如果你不想让某些属性出现在 JSON 中，可以通过下面的几种方式实现属性排除。</p>
<h3 id="排除所有属性值为-null-属性"><a href="#排除所有属性值为-null-属性" class="headerlink" title="排除所有属性值为 null 属性"></a>排除所有属性值为 null 属性</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;</span><br><span class="line">options.IgnoreNullValues = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出，可以看到，Remark 属性被排除</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Age"</span>:<span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除指定标记属性"><a href="#排除指定标记属性" class="headerlink" title="排除指定标记属性"></a>排除指定标记属性</h3><p>&emsp;&emsp;可以为某个属性应用 JsonIgnore 特性，标记为不输出到 JSON。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonIgnore</span>]<span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark =<span class="literal">null</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出，属性 Age  已被排除</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Remark"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除所有只读属性"><a href="#排除所有只读属性" class="headerlink" title="排除所有只读属性"></a>排除所有只读属性</h3><p>&emsp;&emsp;还可以选择对所有只读属性进行排查输出 JSON，比如下面的代码，Password 是不需要输出的，那么我们只需要将 Password 设置为 getter，并应用 IgnoreReadOnlyProperties = true 即可。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonIgnore</span>] <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Password &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    IgnoreReadOnlyProperties = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="literal">null</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Remark"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排除派生类的属性"><a href="#排除派生类的属性" class="headerlink" title="排除派生类的属性"></a>排除派生类的属性</h3><p>&emsp;&emsp;在某些情况下，由于业务需求的不同，需要实现实体对象的继承，但是在输出 JSON 的时候，希望只输出基类的属性，而不要输出派生类型的属性，以避免产生不可控制的数据泄露问题；那么，我们可以采用下面的序列化设置。比如下面的 UserInfoExtension 派生自 UserInfo，并扩展了一个属性为身份证的属性，在输出 JSON 的时候，我们希望不要序列化派生类，那么我们可以在 Serialize 序列化的时候，指定序列化的类型为基类：UserInfo，即可达到隐藏派生类属性的目的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">JsonPropertyName(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">decimal</span> Money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonIgnore</span>] <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Password &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Remark &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfoExtension</span> : <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> IdCard &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfoExtension &#123; Name = <span class="string">"Ron"</span>, Money = <span class="number">4.5</span>m, Age = <span class="number">30</span>, Remark = <span class="literal">null</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, <span class="keyword">typeof</span>(UserInfo));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>,<span class="string">"Money"</span>:<span class="number">4.5</span>,<span class="string">"Password"</span>:<span class="number">0</span>,<span class="string">"Remark"</span>:<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="仅输出指定属性（排除属性的逆向操作）"><a href="#仅输出指定属性（排除属性的逆向操作）" class="headerlink" title="仅输出指定属性（排除属性的逆向操作）"></a>仅输出指定属性（排除属性的逆向操作）</h3><p>&emsp;&emsp;在 Newtonsoft.Json 中，我们可以通过指定 MemberSerialization 和 JsonProperty 来实现输出指定属性到 JSON 中，比如下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Newtonsoft.Json.JsonObject(Newtonsoft.Json.MemberSerialization.OptIn)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Newtonsoft.Json.JsonProperty(<span class="meta-string">"name"</span>)</span>] <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo() &#123; Age = <span class="number">18</span>, Name = <span class="string">"Ron"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> json = Newtonsoft.Json.JsonConvert.SerializeObject(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"Ron"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不过，很遗憾的告诉大家，目前 System.Text.Json 不支持这种方式；为此，我特意去看了 corefx 的 issue，我看到了下面这个反馈：</p>
<figure class="image-box">
                <a rel=.NET Core 3.1 中的 Json 互操作最全解读 href="2.webp" title="" data-fancybox="images"><img src="2.webp" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在确定方向了，当 .NETCore 合并到主分支 .NET 也就是 .NET5.0 的时候，官方将提供支持，在此之前，还是使用推荐 Newtonsoft.Json 。</p>
<h3 id="在反序列化的时候，允许-JSON-文本包含注释"><a href="#在反序列化的时候，允许-JSON-文本包含注释" class="headerlink" title="在反序列化的时候，允许 JSON 文本包含注释"></a>在反序列化的时候，允许 JSON 文本包含注释</h3><p>&emsp;&emsp;默认情况下，System.Text.JSON 不支持源 JSON 文本包含注释，比如下面的代码，当你不使用 ReadCommentHandling = JsonCommentHandling.Skip 的设置的时候，将抛出异常，因为在字段 Age 的后面有注释 /* age */。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonText = <span class="string">"&#123;\"Name\":\"Ron\",\"Money\":4.5,\"Age\":30/* age */&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    ReadCommentHandling = JsonCommentHandling.Skip,</span><br><span class="line">    AllowTrailingCommas = <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> user = JsonSerializer.Deserialize&lt;UserInfoExtension&gt;(jsonText);</span><br></pre></td></tr></table></figure>

<h3 id="允许字段溢出"><a href="#允许字段溢出" class="headerlink" title="允许字段溢出"></a>允许字段溢出</h3><p>&emsp;&emsp;在接口数据出现变动时，极有可能出现源 JSON 文本和实体对象属性不匹配的问题，JSON 中可能会多出一些实体对象不存在的属性，这种情况我们称之为“溢出”，在默认情况下，溢出的属性将被忽略，如果希望捕获这些“溢出”的属性，可以在实体对象中声明一个类型为：Dictionary 的属性，并对其应用特性标记：JsonExtensionData。<br>&emsp;&emsp;为了演示这种特殊的处理，我们声明了一个实体对象 UserInfo，并构造了一个 JSON 源，该 JSON 源包含了一个 UserInfo 不存在的属性：Money，预期该 Money 属性将被反序列化到属性 ExtensionData 中。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonExtensionData</span>] <span class="keyword">public</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">object</span>&gt; ExtensionData &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="string">"&#123;\"Name\":\"Ron\",\"Money\":4.5,\"Age\":30&#125;"</span>;</span><br><span class="line"><span class="keyword">var</span> user = JsonSerializer.Deserialize&lt;UserInfo&gt;(jsonText);</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=.NET Core 3.1 中的 Json 互操作最全解读 href="3.webp" title="输出截图" data-fancybox="images"><img src="3.webp" alt="输出截图" title class></a>
                <p>输出截图</p>
            </figure>

<p>&emsp;&emsp;有意思的是，被特性 JsonExtensionData 标记的属性，在序列化为 JSON 的时候，他又会将 ExtensionData 的字典都序列化为单个 JSON 的属性，这里不再演示，留给大家去体验。</p>
<h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p>&emsp;&emsp;System.Text.Json 内置了各种丰富的类型转换器，这些默认的转换器在程序初始化 JsonSerializerOptions 的时候就默认加载，在 JsonSerializerOptions 内部，维护着一个私有静态成员 s_defaultSimpleConverters，同时还有一个公有属性 Converters ，Converters 属性在 JsonSerializerOptions 的构造函数中被初始化；从下面的代码中可以看到，默认转换器集合和公有转换器集是相互独立的，System.Text.Json 允许开发人员通过 Converters 添加自定义的转换器。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">JsonSerializerOptions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The global list of built-in simple converters.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;Type, JsonConverter&gt; s_defaultSimpleConverters = GetDefaultSimpleConverters();</span><br><span class="line">    <span class="comment">// The global list of built-in converters that override CanConvert().</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> List&lt;JsonConverter&gt; s_defaultFactoryConverters = GetDefaultConverters();</span><br><span class="line">    <span class="comment">// The cached converters (custom or built-in).</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ConcurrentDictionary&lt;Type, JsonConverter&gt; _converters = <span class="keyword">new</span> ConcurrentDictionary&lt;Type, JsonConverter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Dictionary&lt;Type, JsonConverter&gt; <span class="title">GetDefaultSimpleConverters</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;JsonConverter&gt; <span class="title">GetDefaultConverters</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IList&lt;JsonConverter&gt; Converters &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置转换器"><a href="#内置转换器" class="headerlink" title="内置转换器"></a>内置转换器</h3><p>&emsp;&emsp;在 System.Text.Json 内置的转换器集合中，涵盖了所有的基础数据类型，这些转换器的设计非常精妙，他们通过注册一系列的类型映射，在通过 Utf8JsonWriter / Utf8JsonReader 的内置方法 GetTypeValue / TryGetTypeValue 方法得到值，代码非常精练，复用性非常高，下面是内置类型转换器：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> IEnumerable&lt;JsonConverter&gt; DefaultSimpleConverters</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// When adding to this, update NumberOfSimpleConverters above.</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterBoolean</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterByte</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterByteArray</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterChar</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDateTime</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDateTimeOffset</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDouble</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterDecimal</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterGuid</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterInt16</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterInt32</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterInt64</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterJsonElement</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterObject</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterSByte</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterSingle</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterString</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUInt16</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUInt32</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUInt64</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">JsonConverterUri</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>&emsp;&emsp;虽然 System.Text.Json 内置了各种各样丰富的类型转换器，但是在各种业务开发的过程中，总会根据业务需求来决定一些特殊的数据类型的数据，下面，我们就以经典的日期/时间转换作为演示场景。<br>&emsp;&emsp;我们需要将日期类型输出为 Unix 时间戳而不是格式化的日期内容，为此，我们将实现一个自定义的时间格式转换器，该转换器继承自 JsonConverter。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JsonConverterUnixDateTime : JsonConverter&lt;DateTime&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DateTime Greenwich_Mean_Time = TimeZoneInfo.ConvertTime(<span class="keyword">new</span> DateTime(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>), TimeZoneInfo.Local);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> Limit = <span class="number">10000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DateTime <span class="title">Read</span>(<span class="params"><span class="keyword">ref</span> Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader.TokenType == JsonTokenType.Number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> unixTime = reader.GetInt64();</span><br><span class="line">            <span class="keyword">var</span> dt = <span class="keyword">new</span> DateTime(Greenwich_Mean_Time.Ticks + unixTime * Limit);</span><br><span class="line">            <span class="keyword">return</span> dt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> reader.GetDateTime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Write</span>(<span class="params">Utf8JsonWriter writer, DateTime <span class="keyword">value</span>, JsonSerializerOptions options</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> unixTime = (<span class="keyword">value</span> - Greenwich_Mean_Time).Ticks / Limit;</span><br><span class="line">        writer.WriteNumberValue(unixTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用自定义的时间转换器"><a href="#应用自定义的时间转换器" class="headerlink" title="应用自定义的时间转换器"></a>应用自定义的时间转换器</h3><p>&emsp;&emsp;转换器的应用形式有两种，分别是将转换加入 JsonSerializerOptions.Converters 和给需要转换的属性添加特性标记 JsonConverter。</p>
<h4 id="加入Converters-方式"><a href="#加入Converters-方式" class="headerlink" title="加入Converters 方式"></a>加入Converters 方式</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = <span class="keyword">new</span> JsonSerializerOptions();</span><br><span class="line">options.Converters.Add(<span class="keyword">new</span> JsonConverterUnixDateTime());</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo() &#123; Age = <span class="number">30</span>, Name = <span class="string">"Ron"</span>, LoginTime = DateTime.Now &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user, options);</span><br><span class="line"><span class="keyword">var</span> deUser = JsonSerializer.Deserialize&lt;UserInfo&gt;(json, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 输出</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Ron"</span>,<span class="string">"Age"</span>:<span class="number">30</span>,<span class="string">"LoginTime"</span>:<span class="number">1577655080422</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用-JsonConverter-特性方式"><a href="#应用-JsonConverter-特性方式" class="headerlink" title="应用 JsonConverter 特性方式"></a>应用 JsonConverter 特性方式</h4><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UserInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">JsonConverter(typeof(JsonConverterUnixDateTime))</span>]</span><br><span class="line">    <span class="keyword">public</span> DateTime LoginTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> UserInfo() &#123; Age = <span class="number">30</span>, Name = <span class="string">"Ron"</span>, LoginTime = DateTime.Now &#125;;</span><br><span class="line"><span class="keyword">var</span> json = JsonSerializer.Serialize(user);</span><br><span class="line"><span class="keyword">var</span> deUser = JsonSerializer.Deserialize&lt;UserInfo&gt;(json);</span><br><span class="line"></span><br><span class="line"><span class="comment">// JSON 输出</span></span><br><span class="line">&#123;<span class="string">"Name"</span>:<span class="string">"Ron"</span>,<span class="string">"Age"</span>:<span class="number">30</span>,<span class="string">"LoginTime"</span>:<span class="number">1577655080422</span>&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意上面的 UserInfo.LoginTime 的特性标记，当你想小范围的对某些属性单独应用转换器的时候，这种方式费用小巧而有效。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>&emsp;&emsp;本文全面的介绍了 System.Text.Json 在各种场景下的用法，并比较和 Newtonsoft.Json 使用上的不同，也通过实例演示了具体的使用方法，进一步深入讲解了 System.Text.Json 各种对象的原理，希望对大家在迁移到.NETCore-3.1 的时候有所帮助。</p>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-12-30T09:34:38.386Z" itemprop="dateUpdated">2019-12-30 17:34:38</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/12/30/UsingSystemTextJsonInNetCore31/" target="_blank" rel="external">https://tao-lol.top/2019/12/30/UsingSystemTextJsonInNetCore31/</a>
        
    </div>
    <footer>
        <a href="https://tao-lol.top">
            <img src="/img/avatar.jpg" alt="濤">
            濤
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSharp/">CSharp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dotNET/">dotNET</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tao-lol.top/2019/12/30/UsingSystemTextJsonInNetCore31/&title=《.NET Core 3.1 中的 Json 互操作最全解读》 — Blog&pic=https://tao-lol.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tao-lol.top/2019/12/30/UsingSystemTextJsonInNetCore31/&title=《.NET Core 3.1 中的 Json 互操作最全解读》 — Blog&source=
https://mp.weixin.qq.com/s/OSPxIGiJ1rRw1Sz-kZqgvQ  
" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2020/01/01/LearningGit/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Git 从入门到精通</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/12/30/WhatIsMessageQueuing/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">浅谈消息队列及常见的消息中间件</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#文档比较"><span class="post-toc-number">2.</span> <span class="post-toc-text">文档比较</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#几个重要的对象"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">几个重要的对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JsonDocument"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">JsonDocument</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JsonElement"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">JsonElement</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JsonProperty"><span class="post-toc-number">2.1.3.</span> <span class="post-toc-text">JsonProperty</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JsonSerializer"><span class="post-toc-number">2.1.4.</span> <span class="post-toc-text">JsonSerializer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#JsonSerializerOptions"><span class="post-toc-number">2.1.5.</span> <span class="post-toc-text">JsonSerializerOptions</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Utf8JsonWriter-Utf8JsonReader"><span class="post-toc-number">2.1.6.</span> <span class="post-toc-text">Utf8JsonWriter / Utf8JsonReader</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#初始化一个简单的-JSON-对象"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">初始化一个简单的 JSON 对象</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#封装和加载"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">封装和加载</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#查找元素（对象）"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">查找元素（对象）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#System-Json"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">System.Json</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#基本介绍"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">基本介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用-System-Json-操作上面的查找过程如下"><span class="post-toc-number">2.5.1.1.</span> <span class="post-toc-text">使用 System.Json 操作上面的查找过程如下</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#序列化和反序列化"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">序列化和反序列化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#互操作"><span class="post-toc-number">2.6.1.</span> <span class="post-toc-text">互操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#格式化-JSON"><span class="post-toc-number">2.6.2.</span> <span class="post-toc-text">格式化 JSON</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#字符转义的问题"><span class="post-toc-number">2.6.3.</span> <span class="post-toc-text">字符转义的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#序列化相关-异步-流式"><span class="post-toc-number">2.6.4.</span> <span class="post-toc-text">序列化相关 - 异步/流式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自定义-JSON-名称和值"><span class="post-toc-number">2.6.5.</span> <span class="post-toc-text">自定义 JSON 名称和值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#对所有属性设置为-camel-大小写"><span class="post-toc-number">2.6.6.</span> <span class="post-toc-text">对所有属性设置为 camel 大小写</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自定义名称策略"><span class="post-toc-number">2.6.7.</span> <span class="post-toc-text">自定义名称策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将枚举序列化为名称字符串而不是数值"><span class="post-toc-number">2.6.8.</span> <span class="post-toc-text">将枚举序列化为名称字符串而不是数值</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#排除不需要序列化的属性"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">排除不需要序列化的属性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排除所有属性值为-null-属性"><span class="post-toc-number">2.7.1.</span> <span class="post-toc-text">排除所有属性值为 null 属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排除指定标记属性"><span class="post-toc-number">2.7.2.</span> <span class="post-toc-text">排除指定标记属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排除所有只读属性"><span class="post-toc-number">2.7.3.</span> <span class="post-toc-text">排除所有只读属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#排除派生类的属性"><span class="post-toc-number">2.7.4.</span> <span class="post-toc-text">排除派生类的属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#仅输出指定属性（排除属性的逆向操作）"><span class="post-toc-number">2.7.5.</span> <span class="post-toc-text">仅输出指定属性（排除属性的逆向操作）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在反序列化的时候，允许-JSON-文本包含注释"><span class="post-toc-number">2.7.6.</span> <span class="post-toc-text">在反序列化的时候，允许 JSON 文本包含注释</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#允许字段溢出"><span class="post-toc-number">2.7.7.</span> <span class="post-toc-text">允许字段溢出</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#转换器"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">转换器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内置转换器"><span class="post-toc-number">2.8.1.</span> <span class="post-toc-text">内置转换器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自定义类型转换器"><span class="post-toc-number">2.8.2.</span> <span class="post-toc-text">自定义类型转换器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#应用自定义的时间转换器"><span class="post-toc-number">2.8.3.</span> <span class="post-toc-text">应用自定义的时间转换器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#加入Converters-方式"><span class="post-toc-number">2.8.3.1.</span> <span class="post-toc-text">加入Converters 方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#应用-JsonConverter-特性方式"><span class="post-toc-number">2.8.3.2.</span> <span class="post-toc-text">应用 JsonConverter 特性方式</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#结束语"><span class="post-toc-number">3.</span> <span class="post-toc-text">结束语</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://tao-lol.top" target="_blank">Home</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/hexojs/hexo" target="_blank">Hexo</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">Mellow</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                濤 &copy; 2018 - 2020
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tao-lol.top/2019/12/30/UsingSystemTextJsonInNetCore31/&title=《.NET Core 3.1 中的 Json 互操作最全解读》 — Blog&pic=https://tao-lol.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tao-lol.top/2019/12/30/UsingSystemTextJsonInNetCore31/&title=《.NET Core 3.1 中的 Json 互操作最全解读》 — Blog&source=
https://mp.weixin.qq.com/s/OSPxIGiJ1rRw1Sz-kZqgvQ  
" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACNklEQVR42u3awW6EMAxFUf7/p6nUVaVp4T4bKsW5WVUMFE4WlmP7OPA6vxf59fyxPq98Xr++5+ElQ4aMZRnn5SKv/Hwxv1J71y9UGTJkbMAgYfSvkNp/lpBuvlmGDBkyeOADCWKaVsqQIUNGGnDfC6wyZMiQcc0gh9jrF/DDLce/chaXIUPGgoy0MfCff7/Y35AhQ8YijLOxSOktTQGLXyJDhozRDF7o74xZ8BIeTyIPsmcyZMgYwei/mODTgYy48SBDhowNGOQYmSaL5KRZi5zFE7YMGTIWZ6QHSxKa+dbwZipKDWXIkDGU0Ql8fKii39S86cHKkCFjKIMfKWtNxzSVrLUNZMiQMZvRaTE+kNKFmxVXDWXIkDGOwQcpyJ2dUBtvnAwZMrZhpIfStOX51JBHnBrKkCFjBCMdlSAfx9ulnacO3ueUIUPGsgw+thUX6HHFvjNAJkOGjJ0Z/HP5MFmtURqEdRkyZIxm8E/kq7ZNvEgXBH0ZMmQMYtSaiP0QHMyDyJAhY2NGGjrTRman6MaTRRkyZOzA4A3LdDijVm6Lx8VkyJAxmhEXsPBT/USwleHKkCFjBOONIlqn0Jbeg3JbGTJkLM7oj0rURsRqBTuehsqQIWMegzcOyfAWL8Ol/+dmI2TIkLEBoxb4eAANSvzhkViGDBkyagfUtFWQtksfyDRlyJAxlJEGzU7hjGycDBkydmOkgxSkMVBrP7SK/jJkyBjK6AxVdBqfvDnKD8YyZMgYx/gCVRNgvmVgiwAAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
