<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>T-SQL 语言基础 | Blog | tao-lol</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="数据库">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.4">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	false,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">濤</h5>
          <a href="mailto:tao-lol@qq.com" title="tao-lol@qq.com" class="mail">
            
              <span>t</span>
            
              <span>a</span>
            
              <span>o</span>
            
              <span>-</span>
            
              <span>l</span>
            
              <span>o</span>
            
              <span>l</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/Tao-lol" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>T-SQL 语言基础</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">T-SQL 语言基础</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-01-13T09:57:24.000Z" itemprop="datePublished" class="page-time">
  2020-01-13
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-MicrosoftSQLServer2008T-SQLFundamentals"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">T-SQL 语言基础</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-01-13 17:57:24" datetime="2020-01-13T09:57:24.000Z"  itemprop="datePublished">2020-01-13</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <blockquote>
<p><a href="https://www.cnblogs.com/edisonchou/p/6106176.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/6106176.html</a><br>一：SQL Server 的体系结构<br>二：查询<br>三：表表达式<br>四：集合运算  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/edisonchou/p/6106755.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/6106755.html</a><br>五：透视、逆透视及分组<br>六：数据修改<br>八：可编程对象  </p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/edisonchou/p/6129717.html" target="_blank" rel="noopener">https://www.cnblogs.com/edisonchou/p/6129717.html</a><br>七：事务和并发  </p>
</blockquote>
<a id="more"></a>

<h1 id="SQL-Server-体系结构"><a href="#SQL-Server-体系结构" class="headerlink" title="SQL Server 体系结构"></a>SQL Server 体系结构</h1><h2 id="数据库的物理布局"><a href="#数据库的物理布局" class="headerlink" title="数据库的物理布局"></a>数据库的物理布局</h2><figure class="image-box">
                <a rel=T-SQL 语言基础 href="1.png" title="" data-fancybox="images"><img src="1.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;数据库在物理上由数据文件和事务日志文件组成，每个数据库必须至少有一个数据文件和一个日志文件。<br>&emsp;&emsp;（1）数据文件用于保存数据库对象数据。数据库必须至少有一个主文件组（Primary），而用户定义的文件组则是可选的。Primary 文件组包括 主数据文件（.mdf），以及数据库的系统目录（catalog）。可以选择性地为 Primary 增加多个辅助数据文件（.ndf）。用户定义的文件组只能包含辅助数据文件。<br>&emsp;&emsp;（2）日志文件则用于保存 SQL Server 为了维护事务而需要的信息。虽然 SQL Server 可以同时写多个数据文件，但同一时刻只能以顺序方式写一个日志文件。</p>
<blockquote>
<p><code>.mdf</code>、<code>.ldf</code>和<code>.ndf</code><br>&emsp;&emsp;<code>.mdf</code>代表 Master Data File，<code>.ldf</code>代表 Log Data File，而<code>.ndf</code>代表 Not Master Data File（非主数据文件）。</p>
</blockquote>
<h2 id="架构（Schema）和对象"><a href="#架构（Schema）和对象" class="headerlink" title="架构（Schema）和对象"></a>架构（Schema）和对象</h2><p>&emsp;&emsp;一个数据库包含多个架构，而每个架构又包括多个对象。可以将架构看作是各种对象的<strong>容器</strong>，这些对象可以是表（table）、视图（view）、存储过程（stored procedure）等等。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="2.png" title="" data-fancybox="images"><img src="2.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;此外，架构也是一个命名空间，用作对象名称的前缀。例如，架设在架构 Sales 中有一个 Orders 表，架构限定的对象名称是 Sales.Orders。如果在引用对象时省略架构名称，SQL Server 将采用一定的办法来分析出架构名称是什么。<strong>如果不显式指定架构，那么在解析对象名称时，就会要付出一些没有意义的额外代价。</strong>因此，建议都加上架构名称。</p>
<hr>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><p>（1）关于<code>SELECT</code>子句：使用<code>*</code>号是糟糕的习惯</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Sales.Shippers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在绝大多数情况下，使用星号是一种糟糕的编程习惯，在此还是建议大家即使需要查询表的所有列，也应该显式地指定它们。</p>
<p>（2）关于<code>FROM</code>子句：显示指定架构名称<br>&emsp;&emsp;通过显示指定架构名称，可以保证得到的对象的确是你原来想要的，而且还不必付出任何额外的代价。</p>
<p>（3）关于<code>TOP</code>子句：T-SQL 独有关键字<br>&emsp;&emsp;① 可以使用<code>PERCENT</code>关键字按百分比计算满足条件的行数；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP (<span class="number">1</span>) <span class="keyword">PERCENT</span> orderid, orderdate, custid, empid</span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> orderdate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这条 SQL 就会请求最近更新过的前 1% 个订单。</p>
<p>&emsp;&emsp;② 可以使用<code>WITH TIES</code>选项请求返回所有具有相同结果的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP (<span class="number">5</span>) <span class="keyword">WITH</span> <span class="keyword">TIES</span> orderid, orderdate, custid, empid</span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> orderdate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这条 SQL 请求返回与 TOP n 行中最后一行的排序值相同的其他所有行。</p>
<p>（4）关于<code>OVER</code>子句：为行定义一个窗口以便进行特定的运算<br>&emsp;&emsp;<code>OVER</code>子句的优点在于<strong>能够在返回基本列的同时，在同一行对它们进行聚合；也可以在表达式中混合使用基本列和聚合值列。</strong><br>&emsp;&emsp;例如，下面的查询为 OrderValues 的每一行计算当前价格占总价格的百分比，以及当前价格占客户总价格的百分比。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderid, custid, val,</span><br><span class="line"><span class="number">100.0</span> * val / <span class="keyword">SUM</span>(val) <span class="keyword">OVER</span>() <span class="keyword">AS</span> pctall,</span><br><span class="line"><span class="number">100.0</span> * val / <span class="keyword">SUM</span>(val) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> custid) <span class="keyword">AS</span> pctcust</span><br><span class="line"><span class="keyword">FROM</span> Sales.OrderValues;</span><br></pre></td></tr></table></figure>

<p>（5）子句的逻辑处理顺序</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="3.png" title="" data-fancybox="images"><img src="3.png" alt title class></a>
                <p></p>
            </figure>

<p>（6）运算符的优先级</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="4.png" title="" data-fancybox="images"><img src="4.png" alt title class></a>
                <p></p>
            </figure>

<p>（7）<code>CASE</code>表达式<br>&emsp;&emsp;① 简单表达式：将一个值与一组可能的取值进行比较，并返回满足第一个匹配的结果；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> productid,productname,categoryid,categoryname=(</span><br><span class="line">    <span class="keyword">CASE</span> categoryid</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'Beverages'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'Condiments'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span> <span class="string">'Confections'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'Dairy Products'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'Unkonw Category'</span></span><br><span class="line">    <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">FROM</span> Production.Products;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 搜索表达式：将返回结果为 <em>TRUE</em> 的第一个<code>WHEN</code>逻辑表达式所关联的<code>THEN</code>子句中指定的值。如果没有任何<code>WHEN</code>表达式结果为 <em>TRUE</em> ，<code>CASE</code>表达式则返回<code>ELSE</code>子句中出现的值。（如果没有指定<code>ELSE</code>，则默认返回 <em>NULL</em> ）；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderid, custid, val, valuecategory=(</span><br><span class="line">  <span class="keyword">CASE</span> </span><br><span class="line">    <span class="keyword">WHEN</span> val &lt; <span class="number">1000.00</span>    <span class="keyword">THEN</span> <span class="string">'Less than 1000'</span></span><br><span class="line">    <span class="keyword">WHEN</span> val <span class="keyword">BETWEEN</span> <span class="number">1000.00</span> <span class="keyword">AND</span> <span class="number">3000.00</span> <span class="keyword">THEN</span> <span class="string">'Between 1000 and 3000'</span></span><br><span class="line">    <span class="keyword">WHEN</span> val &gt; <span class="number">3000.00</span>    <span class="keyword">THEN</span> <span class="string">'More than 3000'</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">'Unknown'</span></span><br><span class="line">  <span class="keyword">END</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">FROM</span> Sales.OrderValues</span><br></pre></td></tr></table></figure>

<p>（8）三值谓词逻辑：<code>TRUE</code>、<code>FALSE</code>与<code>UNKNOWN</code><br>&emsp;&emsp;SQL 支持使用<code>NULL</code>表示缺少的值，它使用的是三值谓词逻辑，代表计算结果可以是<code>TRUE</code>、<code>FALSE</code>与<code>UNKNOWN</code>。在 SQL 中，对于<code>UNKNOWN</code>和<code>NULL</code>的处理不一致，这就需要我们在编写每一条查询语句时应该明确地注意到正在使用的是三值谓词逻辑。<br>&emsp;&emsp;例如，我们要请求返回 region 列不等于 WA 的所有行，则需要在查询过滤条件中显式地增加一个对 <em>NULL</em> 值的测试：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> custid, country, region, city</span><br><span class="line"><span class="keyword">FROM</span> Sales.Customers</span><br><span class="line"><span class="keyword">WHERE</span> region &lt;&gt; N<span class="string">'WA'</span></span><br><span class="line">  <span class="keyword">OR</span> region <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;另外，T-SQL 对于 <em>NULL</em> 值的处理是先输出 <em>NULL</em> 值再输出非 <em>NULL</em> 值的顺序，如果想要先输出非 <em>NULL</em> 值，则需要改变一下排序条件，例如下面的请求：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, region</span><br><span class="line"><span class="keyword">from</span> sales.Customers</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> region <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>), region;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当 region 列为 <em>NULL</em> 时返回 1，否则返回 0。非 <em>NULL</em> 值的表达式返回值为 0，因此，它们会排在 <em>NULL</em> 值（表达式返回 1）的前面。如上所示的将<code>CASE</code>表达式作为第一个拍序列，并把 region 列指定为第二个拍序列。这样，非 <em>NULL</em> 值也可以正确地参与排序，是一个完整解决方案的查询。</p>
<p>（9）<code>LIKE</code>谓词的花式用法<br>&emsp;&emsp;① <code>%</code>（百分号）通配符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'D%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>_</code>（下划线）通配符：下划线代表任意单个字符<br>&emsp;&emsp;下面请求返回 lastname 第二个字符为 e 的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'_e%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ <code>[&lt;字符列&gt;]</code>通配符：必须匹配指定字符中的一个字符<br>&emsp;&emsp;下面请求返回 lastname 以字符 A、B、C 开头的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'[ABC]%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ <code>[&lt;字符-字符&gt;]</code>通配符：必须匹配指定范围内中的一个字符<br>&emsp;&emsp;下面请求返回 lastname 以字符 A 到 E 开头的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'[A-E]%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;⑤ <code>[^&lt;字符-字符&gt;]</code>通配符：不属于特定字符序列或范围内的任意单个字符<br>&emsp;&emsp;下面请求返回 lastname 不以 A 到 E 开头的所有员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'[^A-E]%'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;⑥ <code>ESCAPE</code>转义字符<br>&emsp;&emsp;如果搜索包含特殊通配符的字符串（例如 <code>%</code>，<code>_</code>，<code>[</code>、<code>]</code>等），则必须使用转移字符。下面检查 lastname 列是否包含下划线：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empid, lastname</span><br><span class="line"><span class="keyword">FROM</span> HR.Employees</span><br><span class="line"><span class="keyword">WHERE</span> lastname <span class="keyword">LIKE</span> N<span class="string">'%!_%'</span> ESCAPE <span class="string">'!'</span>;</span><br></pre></td></tr></table></figure>

<p>（10）两种转换值的函数：<code>CAST</code>和<code>CONVERT</code><br>&emsp;&emsp;<code>CAST</code>和<code>CONVERT</code>都用于转换值的数据类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(SYSDATETIME() <span class="keyword">AS</span> <span class="built_in">DATE</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT</span>(<span class="built_in">CHAR</span>(<span class="number">8</span>),<span class="keyword">CURRENT_TIMESTAMP</span>,<span class="number">112</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要注意的是，<code>CAST</code>是 ANSI 标准的 SQL，而<code>CONVERT</code>不是。所以，除非需要使用样式值，否则<strong>推荐优先使用<code>CAST</code>函数，以保证代码尽可能与标准兼容。</strong></p>
<h2 id="联接查询"><a href="#联接查询" class="headerlink" title="联接查询"></a>联接查询</h2><p>（1）交叉联接：返回笛卡尔积，即 m*n 行的结果集</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CROSS JOIN</span></span><br><span class="line"><span class="keyword">select</span> c.custid, e.empid</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span> HR.Employees <span class="keyword">as</span> e;</span><br><span class="line"><span class="comment">-- INNER CROSS JOIN    </span></span><br><span class="line"><span class="keyword">select</span> e1.empid,e1.firstname,e1.lastname,</span><br><span class="line">    e2.empid,e2.firstname,e2.lastname</span><br><span class="line"><span class="keyword">from</span> hr.Employees <span class="keyword">as</span> e1</span><br><span class="line">    <span class="keyword">cross</span> <span class="keyword">join</span> hr.Employees <span class="keyword">as</span> e2;</span><br></pre></td></tr></table></figure>

<p>（2）内联接：先笛卡尔积，然后根据指定的谓词对结果进行过滤</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.empid,e.firstname,e.lastname,o.orderid</span><br><span class="line"><span class="keyword">from</span> hr.Employees <span class="keyword">as</span> e</span><br><span class="line">    <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">on</span> e.empid=o.empid;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;虽然不使用<code>JOIN</code>这种 ANSI SQL-92 标准语法也可以实现联接，但强烈推荐使用 ANSI SQL-92 标准，因为它用起来更加安全。比如，假如你要写一条内联接查询，如果不小心忘记了指定联接条件，如果这时候用的是 ANSI SQL-92 语法，那么语法分析器将会报错。</p>
</blockquote>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="5.png" title="" data-fancybox="images"><img src="5.png" alt title class></a>
                <p></p>
            </figure>

<p>（3）外联结：笛卡尔积 → 对结果过滤 → 添加外部行<br>&emsp;&emsp;通过例子来理解外联结：根据客户的客户 ID 和订单的客户 ID 来对 Customers 表和 Orders 表进行联接，并返回客户和他们的订单信息。该查询语句使用的联接类型是左外连接，所以查询结果也包括那些没有发出任何订单的客户；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--LEFT OUTER JOIN</span></span><br><span class="line"><span class="keyword">select</span> c.custid,c.companyname,o.orderid</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">  <span class="keyword">on</span> c.custid=o.custid;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;另外，需要注意的是在对外联结中非保留值得列值进行过滤时，不要在<code>WHERE</code>子句中指定错误的查询条件。<br>&emsp;&emsp;例如，下面请求返回在 2007 年 2 月 12 日下过订单的客户，以及他们的订单。同时也返回在 2007 年 2 月 12 日没有下过订单的客户。这是一个典型的左外连接的案例，但是我们经常会犯这样的错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.custid,c.companyname,o.orderid,o.orderdate</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">on</span> c.custid=o.custid </span><br><span class="line"><span class="keyword">where</span> o.orderdate=<span class="string">'20070212'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="6.png" title="" data-fancybox="images"><img src="6.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;这是因为对于所有的外部行，因为它们在 o.orderdate 列上的取值都为 <em>NULL</em> ，所以<code>WHERE</code>子句中条件 o.orderdate=’20070212’ 的计算结果为 <em>UNKNOWN</em> ，因此<code>WHERE</code>子句会过滤掉所有的外部行。<br>&emsp;&emsp;我们应该将这个条件搬到<code>on</code>后边：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> c.custid,c.companyname,o.orderid,o.orderdate</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line">    <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">on</span> c.custid=o.custid </span><br><span class="line">        <span class="keyword">and</span> o.orderdate=<span class="string">'20070212'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这下的执行结果如下：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="7.png" title="" data-fancybox="images"><img src="7.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>（1）独立子查询：不依赖于它所属的外部查询<br>&emsp;&emsp;例如下面要查询 Orders 表中订单 ID 最大的订单信息，这种叫做 独立标量子查询，即返回值不能超过一个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> orderid, orderdate, empid, custid</span><br><span class="line"><span class="keyword">from</span> sales.Orders</span><br><span class="line"><span class="keyword">where</span> empid=(<span class="keyword">select</span> <span class="keyword">MAX</span>(o.orderid) <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面请求查询返回姓氏以字符 D 开头的员工处理过的订单的 ID，这种叫做 独立多值子查询，即返回值可能有多个。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> orderid</span><br><span class="line"><span class="keyword">from</span> sales.Orders</span><br><span class="line"><span class="keyword">where</span> empid <span class="keyword">in</span> (<span class="keyword">select</span> e.empid </span><br><span class="line">    <span class="keyword">from</span> hr.Employees <span class="keyword">as</span> e</span><br><span class="line">    <span class="keyword">where</span> e.lastname <span class="keyword">like</span> N<span class="string">'D%'</span>);</span><br></pre></td></tr></table></figure>

<p>（2）相关子查询：必须依赖于它所属的外部查询，不能独立地调用它<br>&emsp;&emsp;例如下面的查询会返回每个客户的订单记录中订单 ID 最大的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, orderid, orderdate, empid</span><br><span class="line"><span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o1</span><br><span class="line"><span class="keyword">where</span> orderid=(<span class="keyword">select</span> <span class="keyword">MAX</span>(o2.orderid) </span><br><span class="line">    <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o2</span><br><span class="line">    <span class="keyword">where</span> o2.custid=o1.custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;简单地说，对于 o1 表中的每一行，子查询负责返回当前客户的最大订单 ID。如果 o1 表中某行的订单 ID 和子查询返回的订单 ID 匹配，那么 o1 中的这个订单 ID 就是当前客户的最大订单 ID，在这种情况下，查询便会返回 o1 表中的这个行。</p>
<p>（3）<code>EXISTS</code>谓词：它的输入是一个查询，如果子查询能够返回任何行，则返回 <em>True</em> ，否则返回 <em>False</em><br>&emsp;&emsp;例如下面的查询会返回下过订单的西班牙客户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, companyname</span><br><span class="line"><span class="keyword">from</span> sales.customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> c.country=N<span class="string">'Spain'</span> <span class="keyword">and</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">where</span> o.custid=c.custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样，要查询没有下过订单的西班牙客户只需要加上<code>NOT</code>即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, companyname</span><br><span class="line"><span class="keyword">from</span> sales.customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> c.country=N<span class="string">'Spain'</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line">    <span class="keyword">where</span> o.custid=c.custid);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;对于<code>EXISTS</code>，它采用的是二值逻辑（ <em>TRUE</em> 和 <em>FALSE</em> ），它只关心是否存在匹配行，而不考虑<code>SELECT</code>列表中指定的列，并且无须处理所有满足条件的行。可以将这种处理方式看做是一种“短路”，它<strong>能够提高处理效率</strong>。  　<br>&emsp;&emsp;另外，由于<code>EXISTS</code>采用的是二值逻辑，因此相较于<code>IN</code>要更加安全，可以避免对 <em>NULL</em> 值的处理。　</p>
</blockquote>
<p>（4）高级子查询<br>&emsp;&emsp;① 如何表示前一个或后一个记录？逻辑等式：上一个 -&gt; 小于当前值的最大值；下一个 -&gt; 大于当前值的最小值；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上一个订单ID</span></span><br><span class="line"><span class="keyword">select</span> orderid, orderdate, empid, custid,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">MAX</span>(o2.orderid) </span><br><span class="line"><span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o2</span><br><span class="line"><span class="keyword">where</span> o2.orderid&lt;o1.orderid</span><br><span class="line">) <span class="keyword">as</span> prevorderid </span><br><span class="line"><span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 如何实现连续聚合函数？在子查询中连续计算</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 连续聚合</span></span><br><span class="line"><span class="keyword">select</span> orderyear, qty, </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">SUM</span>(o2.qty) </span><br><span class="line"> <span class="keyword">from</span> sales.OrderTotalsByYear <span class="keyword">as</span> o2</span><br><span class="line"> <span class="keyword">where</span> o2.orderyear&lt;=o1.orderyear) <span class="keyword">as</span> runqty </span><br><span class="line"><span class="keyword">from</span> sales.OrderTotalsByYear <span class="keyword">as</span> o1</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> orderyear;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="8.png" title="" data-fancybox="images"><img src="8.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;③ 使用<code>NOT EXISTS</code>谓词取代<code>NOT IN</code>隐式排除 <em>NULL</em> 值：当对至少返回一个 <em>NULL</em> 值的子查询使用<code>NOT IN</code>谓词时，外部查询总会返回一个空集。（前面提到，<code>EXISTS</code>谓词采用的是二词逻辑而不是三词逻辑）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 隐式排除NULL值</span></span><br><span class="line"><span class="keyword">select</span> custid,companyname <span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></span><br><span class="line">(<span class="keyword">select</span> * </span><br><span class="line"> <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o</span><br><span class="line"> <span class="keyword">where</span> o.custid=c.custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;又如以下查询请求返回每个客户在 2007 年下过订单而在 2008 年没有下过订单的客户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> custid, companyname</span><br><span class="line"><span class="keyword">from</span> sales.Customers <span class="keyword">as</span> c</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o1</span><br><span class="line"> <span class="keyword">where</span> c.custid=o1.custid </span><br><span class="line"> <span class="keyword">and</span> o1.orderdate&gt;=<span class="string">'20070101'</span> <span class="keyword">and</span> o1.orderdate&lt;<span class="string">'20080101'</span>)</span><br><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span> </span><br><span class="line">(<span class="keyword">select</span> * <span class="keyword">from</span> sales.Orders <span class="keyword">as</span> o2</span><br><span class="line"> <span class="keyword">where</span> c.custid=o2.custid</span><br><span class="line"> <span class="keyword">and</span> o2.orderdate&gt;=<span class="string">'20080101'</span> <span class="keyword">and</span> o2.orderdate&lt;<span class="string">'20090101'</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="表表达式"><a href="#表表达式" class="headerlink" title="表表达式"></a>表表达式</h1><p>&emsp;&emsp;表表达式是一种命名的查询表达式，代表一个有效的关系表。可以像其他表一样，在数据处理中使用表表达式。MSSQL 中支持 4 种类型的表表达式：</p>
<h2 id="派生表"><a href="#派生表" class="headerlink" title="派生表"></a>派生表</h2><p>&emsp;&emsp;派生表（也称为表子查询）是在外部查询的 FROM 子句中定义的，只要外部查询一结束，派生表也就不存在了。<br>&emsp;&emsp;例如下面代码定义了一个名为 USACusts 的派生表，它是一个返回所有美国客户的查询。外部查询则选择了派生表的所有行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> custid, companyname </span><br><span class="line">      <span class="keyword">from</span> sales.Customers </span><br><span class="line">      <span class="keyword">where</span> country=<span class="string">'USA'</span>) <span class="keyword">as</span> USACusts;</span><br></pre></td></tr></table></figure>

<h2 id="公用表表达式"><a href="#公用表表达式" class="headerlink" title="公用表表达式"></a>公用表表达式</h2><p>&emsp;&emsp;公用表达式（简称 CTE，Common Table Expression）是和派生表很相似的另一种形式的表表达式，是 ANSI SQL（1999 及以后版本）标准的一部分。<br>&emsp;&emsp;举个栗子，下面的代码定义了一个名为 USACusts 的 CTE，它的内部查询返回所有来自美国的客户，外部查询则选择了 CTE 中的所有行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> USACusts <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> custid, companyname</span><br><span class="line">    <span class="keyword">from</span> sales.Customers </span><br><span class="line">    <span class="keyword">where</span> country=N<span class="string">'USA'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> USACusts;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;和派生表一样，一旦外部查询完成，CTE 的生命周期也就结束了。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>&emsp;&emsp;派生表和 CTE 都是不可重用的，而视图和内联表值函数却是可重用，它们的定义存储在一个数据库对象中，一旦创建，这些对象就是数据库的永久部分。只有用删除语句显式地删除，它们才会从数据库中移除。<br>&emsp;&emsp;下面仍然继续上面的例子，创建一个视图：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('Sales.USACusts') IS NOT NULL</span><br><span class="line">   <span class="keyword">DROP</span> <span class="keyword">VIEW</span> Sales.USACusts;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Sales.USACusts</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    custid, companyname, contactname, contacttitle, address,</span><br><span class="line">    city, region, postalcode, country, phone, fax</span><br><span class="line"><span class="keyword">FROM</span> Sales.Customers</span><br><span class="line"><span class="keyword">WHERE</span> country=N<span class="string">'USA'</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;使用该视图：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Sales.USACusts;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="9.png" title="" data-fancybox="images"><img src="9.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="内联表值函数"><a href="#内联表值函数" class="headerlink" title="内联表值函数"></a>内联表值函数</h2><p>&emsp;&emsp;内联表值函数能够支持输入参数，其他方面就与视图类似了。<br>&emsp;&emsp;下面演示如何创建函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('dbo.fn_GetCustOrders') IS NOT NULL</span><br><span class="line">   <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> dbo.fn_GetCustOrders;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dbo.fn_GetCustOrders</span><br><span class="line">    (@cid <span class="keyword">AS</span> <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">RETURN</span> </span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        orderid, custid, empid, orderdate, requireddate,</span><br><span class="line">        shippeddate, shipperid, freight, shipname, shipaddress, shipcity,</span><br><span class="line">        shipregion, shippostalcode, shipcountry</span><br><span class="line">    <span class="keyword">FROM</span> Sales.Orders</span><br><span class="line">    <span class="keyword">WHERE</span> custid=@cid;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如何使用函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> orderid, custid</span><br><span class="line"><span class="keyword">FROM</span> dbo.fn_GetCustOrders(<span class="number">1</span>) <span class="keyword">AS</span> CO;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="10.png" title="" data-fancybox="images"><img src="10.png" alt title class></a>
                <p></p>
            </figure>

<blockquote>
<p><strong>总结</strong>：<br>&emsp;&emsp;借助表表达式可以简化代码，提高代码地可维护性，还可以封装查询逻辑。<br>&emsp;&emsp;当需要使用表表达式，而且不计划重用它们的定义时，可以使用派生表或 CTE，与派生表相比，CTE 更加模块化，更容易维护。<br>&emsp;&emsp;当需要定义可重用的表表达式时，可以使用视图或内联表值函数。如果不需要支持输入，则使用视图；反之，则使用内联表值函数。</p>
</blockquote>
<hr>
<h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><h2 id="UNION-并集运算"><a href="#UNION-并集运算" class="headerlink" title="UNION 并集运算"></a>UNION 并集运算</h2><figure class="image-box">
                <a rel=T-SQL 语言基础 href="11.png" title="" data-fancybox="images"><img src="11.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 T-SQL 中，<code>UNION</code>集合运算可以将两个输入查询的结果组合成一个结果集。需要注意的是：如果一个行在任何一个输入集合众出现，它也会在<code>UNION</code>运算的结果中出现。T-SQL 支持以下两种选项：<br>（1）<code>UNION ALL</code>：不会删除重复行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union all</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果得到 100 行：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="12.png" title="" data-fancybox="images"><img src="12.png" alt title class></a>
                <p></p>
            </figure>

<p>（2）<code>UNION</code>：会删除重复行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- union</span></span><br><span class="line"><span class="keyword">select</span> country, region <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> country, region <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果得到 34 行：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="13.png" title="" data-fancybox="images"><img src="13.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="INTERSECT-交集运算"><a href="#INTERSECT-交集运算" class="headerlink" title="INTERSECT 交集运算"></a>INTERSECT 交集运算</h2><figure class="image-box">
                <a rel=T-SQL 语言基础 href="14.png" title="" data-fancybox="images"><img src="14.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 T-SQL 中，<code>INTERSECT</code>集合运算对两个输入查询的结果取其交集，只返回在两个查询结果集中都出现的行。<br>&emsp;&emsp;<code>INTERSECT</code>集合运算在逻辑上会首先删除两个输入集中的重复行，然后返回只在两个集合中中都出现的行。换句话说：如果一个行在两个输入集中都至少出现一次，那么交集返回的结果中将包含这一行。<br>&emsp;&emsp;例如，下面返回既是雇员地址，又是客户地址的不同地址：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- intersect</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="15.png" title="" data-fancybox="images"><img src="15.png" alt title class></a>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;这里需要说的是，集合运算对行进行比较时，<strong>认为两个 NULL 值相等</strong>，所以就返回该行记录。</p>
</blockquote>
<h2 id="EXCEPT-差集运算"><a href="#EXCEPT-差集运算" class="headerlink" title="EXCEPT 差集运算"></a>EXCEPT 差集运算</h2><figure class="image-box">
                <a rel=T-SQL 语言基础 href="16.png" title="" data-fancybox="images"><img src="16.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;在 T-SQL 中，集合之差使用<code>EXCEPT</code>集合运算实现的。它对两个输入查询的结果集进行操作，返回出现在第一个结果集中，但不出现在第二个结果集中的所有行。<br>&emsp;&emsp;<code>EXCEPT</code>结合运算在逻辑上首先删除两个输入集中的重复行，然后返回只在第一个集合中出现，在第二个结果集中不出现的所有行。换句话说：一个行能够被返回，仅当这个行在第一个输入的集合中至少出现过一次，而且在第二个集合中一次也没出现过。<br>&emsp;&emsp;此外，相比<code>UNION</code>和<code>INTERSECT</code>，两个输入集合的顺序是会影响到最后返回结果的。<br>&emsp;&emsp;例如，借助<code>EXCEPT</code>运算，我们可以方便地实现属于 A 但不属于 B 的场景，下面返回属于员工地址，但不属于客户地址的地址记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- except </span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="17.png" title="" data-fancybox="images"><img src="17.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="集合运算优先级"><a href="#集合运算优先级" class="headerlink" title="集合运算优先级"></a>集合运算优先级</h2><figure class="image-box">
                <a rel=T-SQL 语言基础 href="18.png" title="" data-fancybox="images"><img src="18.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;SQL 定义了集合运算之间的优先级：<code>INTERSECT</code>最高，<code>UNION</code>和<code>EXCEPT</code>相等。<br>&emsp;&emsp;换句话说：首先会计算<code>INTERSECT</code>，然后按照从左至右的出现顺序依次处理优先级相同的运算。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 集合运算的优先级</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> Production.Suppliers</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面这段 SQL 代码，因为<code>INTERSECT</code>优先级比<code>EXCEPT</code>高，所以首先进行<code>INTERSECT</code>交集运算。因此，这个查询的含义是：返回没有出现在员工地址和客户地址交集中的供应商地址。</p>
<h2 id="使用表表达式避开不支持的逻辑查询处理"><a href="#使用表表达式避开不支持的逻辑查询处理" class="headerlink" title="使用表表达式避开不支持的逻辑查询处理"></a>使用表表达式避开不支持的逻辑查询处理</h2><p>&emsp;&emsp;集合运算查询本身并不支持除<code>ORDER BY</code>以外的其他逻辑查询处理阶段，但可以通过表表达式来避开这一限制。<br>&emsp;&emsp;解决方案就是：首先根据包含集合运算的查询定义一个表表达式，然后在外部查询中对表表达式应用任何需要的逻辑查询处理。<br>（1）例如，下面的查询返回每个国家中不同的员工地址或客户地址的数量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> country, <span class="keyword">COUNT</span>(*) <span class="keyword">as</span> numlocations</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> country, region, city <span class="keyword">from</span> hr.Employees</span><br><span class="line">      <span class="keyword">union</span></span><br><span class="line">      <span class="keyword">select</span> country, region, city <span class="keyword">from</span> sales.Customers) <span class="keyword">as</span> U</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> country;</span><br></pre></td></tr></table></figure>

<p>（2）例如，下面的查询返回由员工地址为 3 或 5 的员工最近处理过的两个订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid,orderid,orderdate </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> top (<span class="number">2</span>) empid,orderid,orderdate </span><br><span class="line">    <span class="keyword">from</span> sales.Orders</span><br><span class="line">    <span class="keyword">where</span> empid=<span class="number">3</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">desc</span>,orderid <span class="keyword">desc</span>) <span class="keyword">as</span> D1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> empid,orderid,orderdate </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> top (<span class="number">2</span>) empid,orderid,orderdate </span><br><span class="line">    <span class="keyword">from</span> sales.Orders</span><br><span class="line">    <span class="keyword">where</span> empid=<span class="number">5</span></span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> orderdate <span class="keyword">desc</span>,orderid <span class="keyword">desc</span>) <span class="keyword">as</span> D2;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="透视、逆透视及分组"><a href="#透视、逆透视及分组" class="headerlink" title="透视、逆透视及分组"></a>透视、逆透视及分组</h1><h2 id="透视"><a href="#透视" class="headerlink" title="透视"></a>透视</h2><p>&emsp;&emsp;所谓透视（Pivoting）就是把数据从行的状态旋转为列的状态的处理。其处理步骤为：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="19.png" title="" data-fancybox="images"><img src="19.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;相信很多人在笔试或面试的时候被问到如何通过 SQL 实现行转列或列转行的问题，可能很多人当时懵逼了，没关系，下面我们通过例子来理解。<br>（1）准备数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.0准备数据</span></span><br><span class="line"><span class="keyword">USE</span> tempdb;</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.Orders', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Orders;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Orders</span><br><span class="line">(</span><br><span class="line">  orderid   <span class="built_in">INT</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  orderdate <span class="built_in">DATE</span>       <span class="keyword">NOT</span> <span class="literal">NULL</span>, <span class="comment">-- prior to SQL Server 2008 use DATETIME</span></span><br><span class="line">  empid     <span class="built_in">INT</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  custid    <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  qty       <span class="built_in">INT</span>        <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_Orders PRIMARY <span class="keyword">KEY</span>(orderid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid, qty)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">30001</span>, <span class="string">'20070802'</span>, <span class="number">3</span>, <span class="string">'A'</span>, <span class="number">10</span>),</span><br><span class="line">  (<span class="number">10001</span>, <span class="string">'20071224'</span>, <span class="number">2</span>, <span class="string">'A'</span>, <span class="number">12</span>),</span><br><span class="line">  (<span class="number">10005</span>, <span class="string">'20071224'</span>, <span class="number">1</span>, <span class="string">'B'</span>, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">40001</span>, <span class="string">'20080109'</span>, <span class="number">2</span>, <span class="string">'A'</span>, <span class="number">40</span>),</span><br><span class="line">  (<span class="number">10006</span>, <span class="string">'20080118'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">14</span>),</span><br><span class="line">  (<span class="number">20001</span>, <span class="string">'20080212'</span>, <span class="number">2</span>, <span class="string">'B'</span>, <span class="number">12</span>),</span><br><span class="line">  (<span class="number">40005</span>, <span class="string">'20090212'</span>, <span class="number">3</span>, <span class="string">'A'</span>, <span class="number">10</span>),</span><br><span class="line">  (<span class="number">20002</span>, <span class="string">'20090216'</span>, <span class="number">1</span>, <span class="string">'C'</span>, <span class="number">20</span>),</span><br><span class="line">  (<span class="number">30003</span>, <span class="string">'20090418'</span>, <span class="number">2</span>, <span class="string">'B'</span>, <span class="number">15</span>),</span><br><span class="line">  (<span class="number">30004</span>, <span class="string">'20070418'</span>, <span class="number">3</span>, <span class="string">'C'</span>, <span class="number">22</span>),</span><br><span class="line">  (<span class="number">30007</span>, <span class="string">'20090907'</span>, <span class="number">3</span>, <span class="string">'D'</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.Orders;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里使用了 MS SQL2008 的<code>VALUES</code>子句格式语法，这是 2008 版本的新特性。如果你使用的是 2005 及以下版本，你需要多个<code>INSERT</code>语句。最后的执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="20.png" title="" data-fancybox="images"><img src="20.png" alt title class></a>
                <p></p>
            </figure>

<p>（2）需求说明<br>&emsp;&emsp;假设我们要生成一个报表，包含每个员工和客户组合之间的总订货量。用以下简单的分组查询可以解决这个问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid,custid,<span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty </span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> empid,custid;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该查询的执行结果如下：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="21.png" title="" data-fancybox="images"><img src="21.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;不过，假设现在要求要按下表所示的的格式来生成输出结果：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="22.png" title="" data-fancybox="images"><img src="22.png" alt title class></a>
                <p></p>
            </figure>
<p>&emsp;&emsp;这时，我们就需要进行透视转换了！</p>
<p>（3）使用<strong>标准 SQL</strong> 进行透视转换<br>&emsp;&emsp;Step1. 分组：<code>GROUP BY empid</code>；<br>&emsp;&emsp;Step2. 扩展：<code>CASE WHEN custid=&#39;A&#39; THEN qty END</code>；<br>&emsp;&emsp;Step3. 聚合：<code>SUM(CASE WHEN custid=&#39;A&#39; THEN qty END)</code>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.1标准SQL透视转换</span></span><br><span class="line"><span class="keyword">select</span> empid,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'A'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> A,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'B'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> B,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'C'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> C,</span><br><span class="line">    <span class="keyword">SUM</span>(<span class="keyword">case</span> <span class="keyword">when</span> custid=<span class="string">'D'</span> <span class="keyword">then</span> qty <span class="keyword">end</span>) <span class="keyword">as</span> D</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> empid;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="23.png" title="" data-fancybox="images"><img src="23.png" alt title class></a>
                <p></p>
            </figure>

<p>（4）使用 T-SQL <code>PIVOT</code>运算符进行透视转换<br>&emsp;&emsp;自 SQL Server 2005 开始引入了一个 T-SQL 独有的表运算符<code>PIVOT</code>，它可以对某个源表或表表达式进行操作、透视数据，再返回一个结果表。<br>&emsp;&emsp;<code>PIVOT</code>运算符同样涉及前面介绍的三个逻辑处理阶段（分组、扩展和聚合）以及同样的透视转换元素，但使用的是不同的、<strong>SQL Server 原生的语法</strong>。<br>&emsp;&emsp;下面是使用<code>PIVOT</code>运算符实现上面一样的效果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid,A,B,C,D</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> empid,custid,qty</span><br><span class="line">      <span class="keyword">from</span> dbo.Orders) <span class="keyword">as</span> D</span><br><span class="line">  <span class="keyword">pivot</span> (<span class="keyword">sum</span>(qty) <span class="keyword">for</span> custid <span class="keyword">in</span> (A,B,C,D)) <span class="keyword">as</span> P;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中，<code>PIVOT</code>运算符的圆括号内要指定聚合函数（本例中<code>SUM</code>）、聚合元素（本例中的 qty）、扩展元素（custid）以及目标列名称的列表（本例中的 A、B、C、D）。在<code>PIVOT</code>运算符的圆括号后面，可以为结果表制定一个别名。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：使用<code>PIVOT</code>运算符一般不直接把它应用到源表（本例中的 Orders 表），而是将其应用到一个表表达式（该表表达式只包含透视转换需要的3种元素，不包含其他属性。）此外，不需要为它显式地指定分组元素，也就不需要再查询中使用<code>GROUP BY</code>子句。</p>
</blockquote>
<h2 id="逆透视"><a href="#逆透视" class="headerlink" title="逆透视"></a>逆透视</h2><p>&emsp;&emsp;所谓逆透视（Unpivoting）转换是一种把数据从列的状态旋转为行的状态的技术，它将来自单个记录中多个列的值扩展为单个列中具有相同值得多个记录。换句话说，将透视表中的每个源行潜在地转换成多个行，每行代表源透视表的一个指定的列值。</p>
<p>还是通过一个栗子来理解：<br>（1）首先还是准备一下数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> tempdb;</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.EmpCustOrders', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.EmpCustOrders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> empid, A, B, C, D</span><br><span class="line"><span class="keyword">INTO</span> dbo.EmpCustOrders</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> empid, custid, qty</span><br><span class="line">      <span class="keyword">FROM</span> dbo.Orders) <span class="keyword">AS</span> D</span><br><span class="line">  <span class="keyword">PIVOT</span>(<span class="keyword">SUM</span>(qty) <span class="keyword">FOR</span> custid <span class="keyword">IN</span>(A, B, C, D)) <span class="keyword">AS</span> P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.EmpCustOrders;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面是对这个表 EmpCustOrders 的查询结果：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="24.png" title="" data-fancybox="images"><img src="24.png" alt title class></a>
                <p></p>
            </figure>

<p>（2）需求说明<br>&emsp;&emsp;要求执行你透视转换，为每个员工和客户组合返回一行记录，其中包含这一组合的订货量。期望的输出结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="25.png" title="" data-fancybox="images"><img src="25.png" alt title class></a>
                <p></p>
            </figure>

<p>（3）标准 SQL 进行逆透视转换<br>&emsp;&emsp;Step1. 生成副本：<code>CROSS JOIN</code>交叉联接生成多个副本<br>&emsp;&emsp;Step2. 提取元素：通过<code>CASE</code>语句生成 qty 数据列<br>&emsp;&emsp;Step3. 删除不相关的交叉：过滤掉 <em>NULL</em> 值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> empid, custid,</span><br><span class="line">        <span class="keyword">case</span> custid</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'A'</span> <span class="keyword">then</span> A</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'B'</span> <span class="keyword">then</span> B</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'C'</span> <span class="keyword">then</span> C</span><br><span class="line">            <span class="keyword">when</span> <span class="string">'D'</span> <span class="keyword">then</span> D</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">as</span> qty</span><br><span class="line">      <span class="keyword">from</span> dbo.EmpCustOrders</span><br><span class="line">        <span class="keyword">cross</span> <span class="keyword">join</span> (<span class="keyword">VALUES</span>(<span class="string">'A'</span>),(<span class="string">'B'</span>),(<span class="string">'C'</span>),(<span class="string">'D'</span>)) <span class="keyword">as</span> Custs(custid)) <span class="keyword">as</span> D</span><br><span class="line"><span class="keyword">where</span> qty <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="26.png" title="" data-fancybox="images"><img src="26.png" alt title class></a>
                <p></p>
            </figure>

<p>（4）T-SQL <code>UNPIVOT</code>运算符进行逆透视转换<br>&emsp;&emsp;和<code>PIVOT</code>类似，在 SQL Server 2005 引入了一个<code>UNPIVOT</code>运算符，它的作用刚好和<code>PIVOT</code>运算符相反，即我们可以拿来做逆透视转换工作。<code>UNPIVOT</code>同样会经历我们上面提到的三个阶段。继续上面的栗子，我们使用<code>UNPIVOT</code>来进行逆透视转换：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> empid, custid, qty</span><br><span class="line"><span class="keyword">from</span> dbo.EmpCustOrders</span><br><span class="line">  <span class="keyword">unpivot</span> (qty <span class="keyword">for</span> custid <span class="keyword">in</span> (A,B,C,D)) <span class="keyword">as</span> U;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中，<code>UNPIVOT</code>运算符后边的括号内包括：用于保存源表列值的目标列明（这里是 qty），用于保存源表列名的目标列名（这里是 custid），以及源表列名列表（A、B、C、D）。同样，在<code>UNPIVOT</code>括号后面也可以跟一个别名。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：对经过透视转换所得的表再进行逆透视转换，并不能得到原来的表。因为你透视转换只是把经过透视转换的值再旋转岛另一种新的格式。</p>
</blockquote>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>&emsp;&emsp;首先了解一下分组集：分组集就是分组（<code>GROUP BY</code>子句）使用的一组属性（或列名）。在传统 SQL 中，一个聚合查询只能定义一个分组集。为了灵活而有效地处理分组集，SQL Server 2008 引入了几个重要的新功能（<strong>它们都是<code>GROUP BY</code>的从属子句，需要依赖于<code>GROUP BY</code>子句</strong>）：<br>（1）<code>GROUPING SETS</code>从属子句<br>&emsp;&emsp;使用该子句，可以方便地在同一个查询中定义多个分组集。例如下面，我们定义了4个分组集：(empid,custid)，(empid)，(custid) 和 ()：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--3.1GROUPING SETS从属子句</span></span><br><span class="line"><span class="keyword">select</span> empid,custid,<span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> </span><br><span class="line">  <span class="keyword">GROUPING</span> <span class="keyword">SETS</span></span><br><span class="line">  (</span><br><span class="line">    (empid,custid),</span><br><span class="line">    (empid),</span><br><span class="line">    (custid),</span><br><span class="line">    ()</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个查询相当于执行了四个 group by 查询的并集。</p>
<p>（2）<code>CUBE</code>从属子句<br>&emsp;&emsp;<code>CUBE</code>子句为定义多个分组集提供了一种更简略的方法，可以把<code>CUBE</code>子句看作是用于生成分组的幂集。例如：<code>CUBE(a,b,c)</code>等价于<code>GROUPING SETS[(a,b,c),(a,b),(a,c),(b,c),(a),(b),(c),()]</code>。下面我们用<code>CUBE</code>来实现上面的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--3.2CUEE从属子句</span></span><br><span class="line"><span class="keyword">select</span> empid,custid,<span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(empid,custid);</span><br></pre></td></tr></table></figure>

<p>（3）<code>ROLLUP</code>从属子句<br>&emsp;&emsp;<code>ROLLUP</code>子句也是一种简略的方法，只不过它与<code>CUBE</code>不同，它强调输入成员之间存在一定的层次关系，从而生成让这种层次关系有意义的所有分组集。例如：<code>CUBE(a,b,c)</code>会生成 8 个可能的分组集，而<code>ROLLUP</code>则认为 3 个输入成员存在 a &gt; b &gt; c 的层次关系，所以只会生成4个分组集：(a,b,c)，(a,b)，(a)，()。<br>&emsp;&emsp;下面我们假设想要按时间层次关系：订单年份 &gt; 订单月份 &gt; 订单日，以这样的关系来定义所有分组集，并未每个分组集返回其总订货量。可能我们用<code>GROUPING SETS</code>需要 4 行，然后使用<code>ROLLUP</code>却只需要一行：<code>group by rollup(YEAR(orderdate),MONTH(orderdate),DAY(orderdate));</code><br>&emsp;&emsp;完整SQL查询如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--3.3ROLLUP从属子句</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  <span class="keyword">YEAR</span>(orderdate) <span class="keyword">as</span> orderyear,</span><br><span class="line">  <span class="keyword">MONTH</span>(orderdate) <span class="keyword">as</span> ordermonth,</span><br><span class="line">  <span class="keyword">DAY</span>(orderdate) <span class="keyword">as</span> orderday,</span><br><span class="line">  <span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>(<span class="keyword">YEAR</span>(orderdate),<span class="keyword">MONTH</span>(orderdate),<span class="keyword">DAY</span>(orderdate));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="27.png" title="" data-fancybox="images"><img src="27.png" alt title class></a>
                <p></p>
            </figure>

<p>（4）<code>GROUPING_ID</code>函数<br>&emsp;&emsp;如果一个查询定义了多个分组集，还想把结果行和分组集关联起来，也就是说，为每个结果行标注它是和哪个分组集关联的。SQL Server 2008 中引入了一个<code>GROUPING_ID</code>函数，简化了关联结果行和分组集的处理，可以容易地计算出每一行和哪个分组集相关联。<br>&emsp;&emsp;例如，继续上面的例子，我们想要将 empid，custid 作为输入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  <span class="keyword">grouping_id</span>(empid,custid) <span class="keyword">as</span> groupingset,</span><br><span class="line">  empid, custid, <span class="keyword">SUM</span>(qty) <span class="keyword">as</span> sumqty</span><br><span class="line"><span class="keyword">from</span> dbo.Orders</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">cube</span>(empid,custid);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果中会出现 groupingset 为 0，1，2，3 ，分别代表了 empid，custid 的4个可能的分组集 (empid,custid)，(empid)，(custid)，() 。</p>
<hr>
<h1 id="数据修改"><a href="#数据修改" class="headerlink" title="数据修改"></a>数据修改</h1><h2 id="插入与删除数据"><a href="#插入与删除数据" class="headerlink" title="插入与删除数据"></a>插入与删除数据</h2><h3 id="看我花式插入数据"><a href="#看我花式插入数据" class="headerlink" title="看我花式插入数据"></a>看我花式插入数据</h3><p>&emsp;&emsp;① <code>INSERT VALUES</code>语句 ：这个语句恐怕我们再熟悉不过了吧，在任何一本数据库的书上面都可以看到这个语句的身影。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid)</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="number">10001</span>, <span class="string">'20090212'</span>, <span class="number">3</span>, <span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要了解的是，前面也提到过，SQL Server 2008 增强了<code>VALUES</code>语句的功能，允许在一条语句中指定由逗号分隔开的多行记录。例如下面的语句向 Orders 中插入了 4 行数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders</span><br><span class="line">  (orderid, orderdate, empid, custid)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">10003</span>, <span class="string">'20090213'</span>, <span class="number">4</span>, <span class="string">'B'</span>),</span><br><span class="line">  (<span class="number">10004</span>, <span class="string">'20090214'</span>, <span class="number">1</span>, <span class="string">'A'</span>),</span><br><span class="line">  (<span class="number">10005</span>, <span class="string">'20090213'</span>, <span class="number">1</span>, <span class="string">'C'</span>),</span><br><span class="line">  (<span class="number">10006</span>, <span class="string">'20090215'</span>, <span class="number">3</span>, <span class="string">'C'</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>INSERT SELECT</code>语句 ：将一组由<code>SELECT</code>查询返回的结果行插入到目标表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid)</span><br><span class="line">  <span class="keyword">SELECT</span> orderid, orderdate, empid, custid</span><br><span class="line">  <span class="keyword">FROM</span> TSQLFundamentals2008.Sales.Orders</span><br><span class="line">  <span class="keyword">WHERE</span> shipcountry = <span class="string">'UK'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ <code>INSERT EXEC</code>语句：将存储过过程或动态 SQL 批处理返回的结果集插入目标表。<br>&emsp;&emsp;下面的示例演示了如何执行存储过程 usp_getorders 并将结果插入到 Orders 表中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Orders(orderid, orderdate, empid, custid)</span><br><span class="line">  EXEC TSQLFundamentals2008.Sales.usp_getorders @country = <span class="string">'France'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ <code>SELECT INTO</code>语句：它会创建一个目标表，并用查询返回的结果来填充它。需要注意的是：<strong>它不是一个标准的 SQL 语句（即不是 ANSI SQL 标准的一部分），不能用这个语句向已经存在的表中插入数据。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--保证目标表不存在</span></span><br><span class="line">IF OBJECT_ID('dbo.Orders', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Orders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> orderid, orderdate, empid, custid</span><br><span class="line"><span class="keyword">INTO</span> dbo.Orders</span><br><span class="line"><span class="keyword">FROM</span> TSQLFundamentals2008.Sales.Orders;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;⑤ <code>BULK INSERT</code>语句：用于将文件中的数据导入一个已经存在的表，需要制定目标表、源文件以及一些其他的选项。<br>&emsp;&emsp;下面的栗子演示了如何将文件 “C:\testdata\orders.txt” 中的数据容量插入（bulk insert）到 Orders 表，同时还指定了文件类型为字符格式，字段终止符为逗号，行终止符为换行符（\t）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BULK <span class="keyword">INSERT</span> dbo.Orders <span class="keyword">FROM</span> <span class="string">'C:\testdata\orders.txt'</span></span><br><span class="line">  <span class="keyword">WITH</span> </span><br><span class="line">    (</span><br><span class="line">       DATAFILETYPE    = <span class="string">'char'</span>,</span><br><span class="line">       FIELDTERMINATOR = <span class="string">','</span>,</span><br><span class="line">       ROWTERMINATOR   = <span class="string">'\n'</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="看我花式删除数据"><a href="#看我花式删除数据" class="headerlink" title="看我花式删除数据"></a>看我花式删除数据</h3><p>&emsp;&emsp;① <code>DELETE</code>语句：标准 SQL 语句，大家最常见的用法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line"><span class="keyword">WHERE</span> orderdate &lt; <span class="string">'20070101'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>TRUNCATE</code>语句：不是标准的 SQL 语句，永于删除表中的所有行，不需要过滤条件。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：<code>TRUNCATE</code>与<code>DELETE</code>在性能上差异巨大，对一个百万行级记录的表，<code>TRUNCATE</code>几秒内就可以解决，而<code>DELETE</code>可能需要几分钟。因为<code>TRUNCATE</code>会以最小模式记录日志，而<code>DELETE</code>则以完整模式记录日志。所以，各位，谨慎使用<code>TRUNCATE</code>。因此，我们可以创建一个虚拟表（Dummy Table），让虚拟表包含一个指向产品表的外键，这样就可以保护产品表了。</p>
</blockquote>
<p>&emsp;&emsp;③ 基于联接的<code>DELETE</code>：也不是标准 SQL 语句，可以根据另一个表中相关行的属性定义的过滤器来删除表中的数据行。<br>&emsp;&emsp;例如，下面语句用以删除美国客户下的订单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> O</span><br><span class="line"><span class="keyword">FROM</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">  <span class="keyword">JOIN</span> dbo.Customers <span class="keyword">AS</span> C</span><br><span class="line">    <span class="keyword">ON</span> O.custid = C.custid</span><br><span class="line"><span class="keyword">WHERE</span> C.country = N<span class="string">'USA'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，如果要使用标准 SQL 语句，也可以采用下面的方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> *</span><br><span class="line">   <span class="keyword">FROM</span> dbo.Customers <span class="keyword">AS</span> C</span><br><span class="line">   <span class="keyword">WHERE</span> Orders.custid = C.custid</span><br><span class="line">     <span class="keyword">AND</span> C.country = N<span class="string">'USA'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="更新与合并数据"><a href="#更新与合并数据" class="headerlink" title="更新与合并数据"></a>更新与合并数据</h2><h3 id="花式更新数据"><a href="#花式更新数据" class="headerlink" title="花式更新数据"></a>花式更新数据</h3><p>&emsp;&emsp;① <code>UPDATE</code>语句：不解释了，大家都在用<br>&emsp;&emsp;下面来看两个不一样的栗子，第一个是关于同时操作的性质。看看下面的<code>UPDATE</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.T1</span><br><span class="line">  <span class="keyword">SET</span> col1 = col1 + <span class="number">10</span>, col2 = col1 + <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;假设 T1 表中的 col1 列为 100，col2 列为 200。在计算后是多少呢？<br>&emsp;&emsp;答案揭晓：col=110, col=110。<br>&emsp;&emsp;再来看一个栗子，假设我们要实现两个数的交换该怎么做？我们可能迫不及待的说出临时变量。然而，在 SQL 中所有赋值表达式好像都是同时计算的，解决这个问题就不需要临时变量了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.T1</span><br><span class="line">  <span class="keyword">SET</span> col1 = col2, col2 = col1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 基于联接的<code>UPDATE</code>语句：同样不是 SQL 标准语法，联接在此与基于联接的<code>DELETE</code>一样是起到过滤作用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> OD</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">FROM</span> dbo.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">  <span class="keyword">JOIN</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">    <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line"><span class="keyword">WHERE</span> custid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样，要使用标准 SQL 语法的话，可以用子查询替代联接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">   <span class="keyword">WHERE</span> O.orderid = OrderDetails.orderid</span><br><span class="line">     <span class="keyword">AND</span> custid = <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ 赋值<code>UPDATE</code>：这是 T-SQL 特有的语法，可以对表中的数据进行更新的同时为变量赋值。你不需要使用单独的<code>UPDATE</code>和<code>SELECT</code>语句，就能完成同样的任务。<br>&emsp;&emsp;假设我们有一个表 Sequence，它只有一列 val，全是序号数字。我们可以通过赋值<code>UPDATE</code>得到一个新的序列值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">nextval</span> <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">Sequence</span> <span class="keyword">SET</span> @<span class="keyword">nextval</span> = val = val + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">nextval</span>;</span><br></pre></td></tr></table></figure>

<h3 id="新玩法：合并数据"><a href="#新玩法：合并数据" class="headerlink" title="新玩法：合并数据"></a>新玩法：合并数据</h3><p>&emsp;&emsp;SQL Server 2008 引入了一个叫做<code>MERGE</code>的语句，它能在一条语句中根据逻辑条件对数据进行不同的修改操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）。<code>MERGE</code>语句是 SQL 标准的一部分，而 T-SQL 版本的<code>MERGE</code>语句也增加了一些非标准的扩展。<br>&emsp;&emsp;下面我们看看如何合并，首先我们准备两张表 Customers 和 CustomersStage：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--merge data</span></span><br><span class="line"><span class="keyword">USE</span> tempdb;</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.Customers', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.Customers;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.Customers</span><br><span class="line">(</span><br><span class="line">  custid      <span class="built_in">INT</span>         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  companyname <span class="built_in">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  phone       <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  address     <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_Customers PRIMARY <span class="keyword">KEY</span>(custid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.Customers(custid, companyname, phone, address)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">'cust 1'</span>, <span class="string">'(111) 111-1111'</span>, <span class="string">'address 1'</span>),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'cust 2'</span>, <span class="string">'(222) 222-2222'</span>, <span class="string">'address 2'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'cust 3'</span>, <span class="string">'(333) 333-3333'</span>, <span class="string">'address 3'</span>),</span><br><span class="line">  (<span class="number">4</span>, <span class="string">'cust 4'</span>, <span class="string">'(444) 444-4444'</span>, <span class="string">'address 4'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="string">'cust 5'</span>, <span class="string">'(555) 555-5555'</span>, <span class="string">'address 5'</span>);</span><br><span class="line"></span><br><span class="line">IF OBJECT_ID('dbo.CustomersStage', 'U') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.CustomersStage;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.CustomersStage</span><br><span class="line">(</span><br><span class="line">  custid      <span class="built_in">INT</span>         <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  companyname <span class="built_in">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  phone       <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  address     <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> PK_CustomersStage PRIMARY <span class="keyword">KEY</span>(custid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.CustomersStage(custid, companyname, phone, address)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">2</span>, <span class="string">'AAAAA'</span>, <span class="string">'(222) 222-2222'</span>, <span class="string">'address 2'</span>),</span><br><span class="line">  (<span class="number">3</span>, <span class="string">'cust 3'</span>, <span class="string">'(333) 333-3333'</span>, <span class="string">'address 3'</span>),</span><br><span class="line">  (<span class="number">5</span>, <span class="string">'BBBBB'</span>, <span class="string">'CCCCC'</span>, <span class="string">'DDDDD'</span>),</span><br><span class="line">  (<span class="number">6</span>, <span class="string">'cust 6 (new)'</span>, <span class="string">'(666) 666-6666'</span>, <span class="string">'address 6'</span>),</span><br><span class="line">  (<span class="number">7</span>, <span class="string">'cust 7 (new)'</span>, <span class="string">'(777) 777-7777'</span>, <span class="string">'address 7'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Query tables</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.Customers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dbo.CustomersStage;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="28.png" title="" data-fancybox="images"><img src="28.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;现在我们想要增加还不存在的客户，并更新已经存在的客户。源表：CustomersStage，目标表：Customers。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> dbo.Customers <span class="keyword">AS</span> TGT</span><br><span class="line"><span class="keyword">USING</span> dbo.CustomersStage <span class="keyword">AS</span> SRC</span><br><span class="line">  <span class="keyword">ON</span> TGT.custid = SRC.custid</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="keyword">SET</span></span><br><span class="line">    TGT.companyname = SRC.companyname,</span><br><span class="line">    TGT.phone = SRC.phone,</span><br><span class="line">    TGT.address = SRC.address</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span> </span><br><span class="line">  <span class="keyword">INSERT</span> (custid, companyname, phone, address)</span><br><span class="line">  <span class="keyword">VALUES</span> (SRC.custid, SRC.companyname, SRC.phone, SRC.address);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;谓词条件：<code>TGT.custid=SRC.custid</code>用于定义什么样的数据是匹配的，什么样的数据是不匹配的。</p>
<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：<strong><code>MERGE</code>语句必须以分号结束</strong>，而对于 T-SQL 中的大多数其他语句来说是可选的。但是，推荐遵循最佳实践，以分号结束。</p>
</blockquote>
<h2 id="高级数据更新方法"><a href="#高级数据更新方法" class="headerlink" title="高级数据更新方法"></a>高级数据更新方法</h2><p>&emsp;&emsp;① 通过表表达式修改数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基于联接的UPDATE</span></span><br><span class="line"><span class="keyword">UPDATE</span> OD</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">FROM</span> dbo.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">  <span class="keyword">JOIN</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">    <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line"><span class="keyword">WHERE</span> custid = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 基于表表达式（这里是CTE）的UPDATE</span></span><br><span class="line"><span class="keyword">WITH</span> C <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> custid, OD.orderid,</span><br><span class="line">    productid, discount, discount + <span class="number">0.05</span> <span class="keyword">AS</span> newdiscount</span><br><span class="line">  <span class="keyword">FROM</span> dbo.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">    <span class="keyword">JOIN</span> dbo.Orders <span class="keyword">AS</span> O</span><br><span class="line">      <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line">  <span class="keyword">WHERE</span> custid = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">UPDATE</span> C</span><br><span class="line">  <span class="keyword">SET</span> discount = newdiscount;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 带有<code>TOP</code>选项的数据更新</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除前50行</span></span><br><span class="line"><span class="keyword">DELETE</span> TOP(<span class="number">50</span>) <span class="keyword">FROM</span> dbo.Orders;</span><br><span class="line"><span class="comment">-- 更新前50行</span></span><br><span class="line"><span class="keyword">UPDATE</span> TOP(<span class="number">50</span>) dbo.Orders</span><br><span class="line">  <span class="keyword">SET</span> freight = freight + <span class="number">10.00</span>;</span><br><span class="line"><span class="comment">-- 基于CTE删除前50行</span></span><br><span class="line"><span class="keyword">WITH</span> C <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> TOP(<span class="number">50</span>) *</span><br><span class="line">  <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> C;</span><br><span class="line"><span class="comment">-- 基于CTE更新前50行</span></span><br><span class="line"><span class="keyword">WITH</span> C <span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> TOP(<span class="number">50</span>) *</span><br><span class="line">  <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> orderid <span class="keyword">DESC</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">UPDATE</span> C</span><br><span class="line">  <span class="keyword">SET</span> freight = freight + <span class="number">10.00</span>;</span><br></pre></td></tr></table></figure>

<h2 id="OUTPUT-子句"><a href="#OUTPUT-子句" class="headerlink" title="OUTPUT 子句"></a>OUTPUT 子句</h2><p>&emsp;&emsp;在某些场景中，我们希望能够从修改过的行中返回数据，这时就可以使用<code>OUTPUT</code>子句。SQL Server 2005 引入了<code>OUTPUT</code>子句，通过在修改语句中添加<code>OUTPUT</code>子句，就可以实现从修改语句中返回数据的功能。<br>&emsp;&emsp;① 带有<code>OUTPUT</code>的<code>INSERT</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1(datacol)</span><br><span class="line">  <span class="keyword">OUTPUT</span> inserted.keycol, inserted.datacol</span><br><span class="line">    <span class="keyword">SELECT</span> lastname</span><br><span class="line">    <span class="keyword">FROM</span> TSQLFundamentals2008.HR.Employees</span><br><span class="line">    <span class="keyword">WHERE</span> country = N<span class="string">'USA'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 带有<code>OUTPUT</code>的<code>DELETE</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> dbo.Orders</span><br><span class="line">  <span class="keyword">OUTPUT</span></span><br><span class="line">    deleted.orderid,</span><br><span class="line">    deleted.orderdate,</span><br><span class="line">    deleted.empid,</span><br><span class="line">    deleted.custid</span><br><span class="line"><span class="keyword">WHERE</span> orderdate &lt; <span class="string">'20080101'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;③ 带有<code>OUTPUT</code>的<code>UPDATE</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> dbo.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> discount = discount + <span class="number">0.05</span></span><br><span class="line"><span class="keyword">OUTPUT</span></span><br><span class="line">  inserted.productid,</span><br><span class="line">  deleted.discount <span class="keyword">AS</span> olddiscount,</span><br><span class="line">  inserted.discount <span class="keyword">AS</span> newdiscount</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">51</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;④ 带有<code>OUTPUT</code>的<code>MERGE</code>语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> dbo.Customers <span class="keyword">AS</span> TGT</span><br><span class="line"><span class="keyword">USING</span> dbo.CustomersStage <span class="keyword">AS</span> SRC</span><br><span class="line">  <span class="keyword">ON</span> TGT.custid = SRC.custid</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span></span><br><span class="line">  <span class="keyword">UPDATE</span> <span class="keyword">SET</span></span><br><span class="line">    TGT.companyname = SRC.companyname,</span><br><span class="line">    TGT.phone = SRC.phone,</span><br><span class="line">    TGT.address = SRC.address</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> <span class="keyword">MATCHED</span> <span class="keyword">THEN</span> </span><br><span class="line">  <span class="keyword">INSERT</span> (custid, companyname, phone, address)</span><br><span class="line">  <span class="keyword">VALUES</span> (SRC.custid, SRC.companyname, SRC.phone, SRC.address)</span><br><span class="line"><span class="keyword">OUTPUT</span> $<span class="keyword">action</span>, inserted.custid,</span><br><span class="line">  deleted.companyname <span class="keyword">AS</span> oldcompanyname,</span><br><span class="line">  inserted.companyname <span class="keyword">AS</span> newcompanyname,</span><br><span class="line">  deleted.phone <span class="keyword">AS</span> oldphone,</span><br><span class="line">  inserted.phone <span class="keyword">AS</span> newphone,</span><br><span class="line">  deleted.address <span class="keyword">AS</span> oldaddress,</span><br><span class="line">  inserted.address <span class="keyword">AS</span> newaddress;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上<code>MERGE</code>语句使用<code>OUTPUT</code>子句返回被修改过的行的新旧版本的值。对于<code>INSERT</code>操作不存在旧版本的值，因此所有 deleted 列的值都返回 <em>NULL</em> 。<code>$action</code>函数会告诉我们输出行是<code>UPDATE</code>还是由<code>INSERT</code>操作生成的。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="29.png" title="" data-fancybox="images"><img src="29.png" alt title class></a>
                <p></p>
            </figure>

<hr>
<h1 id="事务和并发"><a href="#事务和并发" class="headerlink" title="事务和并发"></a>事务和并发</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>&emsp;&emsp;事务是作为单个工作单元而执行的一系列操作，比如查询和修改数据等。<br>&emsp;&emsp;事务是数据库并发控制的基本单位，一条或者一组语句要么全部成功，对数据库中的某些数据成功修改；要么全部不成功，数据库中的数据还原到这些语句执行之前的样子。</p>
<blockquote>
<p>&emsp;&emsp;比如网上订火车票，要么你定票成功，余票显示就减一张；要么你定票失败获取取消订票，余票的数量还是那么多。不允许出现你订票成功了，余票没有减少或者你取消订票了，余票显示却少了一张的这种情况。这种不被允许出现的情况就要求购票和余票减少这两个不同的操作必须放在一起，成为一个完整的逻辑链，这样就构成了一个事务。</p>
</blockquote>
<h3 id="事务的-ACID-特性"><a href="#事务的-ACID-特性" class="headerlink" title="事务的 ACID 特性"></a>事务的 ACID 特性</h3><ul>
<li><strong>原子性（Atomicity）</strong>：<br>&emsp;&emsp;事务的原子性是指一个事务中包含的一条语句或者多条语句构成了一个完整的逻辑单元，这个逻辑单元具有不可再分的原子性。这个逻辑单元要么一起提交执行全部成功，要么一起提交执行全部失败。  </li>
<li><strong>一致性（Consistency）</strong>：<br>&emsp;&emsp;可以理解为数据的完整性，事务的提交要确保在数据库上的操作没有破坏数据的完整性，比如说不要违背一些约束的数据插入或者修改行为。一旦破坏了数据的完整性，SQL Server 会回滚这个事务来确保数据库中的数据是一致的。  </li>
<li><strong>隔离性（Isolation）</strong>：<br>&emsp;&emsp;与数据库中的事务隔离级别以及锁相关，多个用户可以对同一数据并发访问而又不破坏数据的正确性和完整性。但是，并行事务的修改必须与其它并行事务的修改相互独立，隔离。 但是在不同的隔离级别下，事务的读取操作可能得到的结果是不同的。  </li>
<li><strong>持久性（Durability）</strong>：<br>&emsp;&emsp;数据持久化，事务一旦对数据的操作完成并提交后，数据修改就已经完成，即使服务重启这些数据也不会改变。相反，如果在事务的执行过程中，系统服务崩溃或者重启，那么事务所有的操作就会被回滚，即回到事务操作之前的状态。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;在极端断电或者系统崩溃的情况下，一个发生在事务未提交之前，数据库应该记录了这个事务的 “ID” 和部分已经在数据库上更新的数据。供电恢复数据库重新启动之后，这时完成全部撤销和回滚操作。如果在事务提交之后的断电，有可能更改的结果没有正常写入磁盘持久化，但是有可能丢失的数据会通过事务日志自动恢复并重新生成以写入磁盘完成持久化。</p>
</blockquote>
<h3 id="如何定义事务"><a href="#如何定义事务" class="headerlink" title="如何定义事务"></a>如何定义事务</h3><p>（1）显示定义：以<code>BEGIN TRAN</code>开始，提交的话则<code>COMMIT</code>提交事务，否则以<code>ROLLBACK</code>回滚事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--定义事务</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1(keycol, col1, col2) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="string">'C'</span>);</span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1(keycol, col1, col2) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">201</span>,<span class="string">'X'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>（2）隐式定义：SQL Server 中默认把每个单独的语句作为一个事务。<br>&emsp;&emsp;换句话说，SQL Server 默认在执行完每个语句之后就自动提交事务。当然，我们可以通过<code>IMPLICIT_TRANSACTIONS</code>会话选项来改变 SQL Server 处理默认事务的方式，该选项默认情况下是 <em>OFF</em> 。如果将其设置为 <em>ON</em> ，那么就不必用<code>BEGIN TRAN</code>语句来表明事务开始，但仍然需要以<code>COMMIT</code>或<code>ROLLBACK</code>来标明事务完成。</p>
<h2 id="锁定和阻塞"><a href="#锁定和阻塞" class="headerlink" title="锁定和阻塞"></a>锁定和阻塞</h2><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>（1）锁是什么鬼？<br>&emsp;&emsp;锁是事务获取的一种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。</p>
<p>（2）锁模式及其兼容性<br>&emsp;&emsp;主要有两种主要的锁模式 —— <strong>排它锁（Exclusive Lock）</strong> 和 <strong>共享锁（Shared Lock）</strong>。<br>&emsp;&emsp;当试图修改数据时，事务会为所依赖的数据资源请求排它锁，一旦授予，事务将一直持有排它锁，直至事务完成。在事务执行过程中，其他事务就不能再获得该资源的任何类型的锁。<br>&emsp;&emsp;当试图读取数据时，事务默认会为所依赖的数据资源请求共享锁，读操作一完成，就立即释放共享锁。在事务执行过程中，其他事务仍然能够获得该资源的共享锁。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="30.png" title="" data-fancybox="images"><img src="30.png" alt title class></a>
                <p></p>
            </figure>

<p>（3）可锁定资源的类型<br>&emsp;&emsp;SQL Server 可以锁定不同类型或粒度的资源，这些资源类型包括 RID 或 KEY（行），PAGE（页）、对象（例如：表）及数据库等。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>（1）阻塞是个什么鬼？<br>&emsp;&emsp;如果一个事务持有某一数据资源上的锁，而另一事务请求相同资源上的不兼容的锁，则对新锁的请求将被阻塞，发出请求的事务进入等待状态。默认情况下，被阻塞的请求会一直等待，直到原来的事务释放相关的锁。</p>
<blockquote>
<p>&emsp;&emsp;只要能够在合理的时间范围内满足请求，系统中的阻塞就是正常的。但是，如果一些请求等待了太长时间，可能就需要手工排除阻塞状态，看看能采取什么措施来防止这样长时间的延迟。</p>
</blockquote>
<p>（2）近距离观测阻塞<br>&emsp;&emsp;Step1. 打开两个独立的查询窗口，这里称之为 Connection A，Connection B</p>
<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码（这里 productid=2 的 unitprice 本来为 19）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products <span class="keyword">SET</span> unitprice=unitprice+<span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了更新这一行，会话必须先获得一个排它锁，如果更新成功，SQL Server 会向会话授予这个锁。</p>
<p>&emsp;&emsp;Step3. 在 Connection B 中运行以下代码</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;默认情况下，该会话需要一个共享锁，但因为共享锁和排它锁是不兼容的，所以该会话被阻塞，进入等待状态。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="31.png" title="" data-fancybox="images"><img src="31.png" alt title class></a>
                <p></p>
            </figure>

<p>（3）如何检测阻塞<br>&emsp;&emsp;假设我们的系统里边出现了阻塞，而且被阻塞了很长时间，如何去检测和排除呢？<br>&emsp;&emsp;① 继续上例，打开一个新的会话，称之为 Connection C，查询动态管理视图（DMV）<code>sys.dm_tran_locks</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lock info</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">-- use * to explore</span></span><br><span class="line">  request_session_id            <span class="keyword">AS</span> spid,</span><br><span class="line">  resource_type                 <span class="keyword">AS</span> restype,</span><br><span class="line">  resource_database_id          <span class="keyword">AS</span> dbid,</span><br><span class="line">  DB_NAME(resource_database_id) <span class="keyword">AS</span> dbname,</span><br><span class="line">  resource_description          <span class="keyword">AS</span> res,</span><br><span class="line">  resource_associated_entity_id <span class="keyword">AS</span> resid,</span><br><span class="line">  request_mode                  <span class="keyword">AS</span> <span class="keyword">mode</span>,</span><br><span class="line">  request_status                <span class="keyword">AS</span> <span class="keyword">status</span></span><br><span class="line"><span class="keyword">FROM</span> sys.dm_tran_locks;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② 运行上面的代码，可以得到以下输出：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="32.png" title="" data-fancybox="images"><img src="32.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;③ 每个会话都有唯一的服务器进程标识符（SPID），可以通过查询<code>@@SPID</code>函数来查看会话 ID。另外，当前会话的 SPID 还可以在查询窗口的标题栏中找到。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="33.png" title="" data-fancybox="images"><img src="33.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;④ 在前面查询的输出中，可以观察到进程 53 正在等待请求 TSQLFundamental2008 数据库中一个行的共享锁。但是，进程 52 持有同一个行上的排它锁。沿着 52 和 53 的所层次结构向上检查：（查询<code>sys.dm_exec_connections</code>的动态管理视图，筛选阻塞链中涉及到的那些 SPID）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection info</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">-- use * to explore</span></span><br><span class="line">  session_id <span class="keyword">AS</span> spid,</span><br><span class="line">  <span class="keyword">connect_time</span>,</span><br><span class="line">  last_read,</span><br><span class="line">  last_write,</span><br><span class="line">  most_recent_sql_handle</span><br><span class="line"><span class="keyword">FROM</span> sys.dm_exec_connections</span><br><span class="line"><span class="keyword">WHERE</span> session_id <span class="keyword">IN</span>(<span class="number">52</span>, <span class="number">53</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查询结果输出如下：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="34.png" title="" data-fancybox="images"><img src="34.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;⑤ 借助交叉联接，和<code>sys.dm_exec_sql_text</code>表函数生成查询结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SQL text</span></span><br><span class="line"><span class="keyword">SELECT</span> session_id, <span class="built_in">text</span> </span><br><span class="line"><span class="keyword">FROM</span> sys.dm_exec_connections</span><br><span class="line">  <span class="keyword">CROSS</span> <span class="keyword">APPLY</span> sys.dm_exec_sql_text(most_recent_sql_handle) <span class="keyword">AS</span> ST </span><br><span class="line"><span class="keyword">WHERE</span> session_id <span class="keyword">IN</span>(<span class="number">52</span>, <span class="number">53</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查询结果如下，我们可以达到阻塞链中涉及到的每个联接最后调用的批处理代码：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="35.png" title="" data-fancybox="images"><img src="35.png" alt title class></a>
                <p></p>
            </figure>
<p>&emsp;&emsp;以上就显示了进程 53 正在等待的执行代码，因为这是该进程最后执行的一个操作。对于阻塞进程来说，通过这个例子能够看到是哪条语句导致了问题。</p>
<p>（4）如何解除阻塞<br>&emsp;&emsp;① 设置超时时间<br>&emsp;&emsp;首先取消掉原来 Connection B 中的查询，然后执行以下代码：这里我们限制会话等待释放锁的时间为 5 秒：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Session B</span></span><br><span class="line"><span class="keyword">SET</span> LOCK_TIMEOUT <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后 5 秒之后我们可以看到以下执行结果：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="36.png" title="" data-fancybox="images"><img src="36.png" alt title class></a>
                <p></p>
            </figure>
<p>&emsp;&emsp;注意：锁定超时不会引发事务回滚。</p>
<p>&emsp;&emsp;② <code>KILL</code>掉引起阻塞的进程<br>&emsp;&emsp;在 Connection C 中执行以下语句，终止 SPID=52 中的更新事务而产生的效果，于是 SPID=52 中的事务的回滚，同时释放排它锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--KILL SPID=52</span></span><br><span class="line"><span class="keyword">KILL</span> <span class="number">52</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时再在 Connection B 中执行查询，便可以查到回滚后的结果（仍然是 19）：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="37.png" title="" data-fancybox="images"><img src="37.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>&emsp;&emsp;隔离级别用于决定如何控制并发用户读写数据的操作。前面说到，读操作默认使用共享锁，写操作需要使用排它锁。对于操作获得的锁，以及锁的持续时间来说，虽然不能控制写操作的处理方式，但可以控制读操作的处理方式。作为对读操作的行为进行控制的一种结果，也会隐含地影响写操作的行为方式。<br>&emsp;&emsp;为此，可以在会话级别上用会话选项来设置隔离级别，也可以在查询级别上用表提示（Table Hint）来设置隔离级别。<br>&emsp;&emsp;在 SQL Server 中，可以设置的隔离级别有 6 个：<code>READ UNCOMMITED</code>（未提交读）、<code>READ COMMITED</code>（已提交读）、<code>REPEATABLE READ</code>（可重复读）、<code>SERIALIZEABLE</code>（可序列化）、<code>SNAPSHOT</code>（快照）和<code>READ COMMITED SNAPSHOT</code>（已经提交读隔离）。最后两个<code>SNAPSHOT</code>和<code>READ COMMITED SNAPSHOT</code>是在 SQL Server 2005 中引入的。<br>&emsp;&emsp;要设置整个会话级别的隔离级别，可以使用以下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &lt;<span class="keyword">isolation</span> <span class="keyword">name</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;也可以使用表提示来设置查询级别的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">WITH</span> &lt;<span class="keyword">isolation</span> <span class="keyword">name</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="READ-UNCOMMITED-未提交读"><a href="#READ-UNCOMMITED-未提交读" class="headerlink" title="READ UNCOMMITED 未提交读"></a>READ UNCOMMITED 未提交读</h3><p>&emsp;&emsp;未提交读是最低的隔离级别，读操作不会请求共享锁。换句话说，在该级别下的读操作正在读取数据时，写操作可以同时对这些数据进行修改。</p>
<p>&emsp;&emsp;同样，使用两个会话来模拟：<br>&emsp;&emsp;Step1. 在 Connection A 中运行以下代码，更新产品 2 的单价，为当前值（19.00）增加 1.00，然后查询该产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="38.png" title="" data-fancybox="images"><img src="38.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step2. 在 Connection B 中运行以下代码，首先设置隔离级别为未提交读，再查询产品 2 所在的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection B</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因为这个读操作不用请求共享锁，因此不会和其他事务发生冲突，该查询返回了如下图所示的修改后的状态，即使这一状态还没有被提交：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="39.png" title="" data-fancybox="images"><img src="39.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection A 中运行以下代码回滚事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span> TRAN;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;这个回滚操作撤销了对产品 2 的更新，这时它的价格被修改回了 19.00，但是读操作此前获得的 20.00 再也不会被提交了。这就是<strong>脏读</strong>的一个实例！</p>
</blockquote>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="40.png" title="" data-fancybox="images"><img src="40.png" alt title class></a>
                <p></p>
            </figure>

<h3 id="READ-COMMITED-已提交读"><a href="#READ-COMMITED-已提交读" class="headerlink" title="READ COMMITED 已提交读"></a>READ COMMITED 已提交读</h3><p>&emsp;&emsp;刚刚说到，未提交到会引起脏读，能够防止脏读的最低隔离级别是已提交读，这也是所有 SQL Server 版本默认使用的隔离级别。如其名称所示，这个隔离级别只允许读取已经提交的修改，它要求读操作必须获得共享锁才能操作，从而防止读取未提交的修改。</p>
<p>&emsp;&emsp;继续使用两个会话来模拟：<br>&emsp;&emsp;Step1. 在 Connection A 中运行以下代码，更新产品 2 的价格，再查询显示价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="41.png" title="" data-fancybox="images"><img src="41.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step2. 再在 Connection B 中运行以下代码，这段代码将会话的隔离级别设置为已提交读，再查询产品 2 所在的行记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时该会话语句会被阻塞，因为它需要获取共享锁才能进行读操作，而它与会话 A 的写操作持有的排它锁相冲突。这里因为我设置了默认会话阻塞超时时间，所以出现了以下输出：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="42.png" title="" data-fancybox="images"><img src="42.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection A 中运行以下代码，提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step4. 回到 Connection B，此时会得到以下输出：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="43.png" title="" data-fancybox="images"><img src="43.png" alt title class></a>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;在已提交读级别下，不会读取脏数据，只能读取已经提交过的修改。但是，该级别下，其他事务可以在两个读操作之间更改数据资源，读操作因而可能每次得到不同的取值。这种现象被称为<strong>不可重复读</strong>。</p>
</blockquote>
<h3 id="REPEATABLE-READ-可重复读"><a href="#REPEATABLE-READ-可重复读" class="headerlink" title="REPEATABLE READ 可重复读"></a>REPEATABLE READ 可重复读</h3><p>&emsp;&emsp;如果想保证在事务内进行的两个读操作之间，其他任何事务都不能修改由当前事务读取的数据，则需要将隔离级别升级为可重复读。在该级别下，十五中的读操作不但需要获得共享锁才能读数据，而且获得的共享锁将一直保持到事务完成为止。换句话说，在事务完成之前，没有其他事务能够获得排它锁以修改这一数据资源，由此来保证实现可重复的读取。<br>&emsp;&emsp;Step1. 为了重新演示可重复读的示例，首先需要将刚刚的测试数据清理掉，在 Connection A 和 B 中执行以下代码：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Clear Test Data</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码，将会话的隔离级别设置为可重复读，再查询产品 2 所在的行记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="44.png" title="" data-fancybox="images"><img src="44.png" alt title class></a>
                <p></p>
            </figure>
<p>&emsp;&emsp;这时该会话仍然持有产品 2 上的共享锁，因为在该隔离级别下，共享锁要一直保持到事务结束为止。</p>
<p>&emsp;&emsp;Step3. 在 Connection B 中尝试对产品 2 这一行进行修改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时该会话已被阻塞，因为修改操作锁请求的排它锁与前面会话授予的共享锁有冲突。换句话说，如果读操作是在未提交读或已提交读级别下运行的，那么事务此时将不再持有共享锁，Connection B 尝试修改改行的操作应该能够成功。<br>&emsp;&emsp;同样，由于我设置了超时释放时间，因此会有以下输出：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="45.png" title="" data-fancybox="images"><img src="45.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step4. 回到 Connection A，运行以下代码，再次查询产品 2 所在的行，提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时的返回结果仍然与第一次相同：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="46.png" title="" data-fancybox="images"><img src="46.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step5. 这时再执行 Connection B 中的更新语句，便能够正常获得排它锁了，于是执行成功，价格变为了 20.00。</p>
<blockquote>
<p>&emsp;&emsp;可重复读隔离级别不仅可以<strong>防止不可重复读</strong>，另外还能<strong>防止丢失更新</strong>。丢失更新是指两个事务读取了同一个值，然后基于最初读取的值进行计算，接着再更新该值，就会发生丢失更新的问题。这是因为在可重复读隔离级别下，两个事务在第一次读操作之后都保留有共享锁，所以其中一个都不能成功获得为了更新数据而需要的排它锁。但是，<strong>负面影响就是会导致死锁</strong>。<br>&emsp;&emsp;在可重复读级别下运行的事务，读操作获得的共享锁将一直保持到事务结束。因此可以保证在事务中第一次读取某些行后，还可以重复读取这些行。但是，事务只锁定查询第一次运行时找到的那些行，而不会锁定查询结果范围外的其他行。因此，在同一事务进行第二次读取之前，如果其他事务插入了新行，而且新行也能满足读操作额查询过滤条件，那么这些新行也会出现在第二次读操作返回的结果中。这些新行称之为幻影，这种读操作也被称为<strong>幻读</strong>。</p>
</blockquote>
<h3 id="SERIALIZEABLE-可序列化"><a href="#SERIALIZEABLE-可序列化" class="headerlink" title="SERIALIZEABLE 可序列化"></a>SERIALIZEABLE 可序列化</h3><p>&emsp;&emsp;为了避免刚刚提到的幻读，需要将隔离级别设置为可序列化。可序列化级别的处理方式与可重复读类似：读操作需要获得共享锁才能读取数据并一直保留到事务结束，不同之处在于在可序列化级别下，读操作不仅锁定了满足查询条件的那些行，还锁定了可能满足查询条件的行。换句话说，如果其他事务试图增加能够满足操作的查询条件的新行，当前事务就会阻塞这样的操作。</p>
<p>&emsp;&emsp;同样，继续来模拟：<br>&emsp;&emsp;Step1. 在 Connection A 中运行代码，设置隔离级别为可序列化，再查询产品分类等于 1 的所有产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, productname, categoryid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> categoryid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="47.png" title="" data-fancybox="images"><img src="47.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step2. 在 Connection B 中运行代码，尝试插入一个分类等于 1 的新产品：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Production.Products</span><br><span class="line">    (productname, supplierid, categoryid,</span><br><span class="line">     unitprice, discontinued)</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">'Product ABCDE'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20.00</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时，该操作会被阻塞。因为在可序列化级别下，前面的读操作不仅锁定了满足查询条件的那些行，还锁定了可能满足查询条件的行。<br>&emsp;&emsp;同样，由于我设置了超时释放时间，因此会有以下输出：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="48.png" title="" data-fancybox="images"><img src="48.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 回到 Connection A，运行以下代码，再次查询分类 1 的产品，最后提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, productname, categoryid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> categoryid = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step4. 回到 Connection B，这时 Connection B 就已经获得了等候已久的排它锁，插入了新行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Production.Products</span><br><span class="line">    (productname, supplierid, categoryid,</span><br><span class="line">     unitprice, discontinued)</span><br><span class="line">  <span class="keyword">VALUES</span>(<span class="string">'Product ABCDE'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20.00</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> productid, productname, categoryid, unitprice</span><br><span class="line"><span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> categoryid = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="49.png" title="" data-fancybox="images"><img src="49.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step5. 为了后面的演示，运行以下代码清理测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Production.Products</span><br><span class="line"><span class="keyword">WHERE</span> productid &gt; <span class="number">77</span>;</span><br><span class="line"></span><br><span class="line">DBCC CHECKIDENT ('Production.Products', RESEED, 77);</span><br></pre></td></tr></table></figure>

<h3 id="SNAPSHOT-快照"><a href="#SNAPSHOT-快照" class="headerlink" title="SNAPSHOT 快照"></a>SNAPSHOT 快照</h3><p>&emsp;&emsp;首先解释一下什么是快照？事务已经提交的行的上一个版本存在<code>tempdb</code>数据库中，这是 SQL Server 引入的一个新功能。<br>&emsp;&emsp;以这种行版本控制技术为基础，SQL Server 增加了两个新的隔离级别：<code>SNAPSHOT</code>和<code>READ COMMITED SNAPSHOT</code>。如果启用任何一种基于快照的隔离级别，<code>DELETE</code>和<code>UPDATE</code>语句在做出修改前都会把行的当前版本复制到<code>tempdb</code>数据库中；<code>INSERT</code>语句则不会，因为这时还没有行的旧版本。<br>&emsp;&emsp;在<code>SNAPSHOPT</code>（快照）隔离级别下，当读取数据时，可以保证读操作<strong>读取的行是事务开始时可用的最后提交的版本</strong>。</p>
<p>&emsp;&emsp;下面来模拟一下该隔离级别下的场景：<br>&emsp;&emsp;Step1. 还是打开两个会话窗口，在其中一个执行以下代码，设置隔离级别为<code>SNAPSHOT</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Allow SNAPSHOT isolation in the database</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> ALLOW_SNAPSHOT_ISOLATION <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码，更新产品 2 的价格，然后再查询该产品的价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="50.png" title="" data-fancybox="images"><img src="50.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection B 中运行以下代码，设置隔离级别为<code>SNAPSHOT</code>，并查询产品 2 的价格：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SNAPSHOT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时的返回结果如下所示，可以看到这个结果是在该事务启动时可用的最后提交的版本。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="51.png" title="" data-fancybox="images"><img src="51.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step4. 回到 Connection A 提交这一修改的行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step5. 在 Connection B 中运行以下代码，再次读取数据，然后提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们会得到跟之前一样的结果，奇了个怪了：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="52.png" title="" data-fancybox="images"><img src="52.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;但是如果我们再次在 Connection B 中运行以下完整语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时结果便会同步，这个事务开始时可用的上一个提交的版本是价格 = 20.00</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="53.png" title="" data-fancybox="images"><img src="53.png" alt title class></a>
                <p></p>
            </figure>
<p>&emsp;&emsp;为什么两个事务得到结果会不同？这是因为快照清理线程每隔一分钟运行一次，现在由于没有事务需要为价格 = 20.00 的那个行版本了，所以清理线程下一次运行时会将这个行版本从<code>tempdb</code>数据库中删除掉。</p>
<p>&emsp;&emsp;最后，为了下一次演示，清理测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Clear Test Data</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;这一隔离级别使用的不是共享锁，而是行版本控制。如前所述，不论修改操作（主要是更新和删除数据）是否在某种基于快照的隔离级别下的会话执行，快照隔离级别都会带来性能上的开销。</p>
</blockquote>
<p>&emsp;&emsp;另外，在<code>SNAPSHOT</code>快照级别下，可以通过检查的行版本，检测出更新冲突。它能判断出在快照事务的一次读操作和一次写操作之间是否有其他事务修改过数据。如果 SQL Server 检测到在读取和写入操作之间有另一个事务修改了数据，则会让事务因失败而终止，并返回以下错误信息：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="54.png" title="" data-fancybox="images"><img src="54.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;冲突检测完整实例如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">-- Conflict Detection 冲突检测实例</span></span><br><span class="line"><span class="comment">---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 1</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SNAPSHOT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 2</span></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = <span class="number">20.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 1</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection B, Step 1</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">25.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Connection A, Step 2</span></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = <span class="number">20.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Close all connections</span></span><br></pre></td></tr></table></figure>

<h3 id="READ-COMMITED-SNAPSHOT-已经提交读隔离"><a href="#READ-COMMITED-SNAPSHOT-已经提交读隔离" class="headerlink" title="READ COMMITED SNAPSHOT 已经提交读隔离"></a>READ COMMITED SNAPSHOT 已经提交读隔离</h3><p>&emsp;&emsp;已提交读隔离也是基于行版本控制，但与快照不同之处在于：在已提交读级别下，读操作读取的数据行不是食物启动之前最后提交的版本，而是语句启动前最后提交的版本。<br>&emsp;&emsp;此外，该级别不会像快照隔离级别一样进行更新冲突检测。这样一来，它就跟 SQL Server 默认的<code>READ COMMITED</code>级别非常类似了，只不过<strong>读操作不用获得共享锁，当请求的资源被其他事务的排它锁锁定时，也不用等待</strong>。</p>
<p>&emsp;&emsp;下面继续通过案例来模拟：<br>&emsp;&emsp;Step1. 运行以下代码，设置隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Turn on READ_COMMITTED_SNAPSHOT</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行该查询需要一定的时间，并且要注意：要成功运行，当前连接必须是指定数据库的唯一连接，请关掉其他连接，只保留一个会话来执行。<br>&emsp;&emsp;可以看到它跟我们之前设置隔离级别所使用的的语句不同，这个选项其实就是把默认的<code>READ COMMITED</code>的寒意变成了<code>READ COMMITED SNAPSHOT</code>。意味着打开这个选项时，除非显式地修改会话的隔离级别，否则<code>READ COMMITED SNAPSHOT</code>将成为默认的隔离级别。</p>
<p>&emsp;&emsp;Step2. 在 Connection A 中运行以下代码，更新产品 2 所在的行记录，再读取这一行记录，并且一直保持事务打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="55.png" title="" data-fancybox="images"><img src="55.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step3. 在 Connection B 中读取产品 2 所在的行记录，并一直保持事务打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection B</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;得到的结果是语句启动之前最后提交的版本（19.00）：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="56.png" title="" data-fancybox="images"><img src="56.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step4. 回到 Connection A，提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Step5. 回到 Connection B，再次读取产品 2 所在的行，并提交事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时结果如下，可以看到跟<code>SNAPSHOT</code>不同，这次的结果是在语句执行之前最后提交的版本而不是事务执行之前最后提交的版本，因此得到了 20.00：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="57.png" title="" data-fancybox="images"><img src="57.png" alt title class></a>
                <p></p>
            </figure>

<blockquote>
<p>&emsp;&emsp;回想一下，这种现象是不是我们常听见的<strong>不可重复读</strong>？也就是说，该级别下，无法防止不可重复读问题。</p>
</blockquote>
<p>&emsp;&emsp;最后，按照国际惯例，清理测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Clear Test Data</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line"><span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后，关闭所有连接，然后在一个新的连接下运行以下代码，以禁用指定数据库的基于快照的隔离级别：（执行<code>ALTER DATABASE TSQLFundamentals2008 SET READ_COMMITTED_SNAPSHOT OFF;</code>这一句时可能需要花费一点时间，请耐心等候）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Make sure you're back in default mode</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Change database options to default</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> ALLOW_SNAPSHOT_ISOLATION <span class="keyword">OFF</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> TSQLFundamentals2008 <span class="keyword">SET</span> READ_COMMITTED_SNAPSHOT <span class="keyword">OFF</span>;</span><br></pre></td></tr></table></figure>

<h3 id="隔离级别总结"><a href="#隔离级别总结" class="headerlink" title="隔离级别总结"></a>隔离级别总结</h3><p>&emsp;&emsp;下表总结了每种隔离级别能够解决各种逻辑一致性的问题，以及隔离级别是否会检测更新冲突，是否使用了行版本控制。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="58.png" title="" data-fancybox="images"><img src="58.png" alt title class></a>
                <p></p>
            </figure>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="59.png" title="" data-fancybox="images"><img src="59.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;这时再回顾以下各个问题的描述及结果，我们来看另一个表：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="60.png" title="" data-fancybox="images"><img src="60.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁是个什么鬼？"><a href="#死锁是个什么鬼？" class="headerlink" title="死锁是个什么鬼？"></a>死锁是个什么鬼？</h3><p>&emsp;&emsp;死锁是指一种<strong>进程之间互相永久阻塞的状态</strong>，可能涉及到两个或者多个进程。两个进程发生死锁的例子是：进程 A 阻塞了进程 B，进程 B 又阻塞了进程 A。在任何一种情况下，SQL Server 都可以检测到死锁，并选择终止其中一个事务以干预死锁状态。如果 SQL Server 不干预，那么死锁涉及到的进程将会永远保持死锁状态。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="61.png" title="" data-fancybox="images"><img src="61.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;默认情况下，SQL Server 会选择终止做过的操作最少的事务，因为这样可以让回滚开销降低到最低。当然，在 SQL Server 2005 及之后的版本中，可以通过将会话选项<code>DEADLOCK_PRIORITY</code>设置为范围（-10 到 10）之间的任一整数值。</p>
<h3 id="死锁实例"><a href="#死锁实例" class="headerlink" title="死锁实例"></a>死锁实例</h3><p>&emsp;&emsp;仍然打开三个会话：Connection A、B 和 C：<br>&emsp;&emsp;Step1. 在 Connection A 中更新 Products 表中产品 2 的行记录，并保持事务一直打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时 Connection A 对产品表的产品 2 请求了排它锁。</p>
<p>&emsp;&emsp;Step2. 在 Connection B 中更新 OrderDetails 表中产品 2 的订单明细，并保持事务一直打开：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection 2</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRAN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> Sales.OrderDetails</span><br><span class="line">    <span class="keyword">SET</span> unitprice = unitprice + <span class="number">1.00</span></span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时 Connection A 对订单明细表的产品 2 请求了排它锁。</p>
<p>&emsp;&emsp;Step3. 回到 Connection A 中，执行以下语句，请求查询产品 2 的订单明细记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection A</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> orderid, productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Sales.OrderDetails</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于此时实在默认的<code>READ COMMITED</code>隔离级别下运行的，所以 Connection A 中的事务需要一个共享锁才能读数据，因此这里会一直阻塞住。但是，此时并没有发生死锁，而只是发生了阻塞。</p>
<p>&emsp;&emsp;Step4. 回到 Connection B 中，执行以下语句，尝试在 Products 表查询产品 2 的记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Connection 2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> productid, unitprice</span><br><span class="line">  <span class="keyword">FROM</span> Production.Products</span><br><span class="line">  <span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里由于这个请求和 Connection A 中的事务在同一个资源上持有的排它锁发生了冲突，于是相互阻塞发生了死锁。SQL Server 通常会在几秒钟之内检测到死锁，并从这两个进程中选择一个作为牺牲品，终止其事务。所以我们还是得到了以下结果：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="62.png" title="" data-fancybox="images"><img src="62.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;Step5. 刚刚提到了 SQL Server 会选择一个作为牺牲品，我们回到 Connection A 会看到以下的错误信息提示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="63.png" title="" data-fancybox="images"><img src="63.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;在这个例子中，由于两个事务进行的工作量差不多一样，所以任何一个事务都有可能被终止。（前面提到，如果没有手动设置优先级，那么 SQL Server 会选择工作量较小的一个事务作为牺牲品）另外，解除死锁需要一定的系统开销，因为这个过程会涉及撤销已经执行过的处理。</p>
<blockquote>
<p>&emsp;&emsp;显然，事务处理的时间越长，持有锁的时间也就越长，死锁的可能性也就越大。应该尽量<strong>保持事务简短</strong>，把逻辑上可以属于同一工作单元的操作移到事务之外。</p>
</blockquote>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>（1）<strong>改变访问资源的顺序可以避免死锁</strong><br>&emsp;&emsp;继续上面的例子，Connection A 先访问 Products 表中的行，然后访问 OrderDetails 表中的行；Connection B 先访问 OrderDetails 表中的行，然后访问 Products 表中的行。<br>&emsp;&emsp;这时如果我们改变一下访问顺序：两个事务按照同样的顺序来访问资源，则不会发生这种类型的死锁。</p>
<blockquote>
<p>&emsp;&emsp;通过交换其中一个事务的操作顺序，就可以避免发生这种类型的死锁（假设交换顺序不必改变程序的逻辑）。</p>
</blockquote>
<p>（2）<strong>良好的索引设计也可以避免死锁</strong><br>&emsp;&emsp;如果查询筛选条件缺少良好的索引支持，也会造成死锁。例如，假设 Connection B 中的事务有两条语句要对产品 5 进行筛选，Connection A 中的事务要对产品 2 进行处理，那么他们就不应该有任何冲突。但是，如果在表的 productid 列上如果没有索引来支持查询筛选，那么 SQL Server 就必须扫描（并锁定）表中的所有行，这样当然会导致死锁。</p>
<blockquote>
<p>&emsp;&emsp;总之，良好的索引设计将有助于减少这种没有真正的逻辑冲突的死锁。</p>
</blockquote>
<p>&emsp;&emsp;最后，按照国际惯例清理掉测试数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Cleanup</span></span><br><span class="line"><span class="keyword">UPDATE</span> Production.Products</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Sales.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">19.00</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span></span><br><span class="line">  <span class="keyword">AND</span> orderid &gt;= <span class="number">10500</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> Sales.OrderDetails</span><br><span class="line">  <span class="keyword">SET</span> unitprice = <span class="number">15.20</span></span><br><span class="line"><span class="keyword">WHERE</span> productid = <span class="number">2</span></span><br><span class="line">  <span class="keyword">AND</span> orderid &lt; <span class="number">10500</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="可编程对象"><a href="#可编程对象" class="headerlink" title="可编程对象"></a>可编程对象</h1><h2 id="变量与批处理"><a href="#变量与批处理" class="headerlink" title="变量与批处理"></a>变量与批处理</h2><p>（1）变量：<code>DECLARE</code>+<code>SET</code>/<code>SELECT</code><br>&emsp;&emsp;<code>DECLARE</code>语句可以声明一个或多个变量，然后使用<code>SET</code>/<code>SELECT</code>语句可以把一个变量设置成指定的值。<br>&emsp;&emsp;① <code>SET</code>语句每次只能针对一个变量进行操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--set方式</span></span><br><span class="line"><span class="keyword">declare</span> @i <span class="keyword">as</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">set</span> @i=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--SQL Server 2008可以在同一语句同时声明和初始化变量</span></span><br><span class="line"><span class="keyword">declare</span> @i <span class="keyword">as</span> <span class="built_in">int</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;② <code>SELECT</code>语句允许从同一行中获得的多个值分配给多个变量。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--select方式</span></span><br><span class="line"><span class="keyword">declare</span> @firstname <span class="keyword">as</span> <span class="keyword">nvarchar</span>(<span class="number">20</span>), @lastname <span class="keyword">as</span> <span class="keyword">nvarchar</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  @firstname = firstname,</span><br><span class="line">  @lastname = lastname</span><br><span class="line"><span class="keyword">from</span> hr.Employees</span><br><span class="line"><span class="keyword">where</span> empid=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @firstname <span class="keyword">as</span> firstname, @lastname <span class="keyword">as</span> lastname;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>SET</code>语句比复制<code>SELECT</code>语句更加安全，因为它要求使用标量子查询来从表中提取数据。如果在运行时，标量子查询返回了多个值，则查询会失败。例如下面的代码在运行时会报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--set比select语句更安全</span></span><br><span class="line"><span class="keyword">declare</span> @empname <span class="keyword">as</span> <span class="keyword">nvarchar</span>(<span class="number">61</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @empname = (<span class="keyword">select</span> firstname + N<span class="string">' '</span>+ lastname</span><br><span class="line">                <span class="keyword">from</span> hr.Employees</span><br><span class="line">                <span class="keyword">where</span> mgrid=<span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line"><span class="keyword">select</span> @empname <span class="keyword">as</span> empname;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=T-SQL 语言基础 href="64.png" title="" data-fancybox="images"><img src="64.png" alt title class></a>
                <p></p>
            </figure>

<p>（2）批处理<br>&emsp;&emsp;客户端应用程序发送到 SQL Server 的一组单条或多条 T-SQL 语句，SQL Server 将批处理语句作为单个可执行的单元。</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="65.png" title="" data-fancybox="images"><img src="65.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;下面是一个批处理的示例，但要注意的是如果批处理中存在语法错误，整个批处理是不会提交到 SQL Server 执行的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A Batch as a Unit of Parsing</span></span><br><span class="line"><span class="comment">-- Valid batch</span></span><br><span class="line">PRINT 'First batch';</span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line">GO</span><br><span class="line"><span class="comment">-- Invalid batch</span></span><br><span class="line">PRINT 'Second batch';</span><br><span class="line"><span class="keyword">SELECT</span> custid <span class="keyword">FROM</span> Sales.Customers;</span><br><span class="line"><span class="keyword">SELECT</span> orderid FOM Sales.Orders; <span class="comment">-- 这一句有语法错误，故整个批处理不能提交到SQL Server执行</span></span><br><span class="line">GO</span><br><span class="line"><span class="comment">-- Valid batch</span></span><br><span class="line">PRINT 'Third batch';</span><br><span class="line"><span class="keyword">SELECT</span> empid <span class="keyword">FROM</span> HR.Employees;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：批处理和事务不同，事务是工作的原子工作单元，而一个批处理可以包含多个事务，一个事务也可以在多个批处理中的某些部分提交。当事务在执行中被取消或者回滚时，SQL Server 会撤销自事务开始以来的部分活动，而不考虑批处理是从哪里开始的。</p>
</blockquote>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>（1）<code>IF</code>…<code>ELSE</code><br>&emsp;&emsp;这个大家应该都知道，但是需要注意的是：T-SQL 使用的是三值逻辑，当条件取值为 <em>FALSE</em> 或 <em>UNKNOWN</em> 时，都可以激活<code>ELSE</code>语句块。如果条件取值可能为 <em>FALSE</em> 或 <em>UNKNOWN</em> （例如，涉及到 <em>NULL</em> 值），而且对每种情况需要进行不同的处理时，必须用<code>IS NULL</code>谓词对 <em>NULL</em> 值进行显式地测试。<br>&emsp;&emsp;下面的<code>IF-ELSE</code>代码演示了：如果今天是一个月的第一天，则对数据库进行完整备份；如果今天是一个月的最后一天，则对数据库进行差异备份（所谓差异备份，就是指只保存上一次完整备份以来做过的更新）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IF DAY(CURRENT_TIMESTAMP) = 1</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  PRINT <span class="string">'Today is the first day of the month.'</span>;</span><br><span class="line">  PRINT 'Starting a full database backup.<span class="string">';</span></span><br><span class="line"><span class="string">  BACKUP DATABASE TSQLFundamentals2008</span></span><br><span class="line"><span class="string">    TO DISK = '</span>C:\Temp\TSQLFundamentals2008_Full.BAK<span class="string">' WITH INIT;</span></span><br><span class="line"><span class="string">  PRINT '</span>Finished <span class="keyword">full</span> <span class="keyword">database</span> backup.<span class="string">';</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line"><span class="string">ELSE</span></span><br><span class="line"><span class="string">BEGIN</span></span><br><span class="line"><span class="string">  PRINT '</span>Today <span class="keyword">is</span> <span class="keyword">not</span> the <span class="keyword">first</span> <span class="keyword">day</span> <span class="keyword">of</span> the month.<span class="string">'</span></span><br><span class="line"><span class="string">  PRINT '</span><span class="keyword">Starting</span> a differential <span class="keyword">database</span> backup.<span class="string">';</span></span><br><span class="line"><span class="string">  BACKUP DATABASE TSQLFundamentals2008</span></span><br><span class="line"><span class="string">    TO DISK = '</span>C:\Temp\TSQLFundamentals2008_Diff.BAK<span class="string">' WITH INIT;</span></span><br><span class="line"><span class="string">  PRINT '</span>Finished differential <span class="keyword">database</span> backup.<span class="string">';</span></span><br><span class="line"><span class="string">END</span></span><br><span class="line"><span class="string">GO</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里假设备份的文件路径目录 C:Temp 已经存在。</p>
<p>（2）<code>WHILE</code>：不解释了，各位应该都懂。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @i <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"><span class="keyword">SET</span> @i = <span class="number">1</span>;</span><br><span class="line">WHILE @i &lt;= 10</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  PRINT @i;</span><br><span class="line">  <span class="keyword">SET</span> @i = @i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>&emsp;&emsp;T-SQL 中支持一种叫做游标的对象，可以用它来<strong>处理查询返回的结果集中的各行，以指定的顺序一次只处理一行</strong>。这种处理方式与使用基于集合的查询相反，普通的查询是把集合作为一个整体来处理，不依赖任何顺序。<br>&emsp;&emsp;换句话说，使用游标，就像是用鱼竿钓鱼，一次只能勾到一条鱼一样。而使用集合，就像用渔网捕鱼，一次能捕到整整一网鱼。因此，使用游标的场景我们应该多多斟酌。一般来说，如果按固定顺序一次处理一行的游标方式涉及到的数据访问要比基于集合的方式少得多，则使用游标会更加有效，前一篇提到的连续聚合就是这样的一个例子。</p>
<p>&emsp;&emsp;如何使用游标呢？</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="66.png" title="" data-fancybox="images"><img src="66.png" alt title class></a>
                <p></p>
            </figure>

<p>&emsp;&emsp;下面来看看一个实例，它使用游标来计算 CustOrders 视图中每个客户每个月的连续总订货量（连续聚合案例）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Example: Running Aggregations</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"><span class="keyword">USE</span> TSQLFundamentals2008;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">Result</span> <span class="keyword">TABLE</span></span><br><span class="line">(</span><br><span class="line">  custid     <span class="built_in">INT</span>,</span><br><span class="line">  ordermonth DATETIME,</span><br><span class="line">  qty        <span class="built_in">INT</span>, </span><br><span class="line">  runqty     <span class="built_in">INT</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(custid, ordermonth)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  @custid     <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @prvcustid  <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @ordermonth DATETIME,</span><br><span class="line">  @qty        <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @runqty     <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> C <span class="keyword">CURSOR</span> FAST_FORWARD <span class="comment">/* read only, forward only */</span> <span class="keyword">FOR</span></span><br><span class="line">  <span class="keyword">SELECT</span> custid, ordermonth, qty</span><br><span class="line">  <span class="keyword">FROM</span> Sales.CustOrders</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> custid, ordermonth;</span><br><span class="line"></span><br><span class="line">OPEN C</span><br><span class="line"></span><br><span class="line">FETCH NEXT FROM C INTO @custid, @ordermonth, @qty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @prvcustid = @custid, @runqty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WHILE @@FETCH_STATUS = 0</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">IF</span> @custid &lt;&gt; @prvcustid</span><br><span class="line">    <span class="keyword">SELECT</span> @prvcustid = @custid, @runqty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SET</span> @runqty = @runqty + @qty;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> @<span class="keyword">Result</span> <span class="keyword">VALUES</span>(@custid, @ordermonth, @qty, @runqty);</span><br><span class="line">  </span><br><span class="line">  FETCH NEXT FROM C INTO @custid, @ordermonth, @qty;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DEALLOCATE</span> C;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  custid,</span><br><span class="line">  <span class="keyword">CONVERT</span>(<span class="built_in">VARCHAR</span>(<span class="number">7</span>), ordermonth, <span class="number">121</span>) <span class="keyword">AS</span> ordermonth,</span><br><span class="line">  qty,</span><br><span class="line">  runqty</span><br><span class="line"><span class="keyword">FROM</span> @<span class="keyword">Result</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> custid, ordermonth;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行结果如下图所示：</p>
<figure class="image-box">
                <a rel=T-SQL 语言基础 href="67.png" title="" data-fancybox="images"><img src="67.png" alt title class></a>
                <p></p>
            </figure>

<h2 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h2><p>&emsp;&emsp;有时需要把数据临时保存到表中，而且在有些情况下，我们可能不太想要使用永久性的表。在这种情况下，使用临时表可能会更方便。<br>（1）局部临时表：<br>&emsp;&emsp;只对创建它的会话在创建级和对调用对战的内部级（内部的过程、函数、触发器等）是可见的，当创建会话从 SQL Server 实例断开时才会自动删除它。</p>
<p>&emsp;&emsp;创建临时局部表，只需要在命名时以单个<code>#</code>号作为前缀：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('tempdb.dbo.<span class="comment">#MyOrderTotalsByYear') IS NOT NULL</span></span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">TABLE</span> dbo.<span class="comment">#MyOrderTotalsByYear;</span></span><br><span class="line"><span class="keyword">GO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">YEAR</span>(O.orderdate) <span class="keyword">AS</span> orderyear,</span><br><span class="line">  <span class="keyword">SUM</span>(OD.qty) <span class="keyword">AS</span> qty</span><br><span class="line"><span class="keyword">INTO</span> dbo.<span class="comment">#MyOrderTotalsByYear</span></span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders <span class="keyword">AS</span> O</span><br><span class="line">  <span class="keyword">JOIN</span> Sales.OrderDetails <span class="keyword">AS</span> OD</span><br><span class="line">    <span class="keyword">ON</span> OD.orderid = O.orderid</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">YEAR</span>(orderdate);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Cur.orderyear, Cur.qty <span class="keyword">AS</span> curyearqty, Prv.qty <span class="keyword">AS</span> prvyearqty</span><br><span class="line"><span class="keyword">FROM</span> dbo.<span class="comment">#MyOrderTotalsByYear AS Cur</span></span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dbo.<span class="comment">#MyOrderTotalsByYear AS Prv</span></span><br><span class="line">    <span class="keyword">ON</span> Cur.orderyear = Prv.orderyear + <span class="number">1</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>（2）全局临时表：<br>&emsp;&emsp;可以对其他所有会话都可见，当创建临时表的会话断开数据库的连接，而且也没有活动在引用全局临时表时，SQL Server 才会自动删除相应的全局临时表。</p>
<p>&emsp;&emsp;创建全局局部表，只需要在命名时以两个<code>#</code>号作为前缀：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Global Temporary Tables</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dbo.<span class="comment">##Globals</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span>  sysname     <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  val SQL_VARIANT <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>&emsp;&emsp;SQL Server 允许用字符串来动态构造 T-SQL 代码的一个批处理，接着再执行这个批处理，这种功能叫做动态 SQL（Daynamic SQL）。</p>
<p>（1）使用<code>EXEC</code>（EXECUTE 的缩写）命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Simple example of EXEC</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">sql</span> <span class="keyword">AS</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = <span class="string">'PRINT ''This message was printed by a dynamic SQL batch.'';'</span>;</span><br><span class="line">EXEC(@sql);</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>（2）使用<code>sp_executesql</code>存储过程<br>&emsp;&emsp;<code>sp_executesql</code>存储过程有两个输入参数和一个参数赋值部分：第一个参数需要指定包含想要运行的批处理代码的 Unicode 字符串，第二个参数是一个 Unicode 字符串，包含第一个参数中所有输入和输出参数的生命。接着为输入和输出参数指定取值，各参数之间用逗号分隔。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Simple example using sp_executesql</span></span><br><span class="line"><span class="keyword">DECLARE</span> @<span class="keyword">sql</span> <span class="keyword">AS</span> <span class="keyword">NVARCHAR</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = N<span class="string">'SELECT orderid, custid, empid, orderdate</span></span><br><span class="line"><span class="string">FROM Sales.Orders</span></span><br><span class="line"><span class="string">WHERE orderid = @orderid;'</span>;</span><br><span class="line"></span><br><span class="line">EXEC sp_executesql</span><br><span class="line">  @stmt = @sql,</span><br><span class="line">  @params = N'@orderid AS INT',</span><br><span class="line">  @orderid = 10248;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tips</strong>：<br>&emsp;&emsp;① <code>sp_executesql</code>存储过程在执行性能上比<code>EXEC</code>要好，因为它的参数化有助于重用缓存过的执行计划。<br>&emsp;&emsp;② <code>sp_executesql</code>存储过程在安全上也比<code>EXEC</code>要好，它的参数化也可以不必受 SQL 注入的困扰。</p>
</blockquote>
<h2 id="例程：用户定义函数、存储过程与触发器"><a href="#例程：用户定义函数、存储过程与触发器" class="headerlink" title="例程：用户定义函数、存储过程与触发器"></a>例程：用户定义函数、存储过程与触发器</h2><p>（1）用户定义函数：封装计算的逻辑处理，有可能需要基于输入的参数，并返回结果。<br>&emsp;&emsp;下面的示例创建了一个用户定义函数 dbo.fn_age，对于给定出生日期和事件日期，这个函数可以返回某个人在时间`日期当时的年龄：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('dbo.fn_age') IS NOT NULL <span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> dbo.fn_age;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dbo.fn_age</span><br><span class="line">(</span><br><span class="line">  @birthdate <span class="keyword">AS</span> DATETIME,</span><br><span class="line">  @eventdate <span class="keyword">AS</span> DATETIME</span><br><span class="line">)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span></span><br><span class="line">    <span class="keyword">DATEDIFF</span>(<span class="keyword">year</span>, @birthdate, @eventdate)</span><br><span class="line">    - <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="number">100</span> * <span class="keyword">MONTH</span>(@eventdate) + <span class="keyword">DAY</span>(@eventdate)</span><br><span class="line">              &lt; <span class="number">100</span> * <span class="keyword">MONTH</span>(@birthdate) + <span class="keyword">DAY</span>(@birthdate)</span><br><span class="line">           <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span></span><br><span class="line">      <span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>

<p>（2）存储过程：封装 T-SQL 代码地服务器端例程，可以有输入和输出参数，可以返回多个查询的结果集。<br>&emsp;&emsp;下面的示例创建了一个存储过程 usp_GetCustomerOrders，它接受一个客户 ID 和日期范围作为输入参数，返回 Orders 表中由指定客户在指定日期范围内所下的订单组成的结果集，同时也将受查询影响的行为作为输出参数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">IF OBJECT_ID('Sales.usp_GetCustomerOrders', 'P') IS NOT NULL</span><br><span class="line">  <span class="keyword">DROP</span> PROC Sales.usp_GetCustomerOrders;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> PROC Sales.usp_GetCustomerOrders</span><br><span class="line">  @custid   <span class="keyword">AS</span> <span class="built_in">INT</span>,</span><br><span class="line">  @fromdate <span class="keyword">AS</span> DATETIME = <span class="string">'19000101'</span>,</span><br><span class="line">  @todate   <span class="keyword">AS</span> DATETIME = <span class="string">'99991231'</span>,</span><br><span class="line">  @numrows  <span class="keyword">AS</span> <span class="built_in">INT</span> <span class="keyword">OUTPUT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> orderid, custid, empid, orderdate</span><br><span class="line"><span class="keyword">FROM</span> Sales.Orders</span><br><span class="line"><span class="keyword">WHERE</span> custid = @custid</span><br><span class="line">  <span class="keyword">AND</span> orderdate &gt;= @fromdate</span><br><span class="line">  <span class="keyword">AND</span> orderdate &lt; @todate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @numrows = @@rowcount;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> @rc <span class="keyword">AS</span> <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line">EXEC Sales.usp_GetCustomerOrders</span><br><span class="line">  @custid   = 1, <span class="comment">-- Also try with 100</span></span><br><span class="line">  @fromdate = '20070101',</span><br><span class="line">  @todate   = '20080101',</span><br><span class="line">  @numrows  = @rc OUTPUT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> @rc <span class="keyword">AS</span> numrows;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<blockquote>
<p>&emsp;&emsp;<strong>Tips</strong>：存储过程可以封装业务逻辑处理，更好地控制安全性（有助于避免 SQL 注入），提高执行性能（减少网络通信流量）。</p>
</blockquote>
<p>（3）触发器：<br>&emsp;&emsp;一种特殊的存储过程，只要特定事件发生，就会调用触发器，运行它的代码。SQL Server 支持两种类型相关的触发器，分别是：DML 触发器 和 DDL 触发器。</p>
<p>&emsp;&emsp;下面的示例演示了一个简单的 DML 触发器，对插入到表的数据进行审核（插入到 Audit 审核表）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trg_T1_insert_audit <span class="keyword">ON</span> dbo.T1 <span class="keyword">AFTER</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SET</span> NOCOUNT <span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.T1_Audit(keycol, datacol)</span><br><span class="line">  <span class="keyword">SELECT</span> keycol, datacol <span class="keyword">FROM</span> inserted;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>&emsp;&emsp;T-SQL 代码中提供了一种成为 <code>TRY</code>…<code>CATCH</code> 的结构，在 SQL Server 2005 中引入的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRY</span><br><span class="line">  PRINT <span class="number">10</span>/<span class="number">2</span>;</span><br><span class="line">  PRINT 'No error';</span><br><span class="line"><span class="keyword">END</span> TRY</span><br><span class="line"><span class="keyword">BEGIN</span> CATCH</span><br><span class="line">  PRINT <span class="string">'Error'</span>;</span><br><span class="line"><span class="keyword">END</span> CATCH</span><br><span class="line"><span class="keyword">GO</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于错误处理代码，在实际开发中，可以封装创建一个存储过程来重用错误代码。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><figure class="image-box">
                <a rel=T-SQL 语言基础 href="68.png" title="[美] Itzik Ben-Gan 著，成保栋 译，《Microsoft SQL Server 2008 技术内幕：T-SQL 语言基础》" data-fancybox="images"><img src="68.png" alt="[美] Itzik Ben-Gan 著，成保栋 译，《Microsoft SQL Server 2008 技术内幕：T-SQL 语言基础》" title class></a>
                <p>[美] Itzik Ben-Gan 著，成保栋 译，《Microsoft SQL Server 2008 技术内幕：T-SQL 语言基础》</p>
            </figure>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-01-14T10:16:12.247Z" itemprop="dateUpdated">2020-01-14 18:16:12</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/" target="_blank" rel="external">https://tao-lol.top/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/</a>
        
    </div>
    <footer>
        <a href="https://tao-lol.top">
            <img src="/img/avatar.jpg" alt="濤">
            濤
        </a>
    </footer>
</blockquote>

        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tao-lol.top/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/&title=《T-SQL 语言基础》 — Blog&pic=https://tao-lol.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tao-lol.top/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/&title=《T-SQL 语言基础》 — Blog&source=
https://www.cnblogs.com/edisonchou/p/6106176.html一：SQL Server 的体系结构二：查询三：表表达..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="next">
      <a href="/2020/01/10/LearningLinkedList/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">一文学会链表解题</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#SQL-Server-体系结构"><span class="post-toc-number">1.</span> <span class="post-toc-text">SQL Server 体系结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数据库的物理布局"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">数据库的物理布局</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#架构（Schema）和对象"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">架构（Schema）和对象</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#查询"><span class="post-toc-number">2.</span> <span class="post-toc-text">查询</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#单表查询"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">单表查询</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#联接查询"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">联接查询</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#子查询"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">子查询</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#表表达式"><span class="post-toc-number">3.</span> <span class="post-toc-text">表表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#派生表"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">派生表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#公用表表达式"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">公用表表达式</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#视图"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">视图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#内联表值函数"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">内联表值函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#集合运算"><span class="post-toc-number">4.</span> <span class="post-toc-text">集合运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#UNION-并集运算"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">UNION 并集运算</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#INTERSECT-交集运算"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">INTERSECT 交集运算</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#EXCEPT-差集运算"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">EXCEPT 差集运算</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#集合运算优先级"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">集合运算优先级</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#使用表表达式避开不支持的逻辑查询处理"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">使用表表达式避开不支持的逻辑查询处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#透视、逆透视及分组"><span class="post-toc-number">5.</span> <span class="post-toc-text">透视、逆透视及分组</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#透视"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">透视</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#逆透视"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">逆透视</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#分组"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">分组</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#数据修改"><span class="post-toc-number">6.</span> <span class="post-toc-text">数据修改</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#插入与删除数据"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">插入与删除数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#看我花式插入数据"><span class="post-toc-number">6.1.1.</span> <span class="post-toc-text">看我花式插入数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#看我花式删除数据"><span class="post-toc-number">6.1.2.</span> <span class="post-toc-text">看我花式删除数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#更新与合并数据"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">更新与合并数据</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#花式更新数据"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">花式更新数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新玩法：合并数据"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">新玩法：合并数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#高级数据更新方法"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">高级数据更新方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#OUTPUT-子句"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">OUTPUT 子句</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#事务和并发"><span class="post-toc-number">7.</span> <span class="post-toc-text">事务和并发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#事务"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">事务</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事务的概念"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">事务的概念</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#事务的-ACID-特性"><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">事务的 ACID 特性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何定义事务"><span class="post-toc-number">7.1.3.</span> <span class="post-toc-text">如何定义事务</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#锁定和阻塞"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">锁定和阻塞</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#锁"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#阻塞"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">阻塞</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#隔离级别"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">隔离级别</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#READ-UNCOMMITED-未提交读"><span class="post-toc-number">7.3.1.</span> <span class="post-toc-text">READ UNCOMMITED 未提交读</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#READ-COMMITED-已提交读"><span class="post-toc-number">7.3.2.</span> <span class="post-toc-text">READ COMMITED 已提交读</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#REPEATABLE-READ-可重复读"><span class="post-toc-number">7.3.3.</span> <span class="post-toc-text">REPEATABLE READ 可重复读</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SERIALIZEABLE-可序列化"><span class="post-toc-number">7.3.4.</span> <span class="post-toc-text">SERIALIZEABLE 可序列化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SNAPSHOT-快照"><span class="post-toc-number">7.3.5.</span> <span class="post-toc-text">SNAPSHOT 快照</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#READ-COMMITED-SNAPSHOT-已经提交读隔离"><span class="post-toc-number">7.3.6.</span> <span class="post-toc-text">READ COMMITED SNAPSHOT 已经提交读隔离</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#隔离级别总结"><span class="post-toc-number">7.3.7.</span> <span class="post-toc-text">隔离级别总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#死锁"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">死锁</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#死锁是个什么鬼？"><span class="post-toc-number">7.4.1.</span> <span class="post-toc-text">死锁是个什么鬼？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#死锁实例"><span class="post-toc-number">7.4.2.</span> <span class="post-toc-text">死锁实例</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#避免死锁"><span class="post-toc-number">7.4.3.</span> <span class="post-toc-text">避免死锁</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#可编程对象"><span class="post-toc-number">8.</span> <span class="post-toc-text">可编程对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#变量与批处理"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">变量与批处理</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#流程控制"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">流程控制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#游标"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">游标</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#临时表"><span class="post-toc-number">8.4.</span> <span class="post-toc-text">临时表</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#动态-SQL"><span class="post-toc-number">8.5.</span> <span class="post-toc-text">动态 SQL</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#例程：用户定义函数、存储过程与触发器"><span class="post-toc-number">8.6.</span> <span class="post-toc-text">例程：用户定义函数、存储过程与触发器</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#错误处理"><span class="post-toc-number">8.7.</span> <span class="post-toc-text">错误处理</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#参考资料"><span class="post-toc-number">9.</span> <span class="post-toc-text">参考资料</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>


</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://tao-lol.top" target="_blank">Home</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/hexojs/hexo" target="_blank">Hexo</a>
    </span>
    
    <span class="blogroll-item">
        <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">Mellow</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                濤 &copy; 2018 - 2020
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://tao-lol.top/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/&title=《T-SQL 语言基础》 — Blog&pic=https://tao-lol.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://tao-lol.top/2020/01/13/MicrosoftSQLServer2008T-SQLFundamentals/&title=《T-SQL 语言基础》 — Blog&source=
https://www.cnblogs.com/edisonchou/p/6106176.html一：SQL Server 的体系结构二：查询三：表表达..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACqklEQVR42u3aS27jMBAFwNz/0sk2gWH59YeyEZRWgjMQVRyATb3m11d8ff+6Hn/Pf3m8v/7r9ZPXLjw8PLzBqz9eOe/6CdeTdf3q1+/zYkQ8PDy8Y7xnD02W7KQw5IB8KpPR8fDw8D6Bly/WuyUEDw8P7z/xrklJYcgnAg8PD+9zeEkYkbzEvMC8LWvBw8PDi3m9xfq990f6e3h4eHjjrnoeFky69nmZKb8tHh4e3gFevuAmW+3J1GzFGXh4eHj38+Yf+dXANw81mtEJHh4e3iqvenyq972f4+fjlvf7eHh4eEVe0oafDJws/flBgVF/Dw8PD2+VVw1k8230/IDCVgHDw8PD2+Ul7ag8Wp3EFkfKAx4eHt4qr7pAVwtGr7SslQc8PDy8G3eeyf1W2cjL0ig0wcPDwzvGmyy+1eGrxWDyb/Dw8PC2ePmn/vUU5FvzfIJ6UcWfezw8PLxjvOQg1CQmSDbK1bJU6Onh4eHhHePlQ1bZveP71VL0tLOHh4eHt8rrLdPV6UhGmRzqejEdeHh4eAd4vYbWfNHvxROj4w54eHh4S7xqlFBdsrdiiGrxwMPDwzvNS65emNuLaNciDzw8PLxVXuEzflA2JiFvr2hFJyPw8PDwWrxqYUiW7GqzamuTXejy4eHh4R3g9V60GtrmEW11g144lYCHh4c34OXD5OzqM6u86D8GDw8P7xivVxKqIez8OeULDw8Pb5XXCyAmTbJqvFs9vDVKWfDw8PAC3nyNTSKG/ADW/H65hODh4eG1dp55iytv+VebW9WAGA8PD+8eXtI5yrtLvZB3UrSeviceHh7ex/DyZlX+S942ywsGHh4e3qfx5jvY6iGt5AMADw8P7x7efOPbKx691LlcGPDw8PBWeb0P/mSAcwe5jvT38PDw8F7zfgB8E16Tp6DshQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.4"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.4"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.4"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.4"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
